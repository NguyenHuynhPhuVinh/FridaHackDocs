Directory structure:
└── vfsfitvnm-frida-il2cpp-bridge/
    ├── README.md
    ├── LICENSE.md
    ├── Makefile
    ├── package.json
    ├── tsconfig.json
    ├── .clang-format
    ├── cli/
    │   ├── main.py
    │   ├── .npmignore
    │   ├── src/
    │   │   ├── __init__.py
    │   │   ├── app.py
    │   │   ├── dump/
    │   │   │   ├── __init__.py
    │   │   │   ├── agent.js
    │   │   │   ├── command.py
    │   │   │   ├── dumper.py
    │   │   │   └── models.py
    │   │   └── utils/
    │   │       ├── __init__.py
    │   │       ├── app.py
    │   │       └── io.py
    │   └── tests/
    │       ├── __init__.py
    │       └── dump/
    │           ├── __init__.py
    │           └── test_type_name_cleaner.py
    ├── example/
    │   ├── index.ts
    │   ├── package.json
    │   └── tsconfig.json
    ├── lib/
    │   ├── application.ts
    │   ├── boxed.ts
    │   ├── config.ts
    │   ├── dump.ts
    │   ├── exception-listener.ts
    │   ├── exports.ts
    │   ├── filters.ts
    │   ├── gc.ts
    │   ├── index.ts
    │   ├── memory.ts
    │   ├── module.ts
    │   ├── perform.ts
    │   ├── tracer.ts
    │   ├── cmodules/
    │   │   └── memory-snapshot.c
    │   ├── structs/
    │   │   ├── array.ts
    │   │   ├── assembly.ts
    │   │   ├── class.ts
    │   │   ├── delegate.ts
    │   │   ├── domain.ts
    │   │   ├── field.ts
    │   │   ├── gc-handle.ts
    │   │   ├── image.ts
    │   │   ├── memory-snapshot.ts
    │   │   ├── method.ts
    │   │   ├── object.ts
    │   │   ├── parameter.ts
    │   │   ├── pointer.ts
    │   │   ├── reference.ts
    │   │   ├── string.ts
    │   │   ├── thread.ts
    │   │   ├── type.ts
    │   │   └── value-type.ts
    │   └── utils/
    │       ├── android.ts
    │       ├── console.ts
    │       ├── decorate.ts
    │       ├── getter.ts
    │       ├── hash.ts
    │       ├── lazy.ts
    │       ├── native-struct.ts
    │       ├── object.ts
    │       ├── offset-of.ts
    │       ├── read-native-iterator.ts
    │       ├── read-native-list.ts
    │       ├── recycle.ts
    │       └── unity-version.ts
    ├── test/
    │   ├── GameAssembly.cs
    │   ├── host.c
    │   ├── main.py
    │   └── agent/
    │       ├── tsconfig.json
    │       └── src/
    │           ├── assert.ts
    │           └── index.ts
    └── unity/
        ├── common.mk
        ├── 2017.4.40f1/
        │   └── Makefile
        ├── 2018.3.0f1/
        │   └── Makefile
        ├── 2019.3.0f1/
        │   └── Makefile
        ├── 2021.2.0f1/
        │   └── Makefile
        ├── 2023.2.20f1/
        │   └── Makefile
        ├── 5.3.5f1/
        │   └── Makefile
        └── 6000.1.0f1/
            └── Makefile

================================================
FILE: README.md
================================================
# frida-il2cpp-bridge

[![Frida](https://img.shields.io/badge/-frida-ef6456?style=for-the-badge&logo=data:image/svg+xml;base64,PHN2ZyAgIHZlcnNpb249IjEuMSIgICBpZD0iTGF5ZXJfMSIgICB4PSIwcHgiICAgeT0iMHB4IiAgIHZpZXdCb3g9IjAgMCA5LjcyOTk3OTkgMTAuOTM1NzEyIiAgIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDIwNC40IDM5IiAgIHhtbDpzcGFjZT0icHJlc2VydmUiICAgc29kaXBvZGk6ZG9jbmFtZT0ibG9nby5zdmciICAgd2lkdGg9IjkuNzI5OTc5NSIgICBoZWlnaHQ9IjEwLjkzNTcxMiIgICBpbmtzY2FwZTp2ZXJzaW9uPSIxLjEgKGNlNjY2M2IzYjcsIDIwMjEtMDUtMjUpIiAgIHhtbG5zOmlua3NjYXBlPSJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlIiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIgICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnMgICBpZD0iZGVmczkiIC8+PHNvZGlwb2RpOm5hbWVkdmlldyAgIGlkPSJuYW1lZHZpZXc3IiAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIgICBib3JkZXJvcGFjaXR5PSIxLjAiICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMC4wIiAgIGlua3NjYXBlOnBhZ2VjaGVja2VyYm9hcmQ9IjAiICAgc2hvd2dyaWQ9ImZhbHNlIiAgIGZpdC1tYXJnaW4tdG9wPSIwIiAgIGZpdC1tYXJnaW4tbGVmdD0iMCIgICBmaXQtbWFyZ2luLXJpZ2h0PSIwIiAgIGZpdC1tYXJnaW4tYm90dG9tPSIwIiAgIGlua3NjYXBlOnpvb209IjYuOTE3ODA4NCIgICBpbmtzY2FwZTpjeD0iLTAuMTQ0NTU0NDUiICAgaW5rc2NhcGU6Y3k9Ii04LjYwMDk4OTkiICAgaW5rc2NhcGU6d2luZG93LXdpZHRoPSIxOTIwIiAgIGlua3NjYXBlOndpbmRvdy1oZWlnaHQ9IjEwMDgiICAgaW5rc2NhcGU6d2luZG93LXg9IjAiICAgaW5rc2NhcGU6d2luZG93LXk9IjAiICAgaW5rc2NhcGU6d2luZG93LW1heGltaXplZD0iMSIgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJMYXllcl8xIiAvPjxnICAgaWQ9Imc0IiAgIHN0eWxlPSJkaXNwbGF5OmlubGluZTtmaWxsOiNmZmZmZmYiICAgdHJhbnNmb3JtPSJtYXRyaXgoMC4yODA0MDI4NiwwLDAsMC4yODA0MDI4NiwtMTEuNTgwNjM4LDApIj48cGF0aCAgIGZpbGw9IiNmZmZmZmYiICAgZD0iTSA1MS40LDM5IEggNDEuMyBMIDQ5LjcsMjYuMSBDIDQ0LjksMjMuOCA0Mi4zLDE5LjYgNDIuMywxMy41IDQyLjMsNC44IDQ4LjIsMCA1OC41LDAgSCA3NiBWIDM5IEggNjcgViAyOCBIIDU4LjUgNTcuNyBaIE0gNjcsMjAgViA3IGggLTguNSBjIC00LjksMCAtNy43LDIgLTcuNyw2LjQgMCw0LjUgMi44LDYuNiA3LjcsNi42IHoiICAgaWQ9InBhdGgyIiAgIHN0eWxlPSJmaWxsOiNmZmZmZmYiIC8+PC9nPjwvc3ZnPg==)](https://frida.re)
[![NPM](https://img.shields.io/npm/v/frida-il2cpp-bridge?label=&logo=npm&style=for-the-badge)](https://npmjs.org/package/frida-il2cpp-bridge)

A Frida module to dump, trace or hijack any Il2Cpp application at runtime, without needing the `global-metadata.dat` file.

![code](https://github.com/vfsfitvnm/frida-il2cpp-bridge/assets/46219656/d8e81811-b98c-4d67-9cea-be8cab8947ef)

## Features

-   Dump classes, methods, fields and so on
-   Trace, intercept and replace method calls
-   Mess around with the C# runtime
-   Il2Cpp structs and global metadata (almost) free

## Compatibility

#### Unity version

It should work for any Unity version in the range **5.3.0** - **6000.1.x**.

#### Platforms

**Android**, **Linux**, **Windows**, **iOS**, **macOS** are supported.
However, only Android and Linux are "tested": expect breakage if you are using another platform.

## CLI

Starting from version `0.10.0`, a `frida-il2cpp-bridge` Python executable is included alongside the NPM package installation. This executable wraps the `frida` command and adds IL2CPP specific features. To invoke it, simply run:

```sh
npx frida-il2cpp-bridge --help
```

or

```sh
npm exec frida-il2cpp-bridge -- --help
```

### Dumping

Use the `dump` subcommand to dump an application:

```
$ npm exec frida-il2cpp-bridge -- dump --help
usage: frida-il2cpp-bridge [options] dump [-h] [--out-dir OUT_DIR] [--cs-output {none,stdout,flat,tree}] [--no-namespaces] [--flatten-nested-classes] [--keep-implicit-base-classes]
                                          [--enums-as-structs] [--no-type-keywords] [--actual-constructor-names] [--indentation-size INDENTATION_SIZE]

options:
  -h, --help            show this help message and exit
  --out-dir OUT_DIR     where to save the dump (defaults to current working dir)
  --cs-output {none,stdout,flat,tree}
                        style of C# output (defaults to tree)
                        -   none: do nothing;
                        - stdout: print to console;
                        -   flat: one single file (dump.cs);
                        -   tree: directory structure having one file per assembly.
  --no-namespaces       do not emit namespace blocks, and prepend namespace name in class declarations
  --flatten-nested-classes
                        write nested classes at the same level of their inclosing classes, and prepend enclosing class name in their declarations
  --keep-implicit-base-classes
                        write implicit base classes (class -> System.Object, struct -> System.ValueType, enum -> System.Enum) in class declarations
  --enums-as-structs    write enum class declarations as structs
  --no-type-keywords    use fully qualified names for builtin types instead of their keywords (e.g. use 'System.Int32' instead of 'int', or 'System.Object' instead of 'object')
  --actual-constructor-names
                        write actual constructors names (e.g. '.ctor' and '.cctor')
  --indentation-size INDENTATION_SIZE
                        indentation size (defaults to 4)
```

Example:

```sh
npm exec frida-il2cpp-bridge -- -f com.example.application dump --out-dir dumps
```

Output:

```
Spawning `com.example.application`...
IL2CPP module loaded in 1.13s (id=com.example.application, version=1.12.8, unity version=2019.3.0f1)
Dumping mscorlib: 2872 of 2872 classes
Dumping GameAssembly: 32 of 32 classes
Collected 2904 classes in 4.76s
Dump saved to dumps/com.example.application/1.12.8
```

## Testing

Over the time, it was realized that some testing was necessary, as supporting many Unity version makes introducing regressions or faulty features easy. Though it's far from being complete and bullet-proof, there's a minimal testing setup contributors can get advantage of to test their changes. \
In order to test `frida-il2cpp-bridge`, a IL2CPP application is needed (of course). Here are some very useful resources:

-   [IL2CPP toolchain](https://katyscode.wordpress.com/2020/06/24/il2cpp-part-1/)
-   [Scripting](https://github.com/djkaty/Il2CppInspector/blob/116c6355e7ee3656eab85ca753f913d428abc7a3/Il2CppTests/il2cpp.ps1)

### Commands

Unity editors (so IL2CPP toolchains) will be downloaded and extracted automatically.

**Prerequisites**

1. Only Linux is currently supported;
2. Make sure to have `clang` and `make` installed.

#### Build IL2CPP assemblies

```sh
make assemblies
```

An assembly (`GameAssembly.so`) will be built for each of [tested Unity versions](https://github.com/vfsfitvnm/frida-il2cpp-bridge/tree/master/unity).

#### Build IL2CPP assembly for a specific Unity version only

```sh
make unity/2019.3.0f1/
```

#### Run tests

```sh
make test
```

Tests run against only the installed Unity versions.

## Acknowledgements

Thanks to [meme](https://github.com/meme) and [knobse](https://github.com/knobse) for helping and getting me into this,
and to [djkaty](https://github.com/djkaty) and [nneonneo](https://github.com/nneonneo) for providing the Il2Cpp
API.

## Problems?

Discussions and Wiki are both active. Use them!



================================================
FILE: LICENSE.md
================================================
Copyright (c) 2021 vfsfitvnm

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.


================================================
FILE: Makefile
================================================
MAKEFLAGS += --no-builtin-rules
.SUFFIXES:

UNITY_DIRS := $(wildcard unity/*/)

dist: node_modules $(shell find lib) tsconfig.json
	@ npm exec tspc
	@ touch -m "$@"

node_modules:
	@ npm i
	@ touch -m "$@"

test: dist test/agent/dist build/host
	@ python3 test/main.py

test/agent/dist: node_modules $(shell find test/agent/src) test/agent/tsconfig.json
	@ npm exec tspc -- -p test/agent
	@ touch -m "$@"

build/host: test/host.c
	@ mkdir -p build
	@ gcc -o "$(@)" "$<"

$(UNITY_DIRS):
	make -C "$@" assembly

assembly: $(UNITY_DIRS);

clean:
	@ rm -rf dist
	@ rm -rf test/agent/dist

.DEFAULT_GOAL := dist
.PHONY: clean test assembly $(UNITY_DIRS)



================================================
FILE: package.json
================================================
{
  "name": "frida-il2cpp-bridge",
  "version": "0.12.1",
  "description": "A Frida module to dump, trace or hijack any Il2Cpp application at runtime, without needing the global-metadata.dat file.",
  "keywords": [
    "frida",
    "frida-gum",
    "frida-gum-bridge",
    "il2cpp",
    "dump",
    "trace",
    "global-metadata"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/vfsfitvnm/frida-il2cpp-bridge.git"
  },
  "license": "MIT",
  "author": "vfsfitvnm",
  "exports": "./dist/index.js",
  "module": "dist/index.js",
  "main": "dist/index.js",
  "type": "module",
  "types": "dist/index.d.ts",
  "files": [
    "dist", "cli"
  ],
  "scripts": {
    "prepare": "make dist",
    "watch": "npm exec tspc -- --watch",
    "test": "make test"
  },
  "bin": {
    "frida-il2cpp-bridge": "cli/main.py"
  },
  "prettier": {
    "arrowParens": "avoid",
    "bracketSpacing": true,
    "printWidth": 160,
    "tabWidth": 4,
    "trailingComma": "none"
  },
  "devDependencies": {
    "@types/frida-gum": "^19.0.0",
    "ts-patch": "^3.2.1",
    "ts-transformer-inline-file": "^0.2.0"
  },
  "overrides": {
    "ts-transformer-inline-file": {
      "typescript": "^5.0.0"
    }
  }
}



================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "es2022",
    "lib": ["es2021"],
    "moduleResolution": "node",
    "outDir": "dist",
    "outFile": "dist/index.js",
    "sourceRoot": ".",
    "declaration": true,
    "experimentalDecorators": true,
    "sourceMap": true,
    "strict": true,
    "stripInternal": true,
    "plugins": [ 
      { "transform": "ts-transformer-inline-file/transformer" }
    ]
  },
  "exclude": ["dist", "test", "example"]
}



================================================
FILE: .clang-format
================================================
DisableFormat: false
AlwaysBreakAfterDefinitionReturnType: All
BreakBeforeBraces: Allman
ColumnLimit: 80
IndentWidth: 2
MaxEmptyLinesToKeep: 1
SpaceAfterCStyleCast: true
SpaceAroundPointerQualifiers: Both
SpaceBeforeParens: Always
PointerAlignment: Middle



================================================
FILE: cli/main.py
================================================
#!/usr/bin/env python3

from src.app import FridaIl2CppBridgeApplication
from src.dump.command import DumpCommand


if __name__ == "__main__":
    try:
        FridaIl2CppBridgeApplication(commands=[DumpCommand]).run()
    except KeyboardInterrupt:
        pass



================================================
FILE: cli/.npmignore
================================================
tests
__pycache__/



================================================
FILE: cli/src/__init__.py
================================================
from pathlib import Path
from os import environ
import json


__name__ = environ.get("npm_lifecycle_script", "frida-il2cpp-bridge").strip('"')

NPM_MODULE_PATH = Path(__file__)
while NPM_MODULE_PATH.stem != __name__:
    NPM_MODULE_PATH = NPM_MODULE_PATH.parent

with open(NPM_MODULE_PATH / "package.json", "r", encoding="utf-8") as file:
    __version__ = json.load(file)["version"]



================================================
FILE: cli/src/app.py
================================================
from __future__ import annotations
from typing import Mapping, TypedDict, override

import argparse
from pathlib import Path
import colorama
import frida
from frida.core import ScriptMessage

from .utils.app import Application, Command
from . import NPM_MODULE_PATH, __name__, __version__


class FridaIl2CppBridgeApplication(Application):
    class Target(TypedDict):
        identifier: str
        version: str

    def __init__(self, commands: list[type[FridaIl2CppBridgeCommand]]) -> None:
        self.commands = {command.NAME: command(app=self) for command in commands}
        self.target: FridaIl2CppBridgeApplication.Target
        self._script = None

        super().__init__()

    @override
    def _needs_target(self) -> bool:
        return True

    @override
    def _initialize_arguments_parser(self) -> argparse.ArgumentParser:
        parser = super()._initialize_arguments_parser()
        for action in parser._actions:
            if isinstance(action, argparse._VersionAction) and action.dest == "version":
                action.version = (
                    f"{frida.__name__}: {action.version} | {__name__}: {__version__}"
                )
        return parser

    @override
    def _add_options(self, parser: argparse.ArgumentParser) -> None:
        group = parser.add_argument_group(title="IL2CPP options")
        group.add_argument(
            "--unity-version",
            required=False,
            help="Unity version in case it cannot be detected automatically",
        )
        group.add_argument(
            "--module-name",
            required=False,
            help="IL2CPP module name in case it cannot be detected automatically",
        )
        group.add_argument(
            "--script-prelude",
            required=False,
            type=Path,
            help="path to .js script to be executed before running command-specific code",
        )

        self._add_commands(parser, description="IL2CPP specific commands")

    @override
    def _start(self) -> None:
        if agent_src := self._selected_command.agent_src:
            assert self._session is not None

            script = self._session.create_script(
                name="index",
                source=self._script_prelude() + agent_src,
                runtime=self._runtime,
            )

            script.on(
                "message",
                lambda message, data: self._reactor.schedule(
                    lambda: self._process_message(message, data)
                ),
            )

            script.load()

            self._script = script
        else:
            self._script = None

        self._resume()

    @override
    def _stop(self) -> None:
        if self._script:
            self._script.unload()
            self._script = None

    def _process_message(self, message: ScriptMessage, _) -> None:
        if message["type"] == "send" and (payload := message.get("payload")):
            match payload.get("action"):
                case "init":
                    self.target = payload["application"]
                    self.next_status()
                    self.update_status(
                        f"IL2CPP module loaded in {payload['elapsed_ms'] / 1000:.2f}s (id={colorama.Style.BRIGHT}{colorama.Fore.MAGENTA}{self.target['identifier']}{colorama.Fore.RESET}, version={colorama.Style.BRIGHT}{colorama.Fore.MAGENTA}{self.target['version']}{colorama.Fore.RESET}, unity version={colorama.Style.BRIGHT}{colorama.Fore.YELLOW}{payload['unityVersion']}{colorama.Fore.RESET})"
                    )
                case "exit":
                    self._selected_command.on_exit(payload=payload)
                    self._exit(0)
                case None:
                    self._selected_command.on_send(payload=payload)
                case action:
                    raise ValueError(f"Unknown payload action {action}")
        elif message["type"] == "error":
            self._log("error", message.get("stack", message["description"]))
            self._exit(1)

    def _script_prelude(self) -> str:
        dist = NPM_MODULE_PATH / "dist"

        with open(dist / "index.js", mode="r", encoding="utf-8") as file:
            src = file.read() + "\n"

        with open(dist / "index.js.map", mode="r", encoding="utf-8") as file:
            src += f'Script.registerSourceMap("/index.js", `{file.read()}`);\n'

        if unity_version := self.options.unity_version:
            src += f'globalThis.IL2CPP_UNITY_VERSION = "{unity_version}";\n'

        if module_name := self.options.module_name:
            src += f'globalThis.IL2CPP_MODULE_NAME = "{module_name}";\n'

        if script_prelude := self.options.script_prelude:
            with open(script_prelude.resolve(), mode="r", encoding="utf-8") as file:
                src += file.read() + "\n"

        return src


class FridaIl2CppBridgeCommand[
    SendPayload: Mapping[str, object],
    ExitPayload: Mapping[str, object],
](Command[FridaIl2CppBridgeApplication, SendPayload, ExitPayload]):
    pass



================================================
FILE: cli/src/dump/__init__.py
================================================
[Empty file]


================================================
FILE: cli/src/dump/agent.js
================================================
/// <reference path="../../../lib/index.ts">/>
const t0 = new Date();
setTimeout(() => {
    Il2Cpp.perform(() => {
        send({ action: "init", elapsed_ms: new Date() - t0, application: Il2Cpp.application, unityVersion: Il2Cpp.unityVersion });
        const t1 = new Date();
        Il2Cpp.domain.assemblies.forEach(assembly => {
            send({
                type: "assembly",
                handle: assembly.handle,
                name: assembly.name,
                class_count: assembly.image.classCount
            });
            assembly.image.classes.forEach((klass, i) =>
                send({
                    type: "class",
                    nth: i + 1,
                    assembly_handle: assembly.handle,
                    handle: klass.handle,
                    namespace: klass.namespace,
                    name: klass.name,
                    declaring_class_handle: klass.declaringClass?.handle,
                    kind: klass.isEnum ? `enum` : klass.isStruct ? `struct` : klass.isInterface ? `interface` : `class`,
                    generics_type_names: klass.generics.map(_ => _.type.name),
                    parent_type_name: klass.parent?.type.name,
                    interfaces_type_names: klass.interfaces.map(_ => _.type.name),
                    fields: klass.fields.map(field => ({
                        name: field.name,
                        type_name: field.type.name,
                        is_thread_static: field.isThreadStatic,
                        is_static: field.isStatic,
                        is_literal: field.isLiteral,
                        value: field.isLiteral ? (field.type.class.isEnum ? field.value.field("value__").value : field.value)?.toString() : undefined,
                        offset: field.isThreadStatic || field.isLiteral ? undefined : field.offset
                    })),
                    methods: klass.methods.map(method => ({
                        is_static: method.isStatic,
                        name: method.name,
                        return_type_name: method.returnType.name,
                        generics_type_names: method.generics.map(_ => _.type.name),
                        parameters: method.parameters.map(parameter => ({
                            position: parameter.position,
                            name: parameter.name,
                            type_name: parameter.type.name
                        })),
                        offset: method.virtualAddress.isNull() ? undefined : method.relativeVirtualAddress
                    }))
                })
            );
        });
        return new Date() - t1;
    }).then(_ => send({ action: "exit", elapsed_ms: _ }));
});



================================================
FILE: cli/src/dump/command.py
================================================
from typing import override

import argparse
from pathlib import Path

import colorama

from ..app import FridaIl2CppBridgeCommand
from .dumper import Dumper
from .models import AssemblyHandle, ClassHandle, AssemblyDump, ClassDump


class DumpCommand(FridaIl2CppBridgeCommand[AssemblyDump | ClassDump, dict]):
    NAME = "dump"

    def __init__(self, *args, **kwargs):
        self._assemblies_dump: dict[AssemblyHandle, AssemblyDump] = {}
        self._classes_dump: dict[ClassHandle, ClassDump] = {}
        super().__init__(*args, **kwargs)

    @property
    def agent_src(self) -> str:
        with open(
            Path(__file__).parent / "agent.js", mode="r", encoding="utf-8"
        ) as file:
            return file.read()

    @property
    def parser(self) -> dict:
        return dict(
            help="performs a dump of the target application",
            formatter_class=argparse.RawTextHelpFormatter,
        )

    @override
    def add_arguments(self, parser: argparse.ArgumentParser) -> None:
        parser.add_argument(
            "--out-dir",
            type=Path,
            default=Path.cwd(),
            help="where to save the dump (defaults to current working dir)",
        )
        parser.add_argument(
            "--cs-output",
            choices=["none", "stdout", "flat", "tree"],
            default="tree",
            help=(
                "style of C# output (defaults to tree)\n"
                "-   none: do nothing;\n"
                "- stdout: print to console;\n"
                "-   flat: one single file (dump.cs);\n"
                "-   tree: directory structure having one file per assembly."
            ),
        )
        parser.add_argument(
            "--no-namespaces",
            action="store_true",
            default=False,
            help="do not emit namespace blocks, and prepend namespace name in class declarations",
        )
        parser.add_argument(
            "--flatten-nested-classes",
            action="store_true",
            default=False,
            help="write nested classes at the same level of their inclosing classes, and prepend enclosing class name in their declarations",
        )
        parser.add_argument(
            "--keep-implicit-base-classes",
            action="store_true",
            default=False,
            help="write implicit base classes (class -> System.Object, struct -> System.ValueType, enum -> System.Enum) in class declarations",
        )
        parser.add_argument(
            "--enums-as-structs",
            action="store_true",
            default=False,
            help="write enum class declarations as structs",
        )
        parser.add_argument(
            "--no-type-keywords",
            action="store_true",
            default=False,
            help="use fully qualified names for builtin types instead of their keywords (e.g. use 'System.Int32' instead of 'int', or 'System.Object' instead of 'object')",
        )
        parser.add_argument(
            "--actual-constructor-names",
            action="store_true",
            default=False,
            help="write actual constructors names (e.g. '.ctor' and '.cctor')",
        )
        parser.add_argument(
            "--indentation-size",
            type=int,
            default=4,
            help="indentation size (defaults to 4)",
        )

    @override
    def on_send(self, payload: AssemblyDump | ClassDump):
        if payload["type"] == "assembly":
            self._assemblies_dump[payload["handle"]] = payload
            assembly = self._assemblies_dump[payload["handle"]]
            self.app.next_status()
        elif payload["type"] == "class":
            self._classes_dump[payload["handle"]] = payload
            assembly = self._assemblies_dump[payload["assembly_handle"]]
        else:
            raise ValueError(f"Unknow dump type {payload}")

        self.app.update_status(
            f"Dumping {colorama.Fore.BLUE}{assembly['name']}{colorama.Fore.RESET}: {payload.get('nth', 1)} of {assembly['class_count']} classes"
        )

    @override
    def on_exit(self, payload: dict):
        self.app.print(
            f"Collected {colorama.Style.BRIGHT}{colorama.Fore.GREEN}{len(self._classes_dump)}{colorama.Style.RESET_ALL} classes in {payload['elapsed_ms'] / 1000:.2f}s"
        )

        if self.app.options.cs_output != "none":
            if self.app.options.cs_output != "stdout":
                self.app.update_status("Saving dump...")

            dumper = Dumper(
                assemblies_dump=self._assemblies_dump,
                classes_dump=self._classes_dump,
                output_base_path=self._output_base_path,
                config=Dumper.Config(
                    one_file_per_assembly=self.app.options.cs_output == "tree",
                    emit_namespaces=not self.app.options.no_namespaces,
                    flatten_nested_classes=self.app.options.flatten_nested_classes,
                    keep_implicit_base_classes=self.app.options.keep_implicit_base_classes,
                    enums_as_structs=self.app.options.enums_as_structs,
                    use_type_keywords=not self.app.options.no_type_keywords,
                    use_actual_constructor_names=self.app.options.actual_constructor_names,
                    indentation_size=self.app.options.indentation_size,
                ),
            )
            dumper.dump()

            if self.app.options.cs_output != "stdout":
                self.app.update_status(f"Dump saved to {dumper.output_base_path}")

    @property
    def _output_base_path(self) -> Path | None:
        if self.app.options.cs_output != "stdout":
            return (
                self.app.options.out_dir.resolve().absolute()
                / self.app.target["identifier"]
                / self.app.target["version"]
            )
        else:
            return None



================================================
FILE: cli/src/dump/dumper.py
================================================
from typing import Self
from dataclasses import dataclass

from itertools import zip_longest, groupby
from pathlib import Path

from ..utils.io import TextSink, ConsoleTextSink, FileTextSink, NopTextSink, refstr
from .models import (
    AssemblyHandle,
    ClassHandle,
    AssemblyDump,
    ClassDump,
    FieldDump,
    MethodDump,
)


class Dumper:
    @dataclass
    class Config:
        one_file_per_assembly: bool = True
        emit_namespaces: bool = True
        flatten_nested_classes: bool = False
        keep_implicit_base_classes: bool = False
        enums_as_structs: bool = False
        use_type_keywords: bool = True
        use_actual_constructor_names: bool = False
        indentation_size: int = 4

    BUILTIN_TYPE_TO_KEYWORD = {
        "System.Void": "void",
        "System.Boolean": "bool",
        "System.Byte": "byte",
        "System.SByte": "sbyte",
        "System.Char": "char",
        "System.Int16": "short",
        "System.UInt16": "ushort",
        "System.Int32": "int",
        "System.UInt32": "uint",
        "System.Int64": "long",
        "System.UInt64": "ulong",
        "System.IntPtr": "nint",
        "System.UIntPtr": "nuint",
        "System.Single": "float",
        "System.Double": "double",
        "System.Decimal": "decimal",
        "System.Object": "object",
        "System.String": "string",
    }

    BASE_TYPE_TO_KEYWORD = {
        "System.Object": "object",
        "System.ValueType": "struct",
        "System.Enum": "enum",
    }

    def __init__(
        self,
        assemblies_dump: dict[AssemblyHandle, AssemblyDump],
        classes_dump: dict[ClassHandle, ClassDump],
        output_base_path: Path | None,
        config: Config,
    ):
        self.assemblies_dump = assemblies_dump
        self.classes_dump = classes_dump
        self.output_base_path = output_base_path
        self.config = config
        self.output = IndentedTextWriter(
            sink=NopTextSink(),
            indentation_size=self.config.indentation_size,
        )

    def dump(self) -> None:
        if self.output_base_path is not None:
            if not self.config.one_file_per_assembly:
                self.output = IndentedTextWriter(
                    sink=FileTextSink(
                        path=(self.output_base_path / "dump").with_suffix(".cs")
                    ),
                    indentation_size=self.config.indentation_size,
                )
        else:
            self.output = IndentedTextWriter(
                sink=ConsoleTextSink(), indentation_size=self.config.indentation_size
            )

        for class_dump in self.classes_dump.values():
            if not self.config.flatten_nested_classes and (
                declaring_class_handle := class_dump.get("declaring_class_handle")
            ):
                declaring_class = self.classes_dump[declaring_class_handle]
                declaring_class["nested_classes_handles"] = (
                    declaring_class.get("nested_classes_handles") or []
                )
                declaring_class["nested_classes_handles"].append(class_dump["handle"])

            if self.config.enums_as_structs and class_dump["kind"] == "enum":
                class_dump["kind"] = "struct"

        for assembly_handle, classes_dump in groupby(
            sorted(self.classes_dump.values(), key=lambda _: _["assembly_handle"]),
            key=lambda _: _["assembly_handle"],
        ):
            require_new_line = False

            if self.config.one_file_per_assembly:
                self.output.close()

                if self.output_base_path:
                    self.output = IndentedTextWriter(
                        sink=FileTextSink(
                            path=(
                                self.output_base_path
                                / self.assemblies_dump[assembly_handle]["name"].replace(
                                    ".", "/"
                                )
                            ).with_suffix(".cs")
                        ),
                        indentation_size=self.config.indentation_size,
                    )
                else:
                    require_new_line = True

            current_namespace_parts = []

            for class_dump in classes_dump:
                if (
                    self.config.emit_namespaces
                    and "declaring_class_handle" not in class_dump
                ):
                    namespace_parts = (
                        class_dump["namespace"].split(".")
                        if class_dump.get("namespace")
                        else []
                    )

                    for i, (a, b) in enumerate(
                        zip_longest(namespace_parts, current_namespace_parts)
                    ):
                        if a != b:
                            for j in reversed(range(len(current_namespace_parts) - i)):
                                self.output.dedent().write("}")
                            if require_new_line:
                                require_new_line = False
                                self.output.ln()
                            for j in range(len(namespace_parts) - i):
                                self.output.write(
                                    f"namespace {namespace_parts[i + j]}"
                                ).write("{").indent()

                            current_namespace_parts = namespace_parts
                            break

                if (
                    not self.config.flatten_nested_classes
                    and class_dump.get("declaring_class_handle") is not None
                ):
                    continue

                if require_new_line:
                    self.output.ln()

                self._write_class(class_dump=class_dump)
                require_new_line = True

            for _ in range(len(current_namespace_parts)):
                self.output.dedent().write("}")

        self.output.close()

    def _write_class(self, class_dump: ClassDump) -> None:
        require_new_line = False

        if not self.config.one_file_per_assembly:
            with self.output as l:
                l += "// "
                l += self.assemblies_dump[class_dump["assembly_handle"]]["name"]

        with self.output as l:
            l += class_dump["kind"]
            l += " "
            l += self._class_name(class_dump)
            if parent_type_name := class_dump.get("parent_type_name"):
                if (
                    not self.config.keep_implicit_base_classes
                    and parent_type_name in self.BASE_TYPE_TO_KEYWORD
                ):
                    parent_type_name = None
                else:
                    l += " : "
                    l += self._type_name(parent_type_name)
            if interfaces_type_names := class_dump.get("interfaces_type_names"):
                l += ", " if parent_type_name else " : "
                for i, interface_type_name in enumerate(interfaces_type_names):
                    l += ", " if i > 0 else ""
                    l += self._type_name(interface_type_name)

        self.output.write("{").indent()

        fields = class_dump.get("fields") or []
        literal_fields = [_ for _ in fields if _["is_literal"]]
        static_fields = [
            _
            for _ in fields
            if _["is_static"] and not _["is_thread_static"] and not _["is_literal"]
        ]
        thread_static_fields = [_ for _ in fields if _["is_thread_static"]]
        instance_fields = [_ for _ in fields if not _["is_static"]]

        methods = class_dump.get("methods") or []
        static_methods = sorted(
            [_ for _ in methods if _["is_static"]],
            key=lambda _: _["name"] == ".cctor",
            reverse=True,
        )
        instance_methods = sorted(
            [_ for _ in methods if not _["is_static"]],
            key=lambda _: _["name"] == ".ctor",
            reverse=True,
        )

        for field_group in [
            literal_fields,
            static_fields,
            thread_static_fields,
            instance_fields,
        ]:
            require_new_line = require_new_line or len(field_group) > 0
            for field_dump in field_group:
                if class_dump["kind"] == "enum":
                    self._write_enum_field(field_dump=field_dump)
                else:
                    self._write_field(field_dump=field_dump)

        if require_new_line and methods:
            require_new_line = False
            self.output.ln()

        for method_group in [static_methods, instance_methods]:
            require_new_line = require_new_line or len(method_group) > 0
            for method_dump in method_group:
                self._write_method(
                    method_dump=method_dump, declared_in_class_dump=class_dump
                )

        if require_new_line and class_dump.get("nested_classes_handles"):
            require_new_line = False
            self.output.ln()

        for i, nested_class_handle in enumerate(
            class_dump.get("nested_classes_handles") or []
        ):
            if i > 0:
                self.output.ln()
            self._write_class(self.classes_dump[nested_class_handle])

        self.output.dedent().write("}")

    def _write_field(self, field_dump: FieldDump):
        with self.output as l:
            if field_dump["is_thread_static"]:
                l += "[ThreadStatic] "
            if field_dump["is_static"]:
                l += "static "
            if (offset := field_dump.get("offset")) is not None:
                l += "/*"
                l += hex(offset)
                l += "*/ "
            l += self._type_name(field_dump["type_name"])
            l += " "
            l += field_dump["name"]
            if (value := field_dump.get("value", None)) is not None:
                l += " = "
                l += str(value)
            l += ";"

    def _write_enum_field(self, field_dump: FieldDump):
        if not field_dump["is_static"]:
            return
        with self.output as l:
            l += field_dump["name"]
            if (value := field_dump.get("value", None)) is not None:
                l += " = "
                l += str(value)
            l += ","

    def _write_method(self, method_dump: MethodDump, declared_in_class_dump: ClassDump):
        with self.output as l:
            if method_dump["is_static"]:
                l += "static "
            if (offset := method_dump.get("offset")) is not None:
                l += "/*"
                l += offset.lower()
                l += "*/ "
            if not self.config.use_actual_constructor_names and (
                method_dump["name"] == ".ctor" or method_dump["name"] == ".cctor"
            ):
                l += self._constructor_name(declared_in_class_dump)
            else:
                l += self._type_name(method_dump["return_type_name"])
                l += " "
                l += method_dump["name"]
            if generics_type_names := method_dump.get("generics_type_names"):
                l += "<"
                for i, generic_type_name in enumerate(generics_type_names):
                    l += ", " if i > 0 else ""
                    l += self._type_name(generic_type_name)
                l += ">"
            l += "("
            for i, param in enumerate(
                sorted(method_dump.get("parameters", []), key=lambda _: _["position"])
            ):
                l += ", " if i > 0 else ""
                l += self._type_name(param["type_name"])
                l += " "
                l += param["name"]
            l += ");"

    def _class_name(
        self,
        class_dump_or_handle: str | ClassDump,
        include_namespace_name: bool | None = None,
        include_declaring_class_name: bool | None = None,
    ) -> str:
        if isinstance(class_dump_or_handle, str):
            try:
                class_dump = self.classes_dump[class_dump_or_handle]
            except KeyError:
                return "__MISSING__"
        else:
            class_dump = class_dump_or_handle

        if include_namespace_name is None:
            include_namespace_name = not self.config.emit_namespaces

        if include_declaring_class_name is None:
            include_declaring_class_name = self.config.flatten_nested_classes

        s = ""

        if include_namespace_name and (namespace := class_dump.get("namespace")):
            s += namespace + "."

        if include_declaring_class_name and (
            declaring_class_handle := class_dump.get("declaring_class_handle")
        ):
            s += (
                self._class_name(
                    class_dump_or_handle=self.classes_dump[declaring_class_handle],
                    include_namespace_name=include_namespace_name,
                    include_declaring_class_name=include_declaring_class_name,
                )
                + "."
            )

        s += class_dump["name"]

        if generics_type_names := class_dump.get("generics_type_names"):
            s = (
                s.rstrip("`" + str(len(generics_type_names)))
                + "<"
                + ", ".join(generics_type_names)
                + ">"
            )

        return s

    def _constructor_name(self, class_dump: ClassDump) -> str:
        if generics_type_names := class_dump.get("generics_type_names"):
            return class_dump["name"].rstrip("`" + str(len(generics_type_names)))
        else:
            return class_dump["name"]

    def _type_name(self, type_name: str) -> str:
        if self.config.use_type_keywords:
            type_name = TypeNameCleaner.replace_known_types(
                type_name, self.BUILTIN_TYPE_TO_KEYWORD
            )
            type_name = TypeNameCleaner.add_ref_keyword_for_reference_types(type_name)
        type_name = TypeNameCleaner.add_space_after_comma_in_generic_parameters(
            type_name
        )
        return type_name


class TypeNameCleaner:
    @staticmethod
    def add_ref_keyword_for_reference_types(type_name: str) -> str:
        return "ref " + type_name[:-1] if type_name.endswith("&") else type_name

    @staticmethod
    def add_space_after_comma_in_generic_parameters(type_name: str) -> str:
        try:
            start = type_name.index("<")
            end = type_name.rindex(">")
            return type_name[:start] + type_name[start : end + 1].replace(
                ", ", ","
            ).replace(",", ", ")
        except ValueError:
            return type_name

    @staticmethod
    def replace_known_types(type_name: str, mapping: dict[str, str]) -> str:
        for name, replacement in mapping.items():
            if type_name == name:
                return replacement

            for char in [">", ",", "*"]:
                type_name = type_name.replace(name + char, replacement + char)

            if type_name == name + "&":
                return replacement + "&"
            elif type_name.startswith(name + "["):
                return replacement + type_name[len(name) :]

        return type_name


class IndentedTextWriter:
    def __init__(
        self,
        sink: TextSink,
        indentation_size: int = 4,
    ):
        self.sink = sink
        self.indentation_size = indentation_size
        self.indentation_level = 0

        self._context_buf = refstr()

    def indent(self) -> Self:
        self.indentation_level += 1
        return self

    def dedent(self) -> Self:
        self.indentation_level -= 1
        return self

    def ln(self) -> Self:
        self.sink.write("\n")
        return self

    def write(self, text: str) -> Self:
        self.sink.write(
            " " * self.indentation_size * self.indentation_level + text + "\n"
        )
        return self

    def close(self) -> None:
        self.sink.close()

    def __enter__(self) -> refstr:
        return self._context_buf

    def __exit__(self, *_) -> None:
        text = self._context_buf.s
        self._context_buf = refstr()
        self.write(text)



================================================
FILE: cli/src/dump/models.py
================================================
from __future__ import annotations
from typing import TypedDict, Literal, Any


type AssemblyHandle = str


type ClassHandle = str


class AssemblyDump(TypedDict):
    type: Literal["assembly"]
    handle: AssemblyHandle
    name: str
    class_count: int


class ClassDump(TypedDict):
    type: Literal["class"]
    assembly_handle: AssemblyHandle
    handle: ClassHandle
    declaring_class_handle: ClassHandle
    namespace: str | None
    name: str
    generics_type_names: list[str]
    kind: Literal["enum", "struct", "interface", "class"]
    parent_type_name: str
    interfaces_type_names: list[str]
    fields: list[FieldDump]
    methods: list[MethodDump]
    nested_classes_handles: list[ClassHandle] | None


class FieldDump(TypedDict):
    name: str
    type_name: str
    is_thread_static: bool
    is_static: bool
    is_literal: bool
    value: Any
    offset: int | None


class MethodDump(TypedDict):
    name: str
    is_static: bool
    generics_type_names: list[str]
    return_type_name: str
    parameters: list[ParameterDump]
    offset: str | None


class ParameterDump(TypedDict):
    name: str
    type_name: str
    position: int



================================================
FILE: cli/src/utils/__init__.py
================================================
[Empty file]


================================================
FILE: cli/src/utils/app.py
================================================
from __future__ import annotations
from typing import Any, override, Mapping
from abc import ABC, abstractmethod

import argparse
from frida_tools.application import ConsoleApplication, ConsoleState


class Application(ConsoleApplication):
    commands: dict[str, Command]
    options: argparse.Namespace

    @property
    def _selected_command(self) -> Command:
        return self.commands[self.options.command]

    def _add_commands(self, parser: argparse.ArgumentParser, **kwargs) -> None:
        subparsers = parser.add_subparsers(dest="command", required=True, **kwargs)

        for name, command in self.commands.items():
            subparser = subparsers.add_parser(name=name, **command.parser)
            command.add_arguments(subparser)

    @override
    def _initialize(
        self,
        parser: argparse.ArgumentParser,
        options: argparse.Namespace,
        args: list[str],
    ) -> None:
        self.options = options
        return super()._initialize(parser, options, args)

    def print(self, *args: Any, **kwargs: Any) -> None:
        return self._print(*args, **kwargs)

    def update_status(self, message: str) -> None:
        return self._update_status(message)

    def next_status(self) -> None:
        if self._console_state == ConsoleState.STATUS:
            self._print("", end="", flush=True)


class Command[
    T: "Application",
    SendPayload: Mapping[str, object],
    ExitPayload: Mapping[str, object],
](ABC):
    NAME: str

    def __init__(self, app: T):
        self.app = app

    @property
    @abstractmethod
    def agent_src(self) -> str:
        pass

    @property
    @abstractmethod
    def parser(self) -> dict:
        pass

    @abstractmethod
    def add_arguments(self, parser: argparse.ArgumentParser) -> None:
        pass

    @abstractmethod
    def on_send(self, payload: SendPayload) -> None:
        pass

    @abstractmethod
    def on_exit(self, payload: ExitPayload) -> None:
        pass



================================================
FILE: cli/src/utils/io.py
================================================
from typing import override
from pathlib import Path
from sys import stdout


class refstr:
    def __init__(self):
        self.s = ""

    def __add__(self, s):
        self.s += s
        return self

    def __str__(self):
        return self.s


class TextSink:
    def write(self, text: str) -> None:
        pass

    def close(self) -> None:
        pass


class NopTextSink(TextSink):
    pass


class ConsoleTextSink(TextSink):
    @override
    def write(self, text: str) -> None:
        stdout.write(text)


class StrTextSink(TextSink):
    def __init__(self):
        self.s = ""

    @override
    def write(self, text: str) -> None:
        self.s += text


class FileTextSink(TextSink):
    def __init__(self, path: Path):
        path.parent.mkdir(parents=True, exist_ok=True)
        self.file = open(path, mode="w", encoding="utf-8")

    @override
    def write(self, text: str) -> None:
        self.file.write(text)

    @override
    def close(self) -> None:
        self.file.close()



================================================
FILE: cli/tests/__init__.py
================================================
[Empty file]


================================================
FILE: cli/tests/dump/__init__.py
================================================
[Empty file]


================================================
FILE: cli/tests/dump/test_type_name_cleaner.py
================================================
import unittest

from src.dump.dumper import TypeNameCleaner


class TestTypeNameCleaner(unittest.TestCase):
    def test_add_ref_keyword_for_reference_types(self):
        for type_name, expected in [
            ("", None),
            ("&", "ref "),
            ("System.Boolean&", "ref System.Boolean"),
            ("<Module>&", "ref <Module>"),
            ("<>__message&", "ref <>__message"),
            ("Unicode.Contraction[]&", "ref Unicode.Contraction[]"),
            ("System.Byte*&", "ref System.Byte*"),
            ("System.ArraySegment<T>&", "ref System.ArraySegment<T>"),
            ("System.ArraySegment<&T>", None),
            ("Something<T&>", None),
            ("&Something", None),
        ]:
            self.assertEqual(
                TypeNameCleaner.add_ref_keyword_for_reference_types(type_name),
                expected if expected is not None else type_name,
            )

    def test_add_space_after_comma_in_generic_parameters(self):
        for type_name, expected in [
            ("", None),
            (",", None),
            (", ", None),
            ("System.Boolean,", "System.Boolean,"),
            ("<Module,>", "<Module, >"),
            ("System.Action<T,U>", "System.Action<T, U>"),
            ("System.Action<T, U>", None),
            (
                "Action<T,Action<T,Action<T,U,J>>,K>",
                "Action<T, Action<T, Action<T, U, J>>, K>",
            ),
            ("<>Foo<A>", None),
            ("<>Foo<A,B>", "<>Foo<A, B>"),
        ]:
            self.assertEqual(
                TypeNameCleaner.add_space_after_comma_in_generic_parameters(type_name),
                expected if expected is not None else type_name,
            )

    def test_replace_known_types(self):
        mapping = {
            "System.Boolean": "bool",
        }
        for type_name, expected in [
            ("", None),
            ("System.Boolean", "bool"),
            ("System.Boolean&", "bool&"),
            ("System.Boolean*", "bool*"),
            ("System.Boolean**", "bool**"),
            ("System.Boolean.Something", None),
            ("System.Action<System.Boolean>", "System.Action<bool>"),
            ("System.Action<System.Boolean.A>", None),
            ("System.Foo<System.Boolean,System.Boolean>", "System.Foo<bool,bool>"),
            ("System.Foo<System.Boolean, System.Boolean>", "System.Foo<bool, bool>"),
            (
                "Foo<Bar<System.Boolean>, Foo<System.Boolean>>",
                "Foo<Bar<bool>, Foo<bool>>",
            ),
            ("Foo<System.Boolean**>", "Foo<bool**>"),
            ("Foo<System.Boolean&>", "Foo<System.Boolean&>"),
        ]:
            self.assertEqual(
                TypeNameCleaner.replace_known_types(type_name, mapping),
                expected if expected is not None else type_name,
            )



================================================
FILE: example/index.ts
================================================
import "frida-il2cpp-bridge";

Il2Cpp.perform(() => {
    console.log(`Hello, Unity ${Il2Cpp.unityVersion}`);
});



================================================
FILE: example/package.json
================================================
{
  "name": "frida-il2cpp-bridge-example",
  "private": true,
  "source": "index.ts",
  "type": "module",
  "scripts": {
    "build:esbuild": "npm exec esbuild -- --bundle --outfile=dist/index.js --watch index.ts",
    "build:frida-compile": "npm exec frida-compile -- --output dist/index.js --watch index.ts",
    "frida:local": "frida -l dist/index.js --runtime qjs",
    "run:host": "npm run frida:local -- --kill-on-exit -f ../build/host ../build/$UNITY_VERSION/out",
    "run:host:5.3.5f1": "UNITY_VERSION=5.3.5f1 npm run run:host",
    "run:host:2019.3.0f1": "UNITY_VERSION=2019.3.0f1 npm run run:host",
    "run:host:6000.1.0f1": "UNITY_VERSION=6000.1.0f1 npm run run:host",
    "dump:host": "npm exec frida-il2cpp-bridge -- -f ../build/host ../build/$UNITY_VERSION/out dump --out-dir dist",
    "dump:host:5.3.5f1": "UNITY_VERSION=5.3.5f1 npm run dump:host -- --no-type-keywords --actual-constructor-names --keep-implicit-base-classes",
    "dump:host:2019.3.0f1":  "UNITY_VERSION=2019.3.0f1 npm run dump:host"
  },
  "dependencies": {
    "frida-il2cpp-bridge": "file:.."
  },
  "devDependencies": {
    "esbuild": "^0.25.2",
    "frida-compile": "^16.4.2",
    "@types/frida-gum": "^18.8.2"
  },
  "prettier": {
    "tabWidth": 4,
    "arrowParens": "avoid",
    "trailingComma": "none",
    "printWidth": 120
  }
}



================================================
FILE: example/tsconfig.json
================================================
{
  "compilerOptions": {
      "target": "esnext",
      "lib": ["es2022"],
      "esModuleInterop": false,
      "moduleResolution": "bundler",
      "allowJs": true,
      "strict": true,
      "sourceMap": false
  },
  "files": ["index.ts"],
  "exclude": ["dist"]
}



================================================
FILE: lib/application.ts
================================================
namespace Il2Cpp {
    /** */
    export const application = {
        /**
         * Gets the data path name of the current application, e.g.
         * `/data/emulated/0/Android/data/com.example.application/files`
         * on Android.
         *
         * **This information is not guaranteed to exist.**
         *
         * ```ts
         * Il2Cpp.perform(() => {
         *     // prints /data/emulated/0/Android/data/com.example.application/files
         *     console.log(Il2Cpp.application.dataPath);
         * });
         * ```
         */
        get dataPath(): string | null {
            return unityEngineCall("get_persistentDataPath");
        },

        /**
         * Gets the identifier name of the current application, e.g.
         * `com.example.application` on Android.
         *
         * In case the identifier cannot be retrieved, the main module name is
         * returned instead, which typically is the process name.
         *
         * ```ts
         * Il2Cpp.perform(() => {
         *     // prints com.example.application
         *     console.log(Il2Cpp.application.identifier);
         * });
         * ```
         */
        get identifier(): string {
            return unityEngineCall("get_identifier") ?? unityEngineCall("get_bundleIdentifier") ?? Process.mainModule.name;
        },

        /**
         * Gets the version name of the current application, e.g. `4.12.8`.
         *
         * In case the version cannot be retrieved, an hash of the IL2CPP
         * module is returned instead.
         *
         * ```ts
         * Il2Cpp.perform(() => {
         *     // prints 4.12.8
         *     console.log(Il2Cpp.application.version);
         * });
         * ```
         */
        get version(): string {
            return unityEngineCall("get_version") ?? exportsHash(Il2Cpp.module).toString(16);
        }
    };

    /**
     * Gets the Unity version of the current application.
     *
     * **It is possible to override or manually set its value using
     * {@link Il2Cpp.$config.unityVersion}:**
     * ```ts
     * Il2Cpp.$config.unityVersion = "5.3.5f1";
     *
     * Il2Cpp.perform(() => {
     *     // prints 5.3.5f1
     *     console.log(Il2Cpp.unityVersion);
     * });
     * ```
     *
     * When overriding its value, the user has to make sure to set a valid
     * value so that it gets matched by the following regular expression:
     * ```
     * (20\d{2}|\d)\.(\d)\.(\d{1,2})(?:[abcfp]|rc){0,2}\d?
     * ```
     */
    export declare const unityVersion: string;
    // prettier-ignore
    getter(Il2Cpp, "unityVersion", () => {
        try {
            const unityVersion = Il2Cpp.$config.unityVersion ?? unityEngineCall("get_unityVersion");

            if (unityVersion != null) {
                return unityVersion;
            }
        } catch(_) {
        }

        const searchPattern = "69 6c 32 63 70 70";

        for (const range of module.enumerateRanges("r--").concat(Process.getRangeByAddress(module.base))) {
            for (let { address } of Memory.scanSync(range.base, range.size, searchPattern)) {
                while (address.readU8() != 0) {
                    address = address.sub(1);
                }
                const match = UnityVersion.find(address.add(1).readCString());

                if (match != undefined) {
                    return match;
                }
            }
        }

        raise("couldn't determine the Unity version, please specify it manually");
    }, lazy);

    /** @internal */
    export declare const unityVersionIsBelow201830: boolean;
    // prettier-ignore
    getter(Il2Cpp, "unityVersionIsBelow201830", () => {
        return UnityVersion.lt(unityVersion, "2018.3.0");
    }, lazy);

    /** @internal */
    export declare const unityVersionIsBelow202120: boolean;
    // prettier-ignore
    getter(Il2Cpp, "unityVersionIsBelow202120", () => {
        return UnityVersion.lt(unityVersion, "2021.2.0");
    }, lazy);

    function unityEngineCall(method: string): string | null {
        const handle = Il2Cpp.exports.resolveInternalCall(Memory.allocUtf8String("UnityEngine.Application::" + method));
        const nativeFunction = new NativeFunction(handle, "pointer", []);

        return nativeFunction.isNull() ? null : new Il2Cpp.String(nativeFunction()).asNullable()?.content ?? null;
    }
}



================================================
FILE: lib/boxed.ts
================================================
namespace Il2Cpp {
    /** Create a boxed primitive */
    export function boxed<T extends boolean | number | Int64 | UInt64 | NativePointer>(
        value: T,
        type?: T extends number
            ? "int8" | "uint8" | "int16" | "uint16" | "int32" | "uint32" | "int64" | "uint64" | "char"
            : T extends NativePointer
            ? "intptr" | "uintptr"
            : never
    ): Il2Cpp.Object {
        const mapping = {
            int8: "System.SByte",
            uint8: "System.Byte",
            int16: "System.Int16",
            uint16: "System.UInt16",
            int32: "System.Int32",
            uint32: "System.UInt32",
            int64: "System.Int64",
            uint64: "System.UInt64",
            char: "System.Char",
            intptr: "System.IntPtr",
            uintptr: "System.UIntPtr"
        };

        const className =
            typeof value == "boolean"
                ? "System.Boolean"
                : typeof value == "number"
                ? mapping[type ?? "int32"]
                : value instanceof Int64
                ? "System.Int64"
                : value instanceof UInt64
                ? "System.UInt64"
                : value instanceof NativePointer
                ? mapping[type ?? "intptr"]
                : raise(`Cannot create boxed primitive using value of type '${typeof value}'`);

        const object = Il2Cpp.corlib.class(className ?? raise(`Unknown primitive type name '${type}'`)).alloc();
        (object.tryField<T>("m_value") ?? object.tryField("_pointer") ?? raise(`Could not find primitive field in class '${className}'`)).value = value;

        return object;
    }
}



================================================
FILE: lib/config.ts
================================================
namespace Il2Cpp {
    /**
     * Set of configurations users can override. It is for advanced use cases,
     * when certain values cannot be detected automatically. \
     * For reference, see:
     * - {@link Il2Cpp.module};
     * - {@link Il2Cpp.unityVersion};
     * - {@link Il2Cpp.exports};
     */
    export const $config: {
        moduleName?: string;
        unityVersion?: string;
        exports?: Record<`il2cpp_${string}`, () => NativePointer>;
    } = {
        moduleName: undefined,
        unityVersion: undefined,
        exports: undefined
    };
}



================================================
FILE: lib/dump.ts
================================================
namespace Il2Cpp {
    /**
     * @deprecated
     * Dumps the application, i.e. it creates a dummy `.cs` file that contains
     * all the class, field and method declarations.
     *
     * The dump is very useful when it comes to inspecting the application as
     * you can easily search for succulent members using a simple text search,
     * hence this is typically the very first thing it should be done when
     * working with a new application. \
     * Keep in mind the dump is version, platform and arch dependentend, so
     * it has to be re-genereated if any of these changes.
     *
     * The file is generated in the **target** device, so you might need to
     * pull it to the host device afterwards.
     *
     * Dumping *may* require a file name and a directory path (a place where the
     * application can write to). If not provided, the target path is generated
     * automatically using the information from {@link Il2Cpp.application}.
     *
     * ```ts
     * Il2Cpp.perform(() => {
     *     Il2Cpp.dump();
     * });
     * ```
     *
     * For instance, the dump resembles the following:
     * ```
     * class Mono.DataConverter.PackContext : System.Object
     * {
     *     System.Byte[] buffer; // 0x10
     *     System.Int32 next; // 0x18
     *     System.String description; // 0x20
     *     System.Int32 i; // 0x28
     *     Mono.DataConverter conv; // 0x30
     *     System.Int32 repeat; // 0x38
     *     System.Int32 align; // 0x3c
     *
     *     System.Void Add(System.Byte[] group); // 0x012ef4f0
     *     System.Byte[] Get(); // 0x012ef6ec
     *     System.Void .ctor(); // 0x012ef78c
     *   }
     * ```
     */
    export function dump(fileName?: string, path?: string): void {
        fileName = fileName ?? `${Il2Cpp.application.identifier}_${Il2Cpp.application.version}.cs`;
        path = path ?? Il2Cpp.application.dataPath ?? Process.getCurrentDir();

        createDirectoryRecursively(path);

        const destination = `${path}/${fileName}`;
        const file = new File(destination, "w");

        for (const assembly of Il2Cpp.domain.assemblies) {
            inform(`dumping ${assembly.name}...`);

            for (const klass of assembly.image.classes) {
                file.write(`${klass}\n\n`);
            }
        }

        file.flush();
        file.close();
        ok(`dump saved to ${destination}`);
        showDeprecationNotice();
    }

    /**
     * @deprecated
     * Just like {@link Il2Cpp.dump}, but a `.cs` file per assembly is
     * generated instead of having a single big `.cs` file. For instance, all
     * classes within `System.Core` and `System.Runtime.CompilerServices.Unsafe`
     * are dumped into `System/Core.cs` and
     * `System/Runtime/CompilerServices/Unsafe.cs`, respectively.
     *
     * ```ts
     * Il2Cpp.perform(() => {
     *     Il2Cpp.dumpTree();
     * });
     * ```
     */
    export function dumpTree(path?: string, ignoreAlreadyExistingDirectory: boolean = false): void {
        path = path ?? `${Il2Cpp.application.dataPath ?? Process.getCurrentDir()}/${Il2Cpp.application.identifier}_${Il2Cpp.application.version}`;

        if (!ignoreAlreadyExistingDirectory && directoryExists(path)) {
            raise(`directory ${path} already exists - pass ignoreAlreadyExistingDirectory = true to skip this check`);
        }

        for (const assembly of Il2Cpp.domain.assemblies) {
            inform(`dumping ${assembly.name}...`);

            const destination = `${path}/${assembly.name.replaceAll(".", "/")}.cs`;

            createDirectoryRecursively(destination.substring(0, destination.lastIndexOf("/")));

            const file = new File(destination, "w");

            for (const klass of assembly.image.classes) {
                file.write(`${klass}\n\n`);
            }

            file.flush();
            file.close();
        }

        ok(`dump saved to ${path}`);
        showDeprecationNotice();
    }

    function directoryExists(path: string): boolean {
        return Il2Cpp.corlib.class("System.IO.Directory").method<boolean>("Exists").invoke(Il2Cpp.string(path));
    }

    function createDirectoryRecursively(path: string) {
        Il2Cpp.corlib.class("System.IO.Directory").method("CreateDirectory").invoke(Il2Cpp.string(path));
    }

    function showDeprecationNotice() {
        warn("this api will be removed in a future release, please use `npx frida-il2cpp-bridge dump` instead");
    }
}



================================================
FILE: lib/exception-listener.ts
================================================
namespace Il2Cpp {
    /**
     * Installs a listener to track any thrown (unrecoverable) C# exception. \
     * This may be useful when incurring in `abort was called` errors.
     *
     * By default, it only tracks exceptions that were thrown by the *caller*
     * thread.
     *
     * **It may not work for every platform.**
     *
     * ```ts
     * Il2Cpp.perform(() => {
     *     Il2Cpp.installExceptionListener("all");
     *
     *     // rest of the code
     * });
     * ```
     *
     * For instance, it may print something along:
     * ```
     * System.NullReferenceException: Object reference not set to an instance of an object.
     *   at AddressableLoadWrapper+<LoadGameObject>d__3[T].MoveNext () [0x00000] in <00000000000000000000000000000000>:0
     *   at UnityEngine.SetupCoroutine.InvokeMoveNext (System.Collections.IEnumerator enumerator, System.IntPtr returnValueAddress) [0x00000] in <00000000000000000000000000000000>:0
     * ```
     */
    export function installExceptionListener(targetThread: "current" | "all" = "current"): InvocationListener {
        const currentThread = Il2Cpp.exports.threadGetCurrent();

        return Interceptor.attach(Il2Cpp.module.getExportByName("__cxa_throw"), function (args) {
            if (targetThread == "current" && !Il2Cpp.exports.threadGetCurrent().equals(currentThread)) {
                return;
            }

            inform(new Il2Cpp.Object(args[0].readPointer()));
        });
    }
}



================================================
FILE: lib/exports.ts
================================================
namespace Il2Cpp {
    /**
     * The **core** object where all the necessary IL2CPP native functions are
     * held. \
     * `frida-il2cpp-bridge` is built around this object by providing an
     * easy-to-use abstraction layer: the user isn't expected to use it directly,
     * but it can in case of advanced use cases.
     *
     * The exports depends on the Unity version, hence some of them may be
     * unavailable; moreover, they are searched by **name** (e.g.
     * `il2cpp_class_from_name`) hence they might get stripped, hidden or
     * renamed by a nasty obfuscator.
     *
     * However, it is possible to override or set the handle of any of the
     * exports using {@link Il2Cpp.$config.exports}:
     * ```ts
     * Il2Cpp.$config.exports = {
     *     il2cpp_image_get_class: () => Il2Cpp.module.base.add(0x1204c),
     *     il2cpp_class_get_parent: () => {
     *         return Memory.scanSync(Il2Cpp.module.base, Il2Cpp.module.size, "2f 10 ee 10 34 a8")[0].address;
     *     },
     * };
     *
     * Il2Cpp.perform(() => {
     *     // ...
     * });
     * ```
     */
    export const exports = {
        get alloc() {
            return r("il2cpp_alloc", "pointer", ["size_t"]);
        },

        get arrayGetLength() {
            return r("il2cpp_array_length", "uint32", ["pointer"]);
        },

        get arrayNew() {
            return r("il2cpp_array_new", "pointer", ["pointer", "uint32"]);
        },

        get assemblyGetImage() {
            return r("il2cpp_assembly_get_image", "pointer", ["pointer"]);
        },

        get classForEach() {
            return r("il2cpp_class_for_each", "void", ["pointer", "pointer"]);
        },

        get classFromName() {
            return r("il2cpp_class_from_name", "pointer", ["pointer", "pointer", "pointer"]);
        },

        get classFromObject() {
            return r("il2cpp_class_from_system_type", "pointer", ["pointer"]);
        },

        get classGetArrayClass() {
            return r("il2cpp_array_class_get", "pointer", ["pointer", "uint32"]);
        },

        get classGetArrayElementSize() {
            return r("il2cpp_class_array_element_size", "int", ["pointer"]);
        },

        get classGetAssemblyName() {
            return r("il2cpp_class_get_assemblyname", "pointer", ["pointer"]);
        },

        get classGetBaseType() {
            return r("il2cpp_class_enum_basetype", "pointer", ["pointer"]);
        },

        get classGetDeclaringType() {
            return r("il2cpp_class_get_declaring_type", "pointer", ["pointer"]);
        },

        get classGetElementClass() {
            return r("il2cpp_class_get_element_class", "pointer", ["pointer"]);
        },

        get classGetFieldFromName() {
            return r("il2cpp_class_get_field_from_name", "pointer", ["pointer", "pointer"]);
        },

        get classGetFields() {
            return r("il2cpp_class_get_fields", "pointer", ["pointer", "pointer"]);
        },

        get classGetFlags() {
            return r("il2cpp_class_get_flags", "int", ["pointer"]);
        },

        get classGetImage() {
            return r("il2cpp_class_get_image", "pointer", ["pointer"]);
        },

        get classGetInstanceSize() {
            return r("il2cpp_class_instance_size", "int32", ["pointer"]);
        },

        get classGetInterfaces() {
            return r("il2cpp_class_get_interfaces", "pointer", ["pointer", "pointer"]);
        },

        get classGetMethodFromName() {
            return r("il2cpp_class_get_method_from_name", "pointer", ["pointer", "pointer", "int"]);
        },

        get classGetMethods() {
            return r("il2cpp_class_get_methods", "pointer", ["pointer", "pointer"]);
        },

        get classGetName() {
            return r("il2cpp_class_get_name", "pointer", ["pointer"]);
        },

        get classGetNamespace() {
            return r("il2cpp_class_get_namespace", "pointer", ["pointer"]);
        },

        get classGetNestedClasses() {
            return r("il2cpp_class_get_nested_types", "pointer", ["pointer", "pointer"]);
        },

        get classGetParent() {
            return r("il2cpp_class_get_parent", "pointer", ["pointer"]);
        },

        get classGetStaticFieldData() {
            return r("il2cpp_class_get_static_field_data", "pointer", ["pointer"]);
        },

        get classGetValueTypeSize() {
            return r("il2cpp_class_value_size", "int32", ["pointer", "pointer"]);
        },

        get classGetType() {
            return r("il2cpp_class_get_type", "pointer", ["pointer"]);
        },

        get classHasReferences() {
            return r("il2cpp_class_has_references", "bool", ["pointer"]);
        },

        get classInitialize() {
            return r("il2cpp_runtime_class_init", "void", ["pointer"]);
        },

        get classIsAbstract() {
            return r("il2cpp_class_is_abstract", "bool", ["pointer"]);
        },

        get classIsAssignableFrom() {
            return r("il2cpp_class_is_assignable_from", "bool", ["pointer", "pointer"]);
        },

        get classIsBlittable() {
            return r("il2cpp_class_is_blittable", "bool", ["pointer"]);
        },

        get classIsEnum() {
            return r("il2cpp_class_is_enum", "bool", ["pointer"]);
        },

        get classIsGeneric() {
            return r("il2cpp_class_is_generic", "bool", ["pointer"]);
        },

        get classIsInflated() {
            return r("il2cpp_class_is_inflated", "bool", ["pointer"]);
        },

        get classIsInterface() {
            return r("il2cpp_class_is_interface", "bool", ["pointer"]);
        },

        get classIsSubclassOf() {
            return r("il2cpp_class_is_subclass_of", "bool", ["pointer", "pointer", "bool"]);
        },

        get classIsValueType() {
            return r("il2cpp_class_is_valuetype", "bool", ["pointer"]);
        },

        get domainGetAssemblyFromName() {
            return r("il2cpp_domain_assembly_open", "pointer", ["pointer", "pointer"]);
        },

        get domainGet() {
            return r("il2cpp_domain_get", "pointer", []);
        },

        get domainGetAssemblies() {
            return r("il2cpp_domain_get_assemblies", "pointer", ["pointer", "pointer"]);
        },

        get fieldGetClass() {
            return r("il2cpp_field_get_parent", "pointer", ["pointer"]);
        },

        get fieldGetFlags() {
            return r("il2cpp_field_get_flags", "int", ["pointer"]);
        },

        get fieldGetName() {
            return r("il2cpp_field_get_name", "pointer", ["pointer"]);
        },

        get fieldGetOffset() {
            return r("il2cpp_field_get_offset", "int32", ["pointer"]);
        },

        get fieldGetStaticValue() {
            return r("il2cpp_field_static_get_value", "void", ["pointer", "pointer"]);
        },

        get fieldGetType() {
            return r("il2cpp_field_get_type", "pointer", ["pointer"]);
        },

        get fieldSetStaticValue() {
            return r("il2cpp_field_static_set_value", "void", ["pointer", "pointer"]);
        },

        get free() {
            return r("il2cpp_free", "void", ["pointer"]);
        },

        get gcCollect() {
            return r("il2cpp_gc_collect", "void", ["int"]);
        },

        get gcCollectALittle() {
            return r("il2cpp_gc_collect_a_little", "void", []);
        },

        get gcDisable() {
            return r("il2cpp_gc_disable", "void", []);
        },

        get gcEnable() {
            return r("il2cpp_gc_enable", "void", []);
        },

        get gcGetHeapSize() {
            return r("il2cpp_gc_get_heap_size", "int64", []);
        },

        get gcGetMaxTimeSlice() {
            return r("il2cpp_gc_get_max_time_slice_ns", "int64", []);
        },

        get gcGetUsedSize() {
            return r("il2cpp_gc_get_used_size", "int64", []);
        },

        get gcHandleGetTarget() {
            return r("il2cpp_gchandle_get_target", "pointer", ["uint32"]);
        },

        get gcHandleFree() {
            return r("il2cpp_gchandle_free", "void", ["uint32"]);
        },

        get gcHandleNew() {
            return r("il2cpp_gchandle_new", "uint32", ["pointer", "bool"]);
        },

        get gcHandleNewWeakRef() {
            return r("il2cpp_gchandle_new_weakref", "uint32", ["pointer", "bool"]);
        },

        get gcIsDisabled() {
            return r("il2cpp_gc_is_disabled", "bool", []);
        },

        get gcIsIncremental() {
            return r("il2cpp_gc_is_incremental", "bool", []);
        },

        get gcSetMaxTimeSlice() {
            return r("il2cpp_gc_set_max_time_slice_ns", "void", ["int64"]);
        },

        get gcStartIncrementalCollection() {
            return r("il2cpp_gc_start_incremental_collection", "void", []);
        },

        get gcStartWorld() {
            return r("il2cpp_start_gc_world", "void", []);
        },

        get gcStopWorld() {
            return r("il2cpp_stop_gc_world", "void", []);
        },

        get getCorlib() {
            return r("il2cpp_get_corlib", "pointer", []);
        },

        get imageGetAssembly() {
            return r("il2cpp_image_get_assembly", "pointer", ["pointer"]);
        },

        get imageGetClass() {
            return r("il2cpp_image_get_class", "pointer", ["pointer", "uint"]);
        },

        get imageGetClassCount() {
            return r("il2cpp_image_get_class_count", "uint32", ["pointer"]);
        },

        get imageGetName() {
            return r("il2cpp_image_get_name", "pointer", ["pointer"]);
        },

        get initialize() {
            return r("il2cpp_init", "void", ["pointer"]);
        },

        get livenessAllocateStruct() {
            return r("il2cpp_unity_liveness_allocate_struct", "pointer", ["pointer", "int", "pointer", "pointer", "pointer"]);
        },

        get livenessCalculationBegin() {
            return r("il2cpp_unity_liveness_calculation_begin", "pointer", ["pointer", "int", "pointer", "pointer", "pointer", "pointer"]);
        },

        get livenessCalculationEnd() {
            return r("il2cpp_unity_liveness_calculation_end", "void", ["pointer"]);
        },

        get livenessCalculationFromStatics() {
            return r("il2cpp_unity_liveness_calculation_from_statics", "void", ["pointer"]);
        },

        get livenessFinalize() {
            return r("il2cpp_unity_liveness_finalize", "void", ["pointer"]);
        },

        get livenessFreeStruct() {
            return r("il2cpp_unity_liveness_free_struct", "void", ["pointer"]);
        },

        get memorySnapshotCapture() {
            return r("il2cpp_capture_memory_snapshot", "pointer", []);
        },

        get memorySnapshotFree() {
            return r("il2cpp_free_captured_memory_snapshot", "void", ["pointer"]);
        },

        get memorySnapshotGetClasses() {
            return r("il2cpp_memory_snapshot_get_classes", "pointer", ["pointer", "pointer"]);
        },

        get memorySnapshotGetObjects() {
            return r("il2cpp_memory_snapshot_get_objects", "pointer", ["pointer", "pointer"]);
        },

        get methodGetClass() {
            return r("il2cpp_method_get_class", "pointer", ["pointer"]);
        },

        get methodGetFlags() {
            return r("il2cpp_method_get_flags", "uint32", ["pointer", "pointer"]);
        },

        get methodGetName() {
            return r("il2cpp_method_get_name", "pointer", ["pointer"]);
        },

        get methodGetObject() {
            return r("il2cpp_method_get_object", "pointer", ["pointer", "pointer"]);
        },

        get methodGetParameterCount() {
            return r("il2cpp_method_get_param_count", "uint8", ["pointer"]);
        },

        get methodGetParameterName() {
            return r("il2cpp_method_get_param_name", "pointer", ["pointer", "uint32"]);
        },

        get methodGetParameters() {
            return r("il2cpp_method_get_parameters", "pointer", ["pointer", "pointer"]);
        },

        get methodGetParameterType() {
            return r("il2cpp_method_get_param", "pointer", ["pointer", "uint32"]);
        },

        get methodGetReturnType() {
            return r("il2cpp_method_get_return_type", "pointer", ["pointer"]);
        },

        get methodIsGeneric() {
            return r("il2cpp_method_is_generic", "bool", ["pointer"]);
        },

        get methodIsInflated() {
            return r("il2cpp_method_is_inflated", "bool", ["pointer"]);
        },

        get methodIsInstance() {
            return r("il2cpp_method_is_instance", "bool", ["pointer"]);
        },

        get monitorEnter() {
            return r("il2cpp_monitor_enter", "void", ["pointer"]);
        },

        get monitorExit() {
            return r("il2cpp_monitor_exit", "void", ["pointer"]);
        },

        get monitorPulse() {
            return r("il2cpp_monitor_pulse", "void", ["pointer"]);
        },

        get monitorPulseAll() {
            return r("il2cpp_monitor_pulse_all", "void", ["pointer"]);
        },

        get monitorTryEnter() {
            return r("il2cpp_monitor_try_enter", "bool", ["pointer", "uint32"]);
        },

        get monitorTryWait() {
            return r("il2cpp_monitor_try_wait", "bool", ["pointer", "uint32"]);
        },

        get monitorWait() {
            return r("il2cpp_monitor_wait", "void", ["pointer"]);
        },

        get objectGetClass() {
            return r("il2cpp_object_get_class", "pointer", ["pointer"]);
        },

        get objectGetVirtualMethod() {
            return r("il2cpp_object_get_virtual_method", "pointer", ["pointer", "pointer"]);
        },

        get objectInitialize() {
            return r("il2cpp_runtime_object_init_exception", "void", ["pointer", "pointer"]);
        },

        get objectNew() {
            return r("il2cpp_object_new", "pointer", ["pointer"]);
        },

        get objectGetSize() {
            return r("il2cpp_object_get_size", "uint32", ["pointer"]);
        },

        get objectUnbox() {
            return r("il2cpp_object_unbox", "pointer", ["pointer"]);
        },

        get resolveInternalCall() {
            return r("il2cpp_resolve_icall", "pointer", ["pointer"]);
        },

        get stringGetChars() {
            return r("il2cpp_string_chars", "pointer", ["pointer"]);
        },

        get stringGetLength() {
            return r("il2cpp_string_length", "int32", ["pointer"]);
        },

        get stringNew() {
            return r("il2cpp_string_new", "pointer", ["pointer"]);
        },

        get valueTypeBox() {
            return r("il2cpp_value_box", "pointer", ["pointer", "pointer"]);
        },

        get threadAttach() {
            return r("il2cpp_thread_attach", "pointer", ["pointer"]);
        },

        get threadDetach() {
            return r("il2cpp_thread_detach", "void", ["pointer"]);
        },

        get threadGetAttachedThreads() {
            return r("il2cpp_thread_get_all_attached_threads", "pointer", ["pointer"]);
        },

        get threadGetCurrent() {
            return r("il2cpp_thread_current", "pointer", []);
        },

        get threadIsVm() {
            return r("il2cpp_is_vm_thread", "bool", ["pointer"]);
        },

        get typeEquals() {
            return r("il2cpp_type_equals", "bool", ["pointer", "pointer"]);
        },

        get typeGetClass() {
            return r("il2cpp_class_from_type", "pointer", ["pointer"]);
        },

        get typeGetName() {
            return r("il2cpp_type_get_name", "pointer", ["pointer"]);
        },

        get typeGetObject() {
            return r("il2cpp_type_get_object", "pointer", ["pointer"]);
        },

        get typeGetTypeEnum() {
            return r("il2cpp_type_get_type", "int", ["pointer"]);
        }
    };

    decorate(exports, lazy);

    /** @internal */
    export declare const memorySnapshotExports: CModule;
    getter(Il2Cpp, "memorySnapshotExports", () => new CModule($inline_file("cmodules/memory-snapshot.c")), lazy);

    function r<R extends NativeFunctionReturnType, A extends NativeFunctionArgumentType[] | []>(exportName: `il2cpp_${string}`, retType: R, argTypes: A) {
        const handle: NativePointer | null | undefined =
            Il2Cpp.$config.exports?.[exportName]?.() ?? Il2Cpp.module.findExportByName(exportName) ?? memorySnapshotExports[exportName];

        const target = new NativeFunction(handle ?? NULL, retType, argTypes);

        return target.isNull()
            ? new Proxy(target, {
                  get(value: typeof target, name: keyof typeof target) {
                      const property = value[name];
                      return typeof property === "function" ? property.bind(value) : property;
                  },
                  apply() {
                      if (handle == null) {
                          raise(`couldn't resolve export ${exportName}`);
                      } else if (handle.isNull()) {
                          raise(`export ${exportName} points to NULL IL2CPP library has likely been stripped, obfuscated, or customized`);
                      }
                  }
              })
            : target;
    }

    declare const $inline_file: typeof import("ts-transformer-inline-file").$INLINE_FILE;
}



================================================
FILE: lib/filters.ts
================================================
namespace Il2Cpp {
    /**
     * Creates a filter to include elements whose type can be assigned to a
     * variable of the given class. \
     * It relies on {@link Il2Cpp.Class.isAssignableFrom}.
     *
     * ```ts
     * const IComparable = Il2Cpp.corlib.class("System.IComparable");
     *
     * const objects = [
     *     Il2Cpp.corlib.class("System.Object").new(),
     *     Il2Cpp.corlib.class("System.String").new()
     * ];
     *
     * const comparables = objects.filter(Il2Cpp.is(IComparable));
     * ```
     */
    export function is<T extends Il2Cpp.Class | Il2Cpp.Object | Il2Cpp.Type>(klass: Il2Cpp.Class): (element: T) => boolean {
        return (element: T): boolean => {
            if (element instanceof Il2Cpp.Class) {
                return klass.isAssignableFrom(element);
            } else {
                return klass.isAssignableFrom(element.class);
            }
        };
    }

    /**
     * Creates a filter to include elements whose type can be corresponds to
     * the given class. \
     * It compares the native handle of the element classes.
     *
     * ```ts
     * const String = Il2Cpp.corlib.class("System.String");
     *
     * const objects = [
     *     Il2Cpp.corlib.class("System.Object").new(),
     *     Il2Cpp.corlib.class("System.String").new()
     * ];
     *
     * const strings = objects.filter(Il2Cpp.isExactly(String));
     * ```
     */
    export function isExactly<T extends Il2Cpp.Class | Il2Cpp.Object | Il2Cpp.Type>(klass: Il2Cpp.Class): (element: T) => boolean {
        return (element: T): boolean => {
            if (element instanceof Il2Cpp.Class) {
                return element.equals(klass);
            } else {
                return element.class.equals(klass);
            }
        };
    }
}



================================================
FILE: lib/gc.ts
================================================
namespace Il2Cpp {
    /**
     * The object literal to interacts with the garbage collector.
     */
    export const gc = {
        /**
         * Gets the heap size in bytes.
         */
        get heapSize(): Int64 {
            return Il2Cpp.exports.gcGetHeapSize();
        },

        /**
         * Determines whether the garbage collector is enabled.
         */
        get isEnabled(): boolean {
            return !Il2Cpp.exports.gcIsDisabled();
        },

        /**
         * Determines whether the garbage collector is incremental
         * ([source](https://docs.unity3d.com/Manual/performance-incremental-garbage-collection.html)).
         */
        get isIncremental(): boolean {
            return !!Il2Cpp.exports.gcIsIncremental();
        },

        /**
         * Gets the number of nanoseconds the garbage collector can spend in a
         * collection step.
         */
        get maxTimeSlice(): Int64 {
            return Il2Cpp.exports.gcGetMaxTimeSlice();
        },

        /**
         * Gets the used heap size in bytes.
         */
        get usedHeapSize(): Int64 {
            return Il2Cpp.exports.gcGetUsedSize();
        },

        /**
         * Enables or disables the garbage collector.
         */
        set isEnabled(value: boolean) {
            value ? Il2Cpp.exports.gcEnable() : Il2Cpp.exports.gcDisable();
        },

        /**
         *  Sets the number of nanoseconds the garbage collector can spend in
         * a collection step.
         */
        set maxTimeSlice(nanoseconds: number | Int64) {
            Il2Cpp.exports.gcSetMaxTimeSlice(nanoseconds);
        },

        /**
         * Returns the heap allocated objects of the specified class. \
         * This variant reads GC descriptors.
         */
        choose(klass: Il2Cpp.Class): Il2Cpp.Object[] {
            const matches: Il2Cpp.Object[] = [];

            const callback = (objects: NativePointer, size: number) => {
                for (let i = 0; i < size; i++) {
                    matches.push(new Il2Cpp.Object(objects.add(i * Process.pointerSize).readPointer()));
                }
            };

            const chooseCallback = new NativeCallback(callback, "void", ["pointer", "int", "pointer"]);

            if (Il2Cpp.unityVersionIsBelow202120) {
                const onWorld = new NativeCallback(() => {}, "void", []);
                const state = Il2Cpp.exports.livenessCalculationBegin(klass, 0, chooseCallback, NULL, onWorld, onWorld);

                Il2Cpp.exports.livenessCalculationFromStatics(state);
                Il2Cpp.exports.livenessCalculationEnd(state);
            } else {
                const realloc = (handle: NativePointer, size: UInt64) => {
                    if (!handle.isNull() && size.compare(0) == 0) {
                        Il2Cpp.free(handle);
                        return NULL;
                    } else {
                        return Il2Cpp.alloc(size);
                    }
                };

                const reallocCallback = new NativeCallback(realloc, "pointer", ["pointer", "size_t", "pointer"]);

                this.stopWorld();

                const state = Il2Cpp.exports.livenessAllocateStruct(klass, 0, chooseCallback, NULL, reallocCallback);
                Il2Cpp.exports.livenessCalculationFromStatics(state);
                Il2Cpp.exports.livenessFinalize(state);

                this.startWorld();

                Il2Cpp.exports.livenessFreeStruct(state);
            }

            return matches;
        },

        /**
         * Forces a garbage collection of the specified generation.
         */
        collect(generation: 0 | 1 | 2): void {
            Il2Cpp.exports.gcCollect(generation < 0 ? 0 : generation > 2 ? 2 : generation);
        },

        /**
         * Forces a garbage collection.
         */
        collectALittle(): void {
            Il2Cpp.exports.gcCollectALittle();
        },

        /**
         *  Resumes all the previously stopped threads.
         */
        startWorld(): void {
            return Il2Cpp.exports.gcStartWorld();
        },

        /**
         * Performs an incremental garbage collection.
         */
        startIncrementalCollection(): void {
            return Il2Cpp.exports.gcStartIncrementalCollection();
        },

        /**
         * Stops all threads which may access the garbage collected heap, other
         * than the caller.
         */
        stopWorld(): void {
            return Il2Cpp.exports.gcStopWorld();
        }
    };
}



================================================
FILE: lib/index.ts
================================================
/// <reference path="./utils/android.ts">/>
/// <reference path="./utils/console.ts">/>
/// <reference path="./utils/decorate.ts">/>
/// <reference path="./utils/getter.ts">/>
/// <reference path="./utils/hash.ts">/>
/// <reference path="./utils/lazy.ts">/>
/// <reference path="./utils/native-struct.ts">/>
/// <reference path="./utils/object.ts">/>
/// <reference path="./utils/offset-of.ts">/>
/// <reference path="./utils/read-native-iterator.ts">/>
/// <reference path="./utils/read-native-list.ts">/>
/// <reference path="./utils/recycle.ts">/>
/// <reference path="./utils/unity-version.ts">/>

/// <reference path="./application.ts">/>
/// <reference path="./boxed.ts">/>
/// <reference path="./config.ts">/>
/// <reference path="./dump.ts">/>
/// <reference path="./exception-listener.ts">/>
/// <reference path="./exports.ts">/>
/// <reference path="./filters.ts">/>
/// <reference path="./gc.ts">/>
/// <reference path="./memory.ts">/>
/// <reference path="./module.ts">/>
/// <reference path="./perform.ts">/>
/// <reference path="./tracer.ts">/>

/// <reference path="./structs/array.ts">/>
/// <reference path="./structs/assembly.ts">/>
/// <reference path="./structs/class.ts">/>
/// <reference path="./structs/delegate.ts">/>
/// <reference path="./structs/domain.ts">/>
/// <reference path="./structs/field.ts">/>
/// <reference path="./structs/gc-handle.ts">/>
/// <reference path="./structs/image.ts">/>
/// <reference path="./structs/memory-snapshot.ts">/>
/// <reference path="./structs/method.ts">/>
/// <reference path="./structs/object.ts">/>
/// <reference path="./structs/parameter.ts">/>
/// <reference path="./structs/pointer.ts">/>
/// <reference path="./structs/reference.ts">/>
/// <reference path="./structs/string.ts">/>
/// <reference path="./structs/thread.ts">/>
/// <reference path="./structs/type.ts">/>
/// <reference path="./structs/value-type.ts">/>

globalThis.Il2Cpp = Il2Cpp;



================================================
FILE: lib/memory.ts
================================================
namespace Il2Cpp {
    /**
     * Allocates the given amount of bytes - it's equivalent to C's `malloc`. \
     * The allocated memory should be freed manually.
     */
    export function alloc(size: number | UInt64 = Process.pointerSize): NativePointer {
        return Il2Cpp.exports.alloc(size);
    }

    /**
     * Frees a previously allocated memory using {@link Il2Cpp.alloc} - it's
     *  equivalent to C's `free`..
     *
     * ```ts
     * const handle = Il2Cpp.alloc(64);
     *
     * // ...
     *
     * Il2Cpp.free(handle);
     * ```
     */
    export function free(pointer: NativePointerValue): void {
        return Il2Cpp.exports.free(pointer);
    }

    /** @internal */
    export function read(pointer: NativePointer, type: Il2Cpp.Type): Il2Cpp.Field.Type {
        switch (type.enumValue) {
            case Il2Cpp.Type.Enum.BOOLEAN:
                return !!pointer.readS8();
            case Il2Cpp.Type.Enum.BYTE:
                return pointer.readS8();
            case Il2Cpp.Type.Enum.UBYTE:
                return pointer.readU8();
            case Il2Cpp.Type.Enum.SHORT:
                return pointer.readS16();
            case Il2Cpp.Type.Enum.USHORT:
                return pointer.readU16();
            case Il2Cpp.Type.Enum.INT:
                return pointer.readS32();
            case Il2Cpp.Type.Enum.UINT:
                return pointer.readU32();
            case Il2Cpp.Type.Enum.CHAR:
                return pointer.readU16();
            case Il2Cpp.Type.Enum.LONG:
                return pointer.readS64();
            case Il2Cpp.Type.Enum.ULONG:
                return pointer.readU64();
            case Il2Cpp.Type.Enum.FLOAT:
                return pointer.readFloat();
            case Il2Cpp.Type.Enum.DOUBLE:
                return pointer.readDouble();
            case Il2Cpp.Type.Enum.NINT:
            case Il2Cpp.Type.Enum.NUINT:
                return pointer.readPointer();
            case Il2Cpp.Type.Enum.POINTER:
                return new Il2Cpp.Pointer(pointer.readPointer(), type.class.baseType!);
            case Il2Cpp.Type.Enum.VALUE_TYPE:
                return new Il2Cpp.ValueType(pointer, type);
            case Il2Cpp.Type.Enum.OBJECT:
            case Il2Cpp.Type.Enum.CLASS:
                return new Il2Cpp.Object(pointer.readPointer());
            case Il2Cpp.Type.Enum.GENERIC_INSTANCE:
                return type.class.isValueType ? new Il2Cpp.ValueType(pointer, type) : new Il2Cpp.Object(pointer.readPointer());
            case Il2Cpp.Type.Enum.STRING:
                return new Il2Cpp.String(pointer.readPointer());
            case Il2Cpp.Type.Enum.ARRAY:
            case Il2Cpp.Type.Enum.NARRAY:
                return new Il2Cpp.Array(pointer.readPointer());
        }

        raise(`couldn't read the value from ${pointer} using an unhandled or unknown type ${type.name} (${type.enumValue}), please file an issue`);
    }

    /** @internal */
    export function write(pointer: NativePointer, value: any, type: Il2Cpp.Type): NativePointer {
        switch (type.enumValue) {
            case Il2Cpp.Type.Enum.BOOLEAN:
                return pointer.writeS8(+value);
            case Il2Cpp.Type.Enum.BYTE:
                return pointer.writeS8(value);
            case Il2Cpp.Type.Enum.UBYTE:
                return pointer.writeU8(value);
            case Il2Cpp.Type.Enum.SHORT:
                return pointer.writeS16(value);
            case Il2Cpp.Type.Enum.USHORT:
                return pointer.writeU16(value);
            case Il2Cpp.Type.Enum.INT:
                return pointer.writeS32(value);
            case Il2Cpp.Type.Enum.UINT:
                return pointer.writeU32(value);
            case Il2Cpp.Type.Enum.CHAR:
                return pointer.writeU16(value);
            case Il2Cpp.Type.Enum.LONG:
                return pointer.writeS64(value);
            case Il2Cpp.Type.Enum.ULONG:
                return pointer.writeU64(value);
            case Il2Cpp.Type.Enum.FLOAT:
                return pointer.writeFloat(value);
            case Il2Cpp.Type.Enum.DOUBLE:
                return pointer.writeDouble(value);
            case Il2Cpp.Type.Enum.NINT:
            case Il2Cpp.Type.Enum.NUINT:
            case Il2Cpp.Type.Enum.POINTER:
            case Il2Cpp.Type.Enum.STRING:
            case Il2Cpp.Type.Enum.ARRAY:
            case Il2Cpp.Type.Enum.NARRAY:
                return pointer.writePointer(value);
            case Il2Cpp.Type.Enum.VALUE_TYPE:
                return Memory.copy(pointer, value, type.class.valueTypeSize), pointer;
            case Il2Cpp.Type.Enum.OBJECT:
            case Il2Cpp.Type.Enum.CLASS:
            case Il2Cpp.Type.Enum.GENERIC_INSTANCE:
                return value instanceof Il2Cpp.ValueType ? (Memory.copy(pointer, value, type.class.valueTypeSize), pointer) : pointer.writePointer(value);
        }

        raise(`couldn't write value ${value} to ${pointer} using an unhandled or unknown type ${type.name} (${type.enumValue}), please file an issue`);
    }

    /** @internal */
    export function fromFridaValue(value: NativeCallbackArgumentValue, type: Il2Cpp.Type): Il2Cpp.Parameter.Type;

    /** @internal */
    export function fromFridaValue(value: NativeFunctionReturnValue, type: Il2Cpp.Type): Il2Cpp.Method.ReturnType;

    /** @internal */
    export function fromFridaValue(
        value: NativeCallbackArgumentValue | NativeFunctionReturnValue,
        type: Il2Cpp.Type
    ): Il2Cpp.Parameter.Type | Il2Cpp.Method.ReturnType {
        if (globalThis.Array.isArray(value)) {
            const handle = Memory.alloc(type.class.valueTypeSize);
            const fields = type.class.fields.filter(_ => !_.isStatic);

            for (let i = 0; i < fields.length; i++) {
                const convertedValue = fromFridaValue(value[i], fields[i].type);
                write(handle.add(fields[i].offset).sub(Il2Cpp.Object.headerSize), convertedValue, fields[i].type);
            }

            return new Il2Cpp.ValueType(handle, type);
        } else if (value instanceof NativePointer) {
            if (type.isByReference) {
                return new Il2Cpp.Reference(value, type);
            }

            switch (type.enumValue) {
                case Il2Cpp.Type.Enum.POINTER:
                    return new Il2Cpp.Pointer(value, type.class.baseType!);
                case Il2Cpp.Type.Enum.STRING:
                    return new Il2Cpp.String(value);
                case Il2Cpp.Type.Enum.CLASS:
                case Il2Cpp.Type.Enum.GENERIC_INSTANCE:
                case Il2Cpp.Type.Enum.OBJECT:
                    return new Il2Cpp.Object(value);
                case Il2Cpp.Type.Enum.ARRAY:
                case Il2Cpp.Type.Enum.NARRAY:
                    return new Il2Cpp.Array(value);
                default:
                    return value;
            }
        } else if (type.enumValue == Il2Cpp.Type.Enum.BOOLEAN) {
            return !!(value as number);
        } else if (type.enumValue == Il2Cpp.Type.Enum.VALUE_TYPE && type.class.isEnum) {
            return fromFridaValue([value], type);
        } else {
            return value;
        }
    }

    /** @internal */
    export function toFridaValue(value: Il2Cpp.Method.ReturnType): NativeFunctionReturnValue;

    /** @internal */
    export function toFridaValue(value: Il2Cpp.Parameter.Type): NativeFunctionArgumentValue;

    /** @internal */
    export function toFridaValue(value: Il2Cpp.Parameter.Type | Il2Cpp.Method.ReturnType): NativeFunctionArgumentValue | NativeFunctionReturnValue {
        if (typeof value == "boolean") {
            return +value;
        } else if (value instanceof Il2Cpp.ValueType) {
            if (value.type.class.isEnum) {
                return value.field<number | Int64 | UInt64>("value__").value;
            } else {
                const _ = value.type.class.fields.filter(_ => !_.isStatic).map(_ => toFridaValue(_.bind(value).value));
                return _.length == 0 ? [0] : _;
            }
        } else {
            return value;
        }
    }
}



================================================
FILE: lib/module.ts
================================================
namespace Il2Cpp {
    /**
     * Gets the IL2CPP module (a *native library*), that is where the IL2CPP
     * exports will be searched for (see {@link Il2Cpp.exports}).
     *
     * The module is located by its name:
     * - Android: `libil2cpp.so`
     * - Linux: `GameAssembly.so`
     * - Windows: `GameAssembly.dll`
     * - iOS: `UnityFramework`
     * - macOS: `GameAssembly.dylib`
     *
     * On iOS and macOS, IL2CPP exports may be located within a module having
     * a different name.
     *
     * In any case, it is possible to override or set the IL2CPP module name
     * using {@link Il2Cpp.$config.moduleName}:
     * ```ts
     * Il2Cpp.$config.moduleName = "CustomName.dylib";
     *
     * Il2Cpp.perform(() => {
     *     // ...
     * });
     * ```
     */
    export declare const module: Module;
    getter(Il2Cpp, "module", () => {
        return tryModule() ?? raise("Could not find IL2CPP module");
    });

    /**
     * @internal
     * Waits for the IL2CPP native library to be loaded and initialized.
     */
    export async function initialize(blocking = false): Promise<boolean> {
        const module =
            tryModule() ??
            (await new Promise<Module>(resolve => {
                const [moduleName, fallbackModuleName] = getExpectedModuleNames();

                const timeout = setTimeout(() => {
                    warn(`after 10 seconds, IL2CPP module '${moduleName}' has not been loaded yet, is the app running?`);
                }, 10000);

                const moduleObserver = Process.attachModuleObserver({
                    onAdded(module: Module) {
                        if (module.name == moduleName || (fallbackModuleName && module.name == fallbackModuleName)) {
                            clearTimeout(timeout);
                            setImmediate(() => {
                                resolve(module);
                                moduleObserver.detach();
                            });
                        }
                    }
                });
            }));

        Reflect.defineProperty(Il2Cpp, "module", { value: module });

        // At this point, the IL2CPP native library has been loaded, but we
        // cannot interact with IL2CPP until `il2cpp_init` is done.
        // It looks like `il2cpp_get_corlib` returns NULL only when the
        // initialization is not completed yet.
        if (Il2Cpp.exports.getCorlib().isNull()) {
            return await new Promise<boolean>(resolve => {
                const interceptor = Interceptor.attach(Il2Cpp.exports.initialize, {
                    onLeave() {
                        interceptor.detach();
                        blocking ? resolve(true) : setImmediate(() => resolve(false));
                    }
                });
            });
        }

        return false;
    }

    function tryModule(): Module | undefined {
        const [moduleName, fallback] = getExpectedModuleNames();
        return (
            Process.findModuleByName(moduleName) ??
            Process.findModuleByName(fallback ?? moduleName) ??
            (Process.platform == "darwin" ? Process.findModuleByAddress(DebugSymbol.fromName("il2cpp_init").address) : undefined)
            ?? undefined
        );
    }

    function getExpectedModuleNames(): [string] | [string, string] {
        if (Il2Cpp.$config.moduleName) {
            return [Il2Cpp.$config.moduleName];
        }

        switch (Process.platform) {
            case "linux":
                return [Android.apiLevel ? "libil2cpp.so" : "GameAssembly.so"];
            case "windows":
                return ["GameAssembly.dll"];
            case "darwin":
                return ["UnityFramework", "GameAssembly.dylib"];
        }

        raise(`${Process.platform} is not supported yet`);
    }
}



================================================
FILE: lib/perform.ts
================================================
namespace Il2Cpp {
    /** Attaches the caller thread to Il2Cpp domain and executes the given block.  */
    export async function perform<T>(block: () => T | Promise<T>, flag: "free" | "bind" | "leak" | "main" = "bind"): Promise<T> {
        let attachedThread: Il2Cpp.Thread | null = null;
        try {
            const isInMainThread = await initialize(flag == "main");

            if (flag == "main" && !isInMainThread) {
                return perform(() => Il2Cpp.mainThread.schedule(block), "free");
            }

            if (Il2Cpp.currentThread == null) {
                attachedThread = Il2Cpp.domain.attach();
            }

            if (flag == "bind" && attachedThread != null) {
                Script.bindWeak(globalThis, () => attachedThread?.detach());
            }

            const result = block();

            return result instanceof Promise ? await result : result;
        } catch (error: any) {
            Script.nextTick(_ => { throw _; }, error); // prettier-ignore
            return Promise.reject<T>(error);
        } finally {
            if (flag == "free" && attachedThread != null) {
                attachedThread.detach();
            }
        }
    }
}



================================================
FILE: lib/tracer.ts
================================================
namespace Il2Cpp {
    export class Tracer {
        /** @internal */
        #state: Il2Cpp.Tracer.State = {
            depth: 0,
            buffer: [],
            history: new Set(),
            flush: () => {
                if (this.#state.depth == 0) {
                    const message = `\n${this.#state.buffer.join("\n")}\n`;

                    if (this.#verbose) {
                        inform(message);
                    } else {
                        const hash = cyrb53(message);
                        if (!this.#state.history.has(hash)) {
                            this.#state.history.add(hash);
                            inform(message);
                        }
                    }

                    this.#state.buffer.length = 0;
                }
            }
        };

        /** @internal */
        #threadId: number = Il2Cpp.mainThread.id;

        /** @internal */
        #verbose: boolean = false;

        /** @internal */
        #applier: Il2Cpp.Tracer.Apply;

        /** @internal */
        #targets: Il2Cpp.Method[] = [];

        /** @internal */
        #domain?: Il2Cpp.Domain;

        /** @internal */
        #assemblies?: Il2Cpp.Assembly[];

        /** @internal */
        #classes?: Il2Cpp.Class[];

        /** @internal */
        #methods?: Il2Cpp.Method[];

        /** @internal */
        #assemblyFilter?: (assembly: Il2Cpp.Assembly) => boolean;

        /** @internal */
        #classFilter?: (klass: Il2Cpp.Class) => boolean;

        /** @internal */
        #methodFilter?: (method: Il2Cpp.Method) => boolean;

        /** @internal */
        #parameterFilter?: (parameter: Il2Cpp.Parameter) => boolean;

        constructor(applier: Il2Cpp.Tracer.Apply) {
            this.#applier = applier;
        }

        /** */
        thread(thread: Il2Cpp.Thread): Pick<Il2Cpp.Tracer, "verbose"> & Il2Cpp.Tracer.ChooseTargets {
            this.#threadId = thread.id;
            return this;
        }

        /** Determines whether print duplicate logs. */
        verbose(value: boolean): Il2Cpp.Tracer.ChooseTargets {
            this.#verbose = value;
            return this;
        }

        /** Sets the application domain as the place where to find the target methods. */
        domain(): Il2Cpp.Tracer.FilterAssemblies {
            this.#domain = Il2Cpp.domain;
            return this;
        }

        /** Sets the passed `assemblies` as the place where to find the target methods. */
        assemblies(...assemblies: Il2Cpp.Assembly[]): Il2Cpp.Tracer.FilterClasses {
            this.#assemblies = assemblies;
            return this;
        }

        /** Sets the passed `classes` as the place where to find the target methods. */
        classes(...classes: Il2Cpp.Class[]): Il2Cpp.Tracer.FilterMethods {
            this.#classes = classes;
            return this;
        }

        /** Sets the passed `methods` as the target methods. */
        methods(...methods: Il2Cpp.Method[]): Il2Cpp.Tracer.FilterParameters {
            this.#methods = methods;
            return this;
        }

        /** Filters the assemblies where to find the target methods. */
        filterAssemblies(filter: (assembly: Il2Cpp.Assembly) => boolean): Il2Cpp.Tracer.FilterClasses {
            this.#assemblyFilter = filter;
            return this;
        }

        /** Filters the classes where to find the target methods. */
        filterClasses(filter: (klass: Il2Cpp.Class) => boolean): Il2Cpp.Tracer.FilterMethods {
            this.#classFilter = filter;
            return this;
        }

        /** Filters the target methods. */
        filterMethods(filter: (method: Il2Cpp.Method) => boolean): Il2Cpp.Tracer.FilterParameters {
            this.#methodFilter = filter;
            return this;
        }

        /** Filters the target methods. */
        filterParameters(filter: (parameter: Il2Cpp.Parameter) => boolean): Pick<Il2Cpp.Tracer, "and"> {
            this.#parameterFilter = filter;
            return this;
        }

        /** Commits the current changes by finding the target methods. */
        and(): Il2Cpp.Tracer.ChooseTargets & Pick<Il2Cpp.Tracer, "attach"> {
            const filterMethod = (method: Il2Cpp.Method): void => {
                if (this.#parameterFilter == undefined) {
                    this.#targets.push(method);
                    return;
                }

                for (const parameter of method.parameters) {
                    if (this.#parameterFilter(parameter)) {
                        this.#targets.push(method);
                        break;
                    }
                }
            };

            const filterMethods = (values: Iterable<Il2Cpp.Method>): void => {
                for (const method of values) {
                    filterMethod(method);
                }
            };

            const filterClass = (klass: Il2Cpp.Class): void => {
                if (this.#methodFilter == undefined) {
                    filterMethods(klass.methods);
                    return;
                }

                for (const method of klass.methods) {
                    if (this.#methodFilter(method)) {
                        filterMethod(method);
                    }
                }
            };

            const filterClasses = (values: Iterable<Il2Cpp.Class>): void => {
                for (const klass of values) {
                    filterClass(klass);
                }
            };

            const filterAssembly = (assembly: Il2Cpp.Assembly): void => {
                if (this.#classFilter == undefined) {
                    filterClasses(assembly.image.classes);
                    return;
                }

                for (const klass of assembly.image.classes) {
                    if (this.#classFilter(klass)) {
                        filterClass(klass);
                    }
                }
            };

            const filterAssemblies = (assemblies: Iterable<Il2Cpp.Assembly>): void => {
                for (const assembly of assemblies) {
                    filterAssembly(assembly);
                }
            };

            const filterDomain = (domain: Il2Cpp.Domain): void => {
                if (this.#assemblyFilter == undefined) {
                    filterAssemblies(domain.assemblies);
                    return;
                }

                for (const assembly of domain.assemblies) {
                    if (this.#assemblyFilter(assembly)) {
                        filterAssembly(assembly);
                    }
                }
            };

            this.#methods
                ? filterMethods(this.#methods)
                : this.#classes
                ? filterClasses(this.#classes)
                : this.#assemblies
                ? filterAssemblies(this.#assemblies)
                : this.#domain
                ? filterDomain(this.#domain)
                : undefined;

            this.#assemblies = undefined;
            this.#classes = undefined;
            this.#methods = undefined;
            this.#assemblyFilter = undefined;
            this.#classFilter = undefined;
            this.#methodFilter = undefined;
            this.#parameterFilter = undefined;

            return this;
        }

        /** Starts tracing. */
        attach(): void {
            for (const target of this.#targets) {
                if (!target.virtualAddress.isNull()) {
                    try {
                        this.#applier(target, this.#state, this.#threadId);
                    } catch (e: any) {
                        switch (e.message) {
                            case /unable to intercept function at \w+; please file a bug/.exec(e.message)?.input:
                            case "already replaced this function":
                                break;
                            default:
                                throw e;
                        }
                    }
                }
            }
        }
    }

    export declare namespace Tracer {
        export type Configure = Pick<Il2Cpp.Tracer, "thread" | "verbose"> & Il2Cpp.Tracer.ChooseTargets;

        export type ChooseTargets = Pick<Il2Cpp.Tracer, "domain" | "assemblies" | "classes" | "methods">;

        export type FilterAssemblies = FilterClasses & Pick<Il2Cpp.Tracer, "filterAssemblies">;

        export type FilterClasses = FilterMethods & Pick<Il2Cpp.Tracer, "filterClasses">;

        export type FilterMethods = FilterParameters & Pick<Il2Cpp.Tracer, "filterMethods">;

        export type FilterParameters = Pick<Il2Cpp.Tracer, "and"> & Pick<Il2Cpp.Tracer, "filterParameters">;

        export interface State {
            depth: number;
            buffer: string[];
            history: Set<number>;
            flush: () => void;
        }

        export type Apply = (method: Il2Cpp.Method, state: Il2Cpp.Tracer.State, threadId: number) => void;
    }

    /** */
    export function trace(parameters: boolean = false): Il2Cpp.Tracer.Configure {
        const applier = (): Il2Cpp.Tracer.Apply => (method, state, threadId) => {
            const paddedVirtualAddress = method.relativeVirtualAddress.toString(16).padStart(8, "0");

            Interceptor.attach(method.virtualAddress, {
                onEnter() {
                    if (this.threadId == threadId) {
                        // prettier-ignore
                        state.buffer.push(`\x1b[2m0x${paddedVirtualAddress}\x1b[0m ${`│ `.repeat(state.depth++)}┌─\x1b[35m${method.class.type.name}::\x1b[1m${method.name}\x1b[0m\x1b[0m`);
                    }
                },
                onLeave() {
                    if (this.threadId == threadId) {
                        // prettier-ignore
                        state.buffer.push(`\x1b[2m0x${paddedVirtualAddress}\x1b[0m ${`│ `.repeat(--state.depth)}└─\x1b[33m${method.class.type.name}::\x1b[1m${method.name}\x1b[0m\x1b[0m`);
                        state.flush();
                    }
                }
            });
        };

        const applierWithParameters = (): Il2Cpp.Tracer.Apply => (method, state, threadId) => {
            const paddedVirtualAddress = method.relativeVirtualAddress.toString(16).padStart(8, "0");

            const startIndex = +!method.isStatic | +Il2Cpp.unityVersionIsBelow201830;

            const callback = function (this: CallbackContext | InvocationContext, ...args: any[]) {
                if ((this as InvocationContext).threadId == threadId) {
                    const thisParameter = method.isStatic ? undefined : new Il2Cpp.Parameter("this", -1, method.class.type);
                    const parameters = thisParameter ? [thisParameter].concat(method.parameters) : method.parameters;

                    // prettier-ignore
                    state.buffer.push(`\x1b[2m0x${paddedVirtualAddress}\x1b[0m ${`│ `.repeat(state.depth++)}┌─\x1b[35m${method.class.type.name}::\x1b[1m${method.name}\x1b[0m\x1b[0m(${parameters.map(e => `\x1b[32m${e.name}\x1b[0m = \x1b[31m${fromFridaValue(args[e.position + startIndex], e.type)}\x1b[0m`).join(", ")})`);
                }

                const returnValue = method.nativeFunction(...args);

                if ((this as InvocationContext).threadId == threadId) {
                    // prettier-ignore
                    state.buffer.push(`\x1b[2m0x${paddedVirtualAddress}\x1b[0m ${`│ `.repeat(--state.depth)}└─\x1b[33m${method.class.type.name}::\x1b[1m${method.name}\x1b[0m\x1b[0m${returnValue == undefined ? "" : ` = \x1b[36m${fromFridaValue(returnValue, method.returnType)}`}\x1b[0m`);
                    state.flush();
                }

                return returnValue;
            };

            method.revert();
            const nativeCallback = new NativeCallback(callback, method.returnType.fridaAlias, method.fridaSignature);
            Interceptor.replace(method.virtualAddress, nativeCallback);
        };

        return new Il2Cpp.Tracer(parameters ? applierWithParameters() : applier());
    }

    /** */
    export function backtrace(mode?: Backtracer): Il2Cpp.Tracer.Configure {
        const methods = Il2Cpp.domain.assemblies
            .flatMap(_ => _.image.classes.flatMap(_ => _.methods.filter(_ => !_.virtualAddress.isNull())))
            .sort((_, __) => _.virtualAddress.compare(__.virtualAddress));

        const searchInsert = (target: NativePointer): Il2Cpp.Method => {
            let left = 0;
            let right = methods.length - 1;

            while (left <= right) {
                const pivot = Math.floor((left + right) / 2);
                const comparison = methods[pivot].virtualAddress.compare(target);

                if (comparison == 0) {
                    return methods[pivot];
                } else if (comparison > 0) {
                    right = pivot - 1;
                } else {
                    left = pivot + 1;
                }
            }
            return methods[right];
        };

        const applier = (): Il2Cpp.Tracer.Apply => (method, state, threadId) => {
            Interceptor.attach(method.virtualAddress, function () {
                if (this.threadId == threadId) {
                    const handles = globalThis.Thread.backtrace(this.context, mode);
                    handles.unshift(method.virtualAddress);

                    for (const handle of handles) {
                        if (handle.compare(Il2Cpp.module.base) > 0 && handle.compare(Il2Cpp.module.base.add(Il2Cpp.module.size)) < 0) {
                            const method = searchInsert(handle);

                            if (method) {
                                const offset = handle.sub(method.virtualAddress);

                                if (offset.compare(0xfff) < 0) {
                                    // prettier-ignore
                                    state.buffer.push(`\x1b[2m0x${method.relativeVirtualAddress.toString(16).padStart(8, "0")}\x1b[0m\x1b[2m+0x${offset.toString(16).padStart(3, `0`)}\x1b[0m ${method.class.type.name}::\x1b[1m${method.name}\x1b[0m`);
                                }
                            }
                        }
                    }

                    state.flush();
                }
            });
        };

        return new Il2Cpp.Tracer(applier());
    }
}



================================================
FILE: lib/cmodules/memory-snapshot.c
================================================
#include <stdint.h>
#include <string.h>

typedef struct Il2CppManagedMemorySnapshot Il2CppManagedMemorySnapshot;
typedef struct Il2CppMetadataType Il2CppMetadataType;

struct Il2CppManagedMemorySnapshot
{
  struct Il2CppManagedHeap
  {
    uint32_t section_count;
    void * sections;
  } heap;
  struct Il2CppStacks
  {
    uint32_t stack_count;
    void * stacks;
  } stacks;
  struct Il2CppMetadataSnapshot
  {
    uint32_t type_count;
    Il2CppMetadataType * types;
  } metadata_snapshot;
  struct Il2CppGCHandles
  {
    uint32_t tracked_object_count;
    void ** pointers_to_objects;
  } gc_handles;
  struct Il2CppRuntimeInformation
  {
    uint32_t pointer_size;
    uint32_t object_header_size;
    uint32_t array_header_size;
    uint32_t array_bounds_offset_in_header;
    uint32_t array_size_offset_in_header;
    uint32_t allocation_granularity;
  } runtime_information;
  void * additional_user_information;
};

struct Il2CppMetadataType
{
  uint32_t flags;
  void * fields;
  uint32_t field_count;
  uint32_t statics_size;
  uint8_t * statics;
  uint32_t base_or_element_type_index;
  char * name;
  const char * assembly_name;
  uint64_t type_info_address;
  uint32_t size;
};

uintptr_t
il2cpp_memory_snapshot_get_classes (
    const Il2CppManagedMemorySnapshot * snapshot, Il2CppMetadataType ** iter)
{
  const int zero = 0;
  const void * null = 0;

  if (iter != NULL && snapshot->metadata_snapshot.type_count > zero)
  {
    if (*iter == null)
    {
      *iter = snapshot->metadata_snapshot.types;
      return (uintptr_t) (*iter)->type_info_address;
    }
    else
    {
      Il2CppMetadataType * metadata_type = *iter + 1;

      if (metadata_type < snapshot->metadata_snapshot.types +
                              snapshot->metadata_snapshot.type_count)
      {
        *iter = metadata_type;
        return (uintptr_t) (*iter)->type_info_address;
      }
    }
  }
  return 0;
}

void **
il2cpp_memory_snapshot_get_objects (
    const Il2CppManagedMemorySnapshot * snapshot, uint32_t * size)
{
  *size = snapshot->gc_handles.tracked_object_count;
  return snapshot->gc_handles.pointers_to_objects;
}



================================================
FILE: lib/structs/array.ts
================================================
namespace Il2Cpp {
    export class Array<T extends Il2Cpp.Field.Type = Il2Cpp.Field.Type> extends NativeStruct implements Iterable<T> {
        /** Gets the Il2CppArray struct size, possibly equal to `Process.pointerSize * 4`. */
        @lazy
        static get headerSize(): number {
            return Il2Cpp.corlib.class("System.Array").instanceSize;
        }

        /** @internal Gets a pointer to the first element of the current array. */
        get elements(): Il2Cpp.Pointer<T> {
            // We previosly obtained an array whose content is known by calling
            // 'System.String::Split(NULL)' on a known string. However, that
            // method invocation somehow blows things up in Unity 2018.3.0f1.
            const array = Il2Cpp.string("v").object.method<Il2Cpp.Array>("ToCharArray", 0).invoke();

            // prettier-ignore
            const offset = array.handle.offsetOf(_ => _.readS16() == 118) ??
                raise("couldn't find the elements offset in the native array struct");

            // prettier-ignore
            getter(Il2Cpp.Array.prototype, "elements", function (this: Il2Cpp.Array) {
                return new Il2Cpp.Pointer(this.handle.add(offset), this.elementType);
            }, lazy);

            return this.elements;
        }

        /** Gets the size of the object encompassed by the current array. */
        @lazy
        get elementSize(): number {
            return this.elementType.class.arrayElementSize;
        }

        /** Gets the type of the object encompassed by the current array. */
        @lazy
        get elementType(): Il2Cpp.Type {
            return this.object.class.type.class.baseType!;
        }

        /** Gets the total number of elements in all the dimensions of the current array. */
        @lazy
        get length(): number {
            return Il2Cpp.exports.arrayGetLength(this);
        }

        /** Gets the encompassing object of the current array. */
        @lazy
        get object(): Il2Cpp.Object {
            return new Il2Cpp.Object(this);
        }

        /** Gets the element at the specified index of the current array. */
        get(index: number): T {
            if (index < 0 || index >= this.length) {
                raise(`cannot get element at index ${index} as the array length is ${this.length}`);
            }

            return this.elements.get(index);
        }

        /** Sets the element at the specified index of the current array. */
        set(index: number, value: T) {
            if (index < 0 || index >= this.length) {
                raise(`cannot set element at index ${index} as the array length is ${this.length}`);
            }

            this.elements.set(index, value);
        }

        /** */
        toString(): string {
            return this.isNull() ? "null" : `[${this.elements.read(this.length, 0)}]`;
        }

        /** Iterable. */
        *[Symbol.iterator](): IterableIterator<T> {
            for (let i = 0; i < this.length; i++) {
                yield this.elements.get(i);
            }
        }
    }

    /** Creates a new empty array of the given length. */
    export function array<T extends Il2Cpp.Field.Type>(klass: Il2Cpp.Class, length: number): Il2Cpp.Array<T>;

    /** Creates a new array with the given elements. */
    export function array<T extends Il2Cpp.Field.Type>(klass: Il2Cpp.Class, elements: T[]): Il2Cpp.Array<T>;

    /** @internal */
    export function array<T extends Il2Cpp.Field.Type>(klass: Il2Cpp.Class, lengthOrElements: number | T[]): Il2Cpp.Array<T> {
        const length = typeof lengthOrElements == "number" ? lengthOrElements : lengthOrElements.length;
        const array = new Il2Cpp.Array<T>(Il2Cpp.exports.arrayNew(klass, length));

        if (globalThis.Array.isArray(lengthOrElements)) {
            array.elements.write(lengthOrElements);
        }

        return array;
    }
}



================================================
FILE: lib/structs/assembly.ts
================================================
namespace Il2Cpp {
    @recycle
    export class Assembly extends NativeStruct {
        /** Gets the image of this assembly. */
        get image(): Il2Cpp.Image {
            if (Il2Cpp.exports.assemblyGetImage.isNull()) {
                // We need to get the System.Reflection.Module of the current assembly;
                // System.Reflection.Assembly::GetModulesInternal, for some reason,
                // throws a NullReferenceExceptionin Unity 5.3.8f1, so we must rely on
                // System.Type::get_Module instead.
                // Now we need to get any System.Type of this assembly.
                // We cannot use System.Reflection.Assembly::GetTypes because it may
                // return an empty array; hence we use System.Reflection.Assembly::GetType
                // to retrieve <Module>, a class/type that seems to be always present
                // (despite being excluded from System.Reflection.Assembly::GetTypes).
                const runtimeModule =
                    this.object
                        .tryMethod<Il2Cpp.Object>("GetType", 1)
                        ?.invoke(Il2Cpp.string("<Module>"))
                        ?.asNullable()
                        ?.tryMethod<Il2Cpp.Object>("get_Module")
                        ?.invoke() ??
                    this.object.tryMethod<Il2Cpp.Array<Il2Cpp.Object>>("GetModules", 1)?.invoke(false)?.get(0) ??
                    raise(`couldn't find the runtime module object of assembly ${this.name}`);

                return new Il2Cpp.Image(runtimeModule.field<NativePointer>("_impl").value);
            }

            return new Il2Cpp.Image(Il2Cpp.exports.assemblyGetImage(this));
        }

        /** Gets the name of this assembly. */
        @lazy
        get name(): string {
            return this.image.name.replace(".dll", "");
        }

        /** Gets the encompassing object of the current assembly. */
        @lazy
        get object(): Il2Cpp.Object {
            for (const _ of Il2Cpp.domain.object.method<Il2Cpp.Array<Il2Cpp.Object>>("GetAssemblies", 1).invoke(false)) {
                if (_.field<NativePointer>("_mono_assembly").value.equals(this)) {
                    return _;
                }
            }

            raise("couldn't find the object of the native assembly struct");
        }
    }
}



================================================
FILE: lib/structs/class.ts
================================================
namespace Il2Cpp {
    @recycle
    export class Class extends NativeStruct {
        /** Gets the actual size of the instance of the current class. */
        get actualInstanceSize(): number {
            const SystemString = Il2Cpp.corlib.class("System.String");

            // prettier-ignore
            const offset = SystemString.handle.offsetOf(_ => _.readInt() == SystemString.instanceSize - 2) 
                ?? raise("couldn't find the actual instance size offset in the native class struct");

            // prettier-ignore
            getter(Il2Cpp.Class.prototype, "actualInstanceSize", function (this: Il2Cpp.Class) {
                return this.handle.add(offset).readS32();
            }, lazy);

            return this.actualInstanceSize;
        }

        /** Gets the array class which encompass the current class. */
        @lazy
        get arrayClass(): Il2Cpp.Class {
            return new Il2Cpp.Class(Il2Cpp.exports.classGetArrayClass(this, 1));
        }

        /** Gets the size of the object encompassed by the current array class. */
        @lazy
        get arrayElementSize(): number {
            return Il2Cpp.exports.classGetArrayElementSize(this);
        }

        /** Gets the name of the assembly in which the current class is defined. */
        @lazy
        get assemblyName(): string {
            return Il2Cpp.exports.classGetAssemblyName(this).readUtf8String()!.replace(".dll", "");
        }

        /** Gets the class that declares the current nested class. */
        @lazy
        get declaringClass(): Il2Cpp.Class | null {
            return new Il2Cpp.Class(Il2Cpp.exports.classGetDeclaringType(this)).asNullable();
        }

        /** Gets the encompassed type of this array, reference, pointer or enum type. */
        @lazy
        get baseType(): Il2Cpp.Type | null {
            return new Il2Cpp.Type(Il2Cpp.exports.classGetBaseType(this)).asNullable();
        }

        /** Gets the class of the object encompassed or referred to by the current array, pointer or reference class. */
        @lazy
        get elementClass(): Il2Cpp.Class | null {
            return new Il2Cpp.Class(Il2Cpp.exports.classGetElementClass(this)).asNullable();
        }

        /** Gets the fields of the current class. */
        @lazy
        get fields(): Il2Cpp.Field[] {
            return readNativeIterator(_ => Il2Cpp.exports.classGetFields(this, _)).map(_ => new Il2Cpp.Field(_));
        }

        /** Gets the flags of the current class. */
        @lazy
        get flags(): number {
            return Il2Cpp.exports.classGetFlags(this);
        }

        /** Gets the full name (namespace + name) of the current class. */
        @lazy
        get fullName(): string {
            return this.namespace ? `${this.namespace}.${this.name}` : this.name;
        }

        /** Gets the generic class of the current class if the current class is inflated. */
        get genericClass(): Il2Cpp.Class | null {
            // We leverage two things here:
            // 1) inflated classes belong to the same assembly of the generic
            // class;
            // 2) inflated classes have the generic class name as their name,
            // e.g. type name is Foo<Bar>, but class name is Foo`1.
            const klass = this.image.tryClass(this.fullName)?.asNullable();
            return klass?.equals(this) ? null : klass ?? null;
        }

        /** Gets the generics parameters of this generic class. */
        @lazy
        get generics(): Il2Cpp.Class[] {
            if (!this.isGeneric && !this.isInflated) {
                return [];
            }

            const types = this.type.object.method<Il2Cpp.Array<Il2Cpp.Object>>("GetGenericArguments").invoke();
            return globalThis.Array.from(types).map(_ => new Il2Cpp.Class(Il2Cpp.exports.classFromObject(_)));
        }

        /** Determines whether the GC has tracking references to the current class instances. */
        @lazy
        get hasReferences(): boolean {
            return !!Il2Cpp.exports.classHasReferences(this);
        }

        /** Determines whether ther current class has a valid static constructor. */
        @lazy
        get hasStaticConstructor(): boolean {
            const staticConstructor = this.tryMethod(".cctor");
            return staticConstructor != null && !staticConstructor.virtualAddress.isNull();
        }

        /** Gets the image in which the current class is defined. */
        @lazy
        get image(): Il2Cpp.Image {
            return new Il2Cpp.Image(Il2Cpp.exports.classGetImage(this));
        }

        /** Gets the size of the instance of the current class. */
        @lazy
        get instanceSize(): number {
            return Il2Cpp.exports.classGetInstanceSize(this);
        }

        /** Determines whether the current class is abstract. */
        @lazy
        get isAbstract(): boolean {
            return !!Il2Cpp.exports.classIsAbstract(this);
        }

        /** Determines whether the current class is blittable. */
        @lazy
        get isBlittable(): boolean {
            return !!Il2Cpp.exports.classIsBlittable(this);
        }

        /** Determines whether the current class is an enumeration. */
        @lazy
        get isEnum(): boolean {
            return !!Il2Cpp.exports.classIsEnum(this);
        }

        /** Determines whether the current class is a generic one. */
        @lazy
        get isGeneric(): boolean {
            return !!Il2Cpp.exports.classIsGeneric(this);
        }

        /** Determines whether the current class is inflated. */
        @lazy
        get isInflated(): boolean {
            return !!Il2Cpp.exports.classIsInflated(this);
        }

        /** Determines whether the current class is an interface. */
        @lazy
        get isInterface(): boolean {
            return !!Il2Cpp.exports.classIsInterface(this);
        }

        /** Determines whether the current class is a struct. */
        get isStruct(): boolean {
            return this.isValueType && !this.isEnum;
        }

        /** Determines whether the current class is a value type. */
        @lazy
        get isValueType(): boolean {
            return !!Il2Cpp.exports.classIsValueType(this);
        }

        /** Gets the interfaces implemented or inherited by the current class. */
        @lazy
        get interfaces(): Il2Cpp.Class[] {
            return readNativeIterator(_ => Il2Cpp.exports.classGetInterfaces(this, _)).map(_ => new Il2Cpp.Class(_));
        }

        /** Gets the methods implemented by the current class. */
        @lazy
        get methods(): Il2Cpp.Method[] {
            return readNativeIterator(_ => Il2Cpp.exports.classGetMethods(this, _)).map(_ => new Il2Cpp.Method(_));
        }

        /** Gets the name of the current class. */
        @lazy
        get name(): string {
            return Il2Cpp.exports.classGetName(this).readUtf8String()!;
        }

        /** Gets the namespace of the current class. */
        @lazy
        get namespace(): string | undefined {
            return Il2Cpp.exports.classGetNamespace(this).readUtf8String()! || undefined;
        }

        /** Gets the classes nested inside the current class. */
        @lazy
        get nestedClasses(): Il2Cpp.Class[] {
            return readNativeIterator(_ => Il2Cpp.exports.classGetNestedClasses(this, _)).map(_ => new Il2Cpp.Class(_));
        }

        /** Gets the class from which the current class directly inherits. */
        @lazy
        get parent(): Il2Cpp.Class | null {
            return new Il2Cpp.Class(Il2Cpp.exports.classGetParent(this)).asNullable();
        }

        /** Gets the pointer class of the current class. */
        @lazy
        get pointerClass(): Il2Cpp.Class {
            return new Il2Cpp.Class(Il2Cpp.exports.classFromObject(this.type.object.method<Il2Cpp.Object>("MakePointerType").invoke()));
        }

        /** Gets the rank (number of dimensions) of the current array class. */
        @lazy
        get rank(): number {
            let rank = 0;
            const name = this.name;

            for (let i = this.name.length - 1; i > 0; i--) {
                const c = name[i];

                if (c == "]") rank++;
                else if (c == "[" || rank == 0) break;
                else if (c == ",") rank++;
                else break;
            }

            return rank;
        }

        /** Gets a pointer to the static fields of the current class. */
        @lazy
        get staticFieldsData(): NativePointer {
            return Il2Cpp.exports.classGetStaticFieldData(this);
        }

        /** Gets the size of the instance - as a value type - of the current class. */
        @lazy
        get valueTypeSize(): number {
            return Il2Cpp.exports.classGetValueTypeSize(this, NULL);
        }

        /** Gets the type of the current class. */
        @lazy
        get type(): Il2Cpp.Type {
            return new Il2Cpp.Type(Il2Cpp.exports.classGetType(this));
        }

        /** Allocates a new object of the current class. */
        alloc(): Il2Cpp.Object {
            return new Il2Cpp.Object(Il2Cpp.exports.objectNew(this));
        }

        /** Gets the field identified by the given name. */
        field<T extends Il2Cpp.Field.Type>(name: string): Il2Cpp.Field<T> {
            return this.tryField<T>(name) ?? raise(`couldn't find field ${name} in class ${this.type.name}`);
        }

        /** Gets the hierarchy of the current class. */
        *hierarchy(options?: { includeCurrent?: boolean }): Generator<Il2Cpp.Class> {
            let klass: Il2Cpp.Class | null = options?.includeCurrent ?? true ? this : this.parent;
            while (klass) {
                yield klass;
                klass = klass.parent;
            }
        }

        /** Builds a generic instance of the current generic class. */
        inflate(...classes: Il2Cpp.Class[]): Il2Cpp.Class {
            if (!this.isGeneric) {
                raise(`cannot inflate class ${this.type.name} as it has no generic parameters`);
            }

            if (this.generics.length != classes.length) {
                raise(`cannot inflate class ${this.type.name} as it needs ${this.generics.length} generic parameter(s), not ${classes.length}`);
            }

            const types = classes.map(_ => _.type.object);
            const typeArray = Il2Cpp.array(Il2Cpp.corlib.class("System.Type"), types);

            const inflatedType = this.type.object.method<Il2Cpp.Object>("MakeGenericType", 1).invoke(typeArray);
            return new Il2Cpp.Class(Il2Cpp.exports.classFromObject(inflatedType));
        }

        /** Calls the static constructor of the current class. */
        initialize(): Il2Cpp.Class {
            Il2Cpp.exports.classInitialize(this);
            return this;
        }

        /** Determines whether an instance of `other` class can be assigned to a variable of the current type. */
        isAssignableFrom(other: Il2Cpp.Class): boolean {
            return !!Il2Cpp.exports.classIsAssignableFrom(this, other);
        }

        /** Determines whether the current class derives from `other` class. */
        isSubclassOf(other: Il2Cpp.Class, checkInterfaces: boolean): boolean {
            return !!Il2Cpp.exports.classIsSubclassOf(this, other, +checkInterfaces);
        }

        /** Gets the method identified by the given name and parameter count. */
        method<T extends Il2Cpp.Method.ReturnType>(name: string, parameterCount: number = -1): Il2Cpp.Method<T> {
            return this.tryMethod<T>(name, parameterCount) ?? raise(`couldn't find method ${name} in class ${this.type.name}`);
        }

        /** Gets the nested class with the given name. */
        nested(name: string): Il2Cpp.Class {
            return this.tryNested(name) ?? raise(`couldn't find nested class ${name} in class ${this.type.name}`);
        }

        /** Allocates a new object of the current class and calls its default constructor. */
        new(): Il2Cpp.Object {
            const object = this.alloc();

            const exceptionArray = Memory.alloc(Process.pointerSize);

            Il2Cpp.exports.objectInitialize(object, exceptionArray);

            const exception = exceptionArray.readPointer();

            if (!exception.isNull()) {
                raise(new Il2Cpp.Object(exception).toString());
            }

            return object;
        }

        /** Gets the field with the given name. */
        tryField<T extends Il2Cpp.Field.Type>(name: string): Il2Cpp.Field<T> | null {
            return new Il2Cpp.Field<T>(Il2Cpp.exports.classGetFieldFromName(this, Memory.allocUtf8String(name))).asNullable();
        }

        /** Gets the method with the given name and parameter count. */
        tryMethod<T extends Il2Cpp.Method.ReturnType>(name: string, parameterCount: number = -1): Il2Cpp.Method<T> | null {
            return new Il2Cpp.Method<T>(Il2Cpp.exports.classGetMethodFromName(this, Memory.allocUtf8String(name), parameterCount)).asNullable();
        }

        /** Gets the nested class with the given name. */
        tryNested(name: string): Il2Cpp.Class | undefined {
            return this.nestedClasses.find(_ => _.name == name);
        }

        /** */
        toString(): string {
            const inherited = [this.parent].concat(this.interfaces);

            return `\
// ${this.assemblyName}
${this.isEnum ? `enum` : this.isStruct ? `struct` : this.isInterface ? `interface` : `class`} \
${this.type.name}\
${inherited ? ` : ${inherited.map(_ => _?.type.name).join(`, `)}` : ``}
{
    ${this.fields.join(`\n    `)}
    ${this.methods.join(`\n    `)}
}`;
        }

        /** Executes a callback for every defined class. */
        static enumerate(block: (klass: Il2Cpp.Class) => void): void {
            const callback = new NativeCallback(_ => block(new Il2Cpp.Class(_)), "void", ["pointer", "pointer"]);
            return Il2Cpp.exports.classForEach(callback, NULL);
        }
    }
}



================================================
FILE: lib/structs/delegate.ts
================================================
namespace Il2Cpp {
    /** Creates a delegate object of the given delegate class. */
    export function delegate<P extends Il2Cpp.Parameter.Type[], R extends Il2Cpp.Method.ReturnType>(
        klass: Il2Cpp.Class,
        block: (...args: P) => R
    ): Il2Cpp.Object {
        const SystemDelegate = Il2Cpp.corlib.class("System.Delegate");
        const SystemMulticastDelegate = Il2Cpp.corlib.class("System.MulticastDelegate");

        if (!SystemDelegate.isAssignableFrom(klass)) {
            raise(`cannot create a delegate for ${klass.type.name} as it's a non-delegate class`);
        }

        if (klass.equals(SystemDelegate) || klass.equals(SystemMulticastDelegate)) {
            raise(`cannot create a delegate for neither ${SystemDelegate.type.name} nor ${SystemMulticastDelegate.type.name}, use a subclass instead`);
        }

        const delegate = klass.alloc();
        const key = delegate.handle.toString();

        const Invoke = delegate.tryMethod("Invoke") ?? raise(`cannot create a delegate for ${klass.type.name}, there is no Invoke method`);
        delegate.method(".ctor").invoke(delegate, Invoke.handle);

        const callback = Invoke.wrap(block as any);

        delegate.field("method_ptr").value = callback;
        delegate.field("invoke_impl").value = callback;
        _callbacksToKeepAlive[key] = callback;

        return delegate;
    }

    /** @internal Used to prevent eager garbage collection against NativeCallbacks. */
    export const _callbacksToKeepAlive: Record<string, NativeCallback<"void", []> | undefined> = {};
}



================================================
FILE: lib/structs/domain.ts
================================================
namespace Il2Cpp {
    @recycle
    export class Domain extends NativeStruct {
        /** Gets the assemblies that have been loaded into the execution context of the application domain. */
        @lazy
        get assemblies(): Il2Cpp.Assembly[] {
            let handles = readNativeList(_ => Il2Cpp.exports.domainGetAssemblies(this, _));

            if (handles.length == 0) {
                const assemblyObjects = this.object.method<Il2Cpp.Array<Il2Cpp.Object>>("GetAssemblies").overload().invoke();
                handles = globalThis.Array.from(assemblyObjects).map(_ => _.field<NativePointer>("_mono_assembly").value);
            }

            return handles.map(_ => new Il2Cpp.Assembly(_));
        }

        /** Gets the encompassing object of the application domain. */
        @lazy
        get object(): Il2Cpp.Object {
            return Il2Cpp.corlib.class("System.AppDomain").method<Il2Cpp.Object>("get_CurrentDomain").invoke();
        }

        /** Opens and loads the assembly with the given name. */
        assembly(name: string): Il2Cpp.Assembly {
            return this.tryAssembly(name) ?? raise(`couldn't find assembly ${name}`);
        }

        /** Attached a new thread to the application domain. */
        attach(): Il2Cpp.Thread {
            return new Il2Cpp.Thread(Il2Cpp.exports.threadAttach(this));
        }

        /** Opens and loads the assembly with the given name. */
        tryAssembly(name: string): Il2Cpp.Assembly | null {
            return new Il2Cpp.Assembly(Il2Cpp.exports.domainGetAssemblyFromName(this, Memory.allocUtf8String(name))).asNullable();
        }
    }

    /** Gets the application domain. */
    export declare const domain: Il2Cpp.Domain;
    // prettier-ignore
    getter(Il2Cpp, "domain", () => {
        return new Il2Cpp.Domain(Il2Cpp.exports.domainGet());
    }, lazy);
}



================================================
FILE: lib/structs/field.ts
================================================
namespace Il2Cpp {
    export class Field<T extends Il2Cpp.Field.Type = Il2Cpp.Field.Type> extends NativeStruct {
        /** Gets the class in which this field is defined. */
        @lazy
        get class(): Il2Cpp.Class {
            return new Il2Cpp.Class(Il2Cpp.exports.fieldGetClass(this));
        }

        /** Gets the flags of the current field. */
        @lazy
        get flags(): number {
            return Il2Cpp.exports.fieldGetFlags(this);
        }

        /** Determines whether this field value is known at compile time. */
        @lazy
        get isLiteral(): boolean {
            return (this.flags & Il2Cpp.Field.Attributes.Literal) != 0;
        }

        /** Determines whether this field is static. */
        @lazy
        get isStatic(): boolean {
            return (this.flags & Il2Cpp.Field.Attributes.Static) != 0;
        }

        /** Determines whether this field is thread static. */
        @lazy
        get isThreadStatic(): boolean {
            const offset = Il2Cpp.corlib.class("System.AppDomain").field("type_resolve_in_progress").offset;

            // prettier-ignore
            getter(Il2Cpp.Field.prototype, "isThreadStatic", function (this: Il2Cpp.Field) {
                return this.offset == offset;
            }, lazy);

            return this.isThreadStatic;
        }

        /** Gets the access modifier of this field. */
        @lazy
        get modifier(): string | undefined {
            switch (this.flags & Il2Cpp.Field.Attributes.FieldAccessMask) {
                case Il2Cpp.Field.Attributes.Private:
                    return "private";
                case Il2Cpp.Field.Attributes.FamilyAndAssembly:
                    return "private protected";
                case Il2Cpp.Field.Attributes.Assembly:
                    return "internal";
                case Il2Cpp.Field.Attributes.Family:
                    return "protected";
                case Il2Cpp.Field.Attributes.FamilyOrAssembly:
                    return "protected internal";
                case Il2Cpp.Field.Attributes.Public:
                    return "public";
            }
        }

        /** Gets the name of this field. */
        @lazy
        get name(): string {
            return Il2Cpp.exports.fieldGetName(this).readUtf8String()!;
        }

        /** Gets the offset of this field, calculated as the difference with its owner virtual address. */
        @lazy
        get offset(): number {
            return Il2Cpp.exports.fieldGetOffset(this);
        }

        /** Gets the type of this field. */
        @lazy
        get type(): Il2Cpp.Type {
            return new Il2Cpp.Type(Il2Cpp.exports.fieldGetType(this));
        }

        /** Gets the value of this field. */
        get value(): T {
            if (!this.isStatic) {
                raise(`cannot access instance field ${this.class.type.name}::${this.name} from a class, use an object instead`);
            }

            const handle = Memory.alloc(Process.pointerSize);
            Il2Cpp.exports.fieldGetStaticValue(this.handle, handle);

            return read(handle, this.type) as T;
        }

        /** Sets the value of this field. Thread static or literal values cannot be altered yet. */
        set value(value: T) {
            if (!this.isStatic) {
                raise(`cannot access instance field ${this.class.type.name}::${this.name} from a class, use an object instead`);
            }

            if (this.isThreadStatic || this.isLiteral) {
                raise(`cannot write the value of field ${this.name} as it's thread static or literal`);
            }

            const handle =
                // pointer-like values should be passed as-is, but boxed
                // value types (primitives included) must be unboxed first
                value instanceof Il2Cpp.Object && this.type.class.isValueType
                    ? value.unbox()
                    : value instanceof NativeStruct
                    ? value.handle
                    : value instanceof NativePointer
                    ? value
                    : write(Memory.alloc(this.type.class.valueTypeSize), value, this.type);

            Il2Cpp.exports.fieldSetStaticValue(this.handle, handle);
        }

        /** */
        toString(): string {
            return `\
${this.isThreadStatic ? `[ThreadStatic] ` : ``}\
${this.isStatic ? `static ` : ``}\
${this.type.name} \
${this.name}\
${this.isLiteral ? ` = ${this.type.class.isEnum ? read((this.value as Il2Cpp.ValueType).handle, this.type.class.baseType!) : this.value}` : ``};\
${this.isThreadStatic || this.isLiteral ? `` : ` // 0x${this.offset.toString(16)}`}`;
        }

        /**
         * @internal
         * Binds the current field to a {@link Il2Cpp.Object} or a
         * {@link Il2Cpp.ValueType} (also known as *instances*), so that it is
         * possible to retrieve its value - see {@link Il2Cpp.Field.value} for
         * details. \
         * Binding a static field is forbidden.
         */
        bind(instance: Il2Cpp.Object | Il2Cpp.ValueType): Il2Cpp.BoundField<T> {
            if (this.isStatic) {
                raise(`cannot bind static field ${this.class.type.name}::${this.name} to an instance`);
            }

            const offset = this.offset - (instance instanceof Il2Cpp.ValueType ? Il2Cpp.Object.headerSize : 0);

            return new Proxy(this, {
                get(target: Il2Cpp.Field<T>, property: keyof Il2Cpp.Field): any {
                    if (property == "value") {
                        return read(instance.handle.add(offset), target.type);
                    }
                    return Reflect.get(target, property);
                },

                set(target: Il2Cpp.Field<T>, property: keyof Il2Cpp.Field, value: any): boolean {
                    if (property == "value") {
                        write(instance.handle.add(offset), value, target.type);
                        return true;
                    }

                    return Reflect.set(target, property, value);
                }
            });
        }
    }

    /**
     * A {@link Il2Cpp.Field} bound to a {@link Il2Cpp.Object} or a
     * {@link Il2Cpp.ValueType} (also known as *instances*).
     * ```ts
     * const object: Il2Cpp.Object = Il2Cpp.string("Hello, world!").object;
     * const m_length: Il2Cpp.BoundField<number> = object.field<number>("m_length");
     * const length = m_length.value; // 13
     * ```
     * Of course, binding a static field does not make sense and may cause
     * unwanted behaviors.
     *
     * Binding can be done manually with:
     * ```ts
     * const SystemString = Il2Cpp.corlib.class("System.String");
     * const m_length: Il2Cpp.Field<number> = SystemString.field<number>("m_length");
     *
     * const object: Il2Cpp.Object = Il2Cpp.string("Hello, world!").object;
     * // ＠ts-ignore
     * const m_length_bound: Il2Cpp.BoundField<number> = m_length.bind(object);
     * ```
     */
    export interface BoundField<T extends Il2Cpp.Field.Type = Il2Cpp.Field.Type> extends Field<T> {}

    export namespace Field {
        export type Type = boolean | number | Int64 | UInt64 | NativePointer | Il2Cpp.Pointer | Il2Cpp.ValueType | Il2Cpp.Object | Il2Cpp.String | Il2Cpp.Array;

        export const enum Attributes {
            FieldAccessMask = 0x0007,
            PrivateScope = 0x0000,
            Private = 0x0001,
            FamilyAndAssembly = 0x0002,
            Assembly = 0x0003,
            Family = 0x0004,
            FamilyOrAssembly = 0x0005,
            Public = 0x0006,
            Static = 0x0010,
            InitOnly = 0x0020,
            Literal = 0x0040,
            NotSerialized = 0x0080,
            SpecialName = 0x0200,
            PinvokeImpl = 0x2000,
            ReservedMask = 0x9500,
            RTSpecialName = 0x0400,
            HasFieldMarshal = 0x1000,
            HasDefault = 0x8000,
            HasFieldRVA = 0x0100
        }
    }
}



================================================
FILE: lib/structs/gc-handle.ts
================================================
namespace Il2Cpp {
    export class GCHandle {
        /** @internal */
        constructor(readonly handle: number) {}

        /** Gets the object associated to this handle. */
        get target(): Il2Cpp.Object | null {
            return new Il2Cpp.Object(Il2Cpp.exports.gcHandleGetTarget(this.handle)).asNullable();
        }

        /** Frees this handle. */
        free(): void {
            return Il2Cpp.exports.gcHandleFree(this.handle);
        }
    }
}



================================================
FILE: lib/structs/image.ts
================================================
namespace Il2Cpp {
    @recycle
    export class Image extends NativeStruct {
        /** Gets the assembly in which the current image is defined. */
        @lazy
        get assembly(): Il2Cpp.Assembly {
            return new Il2Cpp.Assembly(Il2Cpp.exports.imageGetAssembly(this));
        }

        /** Gets the amount of classes defined in this image. */
        @lazy
        get classCount(): number {
            if (Il2Cpp.unityVersionIsBelow201830) {
                return this.classes.length;
            } else {
                return Il2Cpp.exports.imageGetClassCount(this);
            }
        }

        /** Gets the classes defined in this image. */
        @lazy
        get classes(): Il2Cpp.Class[] {
            if (Il2Cpp.unityVersionIsBelow201830) {
                const types = this.assembly.object.method<Il2Cpp.Array<Il2Cpp.Object>>("GetTypes").invoke(false);
                // In Unity 5.3.8f1, getting System.Reflection.Emit.OpCodes type name
                // without iterating all the classes first somehow blows things up at
                // app startup, hence the `Array.from`.
                const classes = globalThis.Array.from(types, _ => new Il2Cpp.Class(Il2Cpp.exports.classFromObject(_)));

                // <Module> class does not always exist
                // https://github.com/vfsfitvnm/frida-il2cpp-bridge/issues/627
                const Module = this.tryClass("<Module>");
                if (Module) {
                    classes.unshift(Module);
                }

                return classes;
            } else {
                return globalThis.Array.from(globalThis.Array(this.classCount), (_, i) => new Il2Cpp.Class(Il2Cpp.exports.imageGetClass(this, i)));
            }
        }

        /** Gets the name of this image. */
        @lazy
        get name(): string {
            return Il2Cpp.exports.imageGetName(this).readUtf8String()!;
        }

        /** Gets the class with the specified name defined in this image. */
        class(name: string): Il2Cpp.Class {
            return this.tryClass(name) ?? raise(`couldn't find class ${name} in assembly ${this.name}`);
        }

        /** Gets the class with the specified name defined in this image. */
        tryClass(name: string): Il2Cpp.Class | null {
            const dotIndex = name.lastIndexOf(".");
            const classNamespace = Memory.allocUtf8String(dotIndex == -1 ? "" : name.slice(0, dotIndex));
            const className = Memory.allocUtf8String(name.slice(dotIndex + 1));

            return new Il2Cpp.Class(Il2Cpp.exports.classFromName(this, classNamespace, className)).asNullable();
        }
    }

    /** Gets the COR library. */
    export declare const corlib: Il2Cpp.Image;
    // prettier-ignore
    getter(Il2Cpp, "corlib", () => {
        return new Il2Cpp.Image(Il2Cpp.exports.getCorlib());
    }, lazy);
}



================================================
FILE: lib/structs/memory-snapshot.ts
================================================
namespace Il2Cpp {
    export class MemorySnapshot extends NativeStruct {
        /** Captures a memory snapshot. */
        static capture(): Il2Cpp.MemorySnapshot {
            return new Il2Cpp.MemorySnapshot();
        }

        /** Creates a memory snapshot with the given handle. */
        constructor(handle: NativePointer = Il2Cpp.exports.memorySnapshotCapture()) {
            super(handle);
        }

        /** Gets any initialized class. */
        @lazy
        get classes(): Il2Cpp.Class[] {
            return readNativeIterator(_ => Il2Cpp.exports.memorySnapshotGetClasses(this, _)).map(_ => new Il2Cpp.Class(_));
        }

        /** Gets the objects tracked by this memory snapshot. */
        @lazy
        get objects(): Il2Cpp.Object[] {
            // prettier-ignore
            return readNativeList(_ => Il2Cpp.exports.memorySnapshotGetObjects(this, _)).filter(_ => !_.isNull()).map(_ => new Il2Cpp.Object(_));
        }

        /** Frees this memory snapshot. */
        free(): void {
            Il2Cpp.exports.memorySnapshotFree(this);
        }
    }

    /** */
    export function memorySnapshot<T>(block: (memorySnapshot: Omit<Il2Cpp.MemorySnapshot, "free">) => T): T {
        const memorySnapshot = Il2Cpp.MemorySnapshot.capture();
        const result = block(memorySnapshot);
        memorySnapshot.free();
        return result;
    }
}



================================================
FILE: lib/structs/method.ts
================================================
namespace Il2Cpp {
    export class Method<T extends Il2Cpp.Method.ReturnType = Il2Cpp.Method.ReturnType> extends NativeStruct {
        /** Gets the class in which this method is defined. */
        @lazy
        get class(): Il2Cpp.Class {
            return new Il2Cpp.Class(Il2Cpp.exports.methodGetClass(this));
        }

        /** Gets the flags of the current method. */
        @lazy
        get flags(): number {
            return Il2Cpp.exports.methodGetFlags(this, NULL);
        }

        /** Gets the implementation flags of the current method. */
        @lazy
        get implementationFlags(): number {
            const implementationFlagsPointer = Memory.alloc(Process.pointerSize);
            Il2Cpp.exports.methodGetFlags(this, implementationFlagsPointer);

            return implementationFlagsPointer.readU32();
        }

        /** */
        @lazy
        get fridaSignature(): NativeCallbackArgumentType[] {
            const types: NativeCallbackArgumentType[] = [];

            for (const parameter of this.parameters) {
                types.push(parameter.type.fridaAlias);
            }

            if (!this.isStatic || Il2Cpp.unityVersionIsBelow201830) {
                types.unshift("pointer");
            }

            if (this.isInflated) {
                types.push("pointer");
            }

            return types;
        }

        /** Gets the generic parameters of this generic method. */
        @lazy
        get generics(): Il2Cpp.Class[] {
            if (!this.isGeneric && !this.isInflated) {
                return [];
            }

            const types = this.object.method<Il2Cpp.Array<Il2Cpp.Object>>("GetGenericArguments").invoke();
            return globalThis.Array.from(types).map(_ => new Il2Cpp.Class(Il2Cpp.exports.classFromObject(_)));
        }

        /** Determines whether this method is external. */
        @lazy
        get isExternal(): boolean {
            return (this.implementationFlags & Il2Cpp.Method.ImplementationAttribute.InternalCall) != 0;
        }

        /** Determines whether this method is generic. */
        @lazy
        get isGeneric(): boolean {
            return !!Il2Cpp.exports.methodIsGeneric(this);
        }

        /** Determines whether this method is inflated (generic with a concrete type parameter). */
        @lazy
        get isInflated(): boolean {
            return !!Il2Cpp.exports.methodIsInflated(this);
        }

        /** Determines whether this method is static. */
        @lazy
        get isStatic(): boolean {
            return !Il2Cpp.exports.methodIsInstance(this);
        }

        /** Determines whether this method is synchronized. */
        @lazy
        get isSynchronized(): boolean {
            return (this.implementationFlags & Il2Cpp.Method.ImplementationAttribute.Synchronized) != 0;
        }

        /** Gets the access modifier of this method. */
        @lazy
        get modifier(): string | undefined {
            switch (this.flags & Il2Cpp.Method.Attributes.MemberAccessMask) {
                case Il2Cpp.Method.Attributes.Private:
                    return "private";
                case Il2Cpp.Method.Attributes.FamilyAndAssembly:
                    return "private protected";
                case Il2Cpp.Method.Attributes.Assembly:
                    return "internal";
                case Il2Cpp.Method.Attributes.Family:
                    return "protected";
                case Il2Cpp.Method.Attributes.FamilyOrAssembly:
                    return "protected internal";
                case Il2Cpp.Method.Attributes.Public:
                    return "public";
            }
        }

        /** Gets the name of this method. */
        @lazy
        get name(): string {
            return Il2Cpp.exports.methodGetName(this).readUtf8String()!;
        }

        /** @internal */
        @lazy
        get nativeFunction(): NativeFunction<any, any> {
            return new NativeFunction(this.virtualAddress, this.returnType.fridaAlias, this.fridaSignature as NativeFunctionArgumentType[]);
        }

        /** Gets the encompassing object of the current method. */
        @lazy
        get object(): Il2Cpp.Object {
            return new Il2Cpp.Object(Il2Cpp.exports.methodGetObject(this, NULL));
        }

        /** Gets the amount of parameters of this method. */
        @lazy
        get parameterCount(): number {
            return Il2Cpp.exports.methodGetParameterCount(this);
        }

        /** Gets the parameters of this method. */
        @lazy
        get parameters(): Il2Cpp.Parameter[] {
            return globalThis.Array.from(globalThis.Array(this.parameterCount), (_, i) => {
                const parameterName = Il2Cpp.exports.methodGetParameterName(this, i).readUtf8String()!;
                const parameterType = Il2Cpp.exports.methodGetParameterType(this, i);
                return new Il2Cpp.Parameter(parameterName, i, new Il2Cpp.Type(parameterType));
            });
        }

        /** Gets the relative virtual address (RVA) of this method. */
        @lazy
        get relativeVirtualAddress(): NativePointer {
            return this.virtualAddress.sub(Il2Cpp.module.base);
        }

        /** Gets the return type of this method. */
        @lazy
        get returnType(): Il2Cpp.Type {
            return new Il2Cpp.Type(Il2Cpp.exports.methodGetReturnType(this));
        }

        /** Gets the virtual address (VA) of this method. */
        get virtualAddress(): NativePointer {
            const FilterTypeName = Il2Cpp.corlib.class("System.Reflection.Module").initialize().field<Il2Cpp.Object>("FilterTypeName").value;
            const FilterTypeNameMethodPointer = FilterTypeName.field<NativePointer>("method_ptr").value;
            const FilterTypeNameMethod = FilterTypeName.field<NativePointer>("method").value;

            // prettier-ignore
            const offset = FilterTypeNameMethod.offsetOf(_ => _.readPointer().equals(FilterTypeNameMethodPointer)) 
                ?? raise("couldn't find the virtual address offset in the native method struct");

            // prettier-ignore
            getter(Il2Cpp.Method.prototype, "virtualAddress", function (this: Il2Cpp.Method) {
                return this.handle.add(offset).readPointer();
            }, lazy);

            // In Unity 2017.4.40f1 (don't know about others),
            // `Il2Cpp.Class::initialize` somehow triggers a nasty bug during
            // early instrumentation, so that we aren't able to obtain the
            // offset to get the virtual address of a method when the script
            // is reloaded. A workaround consists in manually re-invoking the
            // static constructor.
            Il2Cpp.corlib.class("System.Reflection.Module").method(".cctor").invoke();

            return this.virtualAddress;
        }

        /** Replaces the body of this method. */
        set implementation(block: (this: Il2Cpp.Class | Il2Cpp.Object | Il2Cpp.ValueType, ...parameters: Il2Cpp.Parameter.Type[]) => T) {
            try {
                Interceptor.replace(this.virtualAddress, this.wrap(block));
            } catch (e: any) {
                switch (e.message) {
                    case "access violation accessing 0x0":
                        raise(`couldn't set implementation for method ${this.name} as it has a NULL virtual address`);
                    case /unable to intercept function at \w+; please file a bug/.exec(e.message)?.input:
                        warn(`couldn't set implementation for method ${this.name} as it may be a thunk`);
                        break;
                    case "already replaced this function":
                        warn(`couldn't set implementation for method ${this.name} as it has already been replaced by a thunk`);
                        break;
                    default:
                        throw e;
                }
            }
        }

        /** Creates a generic instance of the current generic method. */
        inflate<R extends Il2Cpp.Method.ReturnType = T>(...classes: Il2Cpp.Class[]): Il2Cpp.Method<R> {
            if (!this.isGeneric || this.generics.length != classes.length) {
                for (const method of this.overloads()) {
                    if (method.isGeneric && method.generics.length == classes.length) {
                        return method.inflate(...classes);
                    }
                }
                raise(`could not find inflatable signature of method ${this.name} with ${classes.length} generic parameter(s)`);
            }

            const types = classes.map(_ => _.type.object);
            const typeArray = Il2Cpp.array(Il2Cpp.corlib.class("System.Type"), types);

            const inflatedMethodObject = this.object.method<Il2Cpp.Object>("MakeGenericMethod", 1).invoke(typeArray);
            return new Il2Cpp.Method(inflatedMethodObject.field<NativePointer>("mhandle").value);
        }

        /** Invokes this method. */
        invoke(...parameters: Il2Cpp.Parameter.Type[]): T {
            if (!this.isStatic) {
                raise(`cannot invoke non-static method ${this.name} as it must be invoked throught a Il2Cpp.Object, not a Il2Cpp.Class`);
            }
            return this.invokeRaw(NULL, ...parameters);
        }

        /** @internal */
        invokeRaw(instance: NativePointerValue, ...parameters: Il2Cpp.Parameter.Type[]): T {
            const allocatedParameters = parameters.map(toFridaValue);

            if (!this.isStatic || Il2Cpp.unityVersionIsBelow201830) {
                allocatedParameters.unshift(instance);
            }

            if (this.isInflated) {
                allocatedParameters.push(this.handle);
            }

            try {
                const returnValue = this.nativeFunction(...allocatedParameters);
                return fromFridaValue(returnValue, this.returnType) as T;
            } catch (e: any) {
                if (e == null) {
                    raise("an unexpected native invocation exception occurred, this is due to parameter types mismatch");
                }

                switch (e.message) {
                    case "bad argument count":
                        raise(`couldn't invoke method ${this.name} as it needs ${this.parameterCount} parameter(s), not ${parameters.length}`);
                    case "expected a pointer":
                    case "expected number":
                    case "expected array with fields":
                        raise(`couldn't invoke method ${this.name} using incorrect parameter types`);
                }

                throw e;
            }
        }

        /** Gets the overloaded method with the given parameter types. */
        overload(...typeNamesOrClasses: (string | Il2Cpp.Class)[]): Il2Cpp.Method<T> {
            const method = this.tryOverload<T>(...typeNamesOrClasses);
            return (
                method ?? raise(`couldn't find overloaded method ${this.name}(${typeNamesOrClasses.map(_ => (_ instanceof Il2Cpp.Class ? _.type.name : _))})`)
            );
        }

        /** @internal */
        *overloads(): Generator<Il2Cpp.Method> {
            for (const klass of this.class.hierarchy()) {
                for (const method of klass.methods) {
                    if (this.name == method.name) {
                        yield method;
                    }
                }
            }
        }

        /** Gets the parameter with the given name. */
        parameter(name: string): Il2Cpp.Parameter {
            return this.tryParameter(name) ?? raise(`couldn't find parameter ${name} in method ${this.name}`);
        }

        /** Restore the original method implementation. */
        revert(): void {
            Interceptor.revert(this.virtualAddress);
            Interceptor.flush();
        }

        /** Gets the overloaded method with the given parameter types. */
        tryOverload<U extends Il2Cpp.Method.ReturnType = T>(...typeNamesOrClasses: (string | Il2Cpp.Class)[]): Il2Cpp.Method<U> | undefined {
            const minScore = typeNamesOrClasses.length * 1;
            const maxScore = typeNamesOrClasses.length * 2;

            let candidate: [number, Il2Cpp.Method] | undefined = undefined;

            loop: for (const method of this.overloads()) {
                if (method.parameterCount != typeNamesOrClasses.length) continue;

                let score = 0;
                let i = 0;
                for (const parameter of method.parameters) {
                    const desiredTypeNameOrClass = typeNamesOrClasses[i];
                    if (desiredTypeNameOrClass instanceof Il2Cpp.Class) {
                        if (parameter.type.is(desiredTypeNameOrClass.type)) {
                            score += 2;
                        } else if (parameter.type.class.isAssignableFrom(desiredTypeNameOrClass)) {
                            score += 1;
                        } else {
                            continue loop;
                        }
                    } else if (parameter.type.name == desiredTypeNameOrClass) {
                        score += 2;
                    } else {
                        continue loop;
                    }
                    i++;
                }

                if (score < minScore) {
                    continue;
                } else if (score == maxScore) {
                    return method as Il2Cpp.Method<U>;
                } else if (candidate == undefined || score > candidate[0]) {
                    candidate = [score, method];
                } else if (score == candidate[0]) {
                    // ```cs
                    // class Parent {}
                    // class Child0 extends Parent {}
                    // class Child1 extends Parent {}
                    // class Child11 extends Child1 {}
                    //
                    // class Methods {
                    //   void Foo(obj: Parent) {}
                    //   void Foo(obj: Child1) {}
                    //}
                    // ```
                    // in this scenario, Foo(Parent) and Foo(Child1) have
                    // the same score when looking for Foo(Child11) -
                    // we must compare the two candidates to determine the
                    // one that is "closer" to Foo(Child11)
                    let i = 0;
                    for (const parameter of candidate[1].parameters) {
                        // in this case, Foo(Parent) is the candidate
                        // overload: let's compare the parameter types - if
                        // any of the candidate ones is a parent, then the
                        // candidate method is not the closest overload
                        if (parameter.type.class.isAssignableFrom(method.parameters[i].type.class)) {
                            candidate = [score, method];
                            continue loop;
                        }
                        i++;
                    }
                }
            }

            return candidate?.[1] as Il2Cpp.Method<U> | undefined;
        }

        /** Gets the parameter with the given name. */
        tryParameter(name: string): Il2Cpp.Parameter | undefined {
            return this.parameters.find(_ => _.name == name);
        }

        /** */
        toString(): string {
            return `\
${this.isStatic ? `static ` : ``}\
${this.returnType.name} \
${this.name}\
${this.generics.length > 0 ? `<${this.generics.map(_ => _.type.name).join(",")}>` : ""}\
(${this.parameters.join(`, `)});\
${this.virtualAddress.isNull() ? `` : ` // 0x${this.relativeVirtualAddress.toString(16).padStart(8, `0`)}`}`;
        }

        /**
         * @internal
         * Binds the current method to a {@link Il2Cpp.Object} or a
         * {@link Il2Cpp.ValueType} (also known as *instances*), so that it is
         * possible to invoke it - see {@link Il2Cpp.Method.invoke} for
         * details. \
         * Binding a static method is forbidden.
         */
        bind(instance: Il2Cpp.Object | Il2Cpp.ValueType): Il2Cpp.BoundMethod<T> {
            if (this.isStatic) {
                raise(`cannot bind static method ${this.class.type.name}::${this.name} to an instance`);
            }

            return new Proxy(this, {
                get(target: Il2Cpp.Method<T>, property: keyof Il2Cpp.Method<T>, receiver: Il2Cpp.Method<T>): any {
                    switch (property) {
                        case "invoke":
                            // In Unity 5.3.5f1 and >= 2021.2.0f1, value types
                            // methods may assume their `this` parameter is a
                            // pointer to raw data (that is how value types are
                            // layed out in memory) instead of a pointer to an
                            // object (that is object header + raw data).
                            // In any case, they also don't use whatever there
                            // is in the object header, so we can safely "skip"
                            // the object header by adding the object header
                            // size to the object (a boxed value type) handle.
                            const handle =
                                instance instanceof Il2Cpp.ValueType
                                    ? target.class.isValueType
                                        ? instance.handle.sub(structMethodsRequireObjectInstances() ? Il2Cpp.Object.headerSize : 0)
                                        : raise(`cannot invoke method ${target.class.type.name}::${target.name} against a value type, you must box it first`)
                                    : target.class.isValueType
                                    ? instance.handle.add(structMethodsRequireObjectInstances() ? 0 : Il2Cpp.Object.headerSize)
                                    : instance.handle;

                            return target.invokeRaw.bind(target, handle);
                        case "overloads":
                            return function* () {
                                for (const method of target[property]()) {
                                    if (!method.isStatic) {
                                        yield method;
                                    }
                                }
                            };
                        case "inflate":
                        case "overload":
                        case "tryOverload":
                            const member = Reflect.get(target, property).bind(receiver);
                            return function (...args: any[]) {
                                return member(...args)?.bind(instance);
                            };
                    }

                    return Reflect.get(target, property);
                }
            });
        }

        /** @internal */
        wrap(block: (this: Il2Cpp.Class | Il2Cpp.Object | Il2Cpp.ValueType, ...parameters: Il2Cpp.Parameter.Type[]) => T): NativeCallback<any, any> {
            const startIndex = +!this.isStatic | +Il2Cpp.unityVersionIsBelow201830;
            return new NativeCallback(
                (...args: NativeCallbackArgumentValue[]): NativeCallbackReturnValue => {
                    const thisObject = this.isStatic
                        ? this.class
                        : this.class.isValueType
                        ? new Il2Cpp.ValueType(
                              (args[0] as NativePointer).add(structMethodsRequireObjectInstances() ? Il2Cpp.Object.headerSize : 0),
                              this.class.type
                          )
                        : new Il2Cpp.Object(args[0] as NativePointer);

                    const parameters = this.parameters.map((_, i) => fromFridaValue(args[i + startIndex], _.type));
                    const result = block.call(thisObject, ...parameters);
                    return toFridaValue(result);
                },
                this.returnType.fridaAlias,
                this.fridaSignature
            );
        }
    }

    /**
     * A {@link Il2Cpp.Method} bound to a {@link Il2Cpp.Object} or a
     * {@link Il2Cpp.ValueType} (also known as *instances*). \
     * Invoking bound methods will pass the assigned instance as `this`.
     * ```ts
     * const object: Il2Cpp.Object = Il2Cpp.string("Hello, world!").object;
     * const GetLength: Il2Cpp.BoundMethod<number> = object.method<number>("GetLength");
     * // There is no need to pass the object when invoking GetLength!
     * const length = GetLength.invoke(); // 13
     * ```
     * Of course, binding a static method does not make sense and may cause
     * unwanted behaviors. \
     *
     * Binding can be done manually with:
     * ```ts
     * const SystemString = Il2Cpp.corlib.class("System.String");
     * const GetLength: Il2Cpp.Method<number> = SystemString.method<number>("GetLength");
     *
     * const object: Il2Cpp.Object = Il2Cpp.string("Hello, world!").object;
     * // ＠ts-ignore
     * const GetLengthBound: Il2Cpp.BoundMethod<number> = GetLength.bind(object);
     * ```
     */
    export interface BoundMethod<T extends Il2Cpp.Method.ReturnType = Il2Cpp.Method.ReturnType> extends Method<T> {}

    let structMethodsRequireObjectInstances = (): boolean => {
        const object = Il2Cpp.corlib.class("System.Int64").alloc();
        object.field("m_value").value = 0xdeadbeef;

        // Here we check where the sentinel value is
        // if it's not where it is supposed to be, it means struct methods
        // assume they are receiving value types (that is a pointer to raw data)
        // hence, we must "skip" the object header when invoking such methods.
        const result = object.method<boolean>("Equals", 1).overload(object.class).invokeRaw(object, 0xdeadbeef);
        return (structMethodsRequireObjectInstances = () => result)();
    };

    export namespace Method {
        export type ReturnType = void | Il2Cpp.Field.Type | Il2Cpp.Reference;

        export const enum Attributes {
            MemberAccessMask = 0x0007,
            PrivateScope = 0x0000,
            Private = 0x0001,
            FamilyAndAssembly = 0x0002,
            Assembly = 0x0003,
            Family = 0x0004,
            FamilyOrAssembly = 0x0005,
            Public = 0x0006,
            Static = 0x0010,
            Final = 0x0020,
            Virtual = 0x0040,
            HideBySig = 0x0080,
            CheckAccessOnOverride = 0x0200,
            VtableLayoutMask = 0x0100,
            ReuseSlot = 0x0000,
            NewSlot = 0x0100,
            Abstract = 0x0400,
            SpecialName = 0x0800,
            PinvokeImpl = 0x2000,
            UnmanagedExport = 0x0008,
            RTSpecialName = 0x1000,
            ReservedMask = 0xd000,
            HasSecurity = 0x4000,
            RequireSecObject = 0x8000
        }

        export const enum ImplementationAttribute {
            CodeTypeMask = 0x0003,
            IntermediateLanguage = 0x0000,
            Native = 0x0001,
            OptimizedIntermediateLanguage = 0x0002,
            Runtime = 0x0003,
            ManagedMask = 0x0004,
            Unmanaged = 0x0004,
            Managed = 0x0000,
            ForwardRef = 0x0010,
            PreserveSig = 0x0080,
            InternalCall = 0x1000,
            Synchronized = 0x0020,
            NoInlining = 0x0008,
            AggressiveInlining = 0x0100,
            NoOptimization = 0x0040,
            SecurityMitigations = 0x0400,
            MaxMethodImplVal = 0xffff
        }
    }
}



================================================
FILE: lib/structs/object.ts
================================================
namespace Il2Cpp {
    export class Object extends NativeStruct {
        /** Gets the Il2CppObject struct size, possibly equal to `Process.pointerSize * 2`. */
        @lazy
        static get headerSize(): number {
            return Il2Cpp.corlib.class("System.Object").instanceSize;
        }

        /**
         * Returns the same object, but having its parent class as class.
         * It basically is the C# `base` keyword, so that parent members can be
         * accessed.
         *
         * **Example** \
         * Consider the following classes:
         * ```csharp
         * class Foo
         * {
         *     int foo()
         *     {
         *          return 1;
         *     }
         * }
         * class Bar : Foo
         * {
         *     new int foo()
         *     {
         *          return 2;
         *     }
         * }
         * ```
         * then:
         * ```ts
         * const Bar: Il2Cpp.Class = ...;
         * const bar = Bar.new();
         *
         * console.log(bar.foo()); // 2
         * console.log(bar.base.foo()); // 1
         * ```
         */
        get base(): Il2Cpp.Object {
            if (this.class.parent == null) {
                raise(`class ${this.class.type.name} has no parent`);
            }

            return new Proxy(this, {
                get(target: Il2Cpp.Object, property: keyof Il2Cpp.Object, receiver: Il2Cpp.Object): any {
                    if (property == "class") {
                        return Reflect.get(target, property).parent;
                    } else if (property == "base") {
                        return Reflect.getOwnPropertyDescriptor(Il2Cpp.Object.prototype, property)!.get!.bind(receiver)();
                    }
                    return Reflect.get(target, property);
                }
            });
        }

        /** Gets the class of this object. */
        @lazy
        get class(): Il2Cpp.Class {
            return new Il2Cpp.Class(Il2Cpp.exports.objectGetClass(this));
        }

        /** Returns a monitor for this object. */
        get monitor(): Il2Cpp.Object.Monitor {
            return new Il2Cpp.Object.Monitor(this);
        }

        /** Gets the size of the current object. */
        @lazy
        get size(): number {
            return Il2Cpp.exports.objectGetSize(this);
        }

        /** Gets the non-static field with the given name of the current class hierarchy. */
        field<T extends Il2Cpp.Field.Type>(name: string): Il2Cpp.BoundField<T> {
            return this.tryField(name) ?? raise(`couldn't find non-static field ${name} in hierarchy of class ${this.class.type.name}`);
        }

        /** Gets the non-static method with the given name (and optionally parameter count) of the current class hierarchy. */
        method<T extends Il2Cpp.Method.ReturnType>(name: string, parameterCount: number = -1): Il2Cpp.BoundMethod<T> {
            return this.tryMethod<T>(name, parameterCount) ?? raise(`couldn't find non-static method ${name} in hierarchy of class ${this.class.type.name}`);
        }

        /** Creates a reference to this object. */
        ref(pin: boolean): Il2Cpp.GCHandle {
            return new Il2Cpp.GCHandle(Il2Cpp.exports.gcHandleNew(this, +pin));
        }

        /** Gets the correct virtual method from the given virtual method. */
        virtualMethod<T extends Il2Cpp.Method.ReturnType>(method: Il2Cpp.Method): Il2Cpp.BoundMethod<T> {
            return new Il2Cpp.Method<T>(Il2Cpp.exports.objectGetVirtualMethod(this, method)).bind(this);
        }

        /** Gets the non-static field with the given name of the current class hierarchy, if it exists. */
        tryField<T extends Il2Cpp.Field.Type>(name: string): Il2Cpp.BoundField<T> | undefined {
            const field = this.class.tryField<T>(name);

            if (field?.isStatic) {
                // classes cannot have static and non-static fields with the
                // same name, hence we can immediately check the parent
                for (const klass of this.class.hierarchy({ includeCurrent: false })) {
                    for (const field of klass.fields) {
                        if (field.name == name && !field.isStatic) {
                            return field.bind(this) as Il2Cpp.Field<T>;
                        }
                    }
                }
                return undefined;
            }

            return field?.bind(this);
        }

        /** Gets the non-static method with the given name (and optionally parameter count) of the current class hierarchy, if it exists. */
        tryMethod<T extends Il2Cpp.Method.ReturnType>(name: string, parameterCount: number = -1): Il2Cpp.BoundMethod<T> | undefined {
            const method = this.class.tryMethod<T>(name, parameterCount);

            if (method?.isStatic) {
                for (const klass of this.class.hierarchy()) {
                    for (const method of klass.methods) {
                        if (method.name == name && !method.isStatic && (parameterCount < 0 || method.parameterCount == parameterCount)) {
                            return method.bind(this) as Il2Cpp.BoundMethod<T>;
                        }
                    }
                }
                return undefined;
            }

            return method?.bind(this);
        }

        /** */
        toString(): string {
            return this.isNull() ? "null" : this.method<Il2Cpp.String>("ToString", 0).invoke().content ?? "null";
        }

        /** Unboxes the value type (either a primitive, a struct or an enum) out of this object. */
        unbox(): Il2Cpp.ValueType {
            return this.class.isValueType
                ? new Il2Cpp.ValueType(Il2Cpp.exports.objectUnbox(this), this.class.type)
                : raise(`couldn't unbox instances of ${this.class.type.name} as they are not value types`);
        }

        /** Creates a weak reference to this object. */
        weakRef(trackResurrection: boolean): Il2Cpp.GCHandle {
            return new Il2Cpp.GCHandle(Il2Cpp.exports.gcHandleNewWeakRef(this, +trackResurrection));
        }
    }

    export namespace Object {
        export class Monitor {
            /** @internal */
            constructor(/** @internal */ readonly handle: NativePointerValue) {}

            /** Acquires an exclusive lock on the current object. */
            enter(): void {
                return Il2Cpp.exports.monitorEnter(this.handle);
            }

            /** Release an exclusive lock on the current object. */
            exit(): void {
                return Il2Cpp.exports.monitorExit(this.handle);
            }

            /** Notifies a thread in the waiting queue of a change in the locked object's state. */
            pulse(): void {
                return Il2Cpp.exports.monitorPulse(this.handle);
            }

            /** Notifies all waiting threads of a change in the object's state. */
            pulseAll(): void {
                return Il2Cpp.exports.monitorPulseAll(this.handle);
            }

            /** Attempts to acquire an exclusive lock on the current object. */
            tryEnter(timeout: number): boolean {
                return !!Il2Cpp.exports.monitorTryEnter(this.handle, timeout);
            }

            /** Releases the lock on an object and attempts to block the current thread until it reacquires the lock. */
            tryWait(timeout: number): boolean {
                return !!Il2Cpp.exports.monitorTryWait(this.handle, timeout);
            }

            /** Releases the lock on an object and blocks the current thread until it reacquires the lock. */
            wait(): void {
                return Il2Cpp.exports.monitorWait(this.handle);
            }
        }
    }
}



================================================
FILE: lib/structs/parameter.ts
================================================
namespace Il2Cpp {
    export class Parameter {
        /** Name of this parameter. */
        readonly name: string;

        /** Position of this parameter. */
        readonly position: number;

        /** Type of this parameter. */
        readonly type: Il2Cpp.Type;

        constructor(name: string, position: number, type: Il2Cpp.Type) {
            this.name = name;
            this.position = position;
            this.type = type;
        }

        /** */
        toString(): string {
            return `${this.type.name} ${this.name}`;
        }
    }

    export namespace Parameter {
        export type Type = Il2Cpp.Field.Type | Il2Cpp.Reference;
    }
}



================================================
FILE: lib/structs/pointer.ts
================================================
namespace Il2Cpp {
    export class Pointer<T extends Il2Cpp.Field.Type = Il2Cpp.Field.Type> extends NativeStruct {
        constructor(handle: NativePointer, readonly type: Il2Cpp.Type) {
            super(handle);
        }

        /** Gets the element at the given index. */
        get(index: number): T {
            return read(this.handle.add(index * this.type.class.arrayElementSize), this.type) as T;
        }

        /** Reads the given amount of elements starting at the given offset. */
        read(length: number, offset: number = 0): T[] {
            const values = new globalThis.Array<T>(length);

            for (let i = 0; i < length; i++) {
                values[i] = this.get(i + offset);
            }

            return values;
        }

        /** Sets the given element at the given index */
        set(index: number, value: T): void {
            write(this.handle.add(index * this.type.class.arrayElementSize), value, this.type);
        }

        /** */
        toString(): string {
            return this.handle.toString();
        }

        /** Writes the given elements starting at the given index. */
        write(values: T[], offset: number = 0): void {
            for (let i = 0; i < values.length; i++) {
                this.set(i + offset, values[i]);
            }
        }
    }
}



================================================
FILE: lib/structs/reference.ts
================================================
namespace Il2Cpp {
    export class Reference<T extends Il2Cpp.Field.Type = Il2Cpp.Field.Type> extends NativeStruct {
        constructor(handle: NativePointer, readonly type: Il2Cpp.Type) {
            super(handle);
        }

        /** Gets the element referenced by the current reference. */
        get value(): T {
            return read(this.handle, this.type) as T;
        }

        /** Sets the element referenced by the current reference. */
        set value(value: T) {
            write(this.handle, value, this.type);
        }

        /** */
        toString(): string {
            return this.isNull() ? "null" : `->${this.value}`;
        }
    }

    export function reference<T extends number | NativePointer>(value: T, type: Il2Cpp.Type): Il2Cpp.Reference<T>;

    export function reference<T extends Exclude<Il2Cpp.Field.Type, number | NativePointer>>(value: T): Il2Cpp.Reference<T>;

    /** Creates a reference to the specified value. */
    export function reference<T extends Il2Cpp.Field.Type>(value: T, type?: Il2Cpp.Type): Il2Cpp.Reference<T> {
        const handle = Memory.alloc(Process.pointerSize);

        switch (typeof value) {
            case "boolean":
                return new Il2Cpp.Reference(handle.writeS8(+value), Il2Cpp.corlib.class("System.Boolean").type);
            case "number":
                switch (type?.enumValue) {
                    case Il2Cpp.Type.Enum.UBYTE:
                        return new Il2Cpp.Reference<T>(handle.writeU8(value), type);
                    case Il2Cpp.Type.Enum.BYTE:
                        return new Il2Cpp.Reference<T>(handle.writeS8(value), type);
                    case Il2Cpp.Type.Enum.CHAR:
                    case Il2Cpp.Type.Enum.USHORT:
                        return new Il2Cpp.Reference<T>(handle.writeU16(value), type);
                    case Il2Cpp.Type.Enum.SHORT:
                        return new Il2Cpp.Reference<T>(handle.writeS16(value), type);
                    case Il2Cpp.Type.Enum.UINT:
                        return new Il2Cpp.Reference<T>(handle.writeU32(value), type);
                    case Il2Cpp.Type.Enum.INT:
                        return new Il2Cpp.Reference<T>(handle.writeS32(value), type);
                    case Il2Cpp.Type.Enum.ULONG:
                        return new Il2Cpp.Reference<T>(handle.writeU64(value), type);
                    case Il2Cpp.Type.Enum.LONG:
                        return new Il2Cpp.Reference<T>(handle.writeS64(value), type);
                    case Il2Cpp.Type.Enum.FLOAT:
                        return new Il2Cpp.Reference<T>(handle.writeFloat(value), type);
                    case Il2Cpp.Type.Enum.DOUBLE:
                        return new Il2Cpp.Reference<T>(handle.writeDouble(value), type);
                }
            case "object":
                if (value instanceof Il2Cpp.ValueType || value instanceof Il2Cpp.Pointer) {
                    return new Il2Cpp.Reference<T>(value.handle, value.type);
                } else if (value instanceof Il2Cpp.Object) {
                    return new Il2Cpp.Reference<T>(handle.writePointer(value), value.class.type);
                } else if (value instanceof Il2Cpp.String || value instanceof Il2Cpp.Array) {
                    return new Il2Cpp.Reference<T>(handle.writePointer(value), value.object.class.type);
                } else if (value instanceof NativePointer) {
                    switch (type?.enumValue) {
                        case Il2Cpp.Type.Enum.NUINT:
                        case Il2Cpp.Type.Enum.NINT:
                            return new Il2Cpp.Reference<T>(handle.writePointer(value), type);
                    }
                } else if (value instanceof Int64) {
                    return new Il2Cpp.Reference<T>(handle.writeS64(value), Il2Cpp.corlib.class("System.Int64").type);
                } else if (value instanceof UInt64) {
                    return new Il2Cpp.Reference<T>(handle.writeU64(value), Il2Cpp.corlib.class("System.UInt64").type);
                }
            default:
                raise(`couldn't create a reference to ${value} using an unhandled type ${type?.name}`);
        }
    }
}



================================================
FILE: lib/structs/string.ts
================================================
namespace Il2Cpp {
    export class String extends NativeStruct {
        /** Gets the content of this string. */
        get content(): string | null {
            return Il2Cpp.exports.stringGetChars(this).readUtf16String(this.length);
        }

        /** @unsafe Sets the content of this string - it may write out of bounds! */
        set content(value: string | null) {
            // prettier-ignore
            const offset = Il2Cpp.string("vfsfitvnm").handle.offsetOf(_ => _.readInt() == 9) 
                ?? raise("couldn't find the length offset in the native string struct");

            globalThis.Object.defineProperty(Il2Cpp.String.prototype, "content", {
                set(this: Il2Cpp.String, value: string | null) {
                    Il2Cpp.exports.stringGetChars(this).writeUtf16String(value ?? "");
                    this.handle.add(offset).writeS32(value?.length ?? 0);
                }
            });

            this.content = value;
        }

        /** Gets the length of this string. */
        get length(): number {
            return Il2Cpp.exports.stringGetLength(this);
        }

        /** Gets the encompassing object of the current string. */
        get object(): Il2Cpp.Object {
            return new Il2Cpp.Object(this);
        }

        /** */
        toString(): string {
            return this.isNull() ? "null" : `"${this.content}"`;
        }
    }

    /** Creates a new string with the specified content. */
    export function string(content: string | null): Il2Cpp.String {
        return new Il2Cpp.String(Il2Cpp.exports.stringNew(Memory.allocUtf8String(content ?? "")));
    }
}



================================================
FILE: lib/structs/thread.ts
================================================
namespace Il2Cpp {
    export class Thread extends NativeStruct {
        /** Gets the native id of the current thread. */
        get id(): number {
            let get = function (this: Il2Cpp.Thread) {
                return this.internal.field<UInt64>("thread_id").value.toNumber();
            };

            // https://github.com/mono/linux-packaging-mono/blob/d586f84dfea30217f34b076a616a098518aa72cd/mono/utils/mono-threads.h#L642
            if (Process.platform != "windows") {
                const currentThreadId = Process.getCurrentThreadId();
                const currentPosixThread = ptr(get.apply(Il2Cpp.currentThread!));

                // prettier-ignore
                const offset = currentPosixThread.offsetOf(_ => _.readS32() == currentThreadId, 1024) ??
                    raise(`couldn't find the offset for determining the kernel id of a posix thread`);

                const _get = get;
                get = function (this: Il2Cpp.Thread) {
                    return ptr(_get.apply(this)).add(offset).readS32();
                };
            }

            getter(Il2Cpp.Thread.prototype, "id", get, lazy);

            return this.id;
        }

        /** Gets the encompassing internal object (System.Threding.InternalThreead) of the current thread. */
        @lazy
        get internal(): Il2Cpp.Object {
            return this.object.tryField<Il2Cpp.Object>("internal_thread")?.value ?? this.object;
        }

        /** Determines whether the current thread is the garbage collector finalizer one. */
        @lazy
        get isFinalizer(): boolean {
            return !Il2Cpp.exports.threadIsVm(this);
        }

        /** Gets the managed id of the current thread. */
        @lazy
        get managedId(): number {
            return this.object.method<number>("get_ManagedThreadId").invoke();
        }

        /** Gets the encompassing object of the current thread. */
        @lazy
        get object(): Il2Cpp.Object {
            return new Il2Cpp.Object(this);
        }

        /** @internal */
        @lazy
        private get staticData(): NativePointer {
            return this.internal.field<NativePointer>("static_data").value;
        }

        /** @internal */
        @lazy
        private get synchronizationContext(): Il2Cpp.Object | null {
            const get_ExecutionContext = this.object.tryMethod<Il2Cpp.Object>("GetMutableExecutionContext") ?? this.object.method("get_ExecutionContext");
            const executionContext = get_ExecutionContext.invoke();

            // From what I observed, only the main thread is supposed to have a
            // synchronization context; however there are two cases where it is
            // not available at all:
            // 1) during early instrumentation;
            // 2) it was dead code has it was stripped out.
            const synchronizationContext =
                executionContext.tryField<Il2Cpp.Object>("_syncContext")?.value ??
                executionContext.tryMethod<Il2Cpp.Object>("get_SynchronizationContext")?.invoke() ??
                this.tryLocalValue(Il2Cpp.corlib.class("System.Threading.SynchronizationContext"));

            return synchronizationContext?.asNullable() ?? null;
        }

        /** Detaches the thread from the application domain. */
        detach(): void {
            return Il2Cpp.exports.threadDetach(this);
        }

        /** Schedules a callback on the current thread. */
        schedule<T>(block: () => T): Promise<T> {
            const Post = this.synchronizationContext?.tryMethod("Post");

            if (Post == null) {
                return Process.runOnThread(this.id, block);
            }

            return new Promise(resolve => {
                const delegate = Il2Cpp.delegate(Il2Cpp.corlib.class("System.Threading.SendOrPostCallback"), () => {
                    const result = block();
                    setImmediate(() => resolve(result));
                });

                // This is to replace pending scheduled callbacks when the script is about to get unlaoded.
                // If we skip this cleanup, Frida's native callbacks will point to invalid memory, making
                // the application crash as soon as the IL2CPP runtime tries to execute such callbacks.
                // For instance, without the following code, this is how you can trigger a crash:
                // 1) unfocus the application;
                // 2) schedule a callback;
                // 3) reload the script;
                // 4) focus application.
                //
                // The "proper" solution consists in removing our delegates from the Unity synchroniztion
                // context, but the interface is not consisent across Unity versions - e.g. 2017.4.40f1 uses
                // a queue instead of a list, whereas newer versions do not allow null work requests.
                // The following solution, which basically redirects the invocation to a native function that
                // survives the script reloading, is much simpler, honestly.
                Script.bindWeak(globalThis, () => {
                    delegate.field("method_ptr").value = delegate.field("invoke_impl").value = Il2Cpp.exports.domainGet;
                });

                Post.invoke(delegate, NULL);
            });
        }

        /** @internal */
        tryLocalValue(klass: Il2Cpp.Class): Il2Cpp.Object | undefined {
            for (let i = 0; i < 16; i++) {
                const base = this.staticData.add(i * Process.pointerSize).readPointer();
                if (!base.isNull()) {
                    const object = new Il2Cpp.Object(base.readPointer()).asNullable();
                    if (object?.class?.isSubclassOf(klass, false)) {
                        return object;
                    }
                }
            }
        }
    }

    /** Gets the attached threads. */
    export declare const attachedThreads: Il2Cpp.Thread[];
    getter(Il2Cpp, "attachedThreads", () => {
        if (Il2Cpp.exports.threadGetAttachedThreads.isNull()) {
            const currentThreadHandle = Il2Cpp.currentThread?.handle ?? raise("Current thread is not attached to IL2CPP");
            const pattern = currentThreadHandle.toMatchPattern();

            const threads: Il2Cpp.Thread[] = [];

            for (const range of Process.enumerateRanges("rw-")) {
                if (range.file == undefined) {
                    const matches = Memory.scanSync(range.base, range.size, pattern);
                    if (matches.length == 1) {
                        while (true) {
                            const handle = matches[0].address.sub(matches[0].size * threads.length).readPointer();

                            if (handle.isNull() || !handle.readPointer().equals(currentThreadHandle.readPointer())) {
                                break;
                            }

                            threads.unshift(new Il2Cpp.Thread(handle));
                        }
                        break;
                    }
                }
            }

            return threads;
        }

        return readNativeList(Il2Cpp.exports.threadGetAttachedThreads).map(_ => new Il2Cpp.Thread(_));
    });

    /** Gets the current attached thread, if any. */
    export declare const currentThread: Il2Cpp.Thread | null;
    getter(Il2Cpp, "currentThread", () => {
        return new Il2Cpp.Thread(Il2Cpp.exports.threadGetCurrent()).asNullable();
    });

    /** Gets the current attached thread, if any. */
    export declare const mainThread: Il2Cpp.Thread;
    getter(Il2Cpp, "mainThread", () => {
        // I'm not sure if this is always the case. Typically, the main
        // thread managed id is 1, but this isn't always true: spawning
        // an Android application with Unity 5.3.8f1 will cause the Frida
        // thread to have the managed id equal to 1, whereas the main thread
        // managed id is 2.
        return attachedThreads[0];
    });
}



================================================
FILE: lib/structs/type.ts
================================================
namespace Il2Cpp {
    @recycle
    export class Type extends NativeStruct {
        /** */
        @lazy
        static get Enum() {
            const _ = (_: string, block = (_: Il2Cpp.Class): { type: Il2Cpp.Type } => _) => block(Il2Cpp.corlib.class(_)).type.enumValue;

            const initial = {
                VOID: _("System.Void"),
                BOOLEAN: _("System.Boolean"),
                CHAR: _("System.Char"),
                BYTE: _("System.SByte"),
                UBYTE: _("System.Byte"),
                SHORT: _("System.Int16"),
                USHORT: _("System.UInt16"),
                INT: _("System.Int32"),
                UINT: _("System.UInt32"),
                LONG: _("System.Int64"),
                ULONG: _("System.UInt64"),
                NINT: _("System.IntPtr"),
                NUINT: _("System.UIntPtr"),
                FLOAT: _("System.Single"),
                DOUBLE: _("System.Double"),
                POINTER: _("System.IntPtr", _ => _.field("m_value")),
                VALUE_TYPE: _("System.Decimal"),
                OBJECT: _("System.Object"),
                STRING: _("System.String"),
                CLASS: _("System.Array"),
                ARRAY: _("System.Void", _ => _.arrayClass),
                NARRAY: _("System.Void", _ => new Il2Cpp.Class(Il2Cpp.exports.classGetArrayClass(_, 2))),
                GENERIC_INSTANCE: _("System.Int32", _ => _.interfaces.find(_ => _.name.endsWith("`1"))!)
            };

            // VAR and MVAR require the rest of the values to be initialized;
            // this is to avoid "Maximum call stack size exceeded"
            Reflect.defineProperty(this, "Enum", { value: initial });

            return addFlippedEntries({
                ...initial,
                VAR: _("System.Action`1", _ => _.generics[0]),
                MVAR: _("System.Array", _ => _.method("AsReadOnly", 1).generics[0])
            });
        }

        /** Gets the class of this type. */
        @lazy
        get class(): Il2Cpp.Class {
            return new Il2Cpp.Class(Il2Cpp.exports.typeGetClass(this));
        }

        /** */
        @lazy
        get fridaAlias(): NativeCallbackArgumentType {
            function getValueTypeFields(type: Il2Cpp.Type): NativeCallbackArgumentType {
                const instanceFields = type.class.fields.filter(_ => !_.isStatic);
                return instanceFields.length == 0 ? ["char"] : instanceFields.map(_ => _.type.fridaAlias);
            }

            if (this.isByReference) {
                return "pointer";
            }

            switch (this.enumValue) {
                case Il2Cpp.Type.Enum.VOID:
                    return "void";
                case Il2Cpp.Type.Enum.BOOLEAN:
                    return "bool";
                case Il2Cpp.Type.Enum.CHAR:
                    return "uchar";
                case Il2Cpp.Type.Enum.BYTE:
                    return "int8";
                case Il2Cpp.Type.Enum.UBYTE:
                    return "uint8";
                case Il2Cpp.Type.Enum.SHORT:
                    return "int16";
                case Il2Cpp.Type.Enum.USHORT:
                    return "uint16";
                case Il2Cpp.Type.Enum.INT:
                    return "int32";
                case Il2Cpp.Type.Enum.UINT:
                    return "uint32";
                case Il2Cpp.Type.Enum.LONG:
                    return "int64";
                case Il2Cpp.Type.Enum.ULONG:
                    return "uint64";
                case Il2Cpp.Type.Enum.FLOAT:
                    return "float";
                case Il2Cpp.Type.Enum.DOUBLE:
                    return "double";
                case Il2Cpp.Type.Enum.NINT:
                case Il2Cpp.Type.Enum.NUINT:
                case Il2Cpp.Type.Enum.POINTER:
                case Il2Cpp.Type.Enum.STRING:
                case Il2Cpp.Type.Enum.ARRAY:
                case Il2Cpp.Type.Enum.NARRAY:
                    return "pointer";
                case Il2Cpp.Type.Enum.VALUE_TYPE:
                    return this.class.isEnum ? this.class.baseType!.fridaAlias : getValueTypeFields(this);
                case Il2Cpp.Type.Enum.CLASS:
                case Il2Cpp.Type.Enum.OBJECT:
                case Il2Cpp.Type.Enum.GENERIC_INSTANCE:
                    return this.class.isStruct ? getValueTypeFields(this) : this.class.isEnum ? this.class.baseType!.fridaAlias : "pointer";
                default:
                    return "pointer";
            }
        }

        /** Determines whether this type is passed by reference. */
        @lazy
        get isByReference(): boolean {
            return this.name.endsWith("&");
        }

        /** Determines whether this type is primitive. */
        @lazy
        get isPrimitive(): boolean {
            switch (this.enumValue) {
                case Il2Cpp.Type.Enum.BOOLEAN:
                case Il2Cpp.Type.Enum.CHAR:
                case Il2Cpp.Type.Enum.BYTE:
                case Il2Cpp.Type.Enum.UBYTE:
                case Il2Cpp.Type.Enum.SHORT:
                case Il2Cpp.Type.Enum.USHORT:
                case Il2Cpp.Type.Enum.INT:
                case Il2Cpp.Type.Enum.UINT:
                case Il2Cpp.Type.Enum.LONG:
                case Il2Cpp.Type.Enum.ULONG:
                case Il2Cpp.Type.Enum.FLOAT:
                case Il2Cpp.Type.Enum.DOUBLE:
                case Il2Cpp.Type.Enum.NINT:
                case Il2Cpp.Type.Enum.NUINT:
                    return true;
                default:
                    return false;
            }
        }

        /** Gets the name of this type. */
        @lazy
        get name(): string {
            const handle = Il2Cpp.exports.typeGetName(this);

            try {
                return handle.readUtf8String()!;
            } finally {
                Il2Cpp.free(handle);
            }
        }

        /** Gets the encompassing object of the current type. */
        @lazy
        get object(): Il2Cpp.Object {
            return new Il2Cpp.Object(Il2Cpp.exports.typeGetObject(this));
        }

        /** Gets the {@link Il2Cpp.Type.Enum} value of the current type. */
        @lazy
        get enumValue(): number {
            return Il2Cpp.exports.typeGetTypeEnum(this);
        }

        is(other: Il2Cpp.Type): boolean {
            if (Il2Cpp.exports.typeEquals.isNull()) {
                return this.object.method<boolean>("Equals").invoke(other.object);
            }

            return !!Il2Cpp.exports.typeEquals(this, other);
        }

        /** */
        toString(): string {
            return this.name;
        }
    }
}



================================================
FILE: lib/structs/value-type.ts
================================================
namespace Il2Cpp {
    export class ValueType extends NativeStruct {
        constructor(handle: NativePointer, readonly type: Il2Cpp.Type) {
            super(handle);
        }

        /** Boxes the current value type in a object. */
        box(): Il2Cpp.Object {
            return new Il2Cpp.Object(Il2Cpp.exports.valueTypeBox(this.type.class, this));
        }

        /** Gets the non-static field with the given name of the current class hierarchy. */
        field<T extends Il2Cpp.Field.Type>(name: string): Il2Cpp.BoundField<T> {
            return this.tryField(name) ?? raise(`couldn't find non-static field ${name} in hierarchy of class ${this.type.name}`);
        }

        /** Gets the non-static method with the given name (and optionally parameter count) of the current class hierarchy. */
        method<T extends Il2Cpp.Method.ReturnType>(name: string, parameterCount: number = -1): Il2Cpp.BoundMethod<T> {
            return this.tryMethod<T>(name, parameterCount) ?? raise(`couldn't find non-static method ${name} in hierarchy of class ${this.type.name}`);
        }

        /** Gets the non-static field with the given name of the current class hierarchy, if it exists. */
        tryField<T extends Il2Cpp.Field.Type>(name: string): Il2Cpp.BoundField<T> | undefined {
            const field = this.type.class.tryField<T>(name);

            if (field?.isStatic) {
                for (const klass of this.type.class.hierarchy()) {
                    for (const field of klass.fields) {
                        if (field.name == name && !field.isStatic) {
                            return field.bind(this) as Il2Cpp.BoundField<T>;
                        }
                    }
                }
                return undefined;
            }

            return field?.bind(this);
        }

        /** Gets the non-static method with the given name (and optionally parameter count) of the current class hierarchy, if it exists. */
        tryMethod<T extends Il2Cpp.Method.ReturnType>(name: string, parameterCount: number = -1): Il2Cpp.BoundMethod<T> | undefined {
            const method = this.type.class.tryMethod<T>(name, parameterCount);

            if (method?.isStatic) {
                for (const klass of this.type.class.hierarchy()) {
                    for (const method of klass.methods) {
                        if (method.name == name && !method.isStatic && (parameterCount < 0 || method.parameterCount == parameterCount)) {
                            return method.bind(this) as Il2Cpp.BoundMethod<T>;
                        }
                    }
                }
                return undefined;
            }

            return method?.bind(this);
        }

        /** */
        toString(): string {
            const ToString = this.method<Il2Cpp.String>("ToString", 0);
            return this.isNull()
                ? "null"
                : // If ToString is defined within a value type class, we can
                // avoid a boxing operation.
                ToString.class.isValueType
                ? ToString.invoke().content ?? "null"
                : this.box().toString() ?? "null";
        }
    }
}



================================================
FILE: lib/utils/android.ts
================================================
/** @internal */
namespace Android {
    export declare const apiLevel: number | null;
    // prettier-ignore
    getter(Android, "apiLevel", () => {
        const value = getProperty("ro.build.version.sdk");
        return value ? parseInt(value) : null;
    }, lazy);

    function getProperty(name: string): string | undefined {
        const handle = Process.findModuleByName("libc.so")?.findExportByName("__system_property_get");

        if (handle) {
            const __system_property_get = new NativeFunction(handle, "void", ["pointer", "pointer"]);

            const value = Memory.alloc(92).writePointer(NULL);
            __system_property_get(Memory.allocUtf8String(name), value);

            return value.readCString() ?? undefined;
        }
    }
}



================================================
FILE: lib/utils/console.ts
================================================
/** @internal */
function raise(message: any): never {
    const error = new Error(message);
    // in the stack message, it is only used by V8 - qjs ignores it
    error.name = "Il2CppError";
    error.stack = error.stack
        // reset style and replace "(Il2Cpp)?Error" with custom tag
        ?.replace(/^(Il2Cpp)?Error/, "\x1b[0m\x1b[38;5;9mil2cpp\x1b[0m")
        // replace the (unhelpful) first line of the stack ("at raise ...") and
        // add style to the stack lines
        ?.replace(/\n    at (.+) \((.+):(.+)\)/, "\x1b[3m\x1b[2m")
        // reset style
        ?.concat("\x1B[0m");

    throw error;
}

/** @internal */
function warn(message: any): void {
    (globalThis as any).console.log(`\x1b[38;5;11mil2cpp\x1b[0m: ${message}`);
}

/** @internal */
function ok(message: any): void {
    (globalThis as any).console.log(`\x1b[38;5;10mil2cpp\x1b[0m: ${message}`);
}

/** @internal */
function inform(message: any): void {
    (globalThis as any).console.log(`\x1b[38;5;12mil2cpp\x1b[0m: ${message}`);
}



================================================
FILE: lib/utils/decorate.ts
================================================
/** @internal */
function decorate<T extends object>(
    target: T,
    decorator: (target: T, key: string, descriptor: PropertyDescriptor) => PropertyDescriptor,
    descriptors = Object.getOwnPropertyDescriptors(target as any)
): T {
    for (const key in descriptors) {
        descriptors[key] = decorator(target, key, descriptors[key]);
    }

    Object.defineProperties(target, descriptors);

    return target;
}



================================================
FILE: lib/utils/getter.ts
================================================
/** @internal */
function getter<T, K extends keyof T>(
    target: T,
    key: K,
    get: () => T[K],
    decorator?: (target: T, key: K, descriptor: PropertyDescriptor) => PropertyDescriptor
) {
    globalThis.Object.defineProperty(target, key, decorator?.(target, key, { get, configurable: true }) ?? { get, configurable: true });
}



================================================
FILE: lib/utils/hash.ts
================================================
/** @internal https://stackoverflow.com/a/52171480/16885569 */
function cyrb53(str: string): number {
    let h1 = 0xdeadbeef;
    let h2 = 0x41c6ce57;

    for (let i = 0, ch; i < str.length; i++) {
        ch = str.charCodeAt(i);
        h1 = Math.imul(h1 ^ ch, 2654435761);
        h2 = Math.imul(h2 ^ ch, 1597334677);
    }

    h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507);
    h1 ^= Math.imul(h2 ^ (h2 >>> 13), 3266489909);

    h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507);
    h2 ^= Math.imul(h1 ^ (h1 >>> 13), 3266489909);

    return 4294967296 * (2097151 & h2) + (h1 >>> 0);
}

/** @internal */
function exportsHash(module: Module): number {
    return cyrb53(
        module
            .enumerateExports()
            .sort((a, b) => a.name.localeCompare(b.name))
            .map(_ => _.name + _.address.sub(module.base))
            .join("")
    );
}



================================================
FILE: lib/utils/lazy.ts
================================================
/** @internal */
function lazy(_: any, propertyKey: PropertyKey, descriptor: PropertyDescriptor) {
    const getter = descriptor.get;

    if (!getter) {
        throw new Error("@lazy can only be applied to getter accessors");
    }

    descriptor.get = function () {
        const value = getter.call(this);
        Object.defineProperty(this, propertyKey, {
            value,
            configurable: descriptor.configurable,
            enumerable: descriptor.enumerable,
            writable: false
        });
        return value;
    };
    return descriptor;
}



================================================
FILE: lib/utils/native-struct.ts
================================================
/** Scaffold class. */
class NativeStruct implements ObjectWrapper {
    readonly handle: NativePointer;

    constructor(handleOrWrapper: NativePointerValue) {
        if (handleOrWrapper instanceof NativePointer) {
            this.handle = handleOrWrapper;
        } else {
            this.handle = handleOrWrapper.handle;
        }
    }

    equals(other: NativeStruct) {
        return this.handle.equals(other.handle);
    }

    isNull(): boolean {
        return this.handle.isNull();
    }

    asNullable(): this | null {
        return this.isNull() ? null : this;
    }
}



================================================
FILE: lib/utils/object.ts
================================================
/** @internal */
function addFlippedEntries<T extends Record<any, any>>(obj: T): T & { [K in keyof T as T[K]]: K } {
    return Object.keys(obj).reduce((obj, key) => (((obj[obj[key]] as any) = key), obj), obj);
}



================================================
FILE: lib/utils/offset-of.ts
================================================
/** @internal */
interface NativePointer {
    offsetOf(condition: (handle: NativePointer) => boolean, depth?: number): number | null;
}

NativePointer.prototype.offsetOf = function (condition, depth) {
    depth ??= 512;

    for (let i = 0; depth > 0 ? i < depth : i < -depth; i++) {
        if (condition(depth > 0 ? this.add(i) : this.sub(i))) {
            return i;
        }
    }

    return null;
};



================================================
FILE: lib/utils/read-native-iterator.ts
================================================
/** @internal */
function readNativeIterator(block: (iteratorPointer: NativePointer) => NativePointer): NativePointer[] {
    const array = [];
    const iterator = Memory.alloc(Process.pointerSize);

    let handle = block(iterator);

    while (!handle.isNull()) {
        array.push(handle);
        handle = block(iterator);
    }

    return array;
}



================================================
FILE: lib/utils/read-native-list.ts
================================================
/** @internal */
function readNativeList(block: (lengthPointer: NativePointer) => NativePointer): NativePointer[] {
    const lengthPointer = Memory.alloc(Process.pointerSize);
    const startPointer = block(lengthPointer);

    if (startPointer.isNull()) {
        return [];
    }

    const array = new Array(lengthPointer.readInt());

    for (let i = 0; i < array.length; i++) {
        array[i] = startPointer.add(i * Process.pointerSize).readPointer();
    }

    return array;
}



================================================
FILE: lib/utils/recycle.ts
================================================
/** @internal */
function recycle<T extends ObjectWrapper, U extends new (handle: NativePointer) => T>(Class: U) {
    return new Proxy(Class, {
        cache: new Map(),
        construct(Target: U, argArray: [NativePointer]): T {
            const handle = argArray[0].toUInt32();

            if (!this.cache.has(handle)) {
                this.cache.set(handle, new Target(argArray[0]));
            }
            return this.cache.get(handle)!;
        }
    } as ProxyHandler<U> & { cache: Map<number, T> });
}



================================================
FILE: lib/utils/unity-version.ts
================================================
/** @internal */
namespace UnityVersion {
    const pattern = /(6\d{3}|20\d{2}|\d)\.(\d)\.(\d{1,2})(?:[abcfp]|rc){0,2}\d?/;

    export function find(string: string | null): string | undefined {
        return string?.match(pattern)?.[0];
    }

    export function gte(a: string, b: string): boolean {
        return compare(a, b) >= 0;
    }

    export function lt(a: string, b: string): boolean {
        return compare(a, b) < 0;
    }

    function compare(a: string, b: string): -1 | 0 | 1 {
        const aMatches = a.match(pattern);
        const bMatches = b.match(pattern);

        for (let i = 1; i <= 3; i++) {
            const a = Number(aMatches?.[i] ?? -1);
            const b = Number(bMatches?.[i] ?? -1);

            if (a > b) return 1;
            else if (a < b) return -1;
        }

        return 0;
    }
}



================================================
FILE: test/GameAssembly.cs
================================================
using System;

class Class : Interface
{
    static int sfield;

    int field;

    static Enum enumfield;

    static Class()
    {
        Class.enumfield = Enum.Second;
    }

    unsafe void Method(bool* pointer, ref bool reference, bool[] array)
    {
        Class.sfield++;
        this.field++;
    }

    static void StaticGenericMethod<T, U>(T t, U u)
    {

    }

    class InnerClass
    {
        class InnerInnerClass
        {

        }
    }
}

public class OverloadTest {
    public int a;

    public OverloadTest(int b)
    {
        this.a = b;
    }

    public int A(Child3 instance)
    {
        return 2;
    }

    public int A(Root instance)
    {
        return 0;
    }

    public int A(Child1 instance) 
    {
        return 1;
    }

    public int A(Child4<Root> instance)
    {
        return 4;
    }

    public int A<T>(Child4<Child4<T>> instance)
    {
        return 5;
    }

    public int A(Child41<Child1, Child2> instance)
    {
        return 6;
    }

    public int B(Root a, Child1 b)
    {
        return 0;
    }

    public int B(Child1 a, Root b)
    {
        return 1;
    }

    public int C()
    {
        return 0;
    }

    public int C(int value)
    {
        return value;
    }

    public static int D(Child1 a)
    {
        return 0;
    }

    public int D(Root a)
    {
        return this.a;
    }

    public static int E(Child11 a, Root b)
    {
        return 0;
    }

    public static int E(Root a, Child1 b)
    {
        return 1;
    }

    public class Nested : OverloadTest
    {
        public Nested(int b) : base(b)
        {
        }

        public int A(Child2 instance)
        {
            return 3;
        }

        public new int C()
        {
            return 2;
        }
    }

    public class Root
    {
    }

    public class Child1 : Root
    {
    }

    public class Child11 : Child1
    {
    }

    public class Child2 : Root
    {
    }

    public class Child3 : Root
    {
    }

    public class Child31 : Child3
    {
    }

    public class Child311 : Child31
    {
    }

    public class Child4<T> : Root
    {
    }

    public class Child41<T, U> : Child4<T>
    {
    }
}

abstract class AbstractGenericClass<T, U>
{

}

class PartiallyInflatedClass<T> : AbstractGenericClass<T, String>
{

}

class InflatedClass : AbstractGenericClass<String, String>
{

}

struct Struct
{

}

struct EmptyStruct
{

}

public class Il2CppClassTest
{
    public class HierarchyTest : Il2CppClassTest
    {
    }

    public class GenericsTest : System.Collections.Generic.List<System.Int32>
    {
    }
}

public class Il2CppObjectTest
{
    public static int F;

    public int G;

    public static int A(int a)
    {
        return 0;
    }

    public int A (string a)
    {
        return 1;
    }

    public static int B()
    {
        return 2;
    }

    public static int C(int a)
    {
        return 3;
    }

    public int C()
    {
        return 4;
    }

    public class BaseTest : Il2CppObjectTest {
        public Il2CppObjectTest D()
        {
            return this;
        }
    }

    public class MemberLookupTest : Il2CppObjectTest {
        public new static int G;

        public int H;

        public new static void C()
        {
        }

        public static void D()
        {
        }

        public void D(int a)
        {
        }
    }
}

enum Enum
{
    First,
    Second,
    Third
}

enum LongEnum : ulong
{
    First,
    Second,
    Third
}

enum EmptyEnum
{

}


interface Interface
{

}

namespace MethodInflateTest {
    class Parent<ClassType> {
        static int A<T>() {
            return 0;
        }

        static int A<T, U>() {
            return 1;
        }

        static int B() {
            return 0;
        }

        static int B<T>(T a) {
            return 1;
        }

        static int B<T, U>() {
            return 2;
        }

        static int C(ClassType a) {
            return 0;
        }

        static int C<T>(T a) {
            return 1;
        }

        static int C<T>(String a) {
            return 2;
        }
        
        static int D(ClassType a) {
            return 0;
        }
    }

    class Child : Parent<System.Object> {
        static int A<T, U, V>() {
            return 3;
        }
    }
}



================================================
FILE: test/host.c
================================================
#include <dlfcn.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>

int
main (int argc, char ** argv)
{
  char * path = argv[1];
  char * so = "GameAssembly.so";
  char * data = "Data";

  char * sopath = malloc (strlen (path) + 1 + strlen (so) + 1);
  sprintf (sopath, "%s/%s", path, so);

  char * datapath = malloc (strlen (path) + 1 + strlen (data) + 1);
  sprintf (datapath, "%s/%s", path, data);

  void * handle = dlopen (sopath, RTLD_LAZY);

  if (handle == NULL)
  {
    printf ("Couldn't find shared library at %s\n", sopath);
    return -1;
  }

  free (sopath);

  void (*il2cpp_set_data_dir) (const char *) =
      dlsym (handle, "il2cpp_set_data_dir");

  (*il2cpp_set_data_dir) (datapath);

  free (datapath);

  int (*il2cpp_init) (const char *) = dlsym (handle, "il2cpp_init");

  (*il2cpp_init) ("IL2CPP ROOT DOMAIN");

  int status;
  wait (&status);
}


================================================
FILE: test/main.py
================================================
from sys import exit
from threading import Semaphore
from pathlib import Path
from colorama import Fore, Style
import frida


ROOT = Path(__file__).resolve().parent.parent


class TestRunner:
    AGENT_PATH = ROOT / "test" / "agent" / "dist" / "index.js"

    def __init__(self, build_path: Path) -> None:
        self.lock = Semaphore(0)
        self.unity_version = build_path.name
        self.passed = []
        self.failed = []
        self.host = frida.spawn([str(ROOT / "build" / "host"), str(build_path / "out")])

    def prepare(self) -> None:
        session = frida.attach(self.host)

        self.script = session.create_script(
            source=self.AGENT_PATH.read_text(encoding="utf-8")
            .replace("$UNITY_VERSION", self.unity_version)
            .replace(
                "$SOURCE_MAP_PATH",
                str(self.AGENT_PATH.with_name("index.js.map")),
            ),
            name=self.unity_version,
        )
        self.script.on("message", self.on_message)
        self.script.load()

    def run(self) -> None:
        frida.resume(self.host)
        if not self.lock.acquire(timeout=10):
            self.stop()
            raise RuntimeError(f"Timed out when running tests for {self.unity_version}")

    def stop(self) -> None:
        self.lock.release()
        self.script.unload()
        frida.kill(self.host)

    def on_message(self, message: frida.core.ScriptMessage, _):
        if message["type"] == "send" and (payload := message.get("payload")):
            if "name" in payload:
                if "exception" in payload:
                    self.failed.append(payload)
                else:
                    self.passed.append(payload)
            elif action := payload.get("action"):
                getattr(self, action)()


def main() -> int:
    passed_count = 0
    failed_count = 0

    for build_path in (ROOT / "build").iterdir():
        if not build_path.is_dir():
            continue

        test_runner = TestRunner(build_path=build_path)
        test_runner.prepare()
        print(f"{Fore.BLUE}►{Style.RESET_ALL} {test_runner.unity_version}")
        test_runner.run()

        for passed in test_runner.passed:
            passed_count += 1
            print(f"  {Fore.GREEN}✓ {passed['name']}{Style.RESET_ALL}")
        for failed in test_runner.failed:
            failed_count += 1
            print(
                f"  {Fore.RED}𐄂 {failed['name']}: {str(failed['exception'])}{Style.RESET_ALL}"
            )

    if failed_count > 0:
        print(f"{Fore.RED}𐄂{Style.RESET_ALL} {failed_count} test(s) failed")
        return 1
    else:
        print(f"{Fore.BLUE}✓{Style.RESET_ALL} {passed_count} test(s) passed")
        return 0


if __name__ == "__main__":
    exit(main())



================================================
FILE: test/agent/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "es2022",
    "lib": ["es2022"],
    "moduleResolution": "bundler",
    "outDir": "dist",
    "outFile": "dist/index.js",
    "mapRoot": ".",
    "allowJs": true,
    "strict": true,
    "esModuleInterop": true,
    "declaration": false,
    "experimentalDecorators": true,
    "sourceMap": true,
    "stripInternal": true,
    "removeComments": true,
  },
}



================================================
FILE: test/agent/src/assert.ts
================================================
function test(name: string, block: () => void) {
    try {
        block();
        send({ name: name });
    } catch (exception: any) {
        send({ name: name, exception: exception.stack });
    }
}

function assert(actual: () => any): CallbackAssertion;
function assert<T>(actual: T): ValueAssertion<T>;

function assert<T>(actual: T | (() => any)): T extends () => any ? CallbackAssertion : ValueAssertion<T> {
    return new Assertion(actual) as any;
}

type ValueAssertion<T> = Omit<Assertion<T>, keyof CallbackAssertion>;

type CallbackAssertion = Pick<Assertion<any>, "throws">;

class Assertion<T> {
    constructor(private readonly actual: T | (() => any)) {}

    is(expected: T) {
        if (Array.isArray(expected) && Array.isArray(this.actual)) {
            if (expected.length != this.actual.length) {
                throw new AssertionError(`array length of \x1b[1m${expected.length}\x1b[22m was expected, but is \x1b[1m${this.actual.length}\x1b[22m`);
            }

            for (let i = 0; i < Math.max(expected.length, this.actual.length); i++) {
                if (!eq(expected[i], this.actual[i])) {
                    throw new AssertionError(`(#${i} element) \x1b[1m${expected[i]}\x1b[22m was expected, but got \x1b[1m${this.actual[i]}\x1b[22m`);
                }
            }
        } else if (!eq(expected, this.actual)) {
            throw new AssertionError(`\x1b[1m${expected}\x1b[22m was expected, but got \x1b[1m${this.actual}\x1b[22m`);
        }
    }

    not(unexpected: T | null) {
        if (eq(unexpected, this.actual)) {
            throw new AssertionError(`\x1b[1m${unexpected}\x1b[22m was not expected`);
        }
    }

    throws(expectedMessage: string) {
        try {
            const value = isCallable(this.actual) ? this.actual() : this.actual;
            throw new AssertionError(`error message \x1b[1m${expectedMessage}\x1b[22m was expected, but got value \x1b[1m${value}\x1b[22m`);
        } catch (err: any) {
            if (err instanceof AssertionError) {
                throw err;
            } else {
                assert(err.message.replaceAll(/\x1b\[[^m]+m/g, "")).is(expectedMessage);
            }
        }
    }
}

class AssertionError extends Error {
    constructor(message: string) {
        super(message);
        this.name = "AssertionError";
    }
}

const ANY: any = {};

function eq(a: any, b: any) {
    return a === ANY || b === ANY ? true : a instanceof NativePointer || a instanceof NativeStruct ? a.equals(b) : a == b;
}

const isCallable = <T>(maybeFunction: T | (() => any)): maybeFunction is () => T => typeof maybeFunction === "function";



================================================
FILE: test/agent/src/index.ts
================================================
/// <reference path="../../../lib/index.ts">/>

Script.registerSourceMap("/$UNITY_VERSION.js", new File("$SOURCE_MAP_PATH", "r").readText());

Il2Cpp.perform(() => {
    test("Unity version is detected", () => {
        assert(Il2Cpp.unityVersion).is("$UNITY_VERSION");
    });

    test("Application identifier fallbacks to process name", () => {
        assert(Il2Cpp.application.identifier).is("host");
    });

    test("Application version is detected", () => {
        assert(Il2Cpp.application.version).not(null);
    });

    test("Il2Cpp.Thread::id", () => {
        assert(Il2Cpp.currentThread?.id).is(Process.getCurrentThreadId());
    });

    test("Il2Cpp.Domain::handle", () => {
        assert(Il2Cpp.domain.handle).not(NULL);
    });

    test("Il2Cpp.Domain::assemblies", () => {
        assert(Il2Cpp.domain.assemblies.length > 0).is(true);
    });

    test("Il2Cpp.Domain::object", () => {
        assert(Il2Cpp.domain.object.class).is(Il2Cpp.corlib.class("System.AppDomain"));
    });

    test("Il2Cpp.Domain::tryAssembly", () => {
        assert(Il2Cpp.domain.tryAssembly("mscorlib")).not(null);
        assert(Il2Cpp.domain.tryAssembly("howboring")).is(null);
        assert(Il2Cpp.domain.tryAssembly("GameAssembly")).not(null);
    });

    test("Il2Cpp.Domain::assembly", () => {
        assert(() => Il2Cpp.domain.assembly("howboring")).throws("couldn't find assembly howboring");
    });

    test("Il2Cpp.Assembly::name", () => {
        assert(Il2Cpp.domain.assembly("mscorlib").name).is("mscorlib");
    });

    test("Il2Cpp.Assembly::image", () => {
        assert(Il2Cpp.domain.assembly("mscorlib").image).is(Il2Cpp.corlib);
    });

    test("Il2Cpp.Assembly::object", () => {
        assert(Il2Cpp.domain.assembly("mscorlib").object.class.isSubclassOf(Il2Cpp.corlib.class("System.Reflection.Assembly"), false)).is(true);
    });

    test("Il2Cpp::corlib", () => {
        assert(Il2Cpp.corlib).is(Il2Cpp.domain.assembly("mscorlib").image);
    });

    test("Il2Cpp.Image::name", () => {
        assert(Il2Cpp.corlib.name).is("mscorlib.dll");
    });

    test("Il2Cpp.Image::assembly", () => {
        assert(Il2Cpp.corlib.assembly).is(Il2Cpp.domain.assembly("mscorlib"));
    });

    test("Il2Cpp.Image::tryClass", () => {
        assert(Il2Cpp.corlib.tryClass("System.Boring")).is(null);
        assert(Il2Cpp.corlib.tryClass("System.String")?.handle ?? NULL).not(NULL);
        assert(Il2Cpp.corlib.tryClass("<Module>")?.handle ?? NULL).not(NULL);
        assert(Il2Cpp.corlib.tryClass("System.Collections.Generic.List`1")?.handle ?? NULL).not(NULL);
    });

    test("Il2Cpp.Image::class", () => {
        assert(() => Il2Cpp.corlib.class("System.Boring")).throws("couldn't find class System.Boring in assembly mscorlib.dll");
    });

    test("Il2Cpp.Image::classes", () => {
        assert(Il2Cpp.corlib.classes.length > 0).is(true);
        assert(Il2Cpp.domain.assembly("GameAssembly").image.classes.length > 0).is(true);
    });

    test("Il2Cpp.Image::classCount", () => {
        assert(Il2Cpp.domain.assembly("GameAssembly").image.classes.length).is(32);
        assert(Il2Cpp.domain.assembly("GameAssembly").image.classCount).is(32);
    });

    test("Il2Cpp.Class::image", () => {
        assert(Il2Cpp.corlib.class("System.String").image).is(Il2Cpp.corlib);
    });

    test("Il2Cpp.Class::assemblyName", () => {
        assert(Il2Cpp.corlib.class("System.String").assemblyName).is("mscorlib");
    });

    test("Il2Cpp.Class::actualInstanceSize", () => {
        assert(Il2Cpp.corlib.class("<Module>").actualInstanceSize).is(1);
        assert(Il2Cpp.corlib.class("System.Void").actualInstanceSize).is(Il2Cpp.Object.headerSize);
        assert(Il2Cpp.corlib.class("System.Int32").actualInstanceSize).is(Il2Cpp.Object.headerSize + 4);
    });

    test("Il2Cpp.Class::arrayElementSize", () => {
        assert(Il2Cpp.corlib.class("System.Void").arrayElementSize).is(0);
        assert(Il2Cpp.corlib.class("System.Byte").arrayElementSize).is(1);
        assert(Il2Cpp.corlib.class("System.Int32").arrayElementSize).is(4);
        assert(Il2Cpp.corlib.class("System.String").arrayElementSize).is(8);
    });

    test("Il2Cpp.Class::name", () => {
        assert(Il2Cpp.corlib.class("System.String").name).is("String");
        assert(Il2Cpp.corlib.class("System.Collections.Generic.List`1").name).is("List`1");
    });

    test("Il2Cpp.Class::namespace", () => {
        assert(Il2Cpp.corlib.class("System.String").namespace).is("System");
        assert(Il2Cpp.corlib.class("System.Collections.Generic.List`1").namespace).is("System.Collections.Generic");
        assert(Il2Cpp.corlib.class("<Module>").namespace).is(undefined);
    });

    test("Il2Cpp.Class::fullname", () => {
        assert(Il2Cpp.corlib.class("System.String").fullName).is("System.String");
        assert(Il2Cpp.corlib.class("System.Collections.Generic.List`1").fullName).is("System.Collections.Generic.List`1");
        assert(Il2Cpp.corlib.class("<Module>").fullName).is("<Module>");
    });

    test("Il2Cpp.Class::genericClass", () => {
        const GenericsTest = Il2Cpp.domain.assembly("GameAssembly").image.class("Il2CppClassTest").nested("GenericsTest");
        const List = Il2Cpp.corlib.class("System.Collections.Generic.List`1");

        assert(List.genericClass).is(null);
        assert(List.inflate(Il2Cpp.corlib.class("System.Int32")).genericClass).is(List);
        assert(List.inflate(List).genericClass).is(List);

        assert(GenericsTest.genericClass).is(null);
        assert(GenericsTest.parent!.genericClass).is(List);
    });

    test("Il2Cpp.Class::type", () => {
        assert(Il2Cpp.corlib.class("System.String").type.handle).not(NULL);
    });

    test("Il2Cpp.Class::hierarchy", () => {
        const T = Il2Cpp.domain.assembly("GameAssembly").image.class("Il2CppClassTest").nested("HierarchyTest");

        assert(Array.from(T.hierarchy())).is([T, T.parent!, T.parent!.parent!]);
        assert(Array.from(T.hierarchy({ includeCurrent: true }))).is([T, T.parent!, T.parent!.parent!]);
        assert(Array.from(T.hierarchy({ includeCurrent: false }))).is([T.parent!, T.parent!.parent!]);

        assert(Array.from(T.parent!.hierarchy())).is([T.parent!, T.parent!.parent!]);
        assert(Array.from(T.parent!.parent!.hierarchy())).is([T.parent!.parent!]);
        assert(Array.from(T.parent!.parent!.hierarchy({ includeCurrent: false }))).is([]);
    });

    test("Il2Cpp.Class::isAbstract", () => {
        assert(Il2Cpp.corlib.class("System.String").isAbstract).is(false);
        assert(Il2Cpp.corlib.class("System.IComparable").isAbstract).is(true);
        assert(Il2Cpp.domain.assembly("GameAssembly").image.class("AbstractGenericClass`2").isAbstract).is(true);
        assert(Il2Cpp.domain.assembly("GameAssembly").image.class("PartiallyInflatedClass`1").isAbstract).is(false);
    });

    test("Il2Cpp.Class::isEnum", () => {
        assert(Il2Cpp.corlib.class("System.String").isEnum).is(false);
        assert(Il2Cpp.corlib.class("System.Boolean").isEnum).is(false);
        assert(Il2Cpp.corlib.class("System.DayOfWeek").isEnum).is(true);
    });

    test("Il2Cpp.Class::isValueType", () => {
        assert(Il2Cpp.corlib.class("System.String").isValueType).is(false);
        assert(Il2Cpp.corlib.class("System.Boolean").isValueType).is(true);
        assert(Il2Cpp.corlib.class("System.DayOfWeek").isValueType).is(true);
    });

    test("Il2Cpp.Class::isGeneric", () => {
        assert(Il2Cpp.corlib.class("System.String").isGeneric).is(false);
        assert(Il2Cpp.corlib.class("System.Collections.Generic.List`1").isGeneric).is(true);
    });

    test("Il2Cpp.Class::inflate", () => {
        assert(() => Il2Cpp.corlib.class("System.String").inflate()).throws("cannot inflate class System.String as it has no generic parameters");
        assert(() => Il2Cpp.corlib.class("System.Collections.Generic.List`1").inflate()).throws(
            "cannot inflate class System.Collections.Generic.List<T> as it needs 1 generic parameter(s), not 0"
        );
        assert(Il2Cpp.corlib.class("System.Action`1").inflate(Il2Cpp.corlib.class("System.String")).handle).not(NULL);
    });

    test("Il2Cpp.Class::isInflated", () => {
        assert(Il2Cpp.corlib.class("System.String").isInflated).is(false);
        assert(Il2Cpp.corlib.class("System.Action`1").isInflated).is(false);
        assert(Il2Cpp.corlib.class("System.Action`1").inflate(Il2Cpp.corlib.class("System.String")).isInflated).is(true);
    });

    test("Il2Cpp.Class::isInterface", () => {
        assert(Il2Cpp.corlib.class("System.String").isInterface).is(false);
        assert(Il2Cpp.corlib.class("System.IComparable").isInterface).is(true);
        assert(Il2Cpp.domain.assembly("GameAssembly").image.class("AbstractGenericClass`2").isInterface).is(false);
        assert(Il2Cpp.domain.assembly("GameAssembly").image.class("PartiallyInflatedClass`1").isInterface).is(false);
    });

    test("Il2Cpp.Class::declaringClass", () => {
        assert(Il2Cpp.corlib.class("System.Array").declaringClass).is(null);
        assert(Il2Cpp.corlib.class("System.Threading.Timer").nested("Scheduler").declaringClass).is(Il2Cpp.corlib.class("System.Threading.Timer"));
    });

    test("Il2Cpp.Class::arrayClass", () => {
        assert(Il2Cpp.corlib.class("System.String").arrayClass.name).is("String[]");
        assert(Il2Cpp.corlib.class("System.String").arrayClass.arrayClass.name).is("String[][]");
    });

    test("Il2Cpp.Class::elementClass", () => {
        const Method = Il2Cpp.domain.assembly("GameAssembly").image.class("Class").method("Method");

        assert(Il2Cpp.corlib.class("System.Boolean").arrayClass.elementClass).is(Il2Cpp.corlib.class("System.Boolean"));
        assert(Method.parameter("pointer").type.class.elementClass).is(Il2Cpp.corlib.class("System.Boolean"));
        assert(Method.parameter("reference").type.class.elementClass).is(Il2Cpp.corlib.class("System.Boolean"));
        assert(Method.parameter("array").type.class.elementClass).is(Il2Cpp.corlib.class("System.Boolean"));
    });

    test("Il2Cpp.Class::pointerClass", () => {
        assert(Il2Cpp.corlib.class("System.Void").pointerClass.name).is("Void*");
        assert(Il2Cpp.corlib.class("System.Boolean").pointerClass.name).is("Boolean*");
        assert(Il2Cpp.corlib.class("System.Boolean").pointerClass.pointerClass.name).is("Boolean**");
        assert(Il2Cpp.domain.assembly("GameAssembly").image.class("Class").pointerClass.name).is("Class*");
    });

    test("Pointer class is declared in the same assembly of its base type", () => {
        assert(Il2Cpp.corlib.class("System.Void").pointerClass.image.assembly).is(Il2Cpp.corlib.assembly);
        assert(Il2Cpp.domain.assembly("GameAssembly").image.class("Class").pointerClass.image.assembly).is(Il2Cpp.domain.assembly("GameAssembly"));
    });

    test("Il2Cpp.Class::baseType", () => {
        const Method = Il2Cpp.domain.assembly("GameAssembly").image.class("Class").method("Method");

        assert(Il2Cpp.corlib.class("System.Boolean").baseType).is(null);
        assert(Il2Cpp.corlib.class("System.Boolean").arrayClass.baseType).is(Il2Cpp.corlib.class("System.Boolean").type);
        assert(Il2Cpp.corlib.class("System.Boolean").arrayClass.arrayClass.baseType).is(Il2Cpp.corlib.class("System.Boolean").arrayClass.type);
        assert(Il2Cpp.corlib.class("System.DayOfWeek").baseType).is(Il2Cpp.corlib.class("System.Int32").type);
        assert(Method.parameter("reference").type.class.baseType).is(null);
        assert(Method.parameter("pointer").type.class.baseType).is(Il2Cpp.corlib.class("System.Boolean").type);
        assert(Method.parameter("array").type.class.baseType).is(Il2Cpp.corlib.class("System.Boolean").type);
    });

    test("Il2Cpp.Type::ENUM.VAR is assigned to generic parameters in a generic type definition", () => {
        assert(Il2Cpp.corlib.class("System.Action`1").generics[0].type.enumValue).is(Il2Cpp.Type.Enum.VAR);
        assert(
            Il2Cpp.domain
                .assembly("GameAssembly")
                .image.class("AbstractGenericClass`2")
                .generics.map(_ => _.type.enumValue)
        ).is([Il2Cpp.Type.Enum.VAR, Il2Cpp.Type.Enum.VAR]);
    });

    test("Il2Cpp.Type::ENUM.MVAR is assigned to generic parameters in a generic method definition", () => {
        assert(Il2Cpp.corlib.class("System.Array").method("AsReadOnly").generics[0].type.enumValue).is(Il2Cpp.Type.Enum.MVAR);
        assert(
            Il2Cpp.domain
                .assembly("GameAssembly")
                .image.class("Class")
                .method("StaticGenericMethod")
                .generics.map(_ => _.type.enumValue)
        ).is([Il2Cpp.Type.Enum.MVAR, Il2Cpp.Type.Enum.MVAR]);
    });

    test("Il2Cpp.String::content", () => {
        assert(Il2Cpp.string("vfsfitvnm").content).is("vfsfitvnm");
    });

    test("Il2Cpp.String::length", () => {
        assert(Il2Cpp.string("vfsfitvnm").length).is(9);
    });

    test("setting Il2Cpp.String::content", () => {
        const string = Il2Cpp.string("vfsfitvnm");
        string.content = "frida-il2cpp-bridge";

        assert(string.content).is("frida-il2cpp-bridge");
        assert(string.length).is(19);
    });

    test("Il2Cpp.String::object", () => {
        assert(Il2Cpp.string("vfsfitvnm").object.class).is(Il2Cpp.corlib.class("System.String"));
    });

    test("Il2Cpp.Array::get", () => {
        assert(Il2Cpp.array(Il2Cpp.corlib.class("System.Int32"), [0, -1, 12, 3900, -2442, 99]).get(4)).is(-2442);
    });

    test("Il2Cpp.Array::set", () => {
        const array = Il2Cpp.array<number>(Il2Cpp.corlib.class("System.Int32"), [0, -1, 12, 3900, -2442, 99]);
        array.set(4, 2147483647);

        assert(array.get(4)).is(2147483647);
    });

    test("Il2Cpp.Object::base", () => {
        const T = Il2Cpp.domain.assembly("GameAssembly").image.class("Il2CppObjectTest").nested("BaseTest");
        const instance = T.new();

        assert(instance.method("D").returnType.class).is(T.parent!.type.class);
        assert(instance.class).is(instance.method<Il2Cpp.Object>("D").invoke().class);
        assert(instance.handle).is(instance.method<Il2Cpp.Object>("D").invoke().handle);

        assert(instance.base.class).is(T.parent!.type.class);
        assert(instance.base.base.class).is(T.parent!.parent!.type.class);
        assert(() => instance.base.base.base.class).throws("class System.Object has no parent");
    });

    test("Boxed primiteves are created using the expected types", () => {
        assert(Il2Cpp.boxed(false).class).is(Il2Cpp.corlib.class("System.Boolean"));
        assert(Il2Cpp.boxed(0).class).is(Il2Cpp.corlib.class("System.Int32"));
        assert(Il2Cpp.boxed(NULL).class).is(Il2Cpp.corlib.class("System.IntPtr"));

        assert(Il2Cpp.boxed(0, undefined).class).is(Il2Cpp.corlib.class("System.Int32"));
        assert(Il2Cpp.boxed(0, "int8").class).is(Il2Cpp.corlib.class("System.SByte"));
        assert(Il2Cpp.boxed(0, "int16").class).is(Il2Cpp.corlib.class("System.Int16"));
        assert(Il2Cpp.boxed(0, "int32").class).is(Il2Cpp.corlib.class("System.Int32"));
        assert(Il2Cpp.boxed(0, "int64").class).is(Il2Cpp.corlib.class("System.Int64"));
        assert(Il2Cpp.boxed(0, "uint8").class).is(Il2Cpp.corlib.class("System.Byte"));
        assert(Il2Cpp.boxed(0, "uint16").class).is(Il2Cpp.corlib.class("System.UInt16"));
        assert(Il2Cpp.boxed(0, "uint32").class).is(Il2Cpp.corlib.class("System.UInt32"));
        assert(Il2Cpp.boxed(0, "uint64").class).is(Il2Cpp.corlib.class("System.UInt64"));

        assert(Il2Cpp.boxed(0, "char").class).is(Il2Cpp.corlib.class("System.Char"));

        assert(Il2Cpp.boxed(NULL, undefined).class).is(Il2Cpp.corlib.class("System.IntPtr"));
        assert(Il2Cpp.boxed(NULL, "intptr").class).is(Il2Cpp.corlib.class("System.IntPtr"));
        assert(Il2Cpp.boxed(NULL, "uintptr").class).is(Il2Cpp.corlib.class("System.UIntPtr"));
    });

    test("Boxed primiteves have correct values", () => {
        assert(Il2Cpp.boxed(false).field("m_value").value).is(false);
        assert(Il2Cpp.boxed(true).field("m_value").value).is(true);
        assert(Il2Cpp.boxed(12345).field("m_value").value).is(12345);
        assert(Il2Cpp.boxed(ptr(12345)).field("m_value").value).is(ptr(12345));
    });

    test("Boxed primitives cannot be created if invalid values or types are provided", () => {
        assert(() => Il2Cpp.boxed(0n as any).class).throws("Cannot create boxed primitive using value of type 'bigint'");
        assert(() => Il2Cpp.boxed("something" as any).class).throws("Cannot create boxed primitive using value of type 'string'");

        assert(() => Il2Cpp.boxed(0, "something" as any).class).throws("Unknown primitive type name 'something'");
        assert(() => Il2Cpp.boxed(NULL, "else" as any).class).throws("Unknown primitive type name 'else'");

        assert(() => Il2Cpp.boxed(NULL, "int8" as any).class).throws("expected an integer");
        assert(() => Il2Cpp.boxed(0, "intptr" as any).class).throws("expected a pointer");
    });

    test("Il2Cpp.Object field lookup ignores static fields", () => {
        const T = Il2Cpp.domain.assembly("GameAssembly").image.class("Il2CppObjectTest").nested("MemberLookupTest");

        assert(T.new().tryField("F")).is(undefined);
        assert(() => T.new().field("F")).throws("couldn't find non-static field F in hierarchy of class Il2CppObjectTest.MemberLookupTest");

        assert(T.new().tryField("H")).not(undefined);
        assert(T.new().tryField("G")?.isStatic).is(false);
    });

    test("Il2Cpp.Object method lookup ignores static methods", () => {
        const T = Il2Cpp.domain.assembly("GameAssembly").image.class("Il2CppObjectTest");

        assert(T.new().tryMethod("A")).not(undefined);
        assert(T.new().tryMethod("B")).is(undefined);
        assert(T.new().tryMethod("C", 1)).is(undefined);
        assert(T.new().tryMethod("C")).not(undefined);
        assert(T.new().tryMethod("C", 0)).not(undefined);

        assert(T.new().method("A").invoke(NULL)).is(1);
        assert(() => T.new().method("B")).throws("couldn't find non-static method B in hierarchy of class Il2CppObjectTest");

        assert(T.nested("MemberLookupTest").new().tryMethod("C")?.isStatic).is(false);
        assert(T.nested("MemberLookupTest").new().tryMethod("D")?.isStatic).is(false);
    });

    test("Every enum base type matches its 'value__' field type", () => {
        Il2Cpp.domain.assemblies.forEach(_ => {
            _.image.classes
                .filter(_ => _.isEnum)
                .forEach(_ => {
                    assert(_.baseType?.name).is(_.field("value__").type.name);
                });
        });
    });

    test("Structs fields are read correctly", () => {
        const runtimeTypeHandle = Il2Cpp.corlib.class("System.RuntimeTypeHandle").alloc();
        runtimeTypeHandle.method(".ctor").invoke(ptr(0xdeadbeef));

        assert(runtimeTypeHandle.unbox().field("value").value).is(ptr(0xdeadbeef));
    });

    test("Enums fields are read correctly", () => {
        assert(Il2Cpp.corlib.class("System.DayOfWeek").field<Il2Cpp.ValueType>("Saturday").value.field("value__").value).is(6);
    });

    test("Boxed structs fields are read correctly", () => {
        const runtimeTypeHandle = Il2Cpp.corlib.class("System.RuntimeTypeHandle").alloc();
        runtimeTypeHandle.method(".ctor").invoke(ptr(0xdeadbeef));

        assert(runtimeTypeHandle.field("value").value).is(ptr(0xdeadbeef));
    });

    test("Boxed structs methods are invoked correctly", () => {
        const runtimeTypeHandle = Il2Cpp.corlib.class("System.RuntimeTypeHandle").alloc();
        runtimeTypeHandle.method(".ctor").invoke(ptr(0xdeadbeef));

        assert(runtimeTypeHandle.handle.add(runtimeTypeHandle.field("value").offset).readPointer()).is(ptr(0xdeadbeef));
        assert(runtimeTypeHandle.method("get_Value").invoke()).is(ptr(0xdeadbeef));
        assert(Il2Cpp.corlib.class("System.RuntimeTypeHandle").alloc().toString()).is("System.RuntimeTypeHandle");
    });

    test("Structs methods are invoked correctly", () => {
        const runtimeTypeHandle = Il2Cpp.corlib.class("System.RuntimeTypeHandle").alloc().unbox();
        runtimeTypeHandle.method(".ctor").invoke(ptr(0xdeadbeef));

        assert(runtimeTypeHandle.method("get_Value").invoke()).is(ptr(0xdeadbeef));
        assert(Il2Cpp.corlib.class("System.RuntimeTypeHandle").alloc().toString()).is("System.RuntimeTypeHandle");
    });

    test("Boxing/unboxing structs works correctly", () => {
        const runtimeTypeHandle = Il2Cpp.corlib.class("System.RuntimeTypeHandle").alloc();
        runtimeTypeHandle.method(".ctor").invoke(ptr(0xdeadbeef));

        assert(runtimeTypeHandle.unbox().box().unbox().box().field("value").value).is(ptr(0xdeadbeef));
    });

    test("Boxed enums fields are read correctly", () => {
        assert(Il2Cpp.corlib.class("System.Reflection.MemberTypes").field<Il2Cpp.ValueType>("Constructor").value.box().field("value__").value).is(1);
    });

    test("Il2Cpp.Field::value::get (static)", () => {
        assert(Il2Cpp.corlib.class("System.Type").initialize().field("Delimiter").value).is(46);
        assert(Il2Cpp.domain.assembly("GameAssembly").image.class("Class").initialize().field("enumfield").value.toString()).is("Second");
        assert(Il2Cpp.corlib.class("System.Decimal").initialize().field("MaxValue").value.toString()).is("79228162514264337593543950335");
        assert(Il2Cpp.corlib.class("System.Boolean").initialize().field<Il2Cpp.String>("TrueString").value.content).is("True");
    });

    test("Il2Cpp.Field::value::set (static)", () => {
        const SystemType = Il2Cpp.corlib.class("System.Type").initialize();
        SystemType.field("Delimiter").value = 48;

        assert(SystemType.field("Delimiter").value).is(48);

        {
            const value = SystemType.field("Delimiter").type.class.alloc();
            value.field("m_value").value = 32;
            SystemType.field("Delimiter").value = value;

            assert(SystemType.field("Delimiter").value).is(32);
        }
        {
            const Class = Il2Cpp.domain.assembly("GameAssembly").image.class("Class");
            Class.field("enumfield").value = Class.field("enumfield").type.class.field("Third").value;

            assert(Class.field("enumfield").value.toString()).is("Third");
        }
        {
            const SystemDecimal = Il2Cpp.corlib.class("System.Decimal").initialize();
            const value = SystemDecimal.alloc();
            value.method(".ctor", 1).invoke(123456);
            SystemDecimal.field("MaxValue").value = value;

            assert(SystemDecimal.field("MaxValue").value.toString()).is("123456");
        }
        {
            const SystemBoolean = Il2Cpp.corlib.class("System.Boolean").initialize();
            SystemBoolean.field("TrueString").value = Il2Cpp.string("VeryTrue");

            assert(SystemBoolean.field<Il2Cpp.String>("TrueString").value.content).is("VeryTrue");
        }
    });

    test("Invoke a method that returns an enum value", () => {
        assert(Il2Cpp.corlib.class("System.Environment").method("get_Platform").invoke()?.toString()).is("Unix");
    });

    test("Invoke a method that takes an enum value", () => {
        const DateTimeFormatInfo = Il2Cpp.corlib.class("System.Globalization.DateTimeFormatInfo").initialize();
        const DayOfWeek = Il2Cpp.corlib.class("System.DayOfWeek");

        assert(DateTimeFormatInfo.new().method<Il2Cpp.String>("GetDayName").invoke(DayOfWeek.field("Sunday").value).content).is("Sunday");
    });

    test("References to value types are created correctly", () => {
        const Decimal = Il2Cpp.corlib.class("System.Decimal").initialize();

        const x = Decimal.alloc().unbox();
        const y = Decimal.alloc().unbox();

        x.method(".ctor").overload("System.Int32").invoke(-1234);
        y.method(".ctor").overload("System.Int32").invoke(777);

        const xRef = Il2Cpp.reference(x);

        assert(xRef.handle.add(Decimal.field("lo").offset - Il2Cpp.Object.headerSize).readInt()).is(1234);

        const Compare = Decimal.tryMethod("FCallCompare") ?? Decimal.tryMethod("decimalCompare");

        assert(Compare ? Compare.invoke(xRef, Il2Cpp.reference(y)) : Decimal.method("Sign").invoke(xRef)).is(-1);
    });

    test("Methods are selected by generic parameter count when inflating", () => {
        const Test = Il2Cpp.domain.assembly("GameAssembly").image.class("MethodInflateTest.Parent`1").inflate(Il2Cpp.corlib.class("System.Object"));

        assert(Test.method("A").inflate(Test).invoke()).is(0);
        assert(Test.method("A").inflate(Test, Test).invoke()).is(1);

        assert(Test.method("B").inflate(Test).invoke(NULL)).is(1);
        assert(Test.method("B").inflate(Test, Test).invoke()).is(2);

        assert(Test.method("C").invoke(NULL)).is(0);
        assert(Test.method("C").inflate(Test).invoke(NULL)).is(1);

        assert(() => Test.method("D").inflate(Test)).throws("could not find inflatable signature of method D with 1 generic parameter(s)");
        assert(() => Test.method("C").inflate(Test, Test)).throws("could not find inflatable signature of method C with 2 generic parameter(s)");
    });

    test("Methods are looked up in parent class when inflating", () => {
        const Test = Il2Cpp.domain.assembly("GameAssembly").image.class("MethodInflateTest.Child");

        assert(Test.method("A").inflate(Test).invoke()).is(0);
        assert(Test.method("B").inflate(Test).invoke(NULL)).is(1);

        assert(Test.method("A").inflate(Test, Test, Test).invoke()).is(3);
    });

    test("Overloading selection picks the correct method", () => {
        const T = Il2Cpp.domain.assembly("GameAssembly").image.class("OverloadTest");

        assert(() => T.new().method("A").overload("A", "B")).throws("couldn't find overloaded method A(A,B)");
        assert(T.new().method("A").overload("OverloadTest.Root").invoke(NULL)).is(0);
        assert(T.new().method("A").overload("OverloadTest.Child1").invoke(NULL)).is(1);
        assert(T.new().method("A").tryOverload("OverloadTest.Child11")).is(undefined);
        assert(T.new().method("A").tryOverload("OverloadTest.Child2")).is(undefined);
        assert(T.new().method("A").overload("OverloadTest.Child3").invoke(NULL)).is(2);
        assert(T.new().method("A").overload("OverloadTest.Child4<OverloadTest.Root>").invoke(NULL)).is(4);
        assert(T.new().method("A").tryOverload("OverloadTest.Child4<T>")).is(undefined);
        assert(T.new().method("A").tryOverload("OverloadTest.Child4<OverloadTest.Child1>")).is(undefined);
    });

    test("Overloading selection looks in parent class", () => {
        const T = Il2Cpp.domain.assembly("GameAssembly").image.class("OverloadTest").nested("Nested");

        assert(T.new().method("C").overload().invoke()).is(2);
        assert(T.new().method("C").overload("System.Int32").invoke(-1)).is(-1);
    });

    test("Overloading selection by type picks the most precise method possible", () => {
        const T = Il2Cpp.domain.assembly("GameAssembly").image.class("OverloadTest");

        assert(T.new().method("A").overload(T.nested("Root")).invoke(NULL)).is(0);
        assert(T.new().method("A").overload(T.nested("Child1")).invoke(NULL)).is(1);
        assert(T.new().method("A").overload(T.nested("Child11")).invoke(NULL)).is(1);
        assert(T.new().method("A").overload(T.nested("Child2")).invoke(NULL)).is(0);
        assert(T.new().method("A").overload(T.nested("Child3")).invoke(NULL)).is(2);
        assert(T.nested("Nested").new().method("A").overload(T.nested("Child2")).invoke(NULL)).is(3);
        assert(T.nested("Nested").new().method("A").overload(T.nested("Child3")).invoke(NULL)).is(2);
        assert(T.nested("Nested").new().method("A").overload(T.nested("Child311")).invoke(NULL)).is(2);

        assert(T.method("E").overload(T.nested("Child1"), T.nested("Child11")).invoke(NULL, NULL)).is(1);
        assert(T.method("E").overload(T.nested("Child11"), T.nested("Child1")).invoke(NULL, NULL)).is(ANY);
        assert(T.method("E").overload(T.nested("Child11"), T.nested("Child11")).invoke(NULL, NULL)).is(ANY);
        assert(T.method("E").tryOverload(T.nested("Child1"), T.nested("Root"))).is(undefined);
    });

    test("Overloading instance methods do not select static methods", () => {
        const T = Il2Cpp.domain.assembly("GameAssembly").image.class("OverloadTest");

        assert(T.method("D").tryOverload("OverloadTest.Child1")).not(undefined);
        assert(T.new().method("D").tryOverload("OverloadTest.Child1")).is(undefined);
        assert(T.method("D").tryOverload("OverloadTest.Rooat")).is(undefined);
        assert(T.new().method("D").tryOverload("OverloadTest.Rot")).is(undefined);
        assert(T.method("D").overload("OverloadTest.Root").isStatic).is(false);
        assert(() => T.method("D").overload("OverloadTest.Rooat")).throws("couldn't find overloaded method D(OverloadTest.Rooat)");
        assert(() => T.new().method("D").overload("OverloadTest.Rot")).throws("couldn't find overloaded method D(OverloadTest.Rot)");
    });
}).then(() => send({ action: "stop" }));



================================================
FILE: unity/common.mk
================================================
MAKEFLAGS += --no-builtin-rules

VER_GTE = $(shell printf '%s\n' "$2" "$1" | sort -C -V && echo YES || echo NO)

THIS_DIR := $(shell dirname $(realpath $(firstword $(MAKEFILE_LIST))))
ROOT_DIR := $(shell realpath $(THIS_DIR)/../..)
UNITY_VERSION := $(shell basename $(THIS_DIR))
BUILD_DIR = $(ROOT_DIR)/build/$(UNITY_VERSION)
EDITOR_DIR = $(THIS_DIR)/Editor

MONO_DIR = $(EDITOR_DIR)/Data/Mono
MONOBL_DIR = $(EDITOR_DIR)/Data/MonoBleedingEdge
IL2CPP_DIR = $(EDITOR_DIR)/Data/il2cpp

MONO := $(MAYBE_STRACE) $(MONOBL_DIR)/bin/mono
MCS := $(MONO) $(MONOBL_DIR)/lib/mono/4.5/mcs.exe

LINKER_DESCRIPTORS_DIR := $(IL2CPP_DIR)/LinkerDescriptors

ifeq "$(call VER_GTE,$(UNITY_VERSION),2019.1.0f1)" "YES"
GENERATED_CPP_FILENAME := %
else
GENERATED_CPP_FILENAME := Bulk_%_0
endif

ASSEMBLY_TARGET := $(BUILD_DIR)/out/%.so
CPP_TARGET := $(BUILD_DIR)/cpp/$(GENERATED_CPP_FILENAME).cpp
LINKED_DLL_TARGET := $(BUILD_DIR)/linked/%.dll
DLL_TARGET := $(BUILD_DIR)/dll/%.dll
CS_SRC := $(ROOT_DIR)/test/%.cs

ECHO := echo -e "\e[1;34m$(UNITY_VERSION)\e[0m ►"
CURL := curl -L -s -A "" --fail

$(ASSEMBLY_TARGET): $(CPP_TARGET)
	@ $(ECHO) compiling $(<F)
	@ $(ASSEMBLY_TARGET_CMD)
	@ strip "$@"

$(CPP_TARGET): $(LINKED_DLL_TARGET)
	@ $(ECHO) generating $(@F)
	@ $(CPP_TARGET_CMD)

$(LINKED_DLL_TARGET): $(DLL_TARGET)
	@ $(ECHO) linking $(<F)
	@ $(LINKED_DLL_TARGET_CMD)
	@ touch "$@"

$(DLL_TARGET): $(CS_SRC) $(EDITOR_DIR) $(BUILD_DIR)
	@ $(ECHO) compiling $(<F)
	@ mkdir -p "$(@D)"
	@ $(DLL_TARGET_CMD)

$(BUILD_DIR):
	@ mkdir -p "$@"

ifdef UNITY_CHANGESET
$(EDITOR_DIR):
	@ $(ECHO) downloading editor...
	@ $(CURL) https://netstorage.unity3d.com/unity/$(UNITY_CHANGESET)/LinuxEditorInstaller/Unity.tar.xz -O

	@ $(ECHO) extracting editor...
	@ tar -xf Unity.tar.xz
	@ touch -m Editor

	@ rm Unity.tar.xz

ifeq "$(call VER_GTE,$(UNITY_VERSION),2019.4.0f1)" "YES"
	@ $(ECHO) downloading editor support...
	@ $(CURL) https://download.unity3d.com/download_unity/$(UNITY_CHANGESET)/LinuxEditorTargetInstaller/UnitySetup-Linux-IL2CPP-Support-for-Editor-$(UNITY_VERSION).tar.xz -o Support.tar.xz

	@ $(ECHO) extracting editor support...
	@ tar -xf Support.tar.xz
	@ touch -m Editor
	
	@ rm Support.tar.xz
endif
endif

DLL_TARGET_CMD ?= $(MCS) \
	-target:library \
	-nologo \
	-noconfig \
	-unsafe \
	-out:"$@" \
	"$<"

.PHONY: assembly
assembly: $(BUILD_DIR)/out/GameAssembly.so

# USED_FILE_LIST := $(BUILD_DIR)/filelist.txt
# .PHONY: minimalize
# minimalize: MAYBE_STRACE := strace -z -o "$(BUILD_DIR)/filelist.txt" -A -e trace=file
# minimalize: | clean assembly
# 	@ grep -oP '$(EDITOR_DIR)/[^"]+' "$(USED_FILE_LIST)" | sort -u | sed -E 's#/+#/#g' > "$(USED_FILE_LIST).sorted"
# 	@ find "$(EDITOR_DIR)" -type f -not -path "$(EDITOR_DIR)/Data/il2cpp/*" -print0 | grep -zFxvf "$(USED_FILE_LIST).sorted" | xargs -0 rm
# 	@ find "$(EDITOR_DIR)" -type d -empty -delete

.PHONY: clean
clean:
	@ rm -rf "$(BUILD_DIR)"

.SECONDARY:



================================================
FILE: unity/2017.4.40f1/Makefile
================================================
UNITY_CHANGESET := 6e14067f8a9a

include ../common.mk

UNITY_LINKER := $(MONO) $(IL2CPP_DIR)/build/UnityLinker.exe
IL2CPP := $(MONO) $(IL2CPP_DIR)/build/il2cpp.exe

MSCORLIB := $(MONO_DIR)/lib/mono/2.0/mscorlib.dll

export TERM = xterm

ASSEMBLY_TARGET_CMD = $(IL2CPP) \
	--compile-cpp \
	--libil2cpp-static \
	--configuration=Release \
	--platform=Linux \
	--architecture=x64 \
	--dotnetprofile=net20 \
	--cachedirectory="$(@D)/../buildstate" \
	--generatedcppdir="$(<D)" \
	--outputpath="$@"

CPP_TARGET_CMD = $(IL2CPP) \
	--convert-to-cpp \
	--emit-null-checks \
	--enable-array-bounds-check \
	--copy-level=None \
	--dotnetprofile=net20 \
	--directory="$(<D)" \
	--generatedcppdir="$(@D)"

LINKED_DLL_TARGET_CMD = $(UNITY_LINKER) \
	--i18n=none \
	--disable-keep-facades \
	--core-action=link \
	--descriptor-directory="$(LINKER_DESCRIPTORS_DIR)" \
	--include-assembly="$<,$(MSCORLIB)" \
	--out="$(@D)"



================================================
FILE: unity/2018.3.0f1/Makefile
================================================
UNITY_CHANGESET := 6e9a27477296

include ../common.mk

UNITY_LINKER := $(MONO) $(IL2CPP_DIR)/build/UnityLinker.exe
IL2CPP := $(MONO) $(IL2CPP_DIR)/build/il2cpp.exe

MSCORLIB := $(MONO_DIR)/lib/mono/2.0/mscorlib.dll

export TERM = xterm

ASSEMBLY_TARGET_CMD = $(IL2CPP) \
	--compile-cpp \
	--libil2cpp-static \
	--configuration=Release \
	--platform=Linux \
	--architecture=x64 \
	--dotnetprofile=net20 \
	--cachedirectory="$(@D)/../buildstate" \
	--generatedcppdir="$(<D)" \
	--outputpath="$@"

CPP_TARGET_CMD = $(IL2CPP) \
	--convert-to-cpp \
	--emit-null-checks \
	--enable-array-bounds-check \
	--copy-level=None \
	--dotnetprofile=net20 \
	--directory="$(<D)" \
	--generatedcppdir="$(@D)"

LINKED_DLL_TARGET_CMD = $(UNITY_LINKER) \
	--i18n=none \
	--disable-keep-facades \
	--core-action=link \
	--dotnetruntime=il2cpp \
	--dotnetprofile=net20 \
	--descriptor-directory="$(LINKER_DESCRIPTORS_DIR)" \
	--include-assembly="$<,$(MSCORLIB)" \
	--out="$(@D)"



================================================
FILE: unity/2019.3.0f1/Makefile
================================================
UNITY_CHANGESET := ffacea4b84e7

include ../common.mk

UNITY_LINKER := $(MONO) $(IL2CPP_DIR)/build/deploy/net471/UnityLinker.exe
IL2CPP := $(MONO) $(IL2CPP_DIR)/build/deploy/net471/il2cpp.exe

MSCORLIB := $(MONOBL_DIR)/lib/mono/unityaot/mscorlib.dll

export TERM = xterm

ASSEMBLY_TARGET_CMD = $(IL2CPP) \
	--compile-cpp \
	--libil2cpp-static \
	--configuration=Release \
	--platform=Linux \
	--architecture=x64 \
	--dotnetprofile=unityaot \
	--cachedirectory="$(@D)/../buildstate" \
	--generatedcppdir="$(<D)" \
	--outputpath="$@"

CPP_TARGET_CMD = $(IL2CPP) \
	--convert-to-cpp \
	--emit-null-checks \
	--enable-array-bounds-check \
	--copy-level=None \
	--dotnetprofile=unityaot \
	--directory="$(<D)" \
	--generatedcppdir="$(@D)"

LINKED_DLL_TARGET_CMD = $(UNITY_LINKER) \
	--i18n=none \
	--silent \
	--core-action=link \
	--strip-security \
	--rule-set=aggressive \
	--dotnetruntime=il2cpp \
	--dotnetprofile=unityaot \
	--descriptor-directory="$(LINKER_DESCRIPTORS_DIR)" \
	--include-assembly="$<,$(MSCORLIB)" \
	--out="$(@D)"



================================================
FILE: unity/2021.2.0f1/Makefile
================================================
UNITY_CHANGESET := 4bf1ec4b23c9

include ../common.mk

UNITY_LINKER := $(MAYBE_STRACE) $(IL2CPP_DIR)/build/deploy/UnityLinker
IL2CPP := $(MAYBE_STRACE) $(IL2CPP_DIR)/build/deploy/il2cpp

MSCORLIB := $(MONOBL_DIR)/lib/mono/unityaot-linux/mscorlib.dll

ASSEMBLY_TARGET_CMD = $(IL2CPP) \
	--compile-cpp \
	--libil2cpp-static \
	--configuration=Release \
	--platform=Linux \
	--architecture=x64 \
	--dotnetprofile=unityaot-linux \
	--cachedirectory="$(@D)/.." \
	--generatedcppdir="$(<D)" \
	--baselib-directory="$(EDITOR_DIR)/Data/PlaybackEngines/LinuxStandaloneSupport/Variations/linux64_player_nondevelopment_il2cpp/" \
	--outputpath="$@"

CPP_TARGET_CMD = $(IL2CPP) \
	--convert-to-cpp \
	--emit-null-checks \
	--enable-array-bounds-check \
	--dotnetprofile=unityaot-linux \
	--copy-level=None \
	--directory="$(<D)" \
	--generatedcppdir="$(@D)"

LINKED_DLL_TARGET_CMD = $(UNITY_LINKER) \
	--silent \
	--i18n=none \
	--core-action=link \
	--strip-security \
	--rule-set=aggressive \
	--dotnetruntime=il2cpp \
	--dotnetprofile=unityaot-linux \
	--descriptor-directory="$(LINKER_DESCRIPTORS_DIR)" \
	--include-assembly="$<,$(MSCORLIB)" \
	--out="$(@D)"



================================================
FILE: unity/2023.2.20f1/Makefile
================================================
UNITY_CHANGESET := 0e25a174756c

include ../common.mk

UNITY_LINKER := $(MAYBE_STRACE) $(IL2CPP_DIR)/build/deploy/UnityLinker
IL2CPP := $(MAYBE_STRACE) $(IL2CPP_DIR)/build/deploy/il2cpp

MSCORLIB := $(MONOBL_DIR)/lib/mono/unityaot-linux/mscorlib.dll

ASSEMBLY_TARGET_CMD = $(IL2CPP) \
	--compile-cpp \
	--libil2cpp-static \
	--configuration=Release \
	--platform=Linux \
	--architecture=x64 \
	--dotnetprofile=unityaot-linux \
	--cachedirectory="$(@D)/.." \
	--generatedcppdir="$(<D)" \
	--baselib-directory="$(EDITOR_DIR)/Data/PlaybackEngines/LinuxStandaloneSupport/Variations/linux64_player_nondevelopment_il2cpp/" \
	--outputpath="$@"

CPP_TARGET_CMD = $(IL2CPP) \
	--convert-to-cpp \
	--emit-null-checks \
	--enable-array-bounds-check \
	--dotnetprofile=unityaot-linux \
	--copy-level=None \
	--directory="$(<D)" \
	--generatedcppdir="$(@D)"

LINKED_DLL_TARGET_CMD = $(UNITY_LINKER) \
	--silent \
	--i18n=none \
	--core-action=link \
	--strip-security \
	--rule-set=aggressive \
	--dotnetruntime=il2cpp \
	--dotnetprofile=unityaot-linux \
	--descriptor-directory="$(LINKER_DESCRIPTORS_DIR)" \
	--include-assembly="$<,$(MSCORLIB)" \
	--out="$(@D)"



================================================
FILE: unity/5.3.5f1/Makefile
================================================
include ../common.mk

UNITY_LINKER := $(MONO) $(EDITOR_DIR)/Data/Tools/UnusedBytecodeStripper.exe
IL2CPP := $(MONO) $(IL2CPP_DIR)/build/il2cpp.exe

MSCORLIB := $(MONO_DIR)/lib/mono/2.0/mscorlib.dll

export TERM = xterm

ASSEMBLY_TARGET_CMD = $(IL2CPP) \
	--compile-cpp \
	--libil2cpp-static \
	--configuration=Release \
	--platform=Linux \
	--architecture=x64 \
	--dotnetprofile=net20 \
	--cachedirectory="$(@D)/.." \
	--generatedcppdir="$(<D)" \
	--outputpath="$@"

CPP_TARGET_CMD = $(IL2CPP) \
	--convert-to-cpp \
	--emit-null-checks \
	--enable-array-bounds-check \
	--copy-level=None \
	--dotnetprofile=net20 \
	--assembly="$^" \
	--generatedcppdir="$(@D)"

LINKED_DLL_TARGET_CMD = $(UNITY_LINKER) \
	-l none \
	-b false \
	-c link \
	-x "$(LINKER_DESCRIPTORS_DIR)/mscorlib.xml" \
	-a "$(MSCORLIB)" \
	-a "$<" \
	-out "$(@D)"

$(EDITOR_DIR):
	@ $(ECHO) downloading editor...
	@ curl -L -s -A "" --fail "http://download.unity3d.com/download_unity/linux/unity-editor-5.3.5f1+20160525_amd64.deb" -o editor.deb

	@ $(ECHO) extracting editor...
	@ ar x editor.deb
	@ tar -xf data.tar.gz --strip-components=3 --exclude="usr*" --exclude="opt/Unity/MonoDevelop*"

	@ ar t editor.deb | xargs rm
	@ rm editor.deb
	@ touch -m Editor



================================================
FILE: unity/6000.1.0f1/Makefile
================================================
UNITY_CHANGESET := 9ea152932a88

include ../common.mk

UNITY_LINKER := $(MAYBE_STRACE) $(IL2CPP_DIR)/build/deploy/UnityLinker
IL2CPP := $(MAYBE_STRACE) $(IL2CPP_DIR)/build/deploy/il2cpp

MSCORLIB := $(MONOBL_DIR)/lib/mono/unityaot-linux/mscorlib.dll

ASSEMBLY_TARGET_CMD = $(IL2CPP) \
	--compile-cpp \
	--libil2cpp-static \
	--configuration=Release \
	--platform=Linux \
	--architecture=x64 \
	--dotnetprofile=unityaot-linux \
	--cachedirectory="$(@D)/.." \
	--generatedcppdir="$(<D)" \
	--baselib-directory="$(EDITOR_DIR)/Data/PlaybackEngines/LinuxStandaloneSupport/Variations/linux64_player_development_il2cpp/" \
	--outputpath="$@"

CPP_TARGET_CMD = $(IL2CPP) \
	--convert-to-cpp \
	--emit-null-checks \
	--enable-array-bounds-check \
	--dotnetprofile=unityaot-linux \
	--copy-level=None \
	--directory="$(<D)" \
	--generatedcppdir="$(@D)"

LINKED_DLL_TARGET_CMD = $(UNITY_LINKER) \
	--silent \
	--i18n=none \
	--core-action=link \
	--strip-security \
	--rule-set=aggressive \
	--dotnetruntime=il2cpp \
	--dotnetprofile=unityaot-linux \
	--descriptor-directory="$(LINKER_DESCRIPTORS_DIR)" \
	--include-assembly="$<,$(MSCORLIB)" \
	--out="$(@D)"


