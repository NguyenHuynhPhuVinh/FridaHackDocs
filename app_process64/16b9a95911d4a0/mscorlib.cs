class <Module>
{
}

class Interop
{
    static /*0x30f40a8*/ void ThrowExceptionForIoErrno(Interop.ErrorInfo errorInfo, string path, bool isDirectory, System.Func<Interop.ErrorInfo, Interop.ErrorInfo> errorRewriter);
    static /*0x30f45f8*/ long CheckIo(long result, string path, bool isDirectory, System.Func<Interop.ErrorInfo, Interop.ErrorInfo> errorRewriter);
    static /*0x30f46e0*/ int CheckIo(int result, string path, bool isDirectory, System.Func<Interop.ErrorInfo, Interop.ErrorInfo> errorRewriter);
    static /*0x30f410c*/ System.Exception GetExceptionForIoErrno(Interop.ErrorInfo errorInfo, string path, bool isDirectory);
    static /*0x30f476c*/ System.Exception GetIOException(Interop.ErrorInfo errorInfo);
    static /*0x30f48c0*/ void GetRandomBytes(byte* buffer, int length);

    enum Error
    {
        SUCCESS = 0,
        E2BIG = 65537,
        EACCES = 65538,
        EADDRINUSE = 65539,
        EADDRNOTAVAIL = 65540,
        EAFNOSUPPORT = 65541,
        EAGAIN = 65542,
        EALREADY = 65543,
        EBADF = 65544,
        EBADMSG = 65545,
        EBUSY = 65546,
        ECANCELED = 65547,
        ECHILD = 65548,
        ECONNABORTED = 65549,
        ECONNREFUSED = 65550,
        ECONNRESET = 65551,
        EDEADLK = 65552,
        EDESTADDRREQ = 65553,
        EDOM = 65554,
        EDQUOT = 65555,
        EEXIST = 65556,
        EFAULT = 65557,
        EFBIG = 65558,
        EHOSTUNREACH = 65559,
        EIDRM = 65560,
        EILSEQ = 65561,
        EINPROGRESS = 65562,
        EINTR = 65563,
        EINVAL = 65564,
        EIO = 65565,
        EISCONN = 65566,
        EISDIR = 65567,
        ELOOP = 65568,
        EMFILE = 65569,
        EMLINK = 65570,
        EMSGSIZE = 65571,
        EMULTIHOP = 65572,
        ENAMETOOLONG = 65573,
        ENETDOWN = 65574,
        ENETRESET = 65575,
        ENETUNREACH = 65576,
        ENFILE = 65577,
        ENOBUFS = 65578,
        ENODEV = 65580,
        ENOENT = 65581,
        ENOEXEC = 65582,
        ENOLCK = 65583,
        ENOLINK = 65584,
        ENOMEM = 65585,
        ENOMSG = 65586,
        ENOPROTOOPT = 65587,
        ENOSPC = 65588,
        ENOSYS = 65591,
        ENOTCONN = 65592,
        ENOTDIR = 65593,
        ENOTEMPTY = 65594,
        ENOTSOCK = 65596,
        ENOTSUP = 65597,
        ENOTTY = 65598,
        ENXIO = 65599,
        EOVERFLOW = 65600,
        EPERM = 65602,
        EPIPE = 65603,
        EPROTO = 65604,
        EPROTONOSUPPORT = 65605,
        EPROTOTYPE = 65606,
        ERANGE = 65607,
        EROFS = 65608,
        ESPIPE = 65609,
        ESRCH = 65610,
        ESTALE = 65611,
        ETIMEDOUT = 65613,
        ETXTBSY = 65614,
        EXDEV = 65615,
        ESOCKTNOSUPPORT = 65630,
        EPFNOSUPPORT = 65632,
        ESHUTDOWN = 65644,
        EHOSTDOWN = 65648,
        ENODATA = 65649,
        EOPNOTSUPP = 65597,
        EWOULDBLOCK = 65542,
    }

    struct ErrorInfo
    {
        /*0x10*/ Interop.Error _error;
        /*0x14*/ int _rawErrno;

        /*0x30f4928*/ ErrorInfo(int errno);
        /*0x30f4994*/ ErrorInfo(Interop.Error error);
        /*0x30f49a0*/ Interop.Error get_Error();
        /*0x30f47f0*/ int get_RawErrno();
        /*0x30f485c*/ string GetErrorMessage();
        /*0x30f4aa8*/ string ToString();
    }

    class Sys
    {
        static /*0x0*/ bool CanSetHiddenFlag;

        static /*0x30f5568*/ Sys();
        static /*0x30f4678*/ Interop.ErrorInfo GetLastErrorInfo();
        static /*0x30f49ac*/ string StrError(int platformErrno);
        static /*0x30f4990*/ Interop.Error ConvertErrorPlatformToPal(int platformErrno);
        static /*0x30f49a8*/ int ConvertErrorPalToPlatform(Interop.Error error);
        static /*0x30f4b68*/ byte* StrErrorR(int platformErrno, byte* buffer, int bufferSize);
        static /*0x30f4924*/ void GetNonCryptographicallySecureRandomBytes(byte* buffer, int length);
        static /*0x30f4b6c*/ nint OpenDir(string path);
        static /*0x30f4ba0*/ int GetReadDirRBufferSize();
        static /*0x30f4ba4*/ int ReadDirR(nint dir, byte* buffer, int bufferSize, ref Interop.Sys.DirectoryEntry outputEntry);
        static /*0x30f4ba8*/ int CloseDir(nint dir);
        static /*0x30f4bc4*/ int ReadLink(string path, byte[] buffer, int bufferSize);
        static /*0x30f4c10*/ string ReadLink(string path);
        static /*0x30f4e38*/ int Stat(string path, ref Interop.Sys.FileStatus output);
        static /*0x30f4e74*/ int LStat(string path, ref Interop.Sys.FileStatus output);
        static /*0x30f4eb0*/ int Symlink(string target, string linkPath);
        static /*0x30f4f04*/ int ChMod(string path, int mode);
        static /*0x30f4f40*/ int CopyFile(Microsoft.Win32.SafeHandles.SafeFileHandle source, Microsoft.Win32.SafeHandles.SafeFileHandle destination);
        static /*0x30f4ff4*/ uint GetEGid();
        static /*0x30f4ff8*/ uint GetEUid();
        static /*0x30f4ffc*/ int LChflags(string path, uint flags);
        static /*0x30f5038*/ int LChflagsCanSetHiddenFlag();
        static /*0x30f503c*/ int Link(string source, string link);
        static /*0x30f5090*/ int MkDir(string path, int mode);
        static /*0x30f50cc*/ int Rename(string oldPath, string newPath);
        static /*0x30f5120*/ int RmDir(string path);
        static /*0x30f5154*/ int Stat(ref byte path, ref Interop.Sys.FileStatus output);
        static /*0x30f5170*/ int Stat(System.ReadOnlySpan<char> path, ref Interop.Sys.FileStatus output);
        static /*0x30f5324*/ int LStat(ref byte path, ref Interop.Sys.FileStatus output);
        static /*0x30f5340*/ int LStat(System.ReadOnlySpan<char> path, ref Interop.Sys.FileStatus output);
        static /*0x30f54f4*/ int UTimes(string path, ref Interop.Sys.TimeValPair times);
        static /*0x30f5530*/ int Unlink(string pathname);
        static /*0x30f5564*/ int DoubleToString(double value, byte* format, byte* buffer, int bufferLength);

        enum NodeType
        {
            DT_UNKNOWN = 0,
            DT_FIFO = 1,
            DT_CHR = 2,
            DT_DIR = 4,
            DT_BLK = 6,
            DT_REG = 8,
            DT_LNK = 10,
            DT_SOCK = 12,
            DT_WHT = 14,
        }

        struct DirectoryEntry
        {
            /*0x10*/ byte* Name;
            /*0x18*/ int NameLength;
            /*0x1c*/ Interop.Sys.NodeType InodeType;

            /*0x30f55bc*/ System.ReadOnlySpan<char> GetName(System.Span<char> buffer);
        }

        struct FileStatus
        {
            /*0x10*/ Interop.Sys.FileStatusFlags Flags;
            /*0x14*/ int Mode;
            /*0x18*/ uint Uid;
            /*0x1c*/ uint Gid;
            /*0x20*/ long Size;
            /*0x28*/ long ATime;
            /*0x30*/ long ATimeNsec;
            /*0x38*/ long MTime;
            /*0x40*/ long MTimeNsec;
            /*0x48*/ long CTime;
            /*0x50*/ long CTimeNsec;
            /*0x58*/ long BirthTime;
            /*0x60*/ long BirthTimeNsec;
            /*0x68*/ long Dev;
            /*0x70*/ long Ino;
            /*0x78*/ uint UserFlags;
        }

        enum FileStatusFlags
        {
            None = 0,
            HasBirthTime = 1,
        }

        enum Permissions
        {
            Mask = 511,
            S_IRWXU = 448,
            S_IRUSR = 256,
            S_IWUSR = 128,
            S_IXUSR = 64,
            S_IRWXG = 56,
            S_IRGRP = 32,
            S_IWGRP = 16,
            S_IXGRP = 8,
            S_IRWXO = 7,
            S_IROTH = 4,
            S_IWOTH = 2,
            S_IXOTH = 1,
        }

        struct TimeValPair
        {
            /*0x10*/ long ASec;
            /*0x18*/ long AUSec;
            /*0x20*/ long MSec;
            /*0x28*/ long MUSec;
        }
    }
}

class InteropErrorExtensions
{
    static /*0x30f5834*/ Interop.ErrorInfo Info(Interop.Error error);
}

class Locale
{
    static /*0x30f583c*/ string GetText(string msg);
    static /*0x30f5840*/ string GetText(string fmt, object[] args);
}

class SR
{
    static /*0x30f5848*/ string GetString(string name, object[] args);
    static /*0x30f58b8*/ string GetString(System.Globalization.CultureInfo culture, string name, object[] args);
    static /*0x30f58c0*/ string GetString(string name);
    static /*0x30f58c4*/ string Format(string resourceFormat, object[] args);
    static /*0x30f46fc*/ string Format(string resourceFormat, object p1);
    static /*0x30f5940*/ string Format(string resourceFormat, object p1, object p2);
    static /*0x30f59b8*/ string Format(string resourceFormat, object p1, object p2, object p3);
    static /*0x30f5a40*/ string GetResourceString(string str);
}

namespace Mono
{
    enum CertificateImportFlags
    {
        None = 0,
        DisableNativeBackend = 1,
        DisableAutomaticFallback = 2,
    }

    class DependencyInjector
    {
        static /*0x0*/ object locker;
        static /*0x8*/ Mono.ISystemDependencyProvider systemDependency;

        static /*0x30f5f20*/ DependencyInjector();
        static /*0x30f5a44*/ Mono.ISystemDependencyProvider get_SystemProvider();
        static /*0x30f5d8c*/ void Register(Mono.ISystemDependencyProvider provider);
        static /*0x30f5c4c*/ Mono.ISystemDependencyProvider ReflectionLoad();
    }

    interface ISystemCertificateProvider
    {
        /*0x1f30300*/ System.Security.Cryptography.X509Certificates.X509CertificateImpl Import(byte[] data, Mono.CertificateImportFlags importFlags);
        System.Security.Cryptography.X509Certificates.X509CertificateImpl Import(byte[] data, Microsoft.Win32.SafeHandles.SafePasswordHandle password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags, Mono.CertificateImportFlags importFlags);
        /*0x1f30300*/ System.Security.Cryptography.X509Certificates.X509CertificateImpl Import(System.Security.Cryptography.X509Certificates.X509Certificate cert, Mono.CertificateImportFlags importFlags);
    }

    interface ISystemDependencyProvider
    {
        /*0x1f30214*/ Mono.ISystemCertificateProvider get_CertificateProvider();
    }

    class Runtime
    {
        static /*0x0*/ object dump;

        static /*0x30f5f9c*/ Runtime();
    }

    struct RuntimeClassHandle
    {
        /*0x10*/ Mono.RuntimeStructs.MonoClass* value;

        static /*0x30f6168*/ nint GetTypeFromClass(Mono.RuntimeStructs.MonoClass* klass);
        /*0x30f6018*/ RuntimeClassHandle(Mono.RuntimeStructs.MonoClass* value);
        /*0x30f6020*/ RuntimeClassHandle(nint ptr);
        /*0x30f6040*/ Mono.RuntimeStructs.MonoClass* get_Value();
        /*0x30f6048*/ bool Equals(object obj);
        /*0x30f6140*/ int GetHashCode();
        /*0x30f616c*/ System.RuntimeTypeHandle GetTypeHandle();
    }

    struct RuntimeRemoteClassHandle
    {
        /*0x10*/ Mono.RuntimeStructs.RemoteClass* value;

        /*0x30f6174*/ Mono.RuntimeClassHandle get_ProxyClass();
    }

    struct RuntimeGenericParamInfoHandle
    {
        /*0x10*/ Mono.RuntimeStructs.GenericParamInfo* value;

        /*0x30f618c*/ RuntimeGenericParamInfoHandle(nint ptr);
        /*0x30f61ac*/ System.Type[] get_Constraints();
        /*0x30f62dc*/ System.Reflection.GenericParameterAttributes get_Attributes();
        /*0x30f61b0*/ System.Type[] GetConstraints();
        /*0x30f62f4*/ int GetConstraintsCount();
    }

    struct RuntimeEventHandle
    {
        /*0x10*/ nint value;

        /*0x30f6334*/ RuntimeEventHandle(nint v);
        /*0x30f633c*/ nint get_Value();
        /*0x30f6344*/ bool Equals(object obj);
        /*0x30f643c*/ int GetHashCode();
    }

    struct RuntimePropertyHandle
    {
        /*0x10*/ nint value;

        /*0x30f6444*/ RuntimePropertyHandle(nint v);
        /*0x30f644c*/ nint get_Value();
        /*0x30f6454*/ bool Equals(object obj);
        /*0x30f654c*/ int GetHashCode();
    }

    struct RuntimeGPtrArrayHandle
    {
        /*0x10*/ Mono.RuntimeStructs.GPtrArray* value;

        static /*0x30f65f4*/ void GPtrArrayFree(Mono.RuntimeStructs.GPtrArray* value);
        static /*0x30f65f8*/ void DestroyAndFree(ref Mono.RuntimeGPtrArrayHandle h);
        /*0x30f6554*/ RuntimeGPtrArrayHandle(nint ptr);
        /*0x30f6574*/ int get_Length();
        /*0x30f658c*/ nint get_Item(int i);
        /*0x30f6590*/ nint Lookup(int i);
    }

    class RuntimeMarshal
    {
        static /*0x30f6614*/ string PtrToUtf8String(nint ptr);
        static /*0x30f66a4*/ Mono.SafeStringMarshal MarshalString(string str);
        static /*0x30f66f0*/ int DecodeBlobSize(nint in_ptr, ref nint out_ptr);
        static /*0x30f676c*/ byte[] DecodeBlobArray(nint ptr);
        static /*0x30f6824*/ int AsciHexDigitValue(int c);
        static /*0x30f6850*/ void FreeAssemblyName(ref Mono.MonoAssemblyName name, bool freeStruct);
    }

    class RuntimeStructs
    {
        struct RemoteClass
        {
            /*0x10*/ nint default_vtable;
            /*0x18*/ nint xdomain_vtable;
            /*0x20*/ Mono.RuntimeStructs.MonoClass* proxy_class;
            /*0x28*/ nint proxy_class_name;
            /*0x30*/ uint interface_count;
        }

        struct MonoClass
        {
        }

        struct GenericParamInfo
        {
            /*0x10*/ Mono.RuntimeStructs.MonoClass* pklass;
            /*0x18*/ nint name;
            /*0x20*/ ushort flags;
            /*0x24*/ uint token;
            /*0x28*/ Mono.RuntimeStructs.MonoClass** constraints;
        }

        struct GPtrArray
        {
            /*0x10*/ nint* data;
            /*0x18*/ int len;
        }
    }

    struct MonoAssemblyName
    {
        /*0x10*/ nint name;
        /*0x18*/ nint culture;
        /*0x20*/ nint hash_value;
        /*0x28*/ nint public_key;
        /*0x30*/ Mono.MonoAssemblyName.<public_key_token> public_key_token;
        /*0x44*/ uint hash_alg;
        /*0x48*/ uint hash_len;
        /*0x4c*/ uint flags;
        /*0x50*/ ushort major;
        /*0x52*/ ushort minor;
        /*0x54*/ ushort build;
        /*0x56*/ ushort revision;
        /*0x58*/ ushort arch;

        struct <public_key_token>e__FixedBuffer
        {
            /*0x10*/ byte FixedElementField;
        }
    }

    struct ValueTuple
    {
    }

    struct ValueTuple<T1>
    {
        /*0x0*/ T1 Item1;
    }

    struct ValueTuple<T1, T2>
    {
        /*0x0*/ T1 Item1;
        /*0x0*/ T2 Item2;
    }

    struct ValueTuple<T1, T2, T3>
    {
        /*0x0*/ T1 Item1;
        /*0x0*/ T2 Item2;
        /*0x0*/ T3 Item3;
    }

    struct ValueTuple<T1, T2, T3, T4>
    {
        /*0x0*/ T1 Item1;
        /*0x0*/ T2 Item2;
        /*0x0*/ T3 Item3;
        /*0x0*/ T4 Item4;
    }

    struct ValueTuple<T1, T2, T3, T4, T5>
    {
        /*0x0*/ T1 Item1;
        /*0x0*/ T2 Item2;
        /*0x0*/ T3 Item3;
        /*0x0*/ T4 Item4;
        /*0x0*/ T5 Item5;
    }

    struct SafeGPtrArrayHandle : System.IDisposable
    {
        /*0x10*/ Mono.RuntimeGPtrArrayHandle handle;

        /*0x30f6854*/ SafeGPtrArrayHandle(nint ptr);
        /*0x30f6874*/ void Dispose();
        /*0x30f6890*/ int get_Length();
        /*0x30f68a8*/ nint get_Item(int i);
    }

    struct SafeStringMarshal : System.IDisposable
    {
        /*0x10*/ string str;
        /*0x18*/ nint marshaled_string;

        static /*0x30f68ac*/ nint StringToUtf8_icall(ref string str);
        static /*0x30f68b0*/ nint StringToUtf8(string str);
        static /*0x30f68c4*/ void GFree(nint ptr);
        /*0x30f66d4*/ SafeStringMarshal(string str);
        /*0x30f68c8*/ nint get_Value();
        /*0x30f6908*/ void Dispose();
    }

    namespace Xml
    {
        class SecurityParser : Mono.Xml.SmallXmlParser, Mono.Xml.SmallXmlParser.IContentHandler
        {
            /*0x68*/ System.Security.SecurityElement root;
            /*0x70*/ System.Security.SecurityElement current;
            /*0x78*/ System.Collections.Stack stack;

            /*0x30f6928*/ SecurityParser();
            /*0x30f6ad8*/ void LoadXml(string xml);
            /*0x30f6d54*/ System.Security.SecurityElement ToXml();
            /*0x30f6d5c*/ void OnStartParsing(Mono.Xml.SmallXmlParser parser);
            /*0x30f6d60*/ void OnProcessingInstruction(string name, string text);
            /*0x30f6d64*/ void OnIgnorableWhitespace(string s);
            /*0x30f6d68*/ void OnStartElement(string name, Mono.Xml.SmallXmlParser.IAttrList attrs);
            /*0x30f7008*/ void OnEndElement(string name);
            /*0x30f70a0*/ void OnChars(string ch);
            /*0x30f7120*/ void OnEndParsing(Mono.Xml.SmallXmlParser parser);
        }

        class SmallXmlParser
        {
            /*0x10*/ Mono.Xml.SmallXmlParser.IContentHandler handler;
            /*0x18*/ System.IO.TextReader reader;
            /*0x20*/ System.Collections.Stack elementNames;
            /*0x28*/ System.Collections.Stack xmlSpaces;
            /*0x30*/ string xmlSpace;
            /*0x38*/ System.Text.StringBuilder buffer;
            /*0x40*/ char[] nameBuffer;
            /*0x48*/ bool isWhitespace;
            /*0x50*/ Mono.Xml.SmallXmlParser.AttrListImpl attributes;
            /*0x58*/ int line;
            /*0x5c*/ int column;
            /*0x60*/ bool resetColumn;

            /*0x30f6990*/ SmallXmlParser();
            /*0x30f71d0*/ System.Exception Error(string msg);
            /*0x30f7300*/ System.Exception UnexpectedEndError();
            /*0x30f73ec*/ bool IsNameChar(char c, bool start);
            /*0x30f74c8*/ bool IsWhitespace(int c);
            /*0x30f74e4*/ void SkipWhitespaces();
            /*0x30f7598*/ void HandleWhitespaces();
            /*0x30f74ec*/ void SkipWhitespaces(bool expected);
            /*0x30f76bc*/ int Peek();
            /*0x30f7654*/ int Read();
            /*0x30f76d8*/ void Expect(int c);
            /*0x30f7794*/ string ReadUntil(char until, bool handleReferences);
            /*0x30f7a38*/ string ReadName();
            /*0x30f6b70*/ void Parse(System.IO.TextReader input, Mono.Xml.SmallXmlParser.IContentHandler handler);
            /*0x30f8444*/ void Cleanup();
            /*0x30f7bec*/ void ReadContent();
            /*0x30f82e4*/ void HandleBufferedContent();
            /*0x30f88d4*/ void ReadCharacters();
            /*0x30f7870*/ void ReadReference();
            /*0x30f895c*/ int ReadCharacterReference();
            /*0x30f8764*/ void ReadAttribute(Mono.Xml.SmallXmlParser.AttrListImpl a);
            /*0x30f85e0*/ void ReadCDATASection();
            /*0x30f86dc*/ void ReadComment();

            interface IContentHandler
            {
                /*0x1f30ebc*/ void OnStartParsing(Mono.Xml.SmallXmlParser parser);
                /*0x1f30ebc*/ void OnEndParsing(Mono.Xml.SmallXmlParser parser);
                /*0x1f30ff0*/ void OnStartElement(string name, Mono.Xml.SmallXmlParser.IAttrList attrs);
                /*0x1f30ebc*/ void OnEndElement(string name);
                /*0x1f30ff0*/ void OnProcessingInstruction(string name, string text);
                /*0x1f30ebc*/ void OnChars(string text);
                /*0x1f30ebc*/ void OnIgnorableWhitespace(string text);
            }

            interface IAttrList
            {
                /*0x1f2ffc8*/ int get_Length();
                /*0x1f30240*/ string GetName(int i);
                /*0x1f30240*/ string GetValue(int i);
                /*0x1f302cc*/ string GetValue(string name);
                /*0x1f30214*/ string[] get_Names();
                /*0x1f30214*/ string[] get_Values();
            }

            class AttrListImpl : Mono.Xml.SmallXmlParser.IAttrList
            {
                /*0x10*/ System.Collections.Generic.List<string> attrNames;
                /*0x18*/ System.Collections.Generic.List<string> attrValues;

                /*0x30f7124*/ AttrListImpl();
                /*0x30f8ac4*/ int get_Length();
                /*0x30f8b0c*/ string GetName(int i);
                /*0x30f8b78*/ string GetValue(int i);
                /*0x30f8be4*/ string GetValue(string name);
                /*0x30f8cac*/ string[] get_Names();
                /*0x30f8cfc*/ string[] get_Values();
                /*0x30f84f0*/ void Clear();
                /*0x30f8a4c*/ void Add(string name, string value);
            }
        }

        class SmallXmlParserException : System.SystemException
        {
            /*0x8c*/ int line;
            /*0x90*/ int column;

            /*0x30f7240*/ SmallXmlParserException(string msg, int line, int column);
        }
    }

    namespace Interop
    {
        class MonoPInvokeCallbackAttribute : System.Attribute
        {
            /*0x30f8d4c*/ MonoPInvokeCallbackAttribute(System.Type t);
        }
    }

    namespace Globalization
    {
        namespace Unicode
        {
            class CodePointIndexer
            {
                /*0x10*/ Mono.Globalization.Unicode.CodePointIndexer.TableRange[] ranges;
                /*0x18*/ int TotalCount;
                /*0x1c*/ int defaultIndex;
                /*0x20*/ int defaultCP;

                /*0x30f8d54*/ CodePointIndexer(int[] starts, int[] ends, int defaultIndex, int defaultCP);
                /*0x30f8ed0*/ int ToIndex(int cp);

                struct TableRange
                {
                    /*0x10*/ int Start;
                    /*0x14*/ int End;
                    /*0x18*/ int Count;
                    /*0x1c*/ int IndexStart;
                    /*0x20*/ int IndexEnd;

                    /*0x30f8eb8*/ TableRange(int start, int end, int indexStart);
                }
            }

            class TailoringInfo
            {
                /*0x10*/ int LCID;
                /*0x14*/ int TailoringIndex;
                /*0x18*/ int TailoringCount;
                /*0x1c*/ bool FrenchSort;

                /*0x30f8f58*/ TailoringInfo(int lcid, int tailoringIndex, int tailoringCount, bool frenchSort);
            }

            class Contraction
            {
                /*0x10*/ int Index;
                /*0x18*/ char[] Source;
                /*0x20*/ string Replacement;
                /*0x28*/ byte[] SortKey;

                /*0x30f8f9c*/ Contraction(int index, char[] source, string replacement, byte[] sortkey);
            }

            class ContractionComparer : System.Collections.Generic.IComparer<Mono.Globalization.Unicode.Contraction>
            {
                static /*0x0*/ Mono.Globalization.Unicode.ContractionComparer Instance;

                static /*0x30f90a4*/ ContractionComparer();
                /*0x30f909c*/ ContractionComparer();
                /*0x30f9004*/ int Compare(Mono.Globalization.Unicode.Contraction c1, Mono.Globalization.Unicode.Contraction c2);
            }

            class Level2Map
            {
                /*0x10*/ byte Source;
                /*0x11*/ byte Replace;

                /*0x30f910c*/ Level2Map(byte source, byte replace);
            }

            class MSCompatUnicodeTable
            {
                static /*0x0*/ int MaxExpansionLength;
                static /*0x8*/ byte* ignorableFlags;
                static /*0x10*/ byte* categories;
                static /*0x18*/ byte* level1;
                static /*0x20*/ byte* level2;
                static /*0x28*/ byte* level3;
                static /*0x30*/ byte* cjkCHScategory;
                static /*0x38*/ byte* cjkCHTcategory;
                static /*0x40*/ byte* cjkJAcategory;
                static /*0x48*/ byte* cjkKOcategory;
                static /*0x50*/ byte* cjkCHSlv1;
                static /*0x58*/ byte* cjkCHTlv1;
                static /*0x60*/ byte* cjkJAlv1;
                static /*0x68*/ byte* cjkKOlv1;
                static /*0x70*/ byte* cjkKOlv2;
                static /*0x78*/ char[] tailoringArr;
                static /*0x80*/ Mono.Globalization.Unicode.TailoringInfo[] tailoringInfos;
                static /*0x88*/ object forLock;
                static /*0x90*/ bool isReady;

                static /*0x30fa580*/ MSCompatUnicodeTable();
                static /*0x30f913c*/ Mono.Globalization.Unicode.TailoringInfo GetTailoringInfo(int lcid);
                static /*0x30f9240*/ void BuildTailoringTables(System.Globalization.CultureInfo culture, Mono.Globalization.Unicode.TailoringInfo t, ref Mono.Globalization.Unicode.Contraction[] contractions, ref Mono.Globalization.Unicode.Level2Map[] diacriticals);
                static /*0x30f98d4*/ void SetCJKReferences(string name, ref Mono.Globalization.Unicode.CodePointIndexer cjkIndexer, ref byte* catTable, ref byte* lv1Table, ref Mono.Globalization.Unicode.CodePointIndexer lv2Indexer, ref byte* lv2Table);
                static /*0x30f9b34*/ byte Category(int cp);
                static /*0x30f9bd8*/ byte Level1(int cp);
                static /*0x30f9c7c*/ byte Level2(int cp);
                static /*0x30f9d20*/ byte Level3(int cp);
                static /*0x30f9dc4*/ bool IsSortable(string s);
                static /*0x30f9e74*/ bool IsSortable(int cp);
                static /*0x30f9f40*/ bool IsIgnorable(int cp);
                static /*0x30f9f98*/ bool IsIgnorable(int cp, byte flag);
                static /*0x30fa0a8*/ bool IsIgnorableNonSpacing(int cp);
                static /*0x30fa100*/ int ToKanaTypeInsensitive(int i);
                static /*0x30fa118*/ int ToWidthCompat(int i);
                static /*0x30fa298*/ bool HasSpecialWeight(char c);
                static /*0x30fa31c*/ bool IsHalfWidthKana(char c);
                static /*0x30fa330*/ bool IsHiragana(char c);
                static /*0x30fa344*/ bool IsJapaneseSmallLetter(char c);
                static /*0x30fa444*/ bool get_IsReady();
                static /*0x30fa49c*/ nint GetResource(string name);
                static /*0x30fa554*/ uint UInt32FromBytePtr(byte* raw, uint idx);
                static /*0x30fa948*/ void FillCJK(string culture, ref Mono.Globalization.Unicode.CodePointIndexer cjkIndexer, ref byte* catTable, ref byte* lv1Table, ref Mono.Globalization.Unicode.CodePointIndexer lv2Indexer, ref byte* lv2Table);
                static /*0x30faab8*/ void FillCJKCore(string culture, ref Mono.Globalization.Unicode.CodePointIndexer cjkIndexer, ref byte* catTable, ref byte* lv1Table, ref Mono.Globalization.Unicode.CodePointIndexer cjkLv2Indexer, ref byte* lv2Table);

                class <>c
                {
                    static /*0x0*/ Mono.Globalization.Unicode.MSCompatUnicodeTable.<> <>9;
                    static /*0x8*/ System.Comparison<Mono.Globalization.Unicode.Level2Map> <>9__17_0;

                    static /*0x30faf1c*/ <>c();
                    /*0x30faf84*/ <>c();
                    /*0x30faf8c*/ int <BuildTailoringTables>b__17_0(Mono.Globalization.Unicode.Level2Map a, Mono.Globalization.Unicode.Level2Map b);
                }
            }

            class MSCompatUnicodeTableUtil
            {
                static /*0x0*/ Mono.Globalization.Unicode.CodePointIndexer Ignorable;
                static /*0x8*/ Mono.Globalization.Unicode.CodePointIndexer Category;
                static /*0x10*/ Mono.Globalization.Unicode.CodePointIndexer Level1;
                static /*0x18*/ Mono.Globalization.Unicode.CodePointIndexer Level2;
                static /*0x20*/ Mono.Globalization.Unicode.CodePointIndexer Level3;
                static /*0x28*/ Mono.Globalization.Unicode.CodePointIndexer CjkCHS;
                static /*0x30*/ Mono.Globalization.Unicode.CodePointIndexer Cjk;

                static /*0x30fafb0*/ MSCompatUnicodeTableUtil();
            }

            class NormalizationTableUtil
            {
                static /*0x0*/ Mono.Globalization.Unicode.CodePointIndexer Prop;
                static /*0x8*/ Mono.Globalization.Unicode.CodePointIndexer Map;
                static /*0x10*/ Mono.Globalization.Unicode.CodePointIndexer Combining;
                static /*0x18*/ Mono.Globalization.Unicode.CodePointIndexer Composite;
                static /*0x20*/ Mono.Globalization.Unicode.CodePointIndexer Helper;

                static /*0x30fb420*/ NormalizationTableUtil();
                static /*0x30fb794*/ int PropIdx(int cp);
                static /*0x30fb7fc*/ int MapIdx(int cp);
            }

            class SimpleCollator : System.Globalization.ISimpleCollator
            {
                static /*0x0*/ Mono.Globalization.Unicode.SimpleCollator invariant;
                /*0x10*/ System.Globalization.TextInfo textInfo;
                /*0x18*/ Mono.Globalization.Unicode.CodePointIndexer cjkIndexer;
                /*0x20*/ Mono.Globalization.Unicode.Contraction[] contractions;
                /*0x28*/ Mono.Globalization.Unicode.Level2Map[] level2Maps;
                /*0x30*/ byte[] unsafeFlags;
                /*0x38*/ byte* cjkCatTable;
                /*0x40*/ byte* cjkLv1Table;
                /*0x48*/ byte* cjkLv2Table;
                /*0x50*/ Mono.Globalization.Unicode.CodePointIndexer cjkLv2Indexer;
                /*0x58*/ int lcid;
                /*0x5c*/ bool frenchSort;

                static /*0x310196c*/ SimpleCollator();
                static /*0x30fbc84*/ System.Globalization.CultureInfo GetNeutralCulture(System.Globalization.CultureInfo info);
                static /*0x30fbf54*/ bool IsHalfKana(int cp, System.Globalization.CompareOptions opt);
                static /*0x30fc750*/ byte ToDashTypeValue(Mono.Globalization.Unicode.SimpleCollator.ExtenderType ext, System.Globalization.CompareOptions opt);
                static /*0x30fc988*/ bool IsIgnorable(int i, System.Globalization.CompareOptions opt);
                /*0x30fb864*/ SimpleCollator(System.Globalization.CultureInfo culture);
                /*0x30fbba8*/ void SetCJKTable(System.Globalization.CultureInfo culture, ref Mono.Globalization.Unicode.CodePointIndexer cjkIndexer, ref byte* catTable, ref byte* lv1Table, ref Mono.Globalization.Unicode.CodePointIndexer lv2Indexer, ref byte* lv2Table);
                /*0x30fbcf4*/ byte Category(int cp);
                /*0x30fbd88*/ byte Level1(int cp);
                /*0x30fbe1c*/ byte Level2(int cp, Mono.Globalization.Unicode.SimpleCollator.ExtenderType ext);
                /*0x30fbfc4*/ Mono.Globalization.Unicode.Contraction GetContraction(string s, int start, int end);
                /*0x30fc084*/ Mono.Globalization.Unicode.Contraction GetContraction(string s, int start, int end, Mono.Globalization.Unicode.Contraction[] clist);
                /*0x30fc1ac*/ Mono.Globalization.Unicode.Contraction GetTailContraction(string s, int start, int end);
                /*0x30fc26c*/ Mono.Globalization.Unicode.Contraction GetTailContraction(string s, int start, int end, Mono.Globalization.Unicode.Contraction[] clist);
                /*0x30fc44c*/ Mono.Globalization.Unicode.Contraction GetContraction(char c);
                /*0x30fc4e8*/ Mono.Globalization.Unicode.Contraction GetContraction(char c, Mono.Globalization.Unicode.Contraction[] clist);
                /*0x30fc568*/ int FilterOptions(int i, System.Globalization.CompareOptions opt);
                /*0x30fc654*/ Mono.Globalization.Unicode.SimpleCollator.ExtenderType GetExtenderType(int i);
                /*0x30fc778*/ int FilterExtender(int i, Mono.Globalization.Unicode.SimpleCollator.ExtenderType ext, System.Globalization.CompareOptions opt);
                /*0x30fca04*/ bool IsSafe(int i);
                /*0x30fca60*/ System.Globalization.SortKey GetSortKey(string s, System.Globalization.CompareOptions options);
                /*0x30fca7c*/ System.Globalization.SortKey GetSortKey(string s, int start, int length, System.Globalization.CompareOptions options);
                /*0x30fcd60*/ void GetSortKey(string s, int start, int end, Mono.Globalization.Unicode.SortKeyBuffer buf, System.Globalization.CompareOptions opt);
                /*0x30fd374*/ void FillSortKeyRaw(int i, Mono.Globalization.Unicode.SimpleCollator.ExtenderType ext, Mono.Globalization.Unicode.SortKeyBuffer buf, System.Globalization.CompareOptions opt);
                /*0x30fd894*/ void FillSurrogateSortKeyRaw(int i, Mono.Globalization.Unicode.SortKeyBuffer buf);
                /*0x30fd9dc*/ int Compare(string s1, string s2);
                /*0x30fdad0*/ int System.Globalization.ISimpleCollator.Compare(string s1, int idx1, int len1, string s2, int idx2, int len2, System.Globalization.CompareOptions options);
                /*0x30fda18*/ int Compare(string s1, int idx1, int len1, string s2, int idx2, int len2, System.Globalization.CompareOptions options);
                /*0x30fd0f4*/ void ClearBuffer(byte* buffer, int size);
                /*0x30fdad4*/ int CompareInternal(string s1, int idx1, int len1, string s2, int idx2, int len2, ref bool targetConsumed, ref bool sourceConsumed, bool skipHeadingExtenders, bool immediateBreakup, ref Mono.Globalization.Unicode.SimpleCollator.Context ctx);
                /*0x30fef40*/ int CompareFlagPair(bool b1, bool b2);
                /*0x30fef5c*/ bool IsPrefix(string src, string target, System.Globalization.CompareOptions opt);
                /*0x30fef78*/ bool IsPrefix(string s, string target, int start, int length, System.Globalization.CompareOptions opt);
                /*0x30ff028*/ bool IsPrefix(string s, string target, int start, int length, bool skipHeadingExtenders, ref Mono.Globalization.Unicode.SimpleCollator.Context ctx);
                /*0x30ff094*/ bool IsSuffix(string src, string target, System.Globalization.CompareOptions opt);
                /*0x30ff0b0*/ bool IsSuffix(string s, string target, int start, int length, System.Globalization.CompareOptions opt);
                /*0x30ff2e0*/ int QuickIndexOf(string s, string target, int start, int length, ref bool testWasUnable);
                /*0x30ff448*/ int IndexOf(string s, string target, int start, int length, System.Globalization.CompareOptions opt);
                /*0x30ffabc*/ int IndexOfOrdinal(string s, string target, int start, int length);
                /*0x30ffb94*/ int IndexOf(string s, char target, int start, int length, System.Globalization.CompareOptions opt);
                /*0x310003c*/ int IndexOfOrdinal(string s, char target, int start, int length);
                /*0x30fffa8*/ int IndexOfSortKey(string s, int start, int length, byte* sortkey, char target, int ti, bool noLv4, ref Mono.Globalization.Unicode.SimpleCollator.Context ctx);
                /*0x30ff648*/ int IndexOf(string s, string target, int start, int length, byte* targetSortKey, ref Mono.Globalization.Unicode.SimpleCollator.Context ctx);
                /*0x3100250*/ int LastIndexOf(string s, string target, System.Globalization.CompareOptions opt);
                /*0x30ff144*/ int LastIndexOf(string s, string target, int start, int length, System.Globalization.CompareOptions opt);
                /*0x3100774*/ int LastIndexOfOrdinal(string s, string target, int start, int length);
                /*0x31008ac*/ int LastIndexOf(string s, char target, System.Globalization.CompareOptions opt);
                /*0x31008c8*/ int LastIndexOf(string s, char target, int start, int length, System.Globalization.CompareOptions opt);
                /*0x3100cd0*/ int LastIndexOfSortKey(string s, int start, int orgStart, int length, byte* sortkey, int ti, bool noLv4, ref Mono.Globalization.Unicode.SimpleCollator.Context ctx);
                /*0x310026c*/ int LastIndexOf(string s, string target, int start, int length, byte* targetSortKey, ref Mono.Globalization.Unicode.SimpleCollator.Context ctx);
                /*0x31000ac*/ bool MatchesForward(string s, ref int idx, int end, int ti, byte* sortkey, bool noLv4, ref Mono.Globalization.Unicode.SimpleCollator.Context ctx);
                /*0x3100f1c*/ bool MatchesForwardCore(string s, ref int idx, int end, int ti, byte* sortkey, bool noLv4, Mono.Globalization.Unicode.SimpleCollator.ExtenderType ext, ref Mono.Globalization.Unicode.Contraction ct, ref Mono.Globalization.Unicode.SimpleCollator.Context ctx);
                /*0x3101290*/ bool MatchesPrimitive(System.Globalization.CompareOptions opt, byte* source, int si, Mono.Globalization.Unicode.SimpleCollator.ExtenderType ext, byte* target, int ti, bool noLv4);
                /*0x3100d6c*/ bool MatchesBackward(string s, ref int idx, int end, int orgStart, int ti, byte* sortkey, bool noLv4, ref Mono.Globalization.Unicode.SimpleCollator.Context ctx);
                /*0x31014c4*/ bool MatchesBackwardCore(string s, ref int idx, int end, int orgStart, int ti, byte* sortkey, bool noLv4, Mono.Globalization.Unicode.SimpleCollator.ExtenderType ext, ref Mono.Globalization.Unicode.Contraction ct, ref Mono.Globalization.Unicode.SimpleCollator.Context ctx);

                struct Context
                {
                    /*0x10*/ System.Globalization.CompareOptions Option;
                    /*0x18*/ byte* NeverMatchFlags;
                    /*0x20*/ byte* AlwaysMatchFlags;
                    /*0x28*/ byte* Buffer1;
                    /*0x30*/ byte* Buffer2;
                    /*0x38*/ int PrevCode;
                    /*0x40*/ byte* PrevSortKey;

                    /*0x30fd358*/ Context(System.Globalization.CompareOptions opt, byte* alwaysMatchFlags, byte* neverMatchFlags, byte* buffer1, byte* buffer2, byte* prev1);
                }

                struct PreviousInfo
                {
                    /*0x10*/ int Code;
                    /*0x18*/ byte* SortKey;

                    /*0x30fef30*/ PreviousInfo(bool dummy);
                }

                struct Escape
                {
                    /*0x10*/ string Source;
                    /*0x18*/ int Index;
                    /*0x1c*/ int Start;
                    /*0x20*/ int End;
                    /*0x24*/ int Optional;
                }

                enum ExtenderType
                {
                    None = 0,
                    Simple = 1,
                    Voiced = 2,
                    Conditional = 3,
                    Buggy = 4,
                }
            }

            class SortKeyBuffer
            {
                /*0x10*/ byte[] l1b;
                /*0x18*/ byte[] l2b;
                /*0x20*/ byte[] l3b;
                /*0x28*/ byte[] l4sb;
                /*0x30*/ byte[] l4tb;
                /*0x38*/ byte[] l4kb;
                /*0x40*/ byte[] l4wb;
                /*0x48*/ byte[] l5b;
                /*0x50*/ string source;
                /*0x58*/ int l1;
                /*0x5c*/ int l2;
                /*0x60*/ int l3;
                /*0x64*/ int l4s;
                /*0x68*/ int l4t;
                /*0x6c*/ int l4k;
                /*0x70*/ int l4w;
                /*0x74*/ int l5;
                /*0x78*/ int lcid;
                /*0x7c*/ System.Globalization.CompareOptions options;
                /*0x80*/ bool processLevel2;
                /*0x81*/ bool frenchSort;
                /*0x82*/ bool frenchSorted;

                /*0x30fcb44*/ SortKeyBuffer(int lcid);
                /*0x3101a08*/ void Reset();
                /*0x30fcb4c*/ void Initialize(System.Globalization.CompareOptions options, int lcid, string s, bool frenchSort);
                /*0x30fd810*/ void AppendCJKExtension(byte lv1msb, byte lv1lsb);
                /*0x30fd948*/ void AppendKana(byte category, byte lv1, byte lv2, byte lv3, bool isSmallKana, byte markType, bool isKatakana, bool isHalfWidth);
                /*0x30fd6e0*/ void AppendNormal(byte category, byte lv1, byte lv2, byte lv3);
                /*0x3101afc*/ void AppendLevel5(byte category, byte lv1);
                /*0x3101a1c*/ void AppendBufferPrimitive(byte value, ref byte[] buf, ref int bidx);
                /*0x30fd0d0*/ System.Globalization.SortKey GetResultAndReset();
                /*0x3102068*/ int GetOptimizedLength(byte[] data, int len, byte defaultValue);
                /*0x3101b8c*/ System.Globalization.SortKey GetResult();
            }
        }
    }

    namespace Security
    {
        class ASN1
        {
            /*0x10*/ byte m_nTag;
            /*0x18*/ byte[] m_aValue;
            /*0x20*/ System.Collections.ArrayList elist;

            /*0x31020cc*/ ASN1(byte tag);
            /*0x3102100*/ ASN1(byte tag, byte[] data);
            /*0x3102138*/ ASN1(byte[] data);
            /*0x31023d8*/ int get_Count();
            /*0x31023f4*/ byte[] get_Value();
            /*0x3102484*/ Mono.Security.ASN1 Add(Mono.Security.ASN1 asn1);
            /*0x310251c*/ byte[] GetBytes();
            /*0x31022b4*/ void Decode(byte[] asn1, ref int anPos, int anLength);
            /*0x3102b90*/ void DecodeTLV(byte[] asn1, ref int pos, ref byte tag, ref int length, ref byte[] content);
            /*0x3102cb8*/ string ToString();
        }

        class BitConverterLE
        {
            static /*0x3102f4c*/ byte[] GetUIntBytes(byte* bytes);
            static /*0x3102fe4*/ byte[] GetULongBytes(byte* bytes);
            static /*0x31030bc*/ byte[] GetBytes(float value);
            static /*0x31030d4*/ byte[] GetBytes(double value);
            static /*0x31030ec*/ void UIntFromBytes(byte* dst, byte[] src, int startIndex);
            static /*0x3103170*/ void ULongFromBytes(byte* dst, byte[] src, int startIndex);
            static /*0x31031c4*/ float ToSingle(byte[] value, int startIndex);
            static /*0x31031e8*/ double ToDouble(byte[] value, int startIndex);
        }

        namespace Cryptography
        {
            class KeyBuilder
            {
                static /*0x0*/ System.Security.Cryptography.RandomNumberGenerator rng;

                static /*0x3103208*/ System.Security.Cryptography.RandomNumberGenerator get_Rng();
                static /*0x3103280*/ byte[] Key(int size);
                static /*0x31032f0*/ byte[] IV(int size);
            }

            class KeyPairPersistence
            {
                static /*0x0*/ bool _userPathExists;
                static /*0x8*/ string _userPath;
                static /*0x10*/ bool _machinePathExists;
                static /*0x18*/ string _machinePath;
                static /*0x20*/ object lockobj;
                /*0x10*/ System.Security.Cryptography.CspParameters _params;
                /*0x18*/ string _keyvalue;
                /*0x20*/ string _filename;
                /*0x28*/ string _container;

                static /*0x3104c10*/ KeyPairPersistence();
                static /*0x3103cc4*/ string get_UserPath();
                static /*0x3103770*/ string get_MachinePath();
                static /*0x3104b40*/ bool _CanSecure(char* root);
                static /*0x3104b44*/ bool _ProtectUser(char* path);
                static /*0x3104b48*/ bool _ProtectMachine(char* path);
                static /*0x3104b4c*/ bool _IsUserProtected(char* path);
                static /*0x3104b50*/ bool _IsMachineProtected(char* path);
                static /*0x3104b54*/ bool CanSecure(string path);
                static /*0x310497c*/ bool ProtectUser(string path);
                static /*0x31048ec*/ bool ProtectMachine(string path);
                static /*0x3104a20*/ bool IsUserProtected(string path);
                static /*0x3104ab0*/ bool IsMachineProtected(string path);
                /*0x3103360*/ KeyPairPersistence(System.Security.Cryptography.CspParameters parameters);
                /*0x3103368*/ KeyPairPersistence(System.Security.Cryptography.CspParameters parameters, string keyPair);
                /*0x3103494*/ string get_Filename();
                /*0x3104218*/ string get_KeyValue();
                /*0x3104220*/ void set_KeyValue(string value);
                /*0x3104244*/ bool Load();
                /*0x31044d4*/ void Save();
                /*0x3104a0c*/ void Remove();
                /*0x3104234*/ bool get_CanChange();
                /*0x3104bf4*/ bool get_UseDefaultKeyContainer();
                /*0x3103754*/ bool get_UseMachineKeyStore();
                /*0x310363c*/ string get_ContainerName();
                /*0x3103400*/ System.Security.Cryptography.CspParameters Copy(System.Security.Cryptography.CspParameters p);
                /*0x31043a0*/ void FromXml(string xml);
                /*0x31046e4*/ string ToXml();
            }

            class MD2 : System.Security.Cryptography.HashAlgorithm
            {
                static /*0x3104ca4*/ Mono.Security.Cryptography.MD2 Create();
                /*0x3104c84*/ MD2();
            }

            class MD2Managed : Mono.Security.Cryptography.MD2
            {
                static /*0x0*/ byte[] PI_SUBST;
                /*0x28*/ byte[] state;
                /*0x30*/ byte[] checksum;
                /*0x38*/ byte[] buffer;
                /*0x40*/ int count;
                /*0x48*/ byte[] x;

                static /*0x31052f0*/ MD2Managed();
                /*0x3104cf4*/ MD2Managed();
                /*0x3104dc8*/ byte[] Padding(int nLength);
                /*0x3104e60*/ void Initialize();
                /*0x3104ec0*/ void HashCore(byte[] array, int ibStart, int cbSize);
                /*0x3105200*/ byte[] HashFinal();
                /*0x3104f9c*/ void MD2Transform(byte[] state, byte[] checksum, byte[] block, int index);
            }

            class MD4 : System.Security.Cryptography.HashAlgorithm
            {
                static /*0x31053b0*/ Mono.Security.Cryptography.MD4 Create();
                /*0x3105390*/ MD4();
            }

            class MD4Managed : Mono.Security.Cryptography.MD4
            {
                /*0x28*/ uint[] state;
                /*0x30*/ byte[] buffer;
                /*0x38*/ uint[] count;
                /*0x40*/ uint[] x;
                /*0x48*/ byte[] digest;

                /*0x3105400*/ MD4Managed();
                /*0x310550c*/ void Initialize();
                /*0x31055c0*/ void HashCore(byte[] array, int ibStart, int cbSize);
                /*0x3105d54*/ byte[] HashFinal();
                /*0x3105f48*/ byte[] Padding(int nLength);
                /*0x3105fc0*/ uint F(uint x, uint y, uint z);
                /*0x3105fd0*/ uint G(uint x, uint y, uint z);
                /*0x3105fe4*/ uint H(uint x, uint y, uint z);
                /*0x3105ff0*/ uint ROL(uint x, byte n);
                /*0x3105ffc*/ void FF(ref uint a, uint b, uint c, uint d, uint x, byte s);
                /*0x3106024*/ void GG(ref uint a, uint b, uint c, uint d, uint x, byte s);
                /*0x310605c*/ void HH(ref uint a, uint b, uint c, uint d, uint x, byte s);
                /*0x3105e50*/ void Encode(byte[] output, uint[] input);
                /*0x310608c*/ void Decode(uint[] output, byte[] input, int index);
                /*0x31056e4*/ void MD4Transform(uint[] state, byte[] block, int index);
            }

            class PKCS1
            {
                static /*0x0*/ byte[] emptySHA1;
                static /*0x8*/ byte[] emptySHA256;
                static /*0x10*/ byte[] emptySHA384;
                static /*0x18*/ byte[] emptySHA512;

                static /*0x310712c*/ PKCS1();
                static /*0x31063bc*/ bool Compare(byte[] array1, byte[] array2);
                static /*0x3106424*/ byte[] I2OSP(byte[] x, int size);
                static /*0x31064b0*/ byte[] OS2IP(byte[] x);
                static /*0x3106574*/ byte[] RSAVP1(System.Security.Cryptography.RSA rsa, byte[] s);
                static /*0x310658c*/ bool Verify_v15(System.Security.Cryptography.RSA rsa, System.Security.Cryptography.HashAlgorithm hash, byte[] hashValue, byte[] signature);
                static /*0x31067e4*/ bool Verify_v15(System.Security.Cryptography.RSA rsa, string hashName, byte[] hashValue, byte[] signature);
                static /*0x310660c*/ bool Verify_v15(System.Security.Cryptography.RSA rsa, System.Security.Cryptography.HashAlgorithm hash, byte[] hashValue, byte[] signature, bool tryNonStandardEncoding);
                static /*0x3106d4c*/ byte[] Encode_v15(System.Security.Cryptography.HashAlgorithm hash, byte[] hashValue, int emLength);
                static /*0x3106974*/ System.Security.Cryptography.HashAlgorithm CreateFromName(string name);
            }

            class RSAManaged : System.Security.Cryptography.RSA
            {
                /*0x20*/ bool isCRTpossible;
                /*0x21*/ bool keyBlinding;
                /*0x22*/ bool keypairGenerated;
                /*0x23*/ bool m_disposed;
                /*0x28*/ Mono.Math.BigInteger d;
                /*0x30*/ Mono.Math.BigInteger p;
                /*0x38*/ Mono.Math.BigInteger q;
                /*0x40*/ Mono.Math.BigInteger dp;
                /*0x48*/ Mono.Math.BigInteger dq;
                /*0x50*/ Mono.Math.BigInteger qInv;
                /*0x58*/ Mono.Math.BigInteger n;
                /*0x60*/ Mono.Math.BigInteger e;
                /*0x68*/ Mono.Security.Cryptography.RSAManaged.KeyGeneratedEventHandler KeyGenerated;

                /*0x31072a0*/ RSAManaged(int keySize);
                /*0x3107388*/ void Finalize();
                /*0x3107418*/ void GenerateKeyPair();
                /*0x3107cf4*/ int get_KeySize();
                /*0x3107d90*/ bool get_PublicOnly();
                /*0x3107ee0*/ byte[] EncryptValue(byte[] rgb);
                /*0x3108398*/ System.Security.Cryptography.RSAParameters ExportParameters(bool includePrivateParameters);
                /*0x310885c*/ void ImportParameters(System.Security.Cryptography.RSAParameters parameters);
                /*0x3108da8*/ void Dispose(bool disposing);
                /*0x310902c*/ void add_KeyGenerated(Mono.Security.Cryptography.RSAManaged.KeyGeneratedEventHandler value);
                /*0x31090c8*/ void remove_KeyGenerated(Mono.Security.Cryptography.RSAManaged.KeyGeneratedEventHandler value);
                /*0x3109164*/ string ToXmlString(bool includePrivateParameters);
                /*0x3108294*/ byte[] GetPaddedValue(Mono.Math.BigInteger value, int length);

                class KeyGeneratedEventHandler : System.MulticastDelegate
                {
                    /*0x3109808*/ KeyGeneratedEventHandler(object object, nint method);
                    /*0x3109914*/ void Invoke(object sender, System.EventArgs e);
                }
            }

            class SymmetricTransform : System.Security.Cryptography.ICryptoTransform, System.IDisposable
            {
                /*0x10*/ System.Security.Cryptography.SymmetricAlgorithm algo;
                /*0x18*/ bool encrypt;
                /*0x1c*/ int BlockSizeByte;
                /*0x20*/ byte[] temp;
                /*0x28*/ byte[] temp2;
                /*0x30*/ byte[] workBuff;
                /*0x38*/ byte[] workout;
                /*0x40*/ System.Security.Cryptography.PaddingMode padmode;
                /*0x44*/ int FeedBackByte;
                /*0x48*/ bool m_disposed;
                /*0x49*/ bool lastBlock;
                /*0x50*/ System.Security.Cryptography.RandomNumberGenerator _rng;

                /*0x3109928*/ SymmetricTransform(System.Security.Cryptography.SymmetricAlgorithm symmAlgo, bool encryption, byte[] rgbIV);
                /*0x3109c14*/ void Finalize();
                /*0x3109ca4*/ void System.IDisposable.Dispose();
                /*0x3109d10*/ void Dispose(bool disposing);
                /*0x3109d90*/ bool get_CanTransformMultipleBlocks();
                /*0x3109d98*/ int get_InputBlockSize();
                /*0x3109da0*/ int get_OutputBlockSize();
                /*0x3109da8*/ void Transform(byte[] input, byte[] output);
                /*0x1f30ff0*/ void ECB(byte[] input, byte[] output);
                /*0x3109f18*/ void CBC(byte[] input, byte[] output);
                /*0x310a07c*/ void CFB(byte[] input, byte[] output);
                /*0x310a244*/ void OFB(byte[] input, byte[] output);
                /*0x310a290*/ void CTS(byte[] input, byte[] output);
                /*0x310a2dc*/ void CheckInput(byte[] inputBuffer, int inputOffset, int inputCount);
                /*0x310a420*/ int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);
                /*0x310a628*/ bool get_KeepLastBlock();
                /*0x310a64c*/ int InternalTransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);
                /*0x310a804*/ void Random(byte[] buffer, int start, int length);
                /*0x310a8c0*/ void ThrowBadPaddingException(System.Security.Cryptography.PaddingMode padding, int length, int position);
                /*0x310aa9c*/ byte[] FinalEncrypt(byte[] inputBuffer, int inputOffset, int inputCount);
                /*0x310ad30*/ byte[] FinalDecrypt(byte[] inputBuffer, int inputOffset, int inputCount);
                /*0x310afc8*/ byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount);
            }

            class DSAManaged : System.Security.Cryptography.DSA
            {
                /*0x20*/ bool keypairGenerated;
                /*0x21*/ bool m_disposed;
                /*0x28*/ Mono.Math.BigInteger p;
                /*0x30*/ Mono.Math.BigInteger q;
                /*0x38*/ Mono.Math.BigInteger g;
                /*0x40*/ Mono.Math.BigInteger x;
                /*0x48*/ Mono.Math.BigInteger y;
                /*0x50*/ Mono.Math.BigInteger j;
                /*0x58*/ Mono.Math.BigInteger seed;
                /*0x60*/ int counter;
                /*0x64*/ bool j_missing;
                /*0x68*/ System.Security.Cryptography.RandomNumberGenerator rng;
                /*0x70*/ Mono.Security.Cryptography.DSAManaged.KeyGeneratedEventHandler KeyGenerated;

                /*0x310b084*/ DSAManaged(int dwKeySize);
                /*0x310b154*/ void Finalize();
                /*0x310b1e4*/ void Generate();
                /*0x310b788*/ void GenerateKeyPair();
                /*0x310b9b8*/ void add(byte[] a, byte[] b, int value);
                /*0x310b230*/ void GenerateParams(int keyLength);
                /*0x310ba50*/ System.Security.Cryptography.RandomNumberGenerator get_Random();
                /*0x310bd94*/ int get_KeySize();
                /*0x310bdb8*/ bool get_PublicOnly();
                /*0x310be2c*/ byte[] NormalizeArray(byte[] array);
                /*0x310becc*/ System.Security.Cryptography.DSAParameters ExportParameters(bool includePrivateParameters);
                /*0x310c1ec*/ void ImportParameters(System.Security.Cryptography.DSAParameters parameters);
                /*0x310c4fc*/ bool VerifySignature(byte[] rgbHash, byte[] rgbSignature);
                /*0x310c988*/ void Dispose(bool disposing);
                /*0x310cbc8*/ void add_KeyGenerated(Mono.Security.Cryptography.DSAManaged.KeyGeneratedEventHandler value);
                /*0x310cc64*/ void remove_KeyGenerated(Mono.Security.Cryptography.DSAManaged.KeyGeneratedEventHandler value);

                class KeyGeneratedEventHandler : System.MulticastDelegate
                {
                    /*0x310cd00*/ KeyGeneratedEventHandler(object object, nint method);
                    /*0x310ce0c*/ void Invoke(object sender, System.EventArgs e);
                }
            }
        }
    }

    namespace Math
    {
        class BigInteger
        {
            static /*0x0*/ uint[] smallPrimes;
            static /*0x8*/ System.Security.Cryptography.RandomNumberGenerator rng;
            /*0x10*/ uint length;
            /*0x18*/ uint[] data;

            static /*0x310f158*/ BigInteger();
            static /*0x3107718*/ Mono.Math.BigInteger op_Implicit(uint value);
            static /*0x3107ab8*/ Mono.Math.BigInteger op_Implicit(int value);
            static /*0x3107b5c*/ Mono.Math.BigInteger op_Subtraction(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
            static /*0x31077dc*/ uint op_Modulus(Mono.Math.BigInteger bi, uint ui);
            static /*0x3107cc8*/ Mono.Math.BigInteger op_Modulus(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
            static /*0x310bd54*/ Mono.Math.BigInteger op_Division(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
            static /*0x3107890*/ Mono.Math.BigInteger op_Multiply(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
            static /*0x310bc28*/ Mono.Math.BigInteger op_Multiply(Mono.Math.BigInteger bi, int i);
            static /*0x310db50*/ Mono.Math.BigInteger op_LeftShift(Mono.Math.BigInteger bi1, int shiftVal);
            static /*0x310dd24*/ Mono.Math.BigInteger op_RightShift(Mono.Math.BigInteger bi1, int shiftVal);
            static /*0x310de98*/ System.Security.Cryptography.RandomNumberGenerator get_Rng();
            static /*0x310df44*/ Mono.Math.BigInteger GenerateRandom(int bits, System.Security.Cryptography.RandomNumberGenerator rng);
            static /*0x310b87c*/ Mono.Math.BigInteger GenerateRandom(int bits);
            static /*0x310b934*/ bool op_Equality(Mono.Math.BigInteger bi1, uint ui);
            static /*0x310c180*/ bool op_Inequality(Mono.Math.BigInteger bi1, uint ui);
            static /*0x3107e30*/ bool op_Equality(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
            static /*0x31077e0*/ bool op_Inequality(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
            static /*0x310e3b0*/ bool op_GreaterThan(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
            static /*0x3107aa4*/ bool op_LessThan(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
            static /*0x310b9a0*/ bool op_GreaterThanOrEqual(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
            static /*0x310bd7c*/ bool op_LessThanOrEqual(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
            static /*0x3107770*/ Mono.Math.BigInteger GeneratePseudoPrime(int bits);
            /*0x310ce20*/ BigInteger(Mono.Math.BigInteger.Sign sign, uint len);
            /*0x310cea0*/ BigInteger(Mono.Math.BigInteger bi);
            /*0x310cf88*/ BigInteger(Mono.Math.BigInteger bi, uint len);
            /*0x3107fe8*/ BigInteger(byte[] inData);
            /*0x310d0cc*/ BigInteger(uint ui);
            /*0x310e0a4*/ void Randomize(System.Security.Cryptography.RandomNumberGenerator rng);
            /*0x310b8d8*/ void Randomize();
            /*0x3107a38*/ int BitCount();
            /*0x310bd18*/ bool TestBit(uint bitNum);
            /*0x310e224*/ bool TestBit(int bitNum);
            /*0x310e2b8*/ void SetBit(uint bitNum);
            /*0x310e2c0*/ void SetBit(uint bitNum, bool value);
            /*0x310e334*/ int LowestSetBit();
            /*0x3108720*/ byte[] GetBytes();
            /*0x310e3c8*/ string ToString(uint radix);
            /*0x310e420*/ string ToString(uint radix, string characterSet);
            /*0x310d070*/ void Normalize();
            /*0x3108344*/ void Clear();
            /*0x310e700*/ int GetHashCode();
            /*0x310e754*/ string ToString();
            /*0x310e75c*/ bool Equals(object o);
            /*0x3107cc4*/ Mono.Math.BigInteger ModInverse(Mono.Math.BigInteger modulus);
            /*0x310821c*/ Mono.Math.BigInteger ModPow(Mono.Math.BigInteger exp, Mono.Math.BigInteger n);
            /*0x310ba80*/ bool IsProbablePrime();
            /*0x310f0bc*/ void Incr2();

            enum Sign
            {
                Negative = -1,
                Zero = 0,
                Positive = 1,
            }

            class ModulusRing
            {
                /*0x10*/ Mono.Math.BigInteger mod;
                /*0x18*/ Mono.Math.BigInteger constant;

                /*0x310ee64*/ ModulusRing(Mono.Math.BigInteger modulus);
                /*0x310f1f8*/ void BarrettReduction(Mono.Math.BigInteger x);
                /*0x310f7f0*/ Mono.Math.BigInteger Multiply(Mono.Math.BigInteger a, Mono.Math.BigInteger b);
                /*0x310f96c*/ Mono.Math.BigInteger Difference(Mono.Math.BigInteger a, Mono.Math.BigInteger b);
                /*0x310ef64*/ Mono.Math.BigInteger Pow(Mono.Math.BigInteger a, Mono.Math.BigInteger k);
                /*0x310fb20*/ Mono.Math.BigInteger Pow(uint b, Mono.Math.BigInteger exp);
            }

            class Kernel
            {
                static /*0x310d2a0*/ Mono.Math.BigInteger Subtract(Mono.Math.BigInteger big, Mono.Math.BigInteger small);
                static /*0x310f560*/ void MinusEq(Mono.Math.BigInteger big, Mono.Math.BigInteger small);
                static /*0x310f664*/ void PlusEq(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
                static /*0x310d15c*/ Mono.Math.BigInteger.Sign Compare(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
                static /*0x310e654*/ uint SingleByteDivideInPlace(Mono.Math.BigInteger n, uint d);
                static /*0x310d44c*/ uint DwordMod(Mono.Math.BigInteger n, uint d);
                static /*0x310fb90*/ Mono.Math.BigInteger[] DwordDivMod(Mono.Math.BigInteger n, uint d);
                static /*0x310d4b0*/ Mono.Math.BigInteger[] multiByteDivide(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
                static /*0x310db54*/ Mono.Math.BigInteger LeftShift(Mono.Math.BigInteger bi, int n);
                static /*0x310dd28*/ Mono.Math.BigInteger RightShift(Mono.Math.BigInteger bi, int n);
                static /*0x310da60*/ Mono.Math.BigInteger MultiplyByDword(Mono.Math.BigInteger n, uint f);
                static /*0x310d97c*/ void Multiply(uint[] x, uint xOffset, uint xLen, uint[] y, uint yOffset, uint yLen, uint[] d, uint dOffset);
                static /*0x310f450*/ void MultiplyMod2p32pmod(uint[] x, int xOffset, int xLen, uint[] y, int yOffest, int yLen, uint[] d, int dOffset, int mod);
                static /*0x310fd30*/ uint modInverse(Mono.Math.BigInteger bi, uint modulus);
                static /*0x310e888*/ Mono.Math.BigInteger modInverse(Mono.Math.BigInteger bi, Mono.Math.BigInteger modulus);
            }
        }

        namespace Prime
        {
            enum ConfidenceFactor
            {
                ExtraLow = 0,
                Low = 1,
                Medium = 2,
                High = 3,
                ExtraHigh = 4,
                Provable = 5,
            }

            class PrimalityTest : System.MulticastDelegate
            {
                /*0x310fdec*/ PrimalityTest(object object, nint method);
                /*0x310fef8*/ bool Invoke(Mono.Math.BigInteger bi, Mono.Math.Prime.ConfidenceFactor confidence);
            }

            class PrimalityTests
            {
                static /*0x310ff0c*/ int GetSPPRounds(Mono.Math.BigInteger bi, Mono.Math.Prime.ConfidenceFactor confidence);
                static /*0x310f068*/ bool Test(Mono.Math.BigInteger n, Mono.Math.Prime.ConfidenceFactor confidence);
                static /*0x3110288*/ bool RabinMillerTest(Mono.Math.BigInteger n, Mono.Math.Prime.ConfidenceFactor confidence);
                static /*0x31100b4*/ bool SmallPrimeSppTest(Mono.Math.BigInteger bi, Mono.Math.Prime.ConfidenceFactor confidence);
            }

            namespace Generator
            {
                class PrimeGeneratorBase
                {
                    /*0x31105a4*/ PrimeGeneratorBase();
                    /*0x3110528*/ Mono.Math.Prime.ConfidenceFactor get_Confidence();
                    /*0x3110530*/ Mono.Math.Prime.PrimalityTest get_PrimalityTest();
                    /*0x311059c*/ int get_TrialDivisionBounds();
                    /*0x1f30240*/ Mono.Math.BigInteger GenerateNewPrime(int bits);
                }

                class SequentialSearchPrimeGeneratorBase : Mono.Math.Prime.Generator.PrimeGeneratorBase
                {
                    /*0x310f0b4*/ SequentialSearchPrimeGeneratorBase();
                    /*0x31105ac*/ Mono.Math.BigInteger GenerateSearchBase(int bits, object context);
                    /*0x3110620*/ Mono.Math.BigInteger GenerateNewPrime(int bits);
                    /*0x3110630*/ Mono.Math.BigInteger GenerateNewPrime(int bits, object context);
                    /*0x3110914*/ bool IsPrimeAcceptable(Mono.Math.BigInteger bi, object context);
                }
            }
        }
    }
}

namespace Microsoft
{
    namespace Win32
    {
        class Win32Native
        {
            static /*0x311091c*/ string GetMessage(int hr);
            static /*0x3110978*/ int MakeHRFromErrorCode(int errorCode);
        }

        namespace SafeHandles
        {
            class SafeHandleCache<T>
            {
                static /*0x0*/ T s_invalidHandle;

                static /*0x1f31840*/ bool IsCachedInvalidHandle(System.Runtime.InteropServices.SafeHandle handle);
            }

            class SafePasswordHandle : System.Runtime.InteropServices.SafeHandle
            {
                /*0x3110a38*/ SafePasswordHandle(string password);
                /*0x3110984*/ nint CreateHandle(string password);
                /*0x31109dc*/ void FreeHandle();
                /*0x3110a74*/ bool ReleaseHandle();
                /*0x3110aac*/ void Dispose(bool disposing);
                /*0x3110b1c*/ bool get_IsInvalid();
                /*0x3110b40*/ string Mono_DangerousGetString();
            }

            class SafeFileHandle : Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid
            {
                /*0x3110b9c*/ SafeFileHandle(nint preexistingHandle, bool ownsHandle);
                /*0x3110bd8*/ bool ReleaseHandle();
            }

            class SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid
            {
                /*0x3110c54*/ SafeWaitHandle(nint existingHandle, bool ownsHandle);
                /*0x3110c80*/ bool ReleaseHandle();
            }

            class SafeHandleZeroOrMinusOneIsInvalid : System.Runtime.InteropServices.SafeHandle
            {
                /*0x3110bc8*/ SafeHandleZeroOrMinusOneIsInvalid(bool ownsHandle);
                /*0x3110c9c*/ bool get_IsInvalid();
            }

            class SafeHandleMinusOneIsInvalid : System.Runtime.InteropServices.SafeHandle
            {
                /*0x3110cf0*/ SafeHandleMinusOneIsInvalid(bool ownsHandle);
                /*0x3110d34*/ bool get_IsInvalid();
            }
        }
    }
}

namespace Internal
{
    namespace Threading
    {
        namespace Tasks
        {
            namespace Tracing
            {
                class TaskTrace
                {
                    static /*0x0*/ Internal.Runtime.Augments.TaskTraceCallbacks s_callbacks;

                    static /*0x3110d6c*/ bool get_Enabled();
                    static /*0x3110dcc*/ void TaskWaitBegin_Asynchronous(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
                    static /*0x3110e50*/ void TaskWaitBegin_Synchronous(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
                    static /*0x3110ed4*/ void TaskWaitEnd(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
                    static /*0x3110f58*/ void TaskScheduled(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID, int CreatingTaskID, int TaskCreationOptions);
                }
            }
        }
    }

    namespace Runtime
    {
        namespace Augments
        {
            enum AsyncStatus
            {
                Started = 0,
                Completed = 1,
                Canceled = 2,
                Error = 3,
            }

            class TaskTraceCallbacks
            {
                /*0x1f2fe14*/ bool get_Enabled();
                void TaskWaitBegin_Asynchronous(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
                void TaskWaitBegin_Synchronous(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
                void TaskWaitEnd(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
                void TaskScheduled(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID, int CreatingTaskID, int TaskCreationOptions);
            }

            class RuntimeAugments
            {
                static /*0x0*/ Internal.Runtime.Augments.ReflectionExecutionDomainCallbacks s_reflectionExecutionDomainCallbacks;

                static /*0x3111070*/ RuntimeAugments();
                static /*0x3110ff8*/ void ReportUnhandledException(System.Exception exception);
                static /*0x3111018*/ Internal.Runtime.Augments.ReflectionExecutionDomainCallbacks get_Callbacks();
            }

            class ReflectionExecutionDomainCallbacks
            {
                /*0x31110ec*/ ReflectionExecutionDomainCallbacks();
                /*0x31110f4*/ System.Exception CreateMissingMetadataException(System.Type attributeType);
            }

            class RuntimeThread
            {
                static /*0x0*/ int OptimalMaxSpinWaitsPerSpinIteration;
                /*0x10*/ System.Threading.Thread thread;

                static /*0x3111280*/ RuntimeThread();
                static /*0x3111178*/ Internal.Runtime.Augments.RuntimeThread Create(System.Threading.ParameterizedThreadStart start, int maxStackSize);
                static /*0x3111250*/ void Sleep(int millisecondsTimeout);
                static /*0x3111258*/ bool Yield();
                static /*0x3111260*/ bool SpinWait(int iterations);
                static /*0x3111278*/ int GetCurrentProcessorId();
                /*0x3111148*/ RuntimeThread(System.Threading.Thread t);
                /*0x311121c*/ void set_IsBackground(bool value);
                /*0x3111238*/ void Start(object state);
            }
        }
    }

    namespace Cryptography
    {
        class Helpers
        {
            static /*0x31112cc*/ byte[] CloneByteArray(byte[] src);
            static /*0x3111344*/ char[] ToHexArrayUpper(byte[] bytes);
            static /*0x3111440*/ string ToHexStringUpper(byte[] bytes);
            static /*0x3111424*/ char NibbleToHex(byte b);
        }
    }
}

namespace System
{
    class String : System.IComparable, System.Collections.IEnumerable, System.Collections.Generic.IEnumerable<char>, System.IComparable<string>, System.IEquatable<string>, System.IConvertible, System.ICloneable
    {
        static int StackallocIntBufferSizeLimit = 128;
        static int PROBABILISTICMAP_BLOCK_INDEX_MASK = 7;
        static int PROBABILISTICMAP_BLOCK_INDEX_SHIFT = 3;
        static int PROBABILISTICMAP_SIZE = 8;
        static /*0x0*/ string Empty;
        /*0x10*/ int _stringLength;
        /*0x14*/ char _firstChar;

        static /*0x3111458*/ bool EqualsHelper(string strA, string strB);
        static /*0x311148c*/ int CompareOrdinalHelper(string strA, int indexA, int countA, string strB, int indexB, int countB);
        static /*0x31114c4*/ int CompareOrdinalHelper(string strA, string strB);
        static /*0x3111674*/ int Compare(string strA, string strB, bool ignoreCase);
        static /*0x311167c*/ int Compare(string strA, string strB, System.StringComparison comparisonType);
        static /*0x3111960*/ int Compare(string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);
        static /*0x31119fc*/ int Compare(string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);
        static /*0x3111a0c*/ int Compare(string strA, int indexA, string strB, int indexB, int length, System.StringComparison comparisonType);
        static /*0x3111e40*/ int CompareOrdinal(string strA, string strB);
        static /*0x3111e84*/ int CompareOrdinal(System.ReadOnlySpan<char> strA, System.ReadOnlySpan<char> strB);
        static /*0x3111f24*/ int CompareOrdinal(string strA, int indexA, string strB, int indexB, int length);
        static /*0x311291c*/ bool Equals(string a, string b);
        static /*0x3112968*/ bool Equals(string a, string b, System.StringComparison comparisonType);
        static /*0x3107128*/ bool op_Equality(string a, string b);
        static /*0x3112c18*/ bool op_Inequality(string a, string b);
        static /*0x3111944*/ void CheckStringComparison(System.StringComparison comparisonType);
        static /*0x3112fcc*/ string Ctor(char[] value);
        static /*0x3113050*/ string Ctor(char[] value, int startIndex, int length);
        static /*0x31131e4*/ string Ctor(char* ptr, int startIndex, int length);
        static /*0x311333c*/ string Ctor(sbyte* value, int startIndex, int length);
        static /*0x311347c*/ string CreateStringForSByteConstructor(byte* pb, int numBytes);
        static /*0x31134dc*/ string Ctor(sbyte* value, int startIndex, int length, System.Text.Encoding enc);
        static /*0x3113714*/ string Ctor(char c, int count);
        static /*0x3113808*/ string Ctor(System.ReadOnlySpan<char> value);
        static /*0x1ffc854*/ string Create<TState>(int length, TState state, System.Buffers.SpanAction<char, TState> action);
        static /*0x31138b0*/ System.ReadOnlySpan<char> op_Implicit(string value);
        static /*0x3113904*/ string Copy(string str);
        static /*0x3113c18*/ bool IsNullOrEmpty(string value);
        static /*0x3113c34*/ bool IsNullOrWhiteSpace(string value);
        static /*0x3113cbc*/ string CreateStringFromEncoding(byte* bytes, int byteLength, System.Text.Encoding encoding);
        static /*0x3113d64*/ string CreateFromChar(char c);
        static /*0x3113040*/ void wstrcpy(char* dmem, char* smem, int charCount);
        static /*0x3113ea4*/ int wcslen(char* ptr);
        static /*0x3114638*/ void FillStringChecked(string dest, int destPos, string src);
        static /*0x31146b0*/ string Concat(object arg0, object arg1, object arg2);
        static /*0x3114834*/ string Concat(System.Collections.Generic.IEnumerable<string> values);
        static /*0x3107090*/ string Concat(string str0, string str1);
        static /*0x3114774*/ string Concat(string str0, string str1, string str2);
        static /*0x3114cd8*/ string Concat(string str0, string str1, string str2, string str3);
        static /*0x3114de0*/ string Concat(string[] values);
        static /*0x310aa58*/ string Format(string format, object arg0);
        static /*0x31150d8*/ string Format(string format, object arg0, object arg1);
        static /*0x311511c*/ string Format(string format, object arg0, object arg1, object arg2);
        static /*0x3115160*/ string Format(string format, object[] args);
        static /*0x3115208*/ string Format(System.IFormatProvider provider, string format, object arg0);
        static /*0x311525c*/ string Format(System.IFormatProvider provider, string format, object arg0, object arg1);
        static /*0x31152b4*/ string Format(System.IFormatProvider provider, string format, object arg0, object arg1, object arg2);
        static /*0x3115310*/ string Format(System.IFormatProvider provider, string format, object[] args);
        static /*0x3114fdc*/ string FormatHelper(System.IFormatProvider provider, string format, System.ParamsArray args);
        static /*0x31154fc*/ string Join(string separator, string[] value);
        static /*0x3115594*/ string Join(string separator, object[] values);
        static /*0x1f32888*/ string Join<T>(string separator, System.Collections.Generic.IEnumerable<T> values);
        static /*0x3115754*/ string Join(string separator, System.Collections.Generic.IEnumerable<string> values);
        static /*0x3115558*/ string Join(string separator, string[] value, int startIndex, int count);
        static /*0x31155c8*/ string JoinCore(char* separator, int separatorLength, object[] values);
        static /*0x1ffc854*/ string JoinCore<T>(char* separator, int separatorLength, System.Collections.Generic.IEnumerable<T> values);
        static /*0x3115c10*/ string JoinCore(char* separator, int separatorLength, string[] value, int startIndex, int count);
        static /*0x311883c*/ void InitializeProbabilisticMap(uint* charMap, System.ReadOnlySpan<char> anyOf);
        static /*0x31195bc*/ bool ArrayContains(char searchChar, char[] anyOf);
        static /*0x3118914*/ bool IsCharBitSet(uint* charMap, byte value);
        static /*0x3119620*/ void SetCharBit(uint* charMap, byte value);
        static /*0x311303c*/ string FastAllocateString(int length);
        static /*0x311a7b4*/ string InternalIsInterned(string str);
        static /*0x311a7b8*/ string InternalIntern(string str);
        static /*0x311a7bc*/ void memset(byte* dest, int val, int len);
        static /*0x311a87c*/ void memcpy(byte* dest, byte* src, int size);
        static /*0x311a884*/ void bzero(byte* dest, int len);
        static /*0x311a890*/ void bzero_aligned_1(byte* dest, int len);
        static /*0x311a898*/ void bzero_aligned_2(byte* dest, int len);
        static /*0x311a8a0*/ void bzero_aligned_4(byte* dest, int len);
        static /*0x311a8a8*/ void bzero_aligned_8(byte* dest, int len);
        static /*0x311a8b0*/ void memcpy_aligned_1(byte* dest, byte* src, int size);
        static /*0x311a8bc*/ void memcpy_aligned_2(byte* dest, byte* src, int size);
        static /*0x311a8c8*/ void memcpy_aligned_4(byte* dest, byte* src, int size);
        static /*0x311a8d4*/ void memcpy_aligned_8(byte* dest, byte* src, int size);
        static /*0x311a92c*/ string Intern(string str);
        static /*0x311a980*/ string IsInterned(string str);
        /*0x3112fc8*/ String(char[] value);
        /*0x311304c*/ String(char[] value, int startIndex, int length);
        /*0x31131e0*/ String(char* value, int startIndex, int length);
        /*0x3113338*/ String(sbyte* value, int startIndex, int length);
        /*0x31134d8*/ String(sbyte* value, int startIndex, int length, System.Text.Encoding enc);
        /*0x3113710*/ String(char c, int count);
        /*0x3113804*/ String(System.ReadOnlySpan<char> value);
        /*0x3112114*/ int CompareTo(object value);
        /*0x311218c*/ int CompareTo(string strB);
        /*0x3112194*/ bool EndsWith(string value);
        /*0x311219c*/ bool EndsWith(string value, System.StringComparison comparisonType);
        /*0x3112470*/ bool EndsWith(string value, bool ignoreCase, System.Globalization.CultureInfo culture);
        /*0x3112584*/ bool EndsWith(char value);
        /*0x31125d4*/ bool Equals(object obj);
        /*0x311262c*/ bool Equals(string value);
        /*0x311266c*/ bool Equals(string value, System.StringComparison comparisonType);
        /*0x3112c30*/ int GetHashCode();
        /*0x3112c34*/ int GetLegacyNonRandomizedHashCode();
        /*0x3112c88*/ bool StartsWith(string value);
        /*0x3112ce0*/ bool StartsWith(string value, System.StringComparison comparisonType);
        /*0x3113900*/ object Clone();
        /*0x3113998*/ void CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count);
        /*0x3113b24*/ char[] ToCharArray();
        /*0x3111484*/ ref char GetRawStringData();
        /*0x3113d88*/ string ToString();
        /*0x3113d8c*/ string ToString(System.IFormatProvider provider);
        /*0x3113d90*/ System.CharEnumerator GetEnumerator();
        /*0x3113dec*/ System.Collections.Generic.IEnumerator<char> System.Collections.Generic.IEnumerable<System.Char>.GetEnumerator();
        /*0x3113e48*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
        /*0x3113fa8*/ System.TypeCode GetTypeCode();
        /*0x3113fb0*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x3114018*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x3114080*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x31140e8*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x3114150*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x31141b8*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x3114220*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x3114288*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x31142f0*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x3114358*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x31143c0*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x3114428*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x3114490*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x31144f8*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x3114560*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);
        /*0x31145d0*/ string Normalize(System.Text.NormalizationForm normalizationForm);
        /*0x31153c0*/ string Insert(int startIndex, string value);
        /*0x3115fa0*/ string PadLeft(int totalWidth, char paddingChar);
        /*0x3116190*/ string PadRight(int totalWidth, char paddingChar);
        /*0x31163bc*/ string Remove(int startIndex, int count);
        /*0x3116540*/ string Remove(int startIndex);
        /*0x3116748*/ string Replace(char oldChar, char newChar);
        /*0x3116820*/ string Replace(string oldValue, string newValue);
        /*0x3116b38*/ string ReplaceHelper(int oldValueLength, string newValue, System.ReadOnlySpan<int> indices);
        /*0x3116f0c*/ string[] Split(char separator, System.StringSplitOptions options);
        /*0x3117350*/ string[] Split(char[] separator);
        /*0x31173c4*/ string[] Split(char[] separator, System.StringSplitOptions options);
        /*0x311743c*/ string[] Split(char[] separator, int count, System.StringSplitOptions options);
        /*0x3116f6c*/ string[] SplitInternal(System.ReadOnlySpan<char> separators, int count, System.StringSplitOptions options);
        /*0x3117c44*/ string[] Split(string separator, System.StringSplitOptions options);
        /*0x31181ec*/ string[] Split(string[] separator, System.StringSplitOptions options);
        /*0x3117c78*/ string[] SplitInternal(string separator, string[] separators, int count, System.StringSplitOptions options);
        /*0x3118200*/ string[] SplitInternal(string separator, int count, System.StringSplitOptions options);
        /*0x31177a8*/ string[] SplitKeepEmptyEntries(System.ReadOnlySpan<int> sepList, System.ReadOnlySpan<int> lengthList, int defaultLength, int count);
        /*0x311798c*/ string[] SplitOmitEmptyEntries(System.ReadOnlySpan<int> sepList, System.ReadOnlySpan<int> lengthList, int defaultLength, int count);
        /*0x31174c0*/ void MakeSeparatorList(System.ReadOnlySpan<char> separators, ref System.Collections.Generic.ValueListBuilder<int> sepListBuilder);
        /*0x311868c*/ void MakeSeparatorList(string separator, ref System.Collections.Generic.ValueListBuilder<int> sepListBuilder);
        /*0x3118474*/ void MakeSeparatorList(string[] separators, ref System.Collections.Generic.ValueListBuilder<int> sepListBuilder, ref System.Collections.Generic.ValueListBuilder<int> lengthListBuilder);
        /*0x3118830*/ string Substring(int startIndex);
        /*0x31165f8*/ string Substring(int startIndex, int length);
        /*0x311892c*/ string InternalSubString(int startIndex, int length);
        /*0x3118984*/ string ToLower();
        /*0x3118a08*/ string ToLower(System.Globalization.CultureInfo culture);
        /*0x3118a94*/ string ToLowerInvariant();
        /*0x3118b18*/ string ToUpper();
        /*0x3118b9c*/ string ToUpper(System.Globalization.CultureInfo culture);
        /*0x3118c28*/ string ToUpperInvariant();
        /*0x3118cac*/ string Trim();
        /*0x3118dcc*/ string Trim(char trimChar);
        /*0x3118f50*/ string Trim(char[] trimChars);
        /*0x3118f7c*/ string TrimStart(char trimChar);
        /*0x3118f9c*/ string TrimStart(char[] trimChars);
        /*0x3118fc8*/ string TrimEnd();
        /*0x3118fd0*/ string TrimEnd(char trimChar);
        /*0x3118ff0*/ string TrimEnd(char[] trimChars);
        /*0x3118cb4*/ string TrimWhiteSpaceHelper(System.String.TrimType trimType);
        /*0x3118dec*/ string TrimHelper(char* trimChars, int trimCharsLength, System.String.TrimType trimType);
        /*0x311901c*/ string CreateTrimmedString(int start, int end);
        /*0x3119050*/ bool Contains(string value);
        /*0x3119084*/ bool Contains(string value, System.StringComparison comparisonType);
        /*0x31190a8*/ bool Contains(char value);
        /*0x31190cc*/ int IndexOf(char value);
        /*0x31190dc*/ int IndexOf(char value, int startIndex);
        /*0x31190e8*/ int IndexOf(char value, int startIndex, int count);
        /*0x31191c0*/ int IndexOfAny(char[] anyOf);
        /*0x3119398*/ int IndexOfAny(char[] anyOf, int startIndex);
        /*0x31191cc*/ int IndexOfAny(char[] anyOf, int startIndex, int count);
        /*0x31193a4*/ int IndexOfAny(char value1, char value2, int startIndex, int count);
        /*0x3119430*/ int IndexOfAny(char value1, char value2, char value3, int startIndex, int count);
        /*0x3119494*/ int IndexOfCharArray(char[] anyOf, int startIndex, int count);
        /*0x3119640*/ int IndexOf(string value);
        /*0x3119650*/ int IndexOf(string value, int startIndex);
        /*0x3119670*/ int IndexOf(string value, int startIndex, int count);
        /*0x3119074*/ int IndexOf(string value, System.StringComparison comparisonType);
        /*0x3119660*/ int IndexOf(string value, int startIndex, System.StringComparison comparisonType);
        /*0x3119730*/ int IndexOf(string value, int startIndex, int count, System.StringComparison comparisonType);
        /*0x3119a90*/ int LastIndexOf(char value);
        /*0x3119aa0*/ int LastIndexOf(char value, int startIndex);
        /*0x3119aa8*/ int LastIndexOf(char value, int startIndex, int count);
        /*0x3119b8c*/ int LastIndexOfAny(char[] anyOf);
        /*0x3119cd0*/ int LastIndexOfAny(char[] anyOf, int startIndex);
        /*0x3119b98*/ int LastIndexOfAny(char[] anyOf, int startIndex, int count);
        /*0x3119cd8*/ int LastIndexOfCharArray(char[] anyOf, int startIndex, int count);
        /*0x3119e00*/ int LastIndexOf(string value);
        /*0x311a1c4*/ int LastIndexOf(string value, System.StringComparison comparisonType);
        /*0x3119e10*/ int LastIndexOf(string value, int startIndex, int count, System.StringComparison comparisonType);
        /*0x311a1d4*/ int get_Length();
        /*0x311a1dc*/ int IndexOfUnchecked(string value, int startIndex, int count);
        /*0x311a2ec*/ int IndexOfUncheckedIgnoreCase(string value, int startIndex, int count);
        /*0x311a4d4*/ int LastIndexOfUnchecked(string value, int startIndex, int count);
        /*0x311a5b0*/ int LastIndexOfUncheckedIgnoreCase(string value, int startIndex, int count);
        /*0x311a764*/ bool StartsWithOrdinalUnchecked(string value);
        /*0x3113700*/ string CreateString(sbyte* value, int startIndex, int length);
        /*0x311a8e0*/ string CreateString(char* value, int startIndex, int length);
        /*0x311a8f0*/ string CreateString(char[] val, int startIndex, int length);
        /*0x3111450*/ string CreateString(char[] val);
        /*0x311a900*/ string CreateString(char c, int count);
        /*0x311a90c*/ string CreateString(sbyte* value, int startIndex, int length, System.Text.Encoding enc);
        /*0x311a920*/ string CreateString(System.ReadOnlySpan<char> value);
        /*0x310e6c4*/ char get_Chars(int index);

        enum TrimType
        {
            Head = 0,
            Tail = 1,
            Both = 2,
        }

        struct ProbabilisticMap
        {
        }
    }

    class TimeZoneInfo : System.IEquatable<System.TimeZoneInfo>, System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IDeserializationCallback
    {
        static /*0x0*/ System.TimeZoneInfo s_utcTimeZone;
        static /*0x8*/ System.TimeZoneInfo.CachedData s_cachedData;
        static /*0x10*/ System.DateTime s_maxDateOnly;
        static /*0x18*/ System.DateTime s_minDateOnly;
        static /*0x20*/ System.TimeSpan MaxOffset;
        static /*0x28*/ System.TimeSpan MinOffset;
        /*0x10*/ string _id;
        /*0x18*/ string _displayName;
        /*0x20*/ string _standardDisplayName;
        /*0x28*/ string _daylightDisplayName;
        /*0x30*/ System.TimeSpan _baseUtcOffset;
        /*0x38*/ bool _supportsDaylightSavingTime;
        /*0x40*/ System.TimeZoneInfo.AdjustmentRule[] _adjustmentRules;

        static /*0x32010ac*/ TimeZoneInfo();
        static /*0x31f6168*/ void PopulateAllSystemTimeZones(System.TimeZoneInfo.CachedData cachedData);
        static /*0x31f6a40*/ System.TimeZoneInfo GetLocalTimeZone(System.TimeZoneInfo.CachedData cachedData);
        static /*0x31f6c10*/ System.TimeZoneInfo.TimeZoneInfoResult TryGetTimeZoneFromLocalMachine(string id, ref System.TimeZoneInfo value, ref System.Exception e);
        static /*0x31f64a4*/ System.Collections.Generic.List<string> GetTimeZoneIds(string timeZoneDirectory);
        static /*0x31f706c*/ bool TryGetLocalTzFile(ref byte[] rawData, ref string id);
        static /*0x31f724c*/ string GetTzEnvironmentVariable();
        static /*0x31f72e4*/ bool TryLoadTzFile(string tzFilePath, ref byte[] rawData, ref string id);
        static /*0x31f749c*/ string FindTimeZoneIdUsingReadLink(string tzFilePath);
        static /*0x31f7868*/ string GetDirectoryEntryFullPath(ref Interop.Sys.DirectoryEntry dirent, string currentPath);
        static /*0x31f7a50*/ void EnumerateFilesRecursively(string path, System.Predicate<string> condition);
        static /*0x31f75a8*/ string FindTimeZoneId(byte[] rawData);
        static /*0x31f7f8c*/ bool CompareTimeZoneFile(string filePath, byte[] buffer, byte[] rawData);
        static /*0x31f6a8c*/ System.TimeZoneInfo GetLocalTimeZoneFromTzFile();
        static /*0x31f6ec4*/ System.TimeZoneInfo GetTimeZoneFromTzData(byte[] rawData, string id);
        static /*0x31f6368*/ string GetTimeZoneDirectory();
        static /*0x31f8824*/ System.TimeZoneInfo FindSystemTimeZoneById(string id);
        static /*0x31f8cc0*/ System.TimeSpan GetDateTimeNowUtcOffsetFromUtc(System.DateTime time, ref bool isAmbiguousLocalDst);
        static /*0x31f56cc*/ void TZif_GenerateAdjustmentRules(ref System.TimeZoneInfo.AdjustmentRule[] rules, System.TimeSpan baseUtcOffset, System.DateTime[] dts, byte[] typeOfLocalTime, System.TimeZoneInfo.TZifType[] transitionType, bool[] StandardTime, bool[] GmtTime, string futureTransitionsPosixFormat);
        static /*0x31f9008*/ void TZif_GenerateAdjustmentRule(ref int index, System.TimeSpan timeZoneBaseUtcOffset, System.Collections.Generic.List<System.TimeZoneInfo.AdjustmentRule> rulesList, System.DateTime[] dts, byte[] typeOfLocalTime, System.TimeZoneInfo.TZifType[] transitionTypes, bool[] StandardTime, bool[] GmtTime, string futureTransitionsPosixFormat);
        static /*0x31f9734*/ System.TimeSpan TZif_CalculateTransitionOffsetFromBase(System.TimeSpan transitionOffset, System.TimeSpan timeZoneBaseUtcOffset);
        static /*0x31f9684*/ System.TimeZoneInfo.TZifType TZif_GetEarlyDateTransitionType(System.TimeZoneInfo.TZifType[] transitionTypes);
        static /*0x31f9bc0*/ System.TimeZoneInfo.AdjustmentRule TZif_CreateAdjustmentRuleForPosixFormat(string posixFormat, System.DateTime startTransitionDate, System.TimeSpan timeZoneBaseUtcOffset);
        static /*0x31fa2e4*/ System.Nullable<System.TimeSpan> TZif_ParseOffsetString(string offset);
        static /*0x31fa794*/ System.DateTime ParseTimeOfDay(string time);
        static /*0x31fa53c*/ System.Nullable<System.TimeZoneInfo.TransitionTime> TZif_CreateTransitionTimeFromPosixRule(string date, string time);
        static /*0x31faca0*/ void TZif_ParseJulianDay(string date, ref int month, ref int day);
        static /*0x31faa3c*/ bool TZif_ParseMDateRule(string dateRule, ref int month, ref int week, ref System.DayOfWeek dayOfWeek);
        static /*0x31fa050*/ bool TZif_ParsePosixFormat(string posixFormat, ref string standardName, ref string standardOffset, ref string daylightSavingsName, ref string daylightSavingsOffset, ref string start, ref string startTime, ref string end, ref string endTime);
        static /*0x31fae80*/ string TZif_ParsePosixName(string posixFormat, ref int index);
        static /*0x31fb0c4*/ string TZif_ParsePosixOffset(string posixFormat, ref int index);
        static /*0x31fb1d8*/ void TZif_ParsePosixDateTime(string posixFormat, ref int index, ref string date, ref string time);
        static /*0x31fb394*/ string TZif_ParsePosixDate(string posixFormat, ref int index);
        static /*0x31fb4a8*/ string TZif_ParsePosixTime(string posixFormat, ref int index);
        static /*0x31fb2e8*/ string TZif_ParsePosixString(string posixFormat, ref int index, System.Func<char, bool> breakCondition);
        static /*0x31f5668*/ string TZif_GetZoneAbbreviation(string zoneAbbreviations, int index);
        static /*0x31fb5bc*/ int TZif_ToInt32(byte[] value, int startIndex);
        static /*0x31fb5ec*/ long TZif_ToInt64(byte[] value, int startIndex);
        static /*0x31fb61c*/ long TZif_ToUnixTime(byte[] value, int startIndex, System.TimeZoneInfo.TZVersion version);
        static /*0x31fb6b4*/ System.DateTime TZif_UnixTimeToDateTime(long unixTime);
        static /*0x31f50b0*/ void TZif_ParseRaw(byte[] data, ref System.TimeZoneInfo.TZifHead t, ref System.DateTime[] dts, ref byte[] typeOfLocalTime, ref System.TimeZoneInfo.TZifType[] transitionType, ref string zoneAbbreviations, ref bool[] StandardTime, ref bool[] GmtTime, ref string futureTransitionsPosixFormat);
        static /*0x31fbe98*/ System.TimeSpan GetLocalUtcOffset(System.DateTime dateTime, System.TimeZoneInfoOptions flags);
        static /*0x31fc310*/ void ClearCachedData();
        static /*0x31fc39c*/ System.DateTime ConvertTime(System.DateTime dateTime, System.TimeZoneInfo destinationTimeZone);
        static /*0x31fc070*/ System.DateTime ConvertTime(System.DateTime dateTime, System.TimeZoneInfo sourceTimeZone, System.TimeZoneInfo destinationTimeZone, System.TimeZoneInfoOptions flags);
        static /*0x31fc528*/ System.DateTime ConvertTime(System.DateTime dateTime, System.TimeZoneInfo sourceTimeZone, System.TimeZoneInfo destinationTimeZone, System.TimeZoneInfoOptions flags, System.TimeZoneInfo.CachedData cachedData);
        static /*0x31fd668*/ System.DateTime ConvertTimeToUtc(System.DateTime dateTime, System.TimeZoneInfoOptions flags);
        static /*0x31fda24*/ System.Collections.ObjectModel.ReadOnlyCollection<System.TimeZoneInfo> GetSystemTimeZones();
        static /*0x31f8bc8*/ System.TimeZoneInfo get_Local();
        static /*0x31fdef0*/ System.TimeZoneInfo get_Utc();
        static /*0x31fe064*/ System.TimeZoneInfo CreateCustomTimeZone(string id, System.TimeSpan baseUtcOffset, string displayName, string standardDisplayName);
        static /*0x31fe0f8*/ System.TimeZoneInfo CreateCustomTimeZone(string id, System.TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, System.TimeZoneInfo.AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime);
        static /*0x31fd448*/ System.DateTime ConvertUtcToTimeZone(long ticks, System.TimeZoneInfo destinationTimeZone, ref bool isAmbiguousLocalDst);
        static /*0x31fd078*/ bool GetIsDaylightSavings(System.DateTime time, System.TimeZoneInfo.AdjustmentRule rule, System.Globalization.DaylightTimeStruct daylightTime, System.TimeZoneInfoOptions flags);
        static /*0x31ffc1c*/ bool GetIsDaylightSavingsFromUtc(System.DateTime time, int year, System.TimeSpan utc, System.TimeZoneInfo.AdjustmentRule rule, System.Nullable<int> ruleIndex, ref bool isAmbiguousLocalDst, System.TimeZoneInfo zone);
        static /*0x31ff498*/ bool CheckIsDst(System.DateTime startTime, System.DateTime time, System.DateTime endTime, bool ignoreYearAdjustment, System.TimeZoneInfo.AdjustmentRule rule);
        static /*0x31ff6d8*/ bool GetIsAmbiguousTime(System.DateTime time, System.TimeZoneInfo.AdjustmentRule rule, System.Globalization.DaylightTimeStruct daylightTime);
        static /*0x31fcc6c*/ bool GetIsInvalidTime(System.DateTime time, System.TimeZoneInfo.AdjustmentRule rule, System.Globalization.DaylightTimeStruct daylightTime);
        static /*0x31fc168*/ System.TimeSpan GetUtcOffset(System.DateTime time, System.TimeZoneInfo zone, System.TimeZoneInfoOptions flags);
        static /*0x31fc0f8*/ System.TimeSpan GetUtcOffsetFromUtc(System.DateTime time, System.TimeZoneInfo zone);
        static /*0x31fef18*/ System.TimeSpan GetUtcOffsetFromUtc(System.DateTime time, System.TimeZoneInfo zone, ref bool isDaylightSavings);
        static /*0x31f8d38*/ System.TimeSpan GetUtcOffsetFromUtc(System.DateTime time, System.TimeZoneInfo zone, ref bool isDaylightSavings, ref bool isAmbiguousLocalDst);
        static /*0x31fef98*/ System.DateTime TransitionTimeToDateTime(int year, System.TimeZoneInfo.TransitionTime transitionTime);
        static /*0x31f686c*/ System.TimeZoneInfo.TimeZoneInfoResult TryGetTimeZone(string id, bool dstDisabled, ref System.TimeZoneInfo value, ref System.Exception e, System.TimeZoneInfo.CachedData cachedData, bool alwaysFallbackToLocalMachine);
        static /*0x320045c*/ System.TimeZoneInfo.TimeZoneInfoResult TryGetTimeZoneFromLocalMachine(string id, bool dstDisabled, ref System.TimeZoneInfo value, ref System.Exception e, System.TimeZoneInfo.CachedData cachedData);
        static /*0x31f5858*/ void ValidateTimeZoneInfo(string id, System.TimeSpan baseUtcOffset, System.TimeZoneInfo.AdjustmentRule[] adjustmentRules, ref bool adjustmentRulesSupportDst);
        static /*0x3200694*/ bool UtcOffsetOutOfRange(System.TimeSpan offset);
        static /*0x32007c8*/ System.TimeSpan GetUtcOffset(System.TimeSpan baseUtcOffset, System.TimeZoneInfo.AdjustmentRule adjustmentRule);
        static /*0x31f98f0*/ bool IsValidAdjustmentRuleOffest(System.TimeSpan baseUtcOffset, System.TimeZoneInfo.AdjustmentRule adjustmentRule);
        static /*0x31f9964*/ void NormalizeAdjustmentRuleOffset(System.TimeSpan baseUtcOffset, ref System.TimeZoneInfo.AdjustmentRule adjustmentRule);
        static /*0x3200890*/ string GetTimeZoneDirectoryUnity();
        static /*0x32008a8*/ System.Collections.Generic.List<System.TimeZoneInfo.AdjustmentRule> CreateAdjustmentRule(int year, ref long[] data, ref string[] names);
        static /*0x31f8324*/ System.TimeZoneInfo CreateLocalUnity();
        /*0x31f4c18*/ TimeZoneInfo(byte[] data, string id, bool dstDisabled);
        /*0x31fdf48*/ TimeZoneInfo(string id, System.TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, System.TimeZoneInfo.AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime);
        /*0x31fe5a8*/ TimeZoneInfo(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x3201230*/ TimeZoneInfo();
        /*0x31f5ba0*/ System.TimeZoneInfo.AdjustmentRule[] GetAdjustmentRules();
        /*0x31fba90*/ string get_Id();
        /*0x31fba98*/ string get_DisplayName();
        /*0x31fbabc*/ string get_StandardName();
        /*0x31fbae0*/ string get_DaylightName();
        /*0x31fbb04*/ System.TimeSpan get_BaseUtcOffset();
        /*0x31fbb0c*/ bool get_SupportsDaylightSavingTime();
        /*0x31fbb14*/ System.TimeZoneInfo.AdjustmentRule GetPreviousAdjustmentRule(System.TimeZoneInfo.AdjustmentRule rule, System.Nullable<int> ruleIndex);
        /*0x31fbc8c*/ System.TimeSpan GetUtcOffset(System.DateTime dateTime);
        /*0x31fbf6c*/ System.TimeSpan GetUtcOffset(System.DateTime dateTime, System.TimeZoneInfoOptions flags);
        /*0x31fbd00*/ System.TimeSpan GetUtcOffset(System.DateTime dateTime, System.TimeZoneInfoOptions flags, System.TimeZoneInfo.CachedData cachedData);
        /*0x31fd75c*/ bool Equals(System.TimeZoneInfo other);
        /*0x31fd920*/ bool Equals(object obj);
        /*0x31fd984*/ int GetHashCode();
        /*0x31fd7ac*/ bool HasSameRules(System.TimeZoneInfo other);
        /*0x31fdecc*/ string ToString();
        /*0x31fe1fc*/ void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
        /*0x31fe3d0*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x31fc9d0*/ System.TimeZoneInfo.AdjustmentRule GetAdjustmentRuleForTime(System.DateTime dateTime, ref System.Nullable<int> ruleIndex);
        /*0x31fe9e8*/ System.TimeZoneInfo.AdjustmentRule GetAdjustmentRuleForTime(System.DateTime dateTime, bool dateTimeisUtc, ref System.Nullable<int> ruleIndex);
        /*0x31feba4*/ int CompareAdjustmentRuleToDateTime(System.TimeZoneInfo.AdjustmentRule rule, System.TimeZoneInfo.AdjustmentRule previousRule, System.DateTime dateTime, System.DateTime dateOnly, bool dateTimeisUtc);
        /*0x31fed54*/ System.DateTime ConvertToUtc(System.DateTime dateTime, System.TimeSpan daylightDelta, System.TimeSpan baseUtcOffsetDelta);
        /*0x31fef10*/ System.DateTime ConvertFromUtc(System.DateTime dateTime, System.TimeSpan daylightDelta, System.TimeSpan baseUtcOffsetDelta);
        /*0x31fed5c*/ System.DateTime ConvertToFromUtc(System.DateTime dateTime, System.TimeSpan daylightDelta, System.TimeSpan baseUtcOffsetDelta, bool convertToUtc);
        /*0x31fcb40*/ System.Globalization.DaylightTimeStruct GetDaylightTime(int year, System.TimeZoneInfo.AdjustmentRule rule, System.Nullable<int> ruleIndex);
        /*0x31ffadc*/ System.TimeSpan GetDaylightSavingsStartOffsetFromUtc(System.TimeSpan baseUtcOffset, System.TimeZoneInfo.AdjustmentRule rule, System.Nullable<int> ruleIndex);
        /*0x31ffba4*/ System.TimeSpan GetDaylightSavingsEndOffsetFromUtc(System.TimeSpan baseUtcOffset, System.TimeZoneInfo.AdjustmentRule rule);

        struct TZifType
        {
            /*0x10*/ System.TimeSpan UtcOffset;
            /*0x18*/ bool IsDst;
            /*0x19*/ byte AbbreviationIndex;

            /*0x31fb954*/ TZifType(byte[] data, int index);
        }

        struct TZifHead
        {
            /*0x10*/ uint Magic;
            /*0x14*/ System.TimeZoneInfo.TZVersion Version;
            /*0x18*/ uint IsGmtCount;
            /*0x1c*/ uint IsStdCount;
            /*0x20*/ uint LeapCount;
            /*0x24*/ uint TimeCount;
            /*0x28*/ uint TypeCount;
            /*0x2c*/ uint CharCount;

            /*0x31fb7a8*/ TZifHead(byte[] data, int index);
        }

        enum TZVersion
        {
            V1 = 0,
            V2 = 1,
            V3 = 2,
        }

        class AdjustmentRule : System.IEquatable<System.TimeZoneInfo.AdjustmentRule>, System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IDeserializationCallback
        {
            /*0x10*/ System.DateTime _dateStart;
            /*0x18*/ System.DateTime _dateEnd;
            /*0x20*/ System.TimeSpan _daylightDelta;
            /*0x28*/ System.TimeZoneInfo.TransitionTime _daylightTransitionStart;
            /*0x40*/ System.TimeZoneInfo.TransitionTime _daylightTransitionEnd;
            /*0x58*/ System.TimeSpan _baseUtcOffsetDelta;
            /*0x60*/ bool _noDaylightTransitions;

            static /*0x31f6080*/ System.TimeZoneInfo.AdjustmentRule CreateAdjustmentRule(System.DateTime dateStart, System.DateTime dateEnd, System.TimeSpan daylightDelta, System.TimeZoneInfo.TransitionTime daylightTransitionStart, System.TimeZoneInfo.TransitionTime daylightTransitionEnd);
            static /*0x31f9828*/ System.TimeZoneInfo.AdjustmentRule CreateAdjustmentRule(System.DateTime dateStart, System.DateTime dateEnd, System.TimeSpan daylightDelta, System.TimeZoneInfo.TransitionTime daylightTransitionStart, System.TimeZoneInfo.TransitionTime daylightTransitionEnd, System.TimeSpan baseUtcOffsetDelta, bool noDaylightTransitions);
            static /*0x32014e0*/ void ValidateAdjustmentRule(System.DateTime dateStart, System.DateTime dateEnd, System.TimeSpan daylightDelta, System.TimeZoneInfo.TransitionTime daylightTransitionStart, System.TimeZoneInfo.TransitionTime daylightTransitionEnd, bool noDaylightTransitions);
            /*0x320141c*/ AdjustmentRule(System.DateTime dateStart, System.DateTime dateEnd, System.TimeSpan daylightDelta, System.TimeZoneInfo.TransitionTime daylightTransitionStart, System.TimeZoneInfo.TransitionTime daylightTransitionEnd, System.TimeSpan baseUtcOffsetDelta, bool noDaylightTransitions);
            /*0x3201d80*/ AdjustmentRule(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x3202168*/ AdjustmentRule();
            /*0x3201268*/ System.DateTime get_DateStart();
            /*0x3201270*/ System.DateTime get_DateEnd();
            /*0x3201278*/ System.TimeSpan get_DaylightDelta();
            /*0x3201280*/ System.TimeZoneInfo.TransitionTime get_DaylightTransitionStart();
            /*0x3201294*/ System.TimeZoneInfo.TransitionTime get_DaylightTransitionEnd();
            /*0x32012a8*/ System.TimeSpan get_BaseUtcOffsetDelta();
            /*0x32012b0*/ bool get_NoDaylightTransitions();
            /*0x31fc9dc*/ bool get_HasDaylightSaving();
            /*0x31fdd68*/ bool Equals(System.TimeZoneInfo.AdjustmentRule other);
            /*0x32013c4*/ int GetHashCode();
            /*0x31ff268*/ bool IsStartDateMarkerForBeginningOfYear();
            /*0x31ff380*/ bool IsEndDateMarkerForEndOfYear();
            /*0x3201a2c*/ void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
            /*0x3201b40*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        struct TransitionTime : System.IEquatable<System.TimeZoneInfo.TransitionTime>, System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IDeserializationCallback
        {
            /*0x10*/ System.DateTime _timeOfDay;
            /*0x18*/ byte _month;
            /*0x19*/ byte _week;
            /*0x1a*/ byte _day;
            /*0x1c*/ System.DayOfWeek _dayOfWeek;
            /*0x20*/ bool _isFixedDateRule;

            static /*0x32012b8*/ bool op_Inequality(System.TimeZoneInfo.TransitionTime t1, System.TimeZoneInfo.TransitionTime t2);
            static /*0x31f6020*/ System.TimeZoneInfo.TransitionTime CreateFixedDateRule(System.DateTime timeOfDay, int month, int day);
            static /*0x31fac38*/ System.TimeZoneInfo.TransitionTime CreateFloatingDateRule(System.DateTime timeOfDay, int month, int week, System.DayOfWeek dayOfWeek);
            static /*0x32022d8*/ void ValidateTransitionTime(System.DateTime timeOfDay, int month, int week, int day, System.DayOfWeek dayOfWeek);
            /*0x3202268*/ TransitionTime(System.DateTime timeOfDay, int month, int week, int day, System.DayOfWeek dayOfWeek, bool isFixedDateRule);
            /*0x320281c*/ TransitionTime(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x32021a0*/ System.DateTime get_TimeOfDay();
            /*0x32021a8*/ int get_Month();
            /*0x32021b0*/ int get_Week();
            /*0x32021b8*/ int get_Day();
            /*0x32021c0*/ System.DayOfWeek get_DayOfWeek();
            /*0x32021c8*/ bool get_IsFixedDateRule();
            /*0x32021d0*/ bool Equals(object obj);
            /*0x32012ec*/ bool Equals(System.TimeZoneInfo.TransitionTime other);
            /*0x3202260*/ int GetHashCode();
            /*0x3202588*/ void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
            /*0x3202674*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        enum TimeZoneInfoResult
        {
            Success = 0,
            TimeZoneNotFoundException = 1,
            InvalidTimeZoneException = 2,
            SecurityException = 3,
        }

        class CachedData
        {
            /*0x10*/ System.TimeZoneInfo _localTimeZone;
            /*0x18*/ System.Collections.Generic.Dictionary<string, System.TimeZoneInfo> _systemTimeZones;
            /*0x20*/ System.Collections.ObjectModel.ReadOnlyCollection<System.TimeZoneInfo> _readOnlySystemTimeZones;
            /*0x28*/ bool _allSystemTimeZonesRead;

            /*0x31fc394*/ CachedData();
            /*0x3202b48*/ System.TimeZoneInfo CreateLocal();
            /*0x31fbf34*/ System.TimeZoneInfo get_Local();
            /*0x31fbfe4*/ System.DateTimeKind GetCorrespondingKind(System.TimeZoneInfo timeZone);
        }

        class <>c__DisplayClass16_0
        {
            /*0x10*/ string localtimeFilePath;
            /*0x18*/ string posixrulesFilePath;
            /*0x20*/ byte[] buffer;
            /*0x28*/ byte[] rawData;
            /*0x30*/ string id;
            /*0x38*/ string timeZoneDirectory;

            /*0x31f7f84*/ <>c__DisplayClass16_0();
            /*0x3202cd8*/ bool <FindTimeZoneId>b__0(string filePath);
        }

        class <>c
        {
            static /*0x0*/ System.TimeZoneInfo.<> <>9;
            static /*0x8*/ System.Func<char, bool> <>9__34_1;
            static /*0x10*/ System.Func<char, bool> <>9__34_0;
            static /*0x18*/ System.Func<char, bool> <>9__35_0;
            static /*0x20*/ System.Func<char, bool> <>9__37_0;
            static /*0x28*/ System.Func<char, bool> <>9__38_0;
            static /*0x30*/ System.Comparison<System.TimeZoneInfo> <>9__113_0;
            static /*0x38*/ System.Comparison<System.TimeZoneInfo.AdjustmentRule> <>9__161_0;

            static /*0x3202de8*/ <>c();
            /*0x3202e50*/ <>c();
            /*0x3202e58*/ bool <TZif_ParsePosixName>b__34_1(char c);
            /*0x3202e68*/ bool <TZif_ParsePosixName>b__34_0(char c);
            /*0x3202f10*/ bool <TZif_ParsePosixOffset>b__35_0(char c);
            /*0x3202f70*/ bool <TZif_ParsePosixDate>b__37_0(char c);
            /*0x3202f88*/ bool <TZif_ParsePosixTime>b__38_0(char c);
            /*0x3202f98*/ int <GetSystemTimeZones>b__113_0(System.TimeZoneInfo x, System.TimeZoneInfo y);
            /*0x3203064*/ int <CreateLocalUnity>b__161_0(System.TimeZoneInfo.AdjustmentRule rule1, System.TimeZoneInfo.AdjustmentRule rule2);
        }
    }

    class AccessViolationException : System.SystemException
    {
        /*0x32030ec*/ AccessViolationException();
        /*0x3203148*/ AccessViolationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class Action : System.MulticastDelegate
    {
        /*0x3203150*/ Action(object object, nint method);
        /*0x32031ec*/ void Invoke();
    }

    class Action<T> : System.MulticastDelegate
    {
        Action(object object, nint method);
        /*0x1ffc854*/ void Invoke(T obj);
    }

    class Action<T1, T2> : System.MulticastDelegate
    {
        Action(object object, nint method);
        /*0x1ffc854*/ void Invoke(T1 arg1, T2 arg2);
    }

    class Action<T1, T2, T3> : System.MulticastDelegate
    {
        Action(object object, nint method);
        /*0x1ffc854*/ void Invoke(T1 arg1, T2 arg2, T3 arg3);
    }

    class Action<T1, T2, T3, T4> : System.MulticastDelegate
    {
        Action(object object, nint method);
        /*0x1ffc854*/ void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    }

    class Action<T1, T2, T3, T4, T5> : System.MulticastDelegate
    {
        Action(object object, nint method);
        /*0x1ffc854*/ void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    }

    class Action<T1, T2, T3, T4, T5, T6> : System.MulticastDelegate
    {
        Action(object object, nint method);
        /*0x1ffc854*/ void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    }

    class Action<T1, T2, T3, T4, T5, T6, T7> : System.MulticastDelegate
    {
        Action(object object, nint method);
        /*0x1ffc854*/ void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    }

    class Action<T1, T2, T3, T4, T5, T6, T7, T8> : System.MulticastDelegate
    {
        Action(object object, nint method);
        /*0x1ffc854*/ void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    }

    class Func<TResult> : System.MulticastDelegate
    {
        Func(object object, nint method);
        /*0x1ffc854*/ TResult Invoke();
    }

    class Func<T, TResult> : System.MulticastDelegate
    {
        Func(object object, nint method);
        /*0x1ffc854*/ TResult Invoke(T arg);
    }

    class Func<T1, T2, TResult> : System.MulticastDelegate
    {
        Func(object object, nint method);
        /*0x1ffc854*/ TResult Invoke(T1 arg1, T2 arg2);
    }

    class Func<T1, T2, T3, TResult> : System.MulticastDelegate
    {
        Func(object object, nint method);
        /*0x1ffc854*/ TResult Invoke(T1 arg1, T2 arg2, T3 arg3);
    }

    class Func<T1, T2, T3, T4, TResult> : System.MulticastDelegate
    {
        Func(object object, nint method);
        /*0x1ffc854*/ TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    }

    class Func<T1, T2, T3, T4, T5, TResult> : System.MulticastDelegate
    {
        Func(object object, nint method);
        /*0x1ffc854*/ TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    }

    class Func<T1, T2, T3, T4, T5, T6, TResult> : System.MulticastDelegate
    {
        Func(object object, nint method);
        /*0x1ffc854*/ TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    }

    class Func<T1, T2, T3, T4, T5, T6, T7, TResult> : System.MulticastDelegate
    {
        Func(object object, nint method);
        /*0x1ffc854*/ TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    }

    class Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult> : System.MulticastDelegate
    {
        Func(object object, nint method);
        /*0x1ffc854*/ TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    }

    class Comparison<T> : System.MulticastDelegate
    {
        Comparison(object object, nint method);
        /*0x1ffc854*/ int Invoke(T x, T y);
    }

    class Converter<TInput, TOutput> : System.MulticastDelegate
    {
        Converter(object object, nint method);
        /*0x1ffc854*/ TOutput Invoke(TInput input);
    }

    class Predicate<T> : System.MulticastDelegate
    {
        Predicate(object object, nint method);
        /*0x1ffc854*/ bool Invoke(T obj);
    }

    class AggregateException : System.Exception
    {
        /*0x90*/ System.Collections.ObjectModel.ReadOnlyCollection<System.Exception> m_innerExceptions;

        /*0x3203200*/ AggregateException();
        /*0x3203334*/ AggregateException(System.Collections.Generic.IEnumerable<System.Exception> innerExceptions);
        /*0x3203448*/ AggregateException(System.Exception[] innerExceptions);
        /*0x320338c*/ AggregateException(string message, System.Collections.Generic.IEnumerable<System.Exception> innerExceptions);
        /*0x32034a0*/ AggregateException(string message, System.Exception[] innerExceptions);
        /*0x32034a4*/ AggregateException(string message, System.Collections.Generic.IList<System.Exception> innerExceptions);
        /*0x32038b0*/ AggregateException(System.Collections.Generic.IEnumerable<System.Runtime.ExceptionServices.ExceptionDispatchInfo> innerExceptionInfos);
        /*0x3203908*/ AggregateException(string message, System.Collections.Generic.IEnumerable<System.Runtime.ExceptionServices.ExceptionDispatchInfo> innerExceptionInfos);
        /*0x32039c4*/ AggregateException(string message, System.Collections.Generic.IList<System.Runtime.ExceptionServices.ExceptionDispatchInfo> innerExceptionInfos);
        /*0x3203e24*/ AggregateException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x3203ff8*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x3204138*/ System.Exception GetBaseException();
        /*0x32041e4*/ System.Collections.ObjectModel.ReadOnlyCollection<System.Exception> get_InnerExceptions();
        /*0x32041ec*/ System.AggregateException Flatten();
        /*0x32044f0*/ string get_Message();
        /*0x3204688*/ string ToString();
    }

    class ApplicationException : System.Exception
    {
        /*0x3204898*/ ApplicationException();
        /*0x3204918*/ ApplicationException(string message);
        /*0x3204990*/ ApplicationException(string message, System.Exception innerException);
        /*0x3204a10*/ ApplicationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class ArgumentException : System.SystemException
    {
        /*0x90*/ string _paramName;

        /*0x3204a90*/ ArgumentException();
        /*0x320388c*/ ArgumentException(string message);
        /*0x3204aec*/ ArgumentException(string message, System.Exception innerException);
        /*0x3204b10*/ ArgumentException(string message, string paramName, System.Exception innerException);
        /*0x31fc990*/ ArgumentException(string message, string paramName);
        /*0x3204b54*/ ArgumentException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x3204be4*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x3204c98*/ string get_Message();
    }

    class ArgumentNullException : System.ArgumentException
    {
        /*0x3204d38*/ ArgumentNullException();
        /*0x31f8c48*/ ArgumentNullException(string paramName);
        /*0x3204d94*/ ArgumentNullException(string paramName, string message);
        /*0x3204dd8*/ ArgumentNullException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class ArgumentOutOfRangeException : System.ArgumentException
    {
        /*0x98*/ object _actualValue;

        /*0x3204ddc*/ ArgumentOutOfRangeException();
        /*0x3204e38*/ ArgumentOutOfRangeException(string paramName);
        /*0x3200784*/ ArgumentOutOfRangeException(string paramName, string message);
        /*0x32019c8*/ ArgumentOutOfRangeException(string paramName, object actualValue, string message);
        /*0x3204eb0*/ ArgumentOutOfRangeException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x3204f68*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x3205018*/ string get_Message();
    }

    class ArithmeticException : System.SystemException
    {
        /*0x32050c4*/ ArithmeticException();
        /*0x3205120*/ ArithmeticException(string message);
        /*0x3205144*/ ArithmeticException(string message, System.Exception innerException);
        /*0x3205168*/ ArithmeticException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    struct ArraySegment<T> : System.Collections.Generic.IList<T>, System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyList<T>, System.Collections.Generic.IReadOnlyCollection<T>
    {
        static /*0x0*/ System.ArraySegment<T> <Empty>k__BackingField;
        /*0x0*/ T[] _array;
        /*0x0*/ int _offset;
        /*0x0*/ int _count;

        static /*0x1f33998*/ ArraySegment();
        static /*0x1ffc854*/ System.ArraySegment<T> get_Empty();
        /*0x1f30ebc*/ ArraySegment(T[] array);
        ArraySegment(T[] array, int offset, int count);
        /*0x1f30214*/ T[] get_Array();
        /*0x1f2ffc8*/ int get_Offset();
        /*0x1f2ffc8*/ int get_Count();
        /*0x1ffc854*/ System.ArraySegment.Enumerator<T> GetEnumerator();
        /*0x1f2ffc8*/ int GetHashCode();
        /*0x1f30ee8*/ void CopyTo(T[] destination, int destinationIndex);
        /*0x1f2fec8*/ bool Equals(object obj);
        /*0x1ffc854*/ bool Equals(System.ArraySegment<T> obj);
        /*0x1ffc854*/ T System.Collections.Generic.IList<T>.get_Item(int index);
        /*0x1ffc854*/ void System.Collections.Generic.IList<T>.set_Item(int index, T value);
        /*0x1ffc854*/ int System.Collections.Generic.IList<T>.IndexOf(T item);
        /*0x1ffc854*/ void System.Collections.Generic.IList<T>.Insert(int index, T item);
        /*0x1f30b78*/ void System.Collections.Generic.IList<T>.RemoveAt(int index);
        /*0x1ffc854*/ T System.Collections.Generic.IReadOnlyList<T>.get_Item(int index);
        /*0x1f2fe14*/ bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
        /*0x1ffc854*/ void System.Collections.Generic.ICollection<T>.Add(T item);
        /*0x1f309e4*/ void System.Collections.Generic.ICollection<T>.Clear();
        /*0x1ffc854*/ bool System.Collections.Generic.ICollection<T>.Contains(T item);
        /*0x1ffc854*/ bool System.Collections.Generic.ICollection<T>.Remove(T item);
        /*0x1f30214*/ System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
        /*0x1f30214*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
        /*0x1f309e4*/ void ThrowInvalidOperationIfDefault();

        struct Enumerator<T> : System.Collections.Generic.IEnumerator<T>, System.IDisposable, System.Collections.IEnumerator
        {
            /*0x0*/ T[] _array;
            /*0x0*/ int _start;
            /*0x0*/ int _end;
            /*0x0*/ int _current;

            /*0x1ffc854*/ Enumerator(System.ArraySegment<T> arraySegment);
            /*0x1f2fe14*/ bool MoveNext();
            /*0x1ffc854*/ T get_Current();
            /*0x1f30214*/ object System.Collections.IEnumerator.get_Current();
            /*0x1f309e4*/ void System.Collections.IEnumerator.Reset();
            /*0x1f309e4*/ void Dispose();
        }
    }

    class ArrayTypeMismatchException : System.SystemException
    {
        /*0x3205170*/ ArrayTypeMismatchException();
        /*0x32051cc*/ ArrayTypeMismatchException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class AssemblyLoadEventArgs : System.EventArgs
    {
        /*0x10*/ System.Reflection.Assembly <LoadedAssembly>k__BackingField;

        /*0x32051d4*/ AssemblyLoadEventArgs(System.Reflection.Assembly loadedAssembly);
    }

    class AssemblyLoadEventHandler : System.MulticastDelegate
    {
        /*0x3205248*/ AssemblyLoadEventHandler(object object, nint method);
        /*0x3205354*/ void Invoke(object sender, System.AssemblyLoadEventArgs args);
    }

    class AsyncCallback : System.MulticastDelegate
    {
        /*0x3205368*/ AsyncCallback(object object, nint method);
        /*0x3205470*/ void Invoke(System.IAsyncResult ar);
        /*0x3205484*/ System.IAsyncResult BeginInvoke(System.IAsyncResult ar, System.AsyncCallback callback, object object);
        /*0x32054a4*/ void EndInvoke(System.IAsyncResult result);
    }

    enum AttributeTargets
    {
        Assembly = 1,
        Module = 2,
        Class = 4,
        Struct = 8,
        Enum = 16,
        Constructor = 32,
        Method = 64,
        Property = 128,
        Field = 256,
        Event = 512,
        Interface = 1024,
        Parameter = 2048,
        Delegate = 4096,
        ReturnValue = 8192,
        GenericParameter = 16384,
        All = 32767,
    }

    class AttributeUsageAttribute : System.Attribute
    {
        static /*0x0*/ System.AttributeUsageAttribute Default;
        /*0x10*/ System.AttributeTargets _attributeTarget;
        /*0x14*/ bool _allowMultiple;
        /*0x15*/ bool _inherited;

        static /*0x3205508*/ AttributeUsageAttribute();
        /*0x32054b0*/ AttributeUsageAttribute(System.AttributeTargets validOn);
        /*0x32054e8*/ bool get_AllowMultiple();
        /*0x32054f0*/ void set_AllowMultiple(bool value);
        /*0x32054f8*/ bool get_Inherited();
        /*0x3205500*/ void set_Inherited(bool value);
    }

    class BadImageFormatException : System.SystemException
    {
        /*0x90*/ string _fileName;
        /*0x98*/ string _fusionLog;

        /*0x3205584*/ BadImageFormatException();
        /*0x32055e0*/ BadImageFormatException(string message);
        /*0x3205604*/ BadImageFormatException(string message, System.Exception inner);
        /*0x3205628*/ BadImageFormatException(string message, string fileName);
        /*0x3205664*/ BadImageFormatException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x3205728*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x320581c*/ string get_Message();
        /*0x3205834*/ void SetMessageField();
        /*0x32058c4*/ string ToString();
    }

    class BitConverter
    {
        static /*0x0*/ bool IsLittleEndian;

        static /*0x3206514*/ BitConverter();
        static /*0x3205aa8*/ byte[] GetBytes(bool value);
        static /*0x3205b10*/ byte[] GetBytes(char value);
        static /*0x3205b74*/ byte[] GetBytes(short value);
        static /*0x3205bd8*/ byte[] GetBytes(int value);
        static /*0x3205c3c*/ byte[] GetBytes(long value);
        static /*0x3205ca0*/ byte[] GetBytes(ushort value);
        static /*0x3205d04*/ byte[] GetBytes(uint value);
        static /*0x3205d68*/ bool TryWriteBytes(System.Span<byte> destination, uint value);
        static /*0x3205de8*/ byte[] GetBytes(ulong value);
        static /*0x3205e4c*/ byte[] GetBytes(float value);
        static /*0x3205eb8*/ byte[] GetBytes(double value);
        static /*0x3205f24*/ char ToChar(byte[] value, int startIndex);
        static /*0x3205f28*/ short ToInt16(byte[] value, int startIndex);
        static /*0x3205fac*/ int ToInt32(byte[] value, int startIndex);
        static /*0x3206030*/ int ToInt32(System.ReadOnlySpan<byte> value);
        static /*0x32060a8*/ long ToInt64(byte[] value, int startIndex);
        static /*0x320612c*/ ushort ToUInt16(byte[] value, int startIndex);
        static /*0x3206130*/ uint ToUInt32(byte[] value, int startIndex);
        static /*0x3206134*/ ulong ToUInt64(byte[] value, int startIndex);
        static /*0x3206138*/ float ToSingle(byte[] value, int startIndex);
        static /*0x320614c*/ double ToDouble(byte[] value, int startIndex);
        static /*0x3206160*/ string ToString(byte[] value, int startIndex, int length);
        static /*0x3206440*/ string ToString(byte[] value);
        static /*0x3206464*/ bool ToBoolean(byte[] value, int startIndex);
        static /*0x32064f4*/ long DoubleToInt64Bits(double value);
        static /*0x32064fc*/ double Int64BitsToDouble(long value);
        static /*0x3206504*/ int SingleToInt32Bits(float value);
        static /*0x320650c*/ float Int32BitsToSingle(int value);

        class <>c
        {
            static /*0x0*/ System.BitConverter.<> <>9;
            static /*0x8*/ System.Buffers.SpanAction<char, System.ValueTuple<System.Byte[], int, int>> <>9__38_0;

            static /*0x3206560*/ <>c();
            /*0x32065c8*/ <>c();
            /*0x32065d0*/ void <ToString>b__38_0(System.Span<char> dst, System.ValueTuple<System.Byte[], int, int> state);
        }
    }

    struct Boolean : System.IComparable, System.IConvertible, System.IComparable<bool>, System.IEquatable<bool>
    {
        static /*0x0*/ string TrueString;
        static /*0x8*/ string FalseString;
        /*0x10*/ bool m_value;

        static /*0x3208168*/ Boolean();
        static /*0x3206968*/ bool Parse(string value);
        static /*0x3206a20*/ bool Parse(System.ReadOnlySpan<char> value);
        static /*0x3206da8*/ bool TryParse(string value, ref bool result);
        static /*0x3206ab8*/ bool TryParse(System.ReadOnlySpan<char> value, ref bool result);
        static /*0x3206e34*/ System.ReadOnlySpan<char> TrimWhiteSpaceAndNull(System.ReadOnlySpan<char> value);
        /*0x3206790*/ int GetHashCode();
        /*0x32067a0*/ string ToString();
        /*0x320680c*/ string ToString(System.IFormatProvider provider);
        /*0x320683c*/ bool Equals(object obj);
        /*0x3206884*/ bool Equals(bool obj);
        /*0x3206898*/ int CompareTo(object obj);
        /*0x3206948*/ int CompareTo(bool value);
        /*0x3207030*/ System.TypeCode GetTypeCode();
        /*0x3207038*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x3207048*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x32070cc*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x3207130*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x3207194*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x32071f8*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x320725c*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x32072c0*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x3207324*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x3207388*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x32073ec*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x3207464*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x32074dc*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x3207590*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x3207614*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);
    }

    struct Byte : System.IComparable, System.IConvertible, System.IFormattable, System.IComparable<byte>, System.IEquatable<byte>, System.ISpanFormattable
    {
        /*0x10*/ byte m_value;

        static /*0x32082d8*/ byte Parse(string s, System.IFormatProvider provider);
        static /*0x32084f8*/ byte Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x3208364*/ byte Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo info);
        static /*0x320859c*/ bool TryParse(string s, ref byte result);
        static /*0x32086d8*/ bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref byte result);
        static /*0x320861c*/ bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo info, ref byte result);
        /*0x32081e4*/ int CompareTo(object value);
        /*0x320826c*/ int CompareTo(byte value);
        /*0x3208278*/ bool Equals(object obj);
        /*0x32082c0*/ bool Equals(byte obj);
        /*0x32082d0*/ int GetHashCode();
        /*0x3208780*/ string ToString();
        /*0x3208818*/ string ToString(string format);
        /*0x32088cc*/ string ToString(System.IFormatProvider provider);
        /*0x3208968*/ string ToString(string format, System.IFormatProvider provider);
        /*0x3208a20*/ bool TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        /*0x3208ac4*/ System.TypeCode GetTypeCode();
        /*0x3208acc*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x3208b34*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x3208b94*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x3208c48*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x3208c50*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x3208cb0*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x3208d10*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x3208d70*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x3208dd0*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x3208e30*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x3208e90*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x3208ef4*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x3208f58*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x3209008*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x320908c*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);
    }

    class CLSCompliantAttribute : System.Attribute
    {
        /*0x10*/ bool _compliant;

        /*0x3209128*/ CLSCompliantAttribute(bool isCompliant);
    }

    struct Char : System.IComparable, System.IComparable<char>, System.IEquatable<char>, System.IConvertible
    {
        static /*0x0*/ byte[] s_categoryForLatin1;
        /*0x10*/ char m_value;

        static /*0x320abf8*/ Char();
        static /*0x3209150*/ bool IsLatin1(char ch);
        static /*0x3209160*/ bool IsAscii(char ch);
        static /*0x3209170*/ System.Globalization.UnicodeCategory GetLatin1UnicodeCategory(char ch);
        static /*0x32092c8*/ string ToString(char c);
        static /*0x3209304*/ char Parse(string s);
        static /*0x32093a0*/ bool TryParse(string s, ref char result);
        static /*0x3202eb0*/ bool IsDigit(char c);
        static /*0x32093e4*/ bool CheckLetter(System.Globalization.UnicodeCategory uc);
        static /*0x32093f0*/ bool IsLetter(char c);
        static /*0x32094ac*/ bool IsWhiteSpaceLatin1(char c);
        static /*0x3206fa0*/ bool IsWhiteSpace(char c);
        static /*0x32094d8*/ bool IsUpper(char c);
        static /*0x3209578*/ bool IsLower(char c);
        static /*0x3209618*/ bool CheckPunctuation(System.Globalization.UnicodeCategory uc);
        static /*0x3209628*/ bool IsPunctuation(char c);
        static /*0x32096b8*/ bool CheckLetterOrDigit(System.Globalization.UnicodeCategory uc);
        static /*0x32096d0*/ bool IsLetterOrDigit(char c);
        static /*0x3209780*/ char ToUpper(char c, System.Globalization.CultureInfo culture);
        static /*0x3209808*/ char ToUpper(char c);
        static /*0x320988c*/ char ToUpperInvariant(char c);
        static /*0x3209910*/ char ToLower(char c, System.Globalization.CultureInfo culture);
        static /*0x3209998*/ char ToLower(char c);
        static /*0x3209a1c*/ char ToLowerInvariant(char c);
        static /*0x320a1e8*/ bool IsControl(char c);
        static /*0x320a258*/ bool CheckNumber(System.Globalization.UnicodeCategory uc);
        static /*0x320a268*/ bool IsNumber(char c);
        static /*0x320a324*/ bool IsNumber(string s, int index);
        static /*0x320a488*/ bool CheckSeparator(System.Globalization.UnicodeCategory uc);
        static /*0x320a498*/ bool IsSeparatorLatin1(char c);
        static /*0x320a4ac*/ bool IsSeparator(char c);
        static /*0x320a53c*/ bool IsSurrogate(char c);
        static /*0x320a54c*/ bool IsSurrogate(string s, int index);
        static /*0x320a610*/ bool IsWhiteSpace(string s, int index);
        static /*0x320a75c*/ System.Globalization.UnicodeCategory GetUnicodeCategory(char c);
        static /*0x320a7c0*/ System.Globalization.UnicodeCategory GetUnicodeCategory(string s, int index);
        static /*0x320a8e4*/ bool IsHighSurrogate(char c);
        static /*0x320a8f4*/ bool IsHighSurrogate(string s, int index);
        static /*0x320a9bc*/ bool IsLowSurrogate(char c);
        static /*0x320a9cc*/ bool IsSurrogatePair(char highSurrogate, char lowSurrogate);
        static /*0x320a9e8*/ string ConvertFromUtf32(int utf32);
        static /*0x320aae0*/ int ConvertToUtf32(char highSurrogate, char lowSurrogate);
        /*0x32091d0*/ int GetHashCode();
        /*0x32091dc*/ bool Equals(object obj);
        /*0x3209224*/ bool Equals(char obj);
        /*0x3209234*/ int CompareTo(object value);
        /*0x32092bc*/ int CompareTo(char value);
        /*0x31f87f0*/ string ToString();
        /*0x32092d0*/ string ToString(System.IFormatProvider provider);
        /*0x3209aa0*/ System.TypeCode GetTypeCode();
        /*0x3209aa8*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x3209b2c*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x3209b34*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x3209bf0*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x3209cac*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x3209d60*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x3209dbc*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x3209e1c*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x3209e7c*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x3209edc*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x3209f3c*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x3209fc0*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x320a044*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x320a0c8*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x320a14c*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);
    }

    class CharEnumerator : System.Collections.IEnumerator, System.Collections.Generic.IEnumerator<char>, System.IDisposable, System.ICloneable
    {
        /*0x10*/ string _str;
        /*0x18*/ int _index;
        /*0x1c*/ char _currentElement;

        /*0x320ac7c*/ CharEnumerator(string str);
        /*0x320ae14*/ CharEnumerator();
        /*0x320acb8*/ object Clone();
        /*0x320acc0*/ bool MoveNext();
        /*0x320ad1c*/ void Dispose();
        /*0x320ad3c*/ object System.Collections.IEnumerator.get_Current();
        /*0x320ad68*/ char get_Current();
        /*0x320ae04*/ void Reset();
    }

    class Convert
    {
        static /*0x0*/ sbyte[] s_decodingMap;
        static /*0x8*/ System.Type[] ConvertTypes;
        static /*0x10*/ System.Type EnumType;
        static /*0x18*/ char[] base64Table;
        static /*0x20*/ object DBNull;

        static /*0x3212790*/ Convert();
        static /*0x320ae4c*/ bool TryDecodeFromUtf16(System.ReadOnlySpan<char> utf16, System.Span<byte> bytes, ref int consumed, ref int written);
        static /*0x320b1d4*/ int Decode(ref char encodedChars, ref sbyte decodingMap);
        static /*0x320b224*/ void WriteThreeLowOrderBytes(ref byte destination, int value);
        static /*0x320b23c*/ System.TypeCode GetTypeCode(object value);
        static /*0x320b300*/ object ChangeType(object value, System.TypeCode typeCode, System.IFormatProvider provider);
        static /*0x32076b8*/ object DefaultToType(System.IConvertible value, System.Type targetType, System.IFormatProvider provider);
        static /*0x320bba0*/ object ChangeType(object value, System.Type conversionType);
        static /*0x320bc3c*/ object ChangeType(object value, System.Type conversionType, System.IFormatProvider provider);
        static /*0x320c588*/ void ThrowCharOverflowException();
        static /*0x320c5d4*/ void ThrowByteOverflowException();
        static /*0x320c620*/ void ThrowSByteOverflowException();
        static /*0x320c66c*/ void ThrowInt16OverflowException();
        static /*0x320c6b8*/ void ThrowUInt16OverflowException();
        static /*0x320c704*/ void ThrowInt32OverflowException();
        static /*0x320c750*/ void ThrowUInt32OverflowException();
        static /*0x320c79c*/ void ThrowInt64OverflowException();
        static /*0x320c7e8*/ void ThrowUInt64OverflowException();
        static /*0x320c834*/ bool ToBoolean(object value);
        static /*0x320c928*/ bool ToBoolean(object value, System.IFormatProvider provider);
        static /*0x320ca2c*/ bool ToBoolean(sbyte value);
        static /*0x3208b28*/ bool ToBoolean(byte value);
        static /*0x320ca38*/ bool ToBoolean(short value);
        static /*0x320ca44*/ bool ToBoolean(ushort value);
        static /*0x320ca50*/ bool ToBoolean(int value);
        static /*0x320ca5c*/ bool ToBoolean(uint value);
        static /*0x320ca68*/ bool ToBoolean(long value);
        static /*0x320ca74*/ bool ToBoolean(ulong value);
        static /*0x320ca80*/ bool ToBoolean(string value, System.IFormatProvider provider);
        static /*0x320cab4*/ bool ToBoolean(float value);
        static /*0x320cac0*/ bool ToBoolean(double value);
        static /*0x320cacc*/ bool ToBoolean(decimal value);
        static /*0x320cb40*/ char ToChar(object value, System.IFormatProvider provider);
        static /*0x320cc44*/ char ToChar(sbyte value);
        static /*0x3208b8c*/ char ToChar(byte value);
        static /*0x320cca0*/ char ToChar(short value);
        static /*0x320ccfc*/ char ToChar(ushort value);
        static /*0x320cd00*/ char ToChar(int value);
        static /*0x320cd60*/ char ToChar(uint value);
        static /*0x320cdc0*/ char ToChar(long value);
        static /*0x320ce20*/ char ToChar(ulong value);
        static /*0x320ce80*/ char ToChar(string value);
        static /*0x320ced4*/ char ToChar(string value, System.IFormatProvider provider);
        static /*0x320cf70*/ sbyte ToSByte(object value, System.IFormatProvider provider);
        static /*0x3207128*/ sbyte ToSByte(bool value);
        static /*0x3209b8c*/ sbyte ToSByte(char value);
        static /*0x3208bec*/ sbyte ToSByte(byte value);
        static /*0x320d074*/ sbyte ToSByte(short value);
        static /*0x320d0dc*/ sbyte ToSByte(ushort value);
        static /*0x320d140*/ sbyte ToSByte(int value);
        static /*0x320d1a0*/ sbyte ToSByte(uint value);
        static /*0x320d200*/ sbyte ToSByte(long value);
        static /*0x320d260*/ sbyte ToSByte(ulong value);
        static /*0x320d2c0*/ sbyte ToSByte(float value);
        static /*0x320d31c*/ sbyte ToSByte(double value);
        static /*0x320d470*/ sbyte ToSByte(decimal value);
        static /*0x320d4e4*/ sbyte ToSByte(string value, System.IFormatProvider provider);
        static /*0x320d4f4*/ byte ToByte(object value, System.IFormatProvider provider);
        static /*0x320718c*/ byte ToByte(bool value);
        static /*0x3209c48*/ byte ToByte(char value);
        static /*0x320d5f8*/ byte ToByte(sbyte value);
        static /*0x320d654*/ byte ToByte(short value);
        static /*0x320d6b8*/ byte ToByte(ushort value);
        static /*0x320d71c*/ byte ToByte(int value);
        static /*0x320d77c*/ byte ToByte(uint value);
        static /*0x320d7dc*/ byte ToByte(long value);
        static /*0x320d83c*/ byte ToByte(ulong value);
        static /*0x320d89c*/ byte ToByte(float value);
        static /*0x320d8f8*/ byte ToByte(double value);
        static /*0x320d958*/ byte ToByte(decimal value);
        static /*0x320d9cc*/ byte ToByte(string value);
        static /*0x320da40*/ byte ToByte(string value, System.IFormatProvider provider);
        static /*0x320da54*/ short ToInt16(object value, System.IFormatProvider provider);
        static /*0x32071f0*/ short ToInt16(bool value);
        static /*0x3209d04*/ short ToInt16(char value);
        static /*0x320db58*/ short ToInt16(sbyte value);
        static /*0x3208ca8*/ short ToInt16(byte value);
        static /*0x320db60*/ short ToInt16(ushort value);
        static /*0x320dbbc*/ short ToInt16(int value);
        static /*0x320dc1c*/ short ToInt16(uint value);
        static /*0x320dc7c*/ short ToInt16(long value);
        static /*0x320dcdc*/ short ToInt16(ulong value);
        static /*0x320dd3c*/ short ToInt16(float value);
        static /*0x320dd98*/ short ToInt16(double value);
        static /*0x320ddf8*/ short ToInt16(decimal value);
        static /*0x320de6c*/ short ToInt16(string value, System.IFormatProvider provider);
        static /*0x320de84*/ ushort ToUInt16(object value, System.IFormatProvider provider);
        static /*0x3207254*/ ushort ToUInt16(bool value);
        static /*0x3209db8*/ ushort ToUInt16(char value);
        static /*0x320df88*/ ushort ToUInt16(sbyte value);
        static /*0x3208d08*/ ushort ToUInt16(byte value);
        static /*0x320dfe4*/ ushort ToUInt16(short value);
        static /*0x320e040*/ ushort ToUInt16(int value);
        static /*0x320e0a0*/ ushort ToUInt16(uint value);
        static /*0x320e100*/ ushort ToUInt16(long value);
        static /*0x320e160*/ ushort ToUInt16(ulong value);
        static /*0x320e1c0*/ ushort ToUInt16(float value);
        static /*0x320e21c*/ ushort ToUInt16(double value);
        static /*0x320e27c*/ ushort ToUInt16(decimal value);
        static /*0x320e2f0*/ ushort ToUInt16(string value, System.IFormatProvider provider);
        static /*0x320e308*/ int ToInt32(object value);
        static /*0x320e3fc*/ int ToInt32(object value, System.IFormatProvider provider);
        static /*0x32072b8*/ int ToInt32(bool value);
        static /*0x3209e14*/ int ToInt32(char value);
        static /*0x3208d68*/ int ToInt32(byte value);
        static /*0x320e500*/ int ToInt32(short value);
        static /*0x320e508*/ int ToInt32(ushort value);
        static /*0x320e510*/ int ToInt32(uint value);
        static /*0x320e56c*/ int ToInt32(long value);
        static /*0x320e5cc*/ int ToInt32(ulong value);
        static /*0x320e62c*/ int ToInt32(float value);
        static /*0x320d37c*/ int ToInt32(double value);
        static /*0x320e688*/ int ToInt32(decimal value);
        static /*0x320e6fc*/ int ToInt32(string value);
        static /*0x320e774*/ int ToInt32(string value, System.IFormatProvider provider);
        static /*0x320e78c*/ uint ToUInt32(object value);
        static /*0x320e880*/ uint ToUInt32(object value, System.IFormatProvider provider);
        static /*0x320731c*/ uint ToUInt32(bool value);
        static /*0x3209e74*/ uint ToUInt32(char value);
        static /*0x320e984*/ uint ToUInt32(sbyte value);
        static /*0x3208dc8*/ uint ToUInt32(byte value);
        static /*0x320e9e0*/ uint ToUInt32(short value);
        static /*0x320ea3c*/ uint ToUInt32(ushort value);
        static /*0x320ea44*/ uint ToUInt32(int value);
        static /*0x320eaa0*/ uint ToUInt32(long value);
        static /*0x320eb00*/ uint ToUInt32(ulong value);
        static /*0x320eb60*/ uint ToUInt32(float value);
        static /*0x320ebbc*/ uint ToUInt32(double value);
        static /*0x320ec5c*/ uint ToUInt32(decimal value);
        static /*0x320ecd0*/ uint ToUInt32(string value, System.IFormatProvider provider);
        static /*0x320ece8*/ long ToInt64(object value);
        static /*0x320eddc*/ long ToInt64(object value, System.IFormatProvider provider);
        static /*0x3207380*/ long ToInt64(bool value);
        static /*0x3209ed4*/ long ToInt64(char value);
        static /*0x320eee0*/ long ToInt64(sbyte value);
        static /*0x3208e28*/ long ToInt64(byte value);
        static /*0x320eee8*/ long ToInt64(short value);
        static /*0x320eef0*/ long ToInt64(ushort value);
        static /*0x320eef8*/ long ToInt64(int value);
        static /*0x320ef00*/ long ToInt64(uint value);
        static /*0x320ef08*/ long ToInt64(ulong value);
        static /*0x320ef64*/ long ToInt64(float value);
        static /*0x320efc0*/ long ToInt64(double value);
        static /*0x320f0d0*/ long ToInt64(decimal value);
        static /*0x320f144*/ long ToInt64(string value);
        static /*0x320f1bc*/ long ToInt64(string value, System.IFormatProvider provider);
        static /*0x320f1d4*/ ulong ToUInt64(object value);
        static /*0x320f2c8*/ ulong ToUInt64(object value, System.IFormatProvider provider);
        static /*0x32073e4*/ ulong ToUInt64(bool value);
        static /*0x3209f34*/ ulong ToUInt64(char value);
        static /*0x320f3cc*/ ulong ToUInt64(sbyte value);
        static /*0x3208e88*/ ulong ToUInt64(byte value);
        static /*0x320f428*/ ulong ToUInt64(short value);
        static /*0x320f484*/ ulong ToUInt64(ushort value);
        static /*0x320f48c*/ ulong ToUInt64(int value);
        static /*0x320f4e8*/ ulong ToUInt64(uint value);
        static /*0x320f4f0*/ ulong ToUInt64(long value);
        static /*0x320f54c*/ ulong ToUInt64(float value);
        static /*0x320f5a8*/ ulong ToUInt64(double value);
        static /*0x320f6a4*/ ulong ToUInt64(decimal value);
        static /*0x320f718*/ ulong ToUInt64(string value);
        static /*0x320f790*/ ulong ToUInt64(string value, System.IFormatProvider provider);
        static /*0x320f7a8*/ float ToSingle(object value);
        static /*0x320f89c*/ float ToSingle(object value, System.IFormatProvider provider);
        static /*0x320f9a0*/ float ToSingle(sbyte value);
        static /*0x3208ee8*/ float ToSingle(byte value);
        static /*0x320f9ac*/ float ToSingle(short value);
        static /*0x320f9b8*/ float ToSingle(ushort value);
        static /*0x320f9c4*/ float ToSingle(int value);
        static /*0x320f9cc*/ float ToSingle(uint value);
        static /*0x320f9d4*/ float ToSingle(long value);
        static /*0x320f9dc*/ float ToSingle(ulong value);
        static /*0x320f9e8*/ float ToSingle(double value);
        static /*0x320f9f0*/ float ToSingle(decimal value);
        static /*0x320fa58*/ float ToSingle(string value, System.IFormatProvider provider);
        static /*0x3207450*/ float ToSingle(bool value);
        static /*0x320fa74*/ double ToDouble(object value);
        static /*0x320fb68*/ double ToDouble(object value, System.IFormatProvider provider);
        static /*0x320fc6c*/ double ToDouble(sbyte value);
        static /*0x3208f4c*/ double ToDouble(byte value);
        static /*0x320fc78*/ double ToDouble(short value);
        static /*0x320fc84*/ double ToDouble(ushort value);
        static /*0x320fc90*/ double ToDouble(int value);
        static /*0x320fc98*/ double ToDouble(uint value);
        static /*0x320fca0*/ double ToDouble(long value);
        static /*0x320fca8*/ double ToDouble(ulong value);
        static /*0x320fcb0*/ double ToDouble(float value);
        static /*0x320fcb8*/ double ToDouble(decimal value);
        static /*0x320fd20*/ double ToDouble(string value, System.IFormatProvider provider);
        static /*0x32074c8*/ double ToDouble(bool value);
        static /*0x320fd3c*/ decimal ToDecimal(object value, System.IFormatProvider provider);
        static /*0x320fe64*/ decimal ToDecimal(sbyte value);
        static /*0x3208fb0*/ decimal ToDecimal(byte value);
        static /*0x320febc*/ decimal ToDecimal(short value);
        static /*0x320ff14*/ decimal ToDecimal(ushort value);
        static /*0x320ff6c*/ decimal ToDecimal(int value);
        static /*0x320ffc4*/ decimal ToDecimal(uint value);
        static /*0x321001c*/ decimal ToDecimal(long value);
        static /*0x3210074*/ decimal ToDecimal(ulong value);
        static /*0x32100cc*/ decimal ToDecimal(float value);
        static /*0x321012c*/ decimal ToDecimal(double value);
        static /*0x321018c*/ decimal ToDecimal(string value, System.IFormatProvider provider);
        static /*0x3207538*/ decimal ToDecimal(bool value);
        static /*0x3210218*/ System.DateTime ToDateTime(object value, System.IFormatProvider provider);
        static /*0x3210348*/ System.DateTime ToDateTime(string value, System.IFormatProvider provider);
        static /*0x32103d8*/ string ToString(object value);
        static /*0x3210430*/ string ToString(object value, System.IFormatProvider provider);
        static /*0x32105c4*/ string ToString(char value, System.IFormatProvider provider);
        static /*0x32105f8*/ string ToString(int value, System.IFormatProvider provider);
        static /*0x3210614*/ string ToString(double value, System.IFormatProvider provider);
        static /*0x3210634*/ byte ToByte(string value, int fromBase);
        static /*0x3210744*/ sbyte ToSByte(string value, int fromBase);
        static /*0x3210864*/ short ToInt16(string value, int fromBase);
        static /*0x3210984*/ ushort ToUInt16(string value, int fromBase);
        static /*0x3210a94*/ int ToInt32(string value, int fromBase);
        static /*0x3210b68*/ uint ToUInt32(string value, int fromBase);
        static /*0x3210c3c*/ long ToInt64(string value, int fromBase);
        static /*0x3210d10*/ ulong ToUInt64(string value, int fromBase);
        static /*0x3210de4*/ string ToString(byte value, int toBase);
        static /*0x3210e68*/ string ToString(int value, int toBase);
        static /*0x3210ee8*/ string ToString(long value, int toBase);
        static /*0x3210f68*/ string ToBase64String(byte[] inArray);
        static /*0x32111c0*/ string ToBase64String(byte[] inArray, int offset, int length);
        static /*0x3211230*/ string ToBase64String(byte[] inArray, int offset, int length, System.Base64FormattingOptions options);
        static /*0x321101c*/ string ToBase64String(System.ReadOnlySpan<byte> bytes, System.Base64FormattingOptions options);
        static /*0x32116ec*/ int ToBase64CharArray(byte[] inArray, int offsetIn, int length, char[] outArray, int offsetOut);
        static /*0x3211774*/ int ToBase64CharArray(byte[] inArray, int offsetIn, int length, char[] outArray, int offsetOut, System.Base64FormattingOptions options);
        static /*0x32114b4*/ int ConvertToBase64Array(char* outChars, byte* inData, int offset, int length, bool insertLineBreaks);
        static /*0x3211404*/ int ToBase64_CalculateAndValidateOutputLength(int inputLength, bool insertLineBreaks);
        static /*0x3211a78*/ byte[] FromBase64String(string s);
        static /*0x3211d40*/ bool TryFromBase64Chars(System.ReadOnlySpan<char> chars, System.Span<byte> bytes, ref int bytesWritten);
        static /*0x3212398*/ void CopyToTempBufferWithoutWhiteSpace(System.ReadOnlySpan<char> chars, System.Span<char> tempBuffer, ref int consumed, ref int charsWritten);
        static /*0x32124b8*/ bool IsSpace(char c);
        static /*0x32124d8*/ byte[] FromBase64CharArray(char[] inArray, int offset, int length);
        static /*0x3211b2c*/ byte[] FromBase64CharPtr(char* inputPtr, int inputLength);
        static /*0x32126d4*/ int FromBase64_ComputeResultLength(char* inputPtr, int inputLength);
    }

    enum Base64FormattingOptions
    {
        None = 0,
        InsertLineBreaks = 1,
    }

    class CurrentSystemTimeZone : System.TimeZone
    {
        /*0x10*/ long m_ticksOffset;
        /*0x18*/ string m_standardName;
        /*0x20*/ string m_daylightName;
        /*0x28*/ System.Collections.Hashtable m_CachedDaylightChanges;

        static /*0x327f3dc*/ System.Globalization.DaylightTime CreateDaylightChanges(int year);
        static /*0x327f848*/ bool GetTimeZoneData(int year, ref long[] data, ref string[] names, ref bool daylight_inverted);
        /*0x327f024*/ CurrentSystemTimeZone();
        /*0x327f134*/ System.Globalization.DaylightTime GetDaylightChanges(int year);
        /*0x327f6d8*/ System.TimeSpan GetUtcOffset(System.DateTime time);
        /*0x327f200*/ System.Globalization.DaylightTime GetCachedDaylightChanges(int year);
    }

    class DBNull : System.Runtime.Serialization.ISerializable, System.IConvertible
    {
        static /*0x0*/ System.DBNull Value;

        static /*0x327fd88*/ DBNull();
        /*0x327f84c*/ DBNull();
        /*0x327f854*/ DBNull(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x327f8a8*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x327f8b8*/ string ToString();
        /*0x327f8d0*/ string ToString(System.IFormatProvider provider);
        /*0x327f8e8*/ System.TypeCode GetTypeCode();
        /*0x327f8f0*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x327f93c*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x327f988*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x327f9d4*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x327fa20*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x327fa6c*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x327fab8*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x327fb04*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x327fb50*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x327fb9c*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x327fbe8*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x327fc34*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x327fc80*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x327fccc*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x327fd18*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);
    }

    struct DateTime : System.IComparable, System.IFormattable, System.IConvertible, System.IComparable<System.DateTime>, System.IEquatable<System.DateTime>, System.Runtime.Serialization.ISerializable, System.ISpanFormattable
    {
        static long TicksPerMillisecond = 10000;
        static long TicksPerSecond = 10000000;
        static long TicksPerMinute = 600000000;
        static long TicksPerHour = 36000000000;
        static long TicksPerDay = 864000000000;
        static int MillisPerSecond = 1000;
        static int MillisPerMinute = 60000;
        static int MillisPerHour = 3600000;
        static int MillisPerDay = 86400000;
        static int DaysPerYear = 365;
        static int DaysPer4Years = 1461;
        static int DaysPer100Years = 36524;
        static int DaysPer400Years = 146097;
        static int DaysTo1601 = 584388;
        static int DaysTo1899 = 693593;
        static int DaysTo1970 = 719162;
        static int DaysTo10000 = 3652059;
        static long MinTicks = 0;
        static long MaxTicks = 3155378975999999999;
        static long MaxMillis = 315537897600000;
        static long UnixEpochTicks = 621355968000000000;
        static long FileTimeOffset = 504911232000000000;
        static long DoubleDateOffset = 599264352000000000;
        static long OADateMinAsTicks = 31241376000000000;
        static double OADateMinAsDouble = -657435;
        static double OADateMaxAsDouble = 2958466;
        static int DatePartYear = 0;
        static int DatePartDayOfYear = 1;
        static int DatePartMonth = 2;
        static int DatePartDay = 3;
        static ulong TicksMask = 4611686018427387903;
        static ulong FlagsMask = 13835058055282163712;
        static ulong LocalMask = 9223372036854775808;
        static long TicksCeiling = 4611686018427387904;
        static ulong KindUnspecified = 0;
        static ulong KindUtc = 4611686018427387904;
        static ulong KindLocal = 9223372036854775808;
        static ulong KindLocalAmbiguousDst = 13835058055282163712;
        static int KindShift = 62;
        static string TicksField = "ticks";
        static string DateDataField = "dateData";
        static /*0x0*/ int[] s_daysToMonth365;
        static /*0x8*/ int[] s_daysToMonth366;
        static /*0x10*/ System.DateTime MinValue;
        static /*0x18*/ System.DateTime MaxValue;
        static /*0x20*/ System.DateTime UnixEpoch;
        /*0x10*/ ulong _dateData;

        static /*0x328503c*/ DateTime();
        static /*0x328188c*/ int Compare(System.DateTime t1, System.DateTime t2);
        static /*0x3280074*/ long DateToTicks(int year, int month, int day);
        static /*0x32802c4*/ long TimeToTicks(int hour, int minute, int second);
        static /*0x328161c*/ int DaysInMonth(int year, int month);
        static /*0x3281c40*/ System.DateTime FromBinary(long dateData);
        static /*0x3281eac*/ System.DateTime FromBinaryRaw(long dateData);
        static /*0x3281f30*/ System.DateTime FromFileTime(long fileTime);
        static /*0x3281fa0*/ System.DateTime FromFileTimeUtc(long fileTime);
        static /*0x32821a0*/ System.DateTime SpecifyKind(System.DateTime value, System.DateTimeKind kind);
        static /*0x328298c*/ System.DateTime get_Now();
        static /*0x3281a5c*/ bool IsLeapYear(int year);
        static /*0x3282c20*/ System.DateTime Parse(string s);
        static /*0x3282df4*/ System.DateTime Parse(string s, System.IFormatProvider provider);
        static /*0x3282ee8*/ System.DateTime Parse(string s, System.IFormatProvider provider, System.Globalization.DateTimeStyles styles);
        static /*0x3283018*/ System.DateTime ParseExact(string s, string format, System.IFormatProvider provider, System.Globalization.DateTimeStyles style);
        static /*0x32832b8*/ System.DateTime ParseExact(string s, string[] formats, System.IFormatProvider provider, System.Globalization.DateTimeStyles style);
        static /*0x3283bec*/ bool TryParse(string s, ref System.DateTime result);
        static /*0x3283df4*/ bool TryParse(string s, System.IFormatProvider provider, System.Globalization.DateTimeStyles styles, ref System.DateTime result);
        static /*0x3283f38*/ bool TryParseExact(string s, string format, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, ref System.DateTime result);
        static /*0x32841f0*/ System.DateTime op_Addition(System.DateTime d, System.TimeSpan t);
        static /*0x32842f0*/ System.DateTime op_Subtraction(System.DateTime d, System.TimeSpan t);
        static /*0x32843e8*/ System.TimeSpan op_Subtraction(System.DateTime d1, System.DateTime d2);
        static /*0x3284450*/ bool op_Equality(System.DateTime d1, System.DateTime d2);
        static /*0x32844b8*/ bool op_Inequality(System.DateTime d1, System.DateTime d2);
        static /*0x3284520*/ bool op_LessThan(System.DateTime t1, System.DateTime t2);
        static /*0x328458c*/ bool op_LessThanOrEqual(System.DateTime t1, System.DateTime t2);
        static /*0x32845f8*/ bool op_GreaterThan(System.DateTime t1, System.DateTime t2);
        static /*0x3284664*/ bool op_GreaterThanOrEqual(System.DateTime t1, System.DateTime t2);
        static /*0x3284e40*/ bool TryCreate(int year, int month, int day, int hour, int minute, int second, int millisecond, ref System.DateTime result);
        static /*0x3282ab4*/ System.DateTime get_UtcNow();
        static /*0x3285030*/ long GetSystemTimeAsFileTime();
        /*0x327fdf0*/ DateTime(long ticks);
        /*0x327fe74*/ DateTime(ulong dateData);
        /*0x327fe7c*/ DateTime(long ticks, System.DateTimeKind kind);
        /*0x327ff5c*/ DateTime(long ticks, System.DateTimeKind kind, bool isAmbiguousDst);
        /*0x327fff4*/ DateTime(int year, int month, int day);
        /*0x3280218*/ DateTime(int year, int month, int day, int hour, int minute, int second);
        /*0x3280398*/ DateTime(int year, int month, int day, int hour, int minute, int second, System.DateTimeKind kind);
        /*0x32804b0*/ DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);
        /*0x328067c*/ DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, System.DateTimeKind kind);
        /*0x32808a0*/ DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, System.Globalization.Calendar calendar);
        /*0x3280b28*/ DateTime(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x3280dec*/ long get_InternalTicks();
        /*0x3280df8*/ ulong get_InternalKind();
        /*0x3280e04*/ System.DateTime Add(System.TimeSpan value);
        /*0x3280f70*/ System.DateTime Add(double value, int scale);
        /*0x3281098*/ System.DateTime AddDays(double value);
        /*0x3281104*/ System.DateTime AddMilliseconds(double value);
        /*0x328116c*/ System.DateTime AddMinutes(double value);
        /*0x32811d4*/ System.DateTime AddMonths(int months);
        /*0x3281754*/ System.DateTime AddSeconds(double value);
        /*0x3280e68*/ System.DateTime AddTicks(long value);
        /*0x32817bc*/ System.DateTime AddYears(int value);
        /*0x32818fc*/ int CompareTo(object value);
        /*0x32819f4*/ int CompareTo(System.DateTime value);
        /*0x3281b24*/ bool Equals(object value);
        /*0x3281bd4*/ bool Equals(System.DateTime value);
        /*0x32820a8*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x3282214*/ long ToBinary();
        /*0x3282314*/ System.DateTime get_Date();
        /*0x328239c*/ int GetDatePart(int part);
        /*0x3281418*/ void GetDatePart(ref int year, ref int month, ref int day);
        /*0x32825a0*/ int get_Day();
        /*0x32825f8*/ System.DayOfWeek get_DayOfWeek();
        /*0x3282684*/ int get_DayOfYear();
        /*0x32826dc*/ int GetHashCode();
        /*0x3282738*/ int get_Hour();
        /*0x32827c0*/ bool IsAmbiguousDaylightSavingTime();
        /*0x327f7d8*/ System.DateTimeKind get_Kind();
        /*0x3282820*/ int get_Millisecond();
        /*0x32828ac*/ int get_Minute();
        /*0x3282934*/ int get_Month();
        /*0x3282b18*/ int get_Second();
        /*0x3280ad0*/ long get_Ticks();
        /*0x3282ba0*/ System.TimeSpan get_TimeOfDay();
        /*0x327f680*/ int get_Year();
        /*0x32834f0*/ System.TimeSpan Subtract(System.DateTime value);
        /*0x328355c*/ long ToFileTimeUtc();
        /*0x3282050*/ System.DateTime ToLocalTime();
        /*0x32836b8*/ System.DateTime ToLocalTime(bool throwOnOverflow);
        /*0x3283874*/ string ToString();
        /*0x328394c*/ string ToString(string format);
        /*0x32839b8*/ string ToString(System.IFormatProvider provider);
        /*0x3283a24*/ string ToString(string format, System.IFormatProvider provider);
        /*0x3283a94*/ bool TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        /*0x3283658*/ System.DateTime ToUniversalTime();
        /*0x32846d0*/ System.TypeCode GetTypeCode();
        /*0x32846d8*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x328475c*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x32847e0*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x3284864*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x32848e8*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x328496c*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x32849f0*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x3284a74*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x3284af8*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x3284b7c*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x3284c00*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x3284c84*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x3284d08*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x3284d8c*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x3284d94*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);
        /*0x3285034*/ long ToBinaryRaw();
    }

    enum DateTimeKind
    {
        Unspecified = 0,
        Utc = 1,
        Local = 2,
    }

    struct DateTimeOffset : System.IComparable, System.IFormattable, System.IComparable<System.DateTimeOffset>, System.IEquatable<System.DateTimeOffset>, System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IDeserializationCallback, System.ISpanFormattable
    {
        static /*0x0*/ System.DateTimeOffset MinValue;
        static /*0x10*/ System.DateTimeOffset MaxValue;
        static /*0x20*/ System.DateTimeOffset UnixEpoch;
        /*0x10*/ System.DateTime _dateTime;
        /*0x18*/ short _offsetMinutes;

        static /*0x32888f0*/ DateTimeOffset();
        static /*0x3285a14*/ System.DateTimeOffset get_Now();
        static /*0x32862fc*/ int Compare(System.DateTimeOffset first, System.DateTimeOffset second);
        static /*0x328676c*/ System.DateTimeOffset FromFileTime(long fileTime);
        static /*0x32867e0*/ System.DateTimeOffset FromUnixTimeSeconds(long seconds);
        static /*0x3286dd0*/ System.DateTimeOffset Parse(string input, System.IFormatProvider formatProvider);
        static /*0x3286e40*/ System.DateTimeOffset Parse(string input, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles);
        static /*0x32871c0*/ System.DateTimeOffset ParseExact(string input, string format, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles);
        static /*0x328805c*/ bool TryParse(string input, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles, ref System.DateTimeOffset result);
        static /*0x3288370*/ bool TryParseExact(string input, string format, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles, ref System.DateTimeOffset result);
        static /*0x3285208*/ short ValidateOffset(System.TimeSpan offset);
        static /*0x3285360*/ System.DateTime ValidateDate(System.DateTime dateTime, System.TimeSpan offset);
        static /*0x3286fec*/ System.Globalization.DateTimeStyles ValidateStyles(System.Globalization.DateTimeStyles style, string parameterName);
        static /*0x32886dc*/ System.DateTimeOffset op_Implicit(System.DateTime dateTime);
        static /*0x3288704*/ System.TimeSpan op_Subtraction(System.DateTimeOffset left, System.DateTimeOffset right);
        static /*0x32887a8*/ bool op_Equality(System.DateTimeOffset left, System.DateTimeOffset right);
        static /*0x328884c*/ bool op_Inequality(System.DateTimeOffset left, System.DateTimeOffset right);
        /*0x328514c*/ DateTimeOffset(long ticks, System.TimeSpan offset);
        /*0x328547c*/ DateTimeOffset(System.DateTime dateTime);
        /*0x3285590*/ DateTimeOffset(System.DateTime dateTime, System.TimeSpan offset);
        /*0x3285788*/ DateTimeOffset(int year, int month, int day, int hour, int minute, int second, System.TimeSpan offset);
        /*0x3285854*/ DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, System.TimeSpan offset);
        /*0x3285930*/ DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, System.Globalization.Calendar calendar, System.TimeSpan offset);
        /*0x3286bac*/ DateTimeOffset(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x3285a80*/ System.DateTime get_DateTime();
        /*0x3285ba8*/ System.DateTime get_UtcDateTime();
        /*0x3285c04*/ System.DateTime get_LocalDateTime();
        /*0x3285ad4*/ System.DateTime get_ClockDateTime();
        /*0x3285cc4*/ int get_Day();
        /*0x3285d5c*/ int get_Hour();
        /*0x3285df4*/ int get_Millisecond();
        /*0x3285e8c*/ int get_Minute();
        /*0x3285f24*/ int get_Month();
        /*0x3285c9c*/ System.TimeSpan get_Offset();
        /*0x3285fbc*/ int get_Second();
        /*0x3286054*/ long get_Ticks();
        /*0x32860ec*/ System.TimeSpan get_TimeOfDay();
        /*0x3286184*/ int get_Year();
        /*0x328621c*/ System.DateTimeOffset AddTicks(long ticks);
        /*0x32863a0*/ int System.IComparable.CompareTo(object obj);
        /*0x32864f0*/ int CompareTo(System.DateTimeOffset other);
        /*0x32865c4*/ bool Equals(object obj);
        /*0x32866bc*/ bool Equals(System.DateTimeOffset other);
        /*0x3286948*/ void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
        /*0x3286ae4*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x3286d38*/ int GetHashCode();
        /*0x328752c*/ long ToUnixTimeSeconds();
        /*0x32875e8*/ System.DateTimeOffset ToLocalTime();
        /*0x3287640*/ System.DateTimeOffset ToLocalTime(bool throwOnOverflow);
        /*0x32876fc*/ string ToString();
        /*0x3287b48*/ string ToString(System.IFormatProvider formatProvider);
        /*0x3287c08*/ string ToString(string format, System.IFormatProvider formatProvider);
        /*0x3287cd4*/ bool TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider formatProvider);
        /*0x3287fe8*/ System.DateTimeOffset ToUniversalTime();
    }

    enum DayOfWeek
    {
        Sunday = 0,
        Monday = 1,
        Tuesday = 2,
        Wednesday = 3,
        Thursday = 4,
        Friday = 5,
        Saturday = 6,
    }

    class DivideByZeroException : System.ArithmeticException
    {
        /*0x32889f4*/ DivideByZeroException();
        /*0x3288a50*/ DivideByZeroException(string message);
        /*0x3288a74*/ DivideByZeroException(string message, System.Exception innerException);
        /*0x3288a98*/ DivideByZeroException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class DllNotFoundException : System.TypeLoadException
    {
        /*0x3288aa0*/ DllNotFoundException();
        /*0x3288afc*/ DllNotFoundException(string message);
        /*0x3288b20*/ DllNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    struct Double : System.IComparable, System.IConvertible, System.IFormattable, System.IComparable<double>, System.IEquatable<double>, System.ISpanFormattable
    {
        /*0x10*/ double m_value;

        static /*0x3288b28*/ bool IsFinite(double d);
        static /*0x3288b3c*/ bool IsInfinity(double d);
        static /*0x3288b54*/ bool IsNaN(double d);
        static /*0x3288b6c*/ bool IsNegative(double d);
        static /*0x3288b78*/ bool IsNegativeInfinity(double d);
        static /*0x3288b8c*/ bool IsPositiveInfinity(double d);
        static /*0x3289098*/ double Parse(string s);
        static /*0x328915c*/ double Parse(string s, System.IFormatProvider provider);
        static /*0x3289230*/ double Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x3289314*/ bool TryParse(string s, ref double result);
        static /*0x3289650*/ bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref double result);
        static /*0x3289394*/ bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo info, ref double result);
        /*0x3288ba0*/ int CompareTo(object value);
        /*0x3288c78*/ int CompareTo(double value);
        /*0x3288cd4*/ bool Equals(object obj);
        /*0x3288d54*/ bool Equals(double obj);
        /*0x3288d98*/ int GetHashCode();
        /*0x3288db8*/ string ToString();
        /*0x3288e34*/ string ToString(string format);
        /*0x3288ebc*/ string ToString(System.IFormatProvider provider);
        /*0x3288f48*/ string ToString(string format, System.IFormatProvider provider);
        /*0x3288fd8*/ bool TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        /*0x32896f8*/ System.TypeCode GetTypeCode();
        /*0x3289700*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x3289764*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x32897e8*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x328984c*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x32898b0*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x3289914*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x3289978*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x32899dc*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x3289a40*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x3289aa4*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x3289b08*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x3289b6c*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x3289b74*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x3289bd8*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x3289c5c*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);
    }

    class EntryPointNotFoundException : System.TypeLoadException
    {
        /*0x3289cfc*/ EntryPointNotFoundException();
        /*0x3289d58*/ EntryPointNotFoundException(string message);
        /*0x3289d7c*/ EntryPointNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class EventArgs
    {
        static /*0x0*/ System.EventArgs Empty;

        static /*0x3289d8c*/ EventArgs();
        /*0x3289d84*/ EventArgs();
    }

    class EventHandler : System.MulticastDelegate
    {
        /*0x3289df4*/ EventHandler(object object, nint method);
        /*0x3289f00*/ void Invoke(object sender, System.EventArgs e);
    }

    class EventHandler<TEventArgs> : System.MulticastDelegate
    {
        EventHandler(object object, nint method);
        /*0x1ffc854*/ void Invoke(object sender, TEventArgs e);
    }

    class ExecutionEngineException : System.SystemException
    {
        /*0x3289f14*/ ExecutionEngineException();
        /*0x3289f70*/ ExecutionEngineException(string message);
        /*0x3289f94*/ ExecutionEngineException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class FieldAccessException : System.MemberAccessException
    {
        /*0x3289f9c*/ FieldAccessException();
        /*0x3289ff8*/ FieldAccessException(string message);
        /*0x328a01c*/ FieldAccessException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class FlagsAttribute : System.Attribute
    {
        /*0x328a024*/ FlagsAttribute();
    }

    class FormatException : System.SystemException
    {
        /*0x328a02c*/ FormatException();
        /*0x328a088*/ FormatException(string message);
        /*0x328a0ac*/ FormatException(string message, System.Exception innerException);
        /*0x328a0d0*/ FormatException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class FormattableString : System.IFormattable
    {
        /*0x328a150*/ FormattableString();
        /*0x1f30214*/ string get_Format();
        /*0x1f30214*/ object[] GetArguments();
        /*0x1f2ffc8*/ int get_ArgumentCount();
        /*0x1f30240*/ object GetArgument(int index);
        /*0x1f302cc*/ string ToString(System.IFormatProvider formatProvider);
        /*0x328a0d8*/ string System.IFormattable.ToString(string ignored, System.IFormatProvider formatProvider);
        /*0x328a0e8*/ string ToString();
    }

    class Gen2GcCallback : System.Runtime.ConstrainedExecution.CriticalFinalizerObject
    {
        /*0x10*/ System.Func<object, bool> _callback;
        /*0x18*/ System.Runtime.InteropServices.GCHandle _weakTargetObj;

        static /*0x328a160*/ void Register(System.Func<object, bool> callback, object targetObj);
        /*0x328a158*/ Gen2GcCallback();
        /*0x328a1ec*/ void Setup(System.Func<object, bool> callback, object targetObj);
        /*0x328a228*/ void Finalize();
    }

    class DateTimeFormat
    {
        static /*0x0*/ System.TimeSpan NullOffset;
        static /*0x8*/ char[] allStandardFormats;
        static /*0x10*/ System.Globalization.DateTimeFormatInfo InvariantFormatInfo;
        static /*0x18*/ string[] InvariantAbbreviatedMonthNames;
        static /*0x20*/ string[] InvariantAbbreviatedDayNames;
        static /*0x28*/ string[] fixedNumberFormats;

        static /*0x328d718*/ DateTimeFormat();
        static /*0x328a450*/ void FormatDigits(System.Text.StringBuilder outputBuffer, int value, int len);
        static /*0x328a4c0*/ void FormatDigits(System.Text.StringBuilder outputBuffer, int value, int len, bool overrideLengthLimit);
        static /*0x328a5cc*/ void HebrewFormatDigits(System.Text.StringBuilder outputBuffer, int digits);
        static /*0x328a648*/ int ParseRepeatPattern(System.ReadOnlySpan<char> format, int pos, char patternChar);
        static /*0x328a6d4*/ string FormatDayOfWeek(int dayOfWeek, int repeat, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x328a710*/ string FormatMonth(int month, int repeatCount, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x328a74c*/ string FormatHebrewMonthName(System.DateTime time, int month, int repeatCount, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x328a80c*/ int ParseQuoteString(System.ReadOnlySpan<char> format, int pos, System.Text.StringBuilder result);
        static /*0x328a9b4*/ int ParseNextChar(System.ReadOnlySpan<char> format, int pos);
        static /*0x328aa24*/ bool IsUseGenitiveForm(System.ReadOnlySpan<char> format, int index, int tokenLen, char patternToMatch);
        static /*0x328ab88*/ System.Text.StringBuilder FormatCustomized(System.DateTime dateTime, System.ReadOnlySpan<char> format, System.Globalization.DateTimeFormatInfo dtfi, System.TimeSpan offset, System.Text.StringBuilder result);
        static /*0x328bc44*/ void FormatCustomizedTimeZone(System.DateTime dateTime, System.TimeSpan offset, System.ReadOnlySpan<char> format, int tokenLen, bool timeOnly, System.Text.StringBuilder result);
        static /*0x328c014*/ void FormatCustomizedRoundripTimeZone(System.DateTime dateTime, System.TimeSpan offset, System.Text.StringBuilder result);
        static /*0x328c268*/ void Append2DigitNumber(System.Text.StringBuilder result, int val);
        static /*0x328c2c4*/ string GetRealFormat(System.ReadOnlySpan<char> format, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x328c5ec*/ string ExpandPredefinedFormat(System.ReadOnlySpan<char> format, ref System.DateTime dateTime, ref System.Globalization.DateTimeFormatInfo dtfi, ref System.TimeSpan offset);
        static /*0x32838d4*/ string Format(System.DateTime dateTime, string format, System.IFormatProvider provider);
        static /*0x32877b8*/ string Format(System.DateTime dateTime, string format, System.IFormatProvider provider, System.TimeSpan offset);
        static /*0x3283b34*/ bool TryFormat(System.DateTime dateTime, System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        static /*0x3287dd4*/ bool TryFormat(System.DateTime dateTime, System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider, System.TimeSpan offset);
        static /*0x328d254*/ System.Text.StringBuilder FormatStringBuilder(System.DateTime dateTime, System.ReadOnlySpan<char> format, System.Globalization.DateTimeFormatInfo dtfi, System.TimeSpan offset);
        static /*0x328c9ac*/ bool TryFormatO(System.DateTime dateTime, System.TimeSpan offset, System.Span<char> destination, ref int charsWritten);
        static /*0x328ced8*/ bool TryFormatR(System.DateTime dateTime, System.TimeSpan offset, System.Span<char> destination, ref int charsWritten);
        static /*0x328d588*/ void WriteTwoDecimalDigits(uint value, System.Span<char> destination, int offset);
        static /*0x328d5d4*/ void WriteFourDecimalDigits(uint value, System.Span<char> buffer, int startingIndex);
        static /*0x328d674*/ void WriteDigits(ulong value, System.Span<char> buffer);
        static /*0x328c9a8*/ void InvalidFormatForLocal(System.ReadOnlySpan<char> format, System.DateTime dateTime);
    }

    class DateTimeParse
    {
        static /*0x0*/ System.DateTimeParse.MatchNumberDelegate m_hebrewNumberParser;
        static /*0x8*/ System.DateTimeParse.DS[][] dateParsingStates;

        static /*0x3296f88*/ DateTimeParse();
        static /*0x32831b0*/ System.DateTime ParseExact(System.ReadOnlySpan<char> s, System.ReadOnlySpan<char> format, System.Globalization.DateTimeFormatInfo dtfi, System.Globalization.DateTimeStyles style);
        static /*0x32873d8*/ System.DateTime ParseExact(System.ReadOnlySpan<char> s, System.ReadOnlySpan<char> format, System.Globalization.DateTimeFormatInfo dtfi, System.Globalization.DateTimeStyles style, ref System.TimeSpan offset);
        static /*0x32840c8*/ bool TryParseExact(System.ReadOnlySpan<char> s, System.ReadOnlySpan<char> format, System.Globalization.DateTimeFormatInfo dtfi, System.Globalization.DateTimeStyles style, ref System.DateTime result);
        static /*0x3288560*/ bool TryParseExact(System.ReadOnlySpan<char> s, System.ReadOnlySpan<char> format, System.Globalization.DateTimeFormatInfo dtfi, System.Globalization.DateTimeStyles style, ref System.DateTime result, ref System.TimeSpan offset);
        static /*0x328da4c*/ bool TryParseExact(System.ReadOnlySpan<char> s, System.ReadOnlySpan<char> format, System.Globalization.DateTimeFormatInfo dtfi, System.Globalization.DateTimeStyles style, ref System.DateTimeResult result);
        static /*0x32833f8*/ System.DateTime ParseExactMultiple(System.ReadOnlySpan<char> s, string[] formats, System.Globalization.DateTimeFormatInfo dtfi, System.Globalization.DateTimeStyles style);
        static /*0x328e550*/ bool TryParseExactMultiple(System.ReadOnlySpan<char> s, string[] formats, System.Globalization.DateTimeFormatInfo dtfi, System.Globalization.DateTimeStyles style, ref System.DateTimeResult result);
        static /*0x328e7bc*/ bool MatchWord(ref System.__DTString str, string target);
        static /*0x328e9a4*/ bool GetTimeZoneName(ref System.__DTString str);
        static /*0x328ea54*/ bool IsDigit(char ch);
        static /*0x328ea68*/ bool ParseFraction(ref System.__DTString str, ref double result);
        static /*0x328eb54*/ bool ParseTimeZone(ref System.__DTString str, ref System.TimeSpan result);
        static /*0x328ee6c*/ bool HandleTimeZone(ref System.__DTString str, ref System.DateTimeResult result);
        static /*0x328eff4*/ bool Lex(System.DateTimeParse.DS dps, ref System.__DTString str, ref System.DateTimeToken dtok, ref System.DateTimeRawInfo raw, ref System.DateTimeResult result, ref System.Globalization.DateTimeFormatInfo dtfi, System.Globalization.DateTimeStyles styles);
        static /*0x3290180*/ System.Globalization.Calendar GetJapaneseCalendarDefaultInstance();
        static /*0x3290268*/ System.Globalization.Calendar GetTaiwanCalendarDefaultInstance();
        static /*0x3290350*/ bool VerifyValidPunctuation(ref System.__DTString str);
        static /*0x3290524*/ bool GetYearMonthDayOrder(string datePattern, System.Globalization.DateTimeFormatInfo dtfi, ref int order);
        static /*0x32907b4*/ bool GetYearMonthOrder(string pattern, System.Globalization.DateTimeFormatInfo dtfi, ref int order);
        static /*0x3290970*/ bool GetMonthDayOrder(string pattern, System.Globalization.DateTimeFormatInfo dtfi, ref int order);
        static /*0x3290b68*/ bool TryAdjustYear(ref System.DateTimeResult result, int year, ref int adjustedYear);
        static /*0x3290c2c*/ bool SetDateYMD(ref System.DateTimeResult result, int year, int month, int day);
        static /*0x3290c9c*/ bool SetDateMDY(ref System.DateTimeResult result, int month, int day, int year);
        static /*0x3290d18*/ bool SetDateDMY(ref System.DateTimeResult result, int day, int month, int year);
        static /*0x3290d94*/ bool SetDateYDM(ref System.DateTimeResult result, int year, int day, int month);
        static /*0x3290e10*/ void GetDefaultYear(ref System.DateTimeResult result, ref System.Globalization.DateTimeStyles styles);
        static /*0x3290fac*/ bool GetDayOfNN(ref System.DateTimeResult result, ref System.Globalization.DateTimeStyles styles, ref System.DateTimeRawInfo raw, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x3291130*/ bool GetDayOfNNN(ref System.DateTimeResult result, ref System.DateTimeRawInfo raw, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x32913e8*/ bool GetDayOfMN(ref System.DateTimeResult result, ref System.Globalization.DateTimeStyles styles, ref System.DateTimeRawInfo raw, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x329160c*/ bool GetHebrewDayOfNM(ref System.DateTimeResult result, ref System.DateTimeRawInfo raw, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x329176c*/ bool GetDayOfNM(ref System.DateTimeResult result, ref System.Globalization.DateTimeStyles styles, ref System.DateTimeRawInfo raw, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x3291990*/ bool GetDayOfMNN(ref System.DateTimeResult result, ref System.DateTimeRawInfo raw, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x3291c74*/ bool GetDayOfYNN(ref System.DateTimeResult result, ref System.DateTimeRawInfo raw, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x3291db8*/ bool GetDayOfNNY(ref System.DateTimeResult result, ref System.DateTimeRawInfo raw, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x3291f3c*/ bool GetDayOfYMN(ref System.DateTimeResult result, ref System.DateTimeRawInfo raw);
        static /*0x3291ff8*/ bool GetDayOfYN(ref System.DateTimeResult result, ref System.DateTimeRawInfo raw);
        static /*0x32920b4*/ bool GetDayOfYM(ref System.DateTimeResult result, ref System.DateTimeRawInfo raw);
        static /*0x3292150*/ void AdjustTimeMark(System.Globalization.DateTimeFormatInfo dtfi, ref System.DateTimeRawInfo raw);
        static /*0x3292210*/ bool AdjustHour(ref int hour, System.DateTimeParse.TM timeMark);
        static /*0x329225c*/ bool GetTimeOfN(ref System.DateTimeResult result, ref System.DateTimeRawInfo raw);
        static /*0x32922b8*/ bool GetTimeOfNN(ref System.DateTimeResult result, ref System.DateTimeRawInfo raw);
        static /*0x3292328*/ bool GetTimeOfNNN(ref System.DateTimeResult result, ref System.DateTimeRawInfo raw);
        static /*0x32923ac*/ bool GetDateOfDSN(ref System.DateTimeResult result, ref System.DateTimeRawInfo raw);
        static /*0x3292404*/ bool GetDateOfNDS(ref System.DateTimeResult result, ref System.DateTimeRawInfo raw);
        static /*0x32924b8*/ bool GetDateOfNNDS(ref System.DateTimeResult result, ref System.DateTimeRawInfo raw, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x32926e4*/ bool ProcessDateTimeSuffix(ref System.DateTimeResult result, ref System.DateTimeRawInfo raw, ref System.DateTimeToken dtok);
        static /*0x32927dc*/ bool ProcessHebrewTerminalState(System.DateTimeParse.DS dps, ref System.__DTString str, ref System.DateTimeResult result, ref System.Globalization.DateTimeStyles styles, ref System.DateTimeRawInfo raw, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x328fe04*/ bool ProcessTerminalState(System.DateTimeParse.DS dps, ref System.__DTString str, ref System.DateTimeResult result, ref System.Globalization.DateTimeStyles styles, ref System.DateTimeRawInfo raw, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x3282d04*/ System.DateTime Parse(System.ReadOnlySpan<char> s, System.Globalization.DateTimeFormatInfo dtfi, System.Globalization.DateTimeStyles styles);
        static /*0x32870b8*/ System.DateTime Parse(System.ReadOnlySpan<char> s, System.Globalization.DateTimeFormatInfo dtfi, System.Globalization.DateTimeStyles styles, ref System.TimeSpan offset);
        static /*0x3283ce4*/ bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.DateTimeFormatInfo dtfi, System.Globalization.DateTimeStyles styles, ref System.DateTime result);
        static /*0x328820c*/ bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.DateTimeFormatInfo dtfi, System.Globalization.DateTimeStyles styles, ref System.DateTime result, ref System.TimeSpan offset);
        static /*0x3292b90*/ bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.DateTimeFormatInfo dtfi, System.Globalization.DateTimeStyles styles, ref System.DateTimeResult result);
        static /*0x3293bb0*/ bool DetermineTimeZoneAdjustments(ref System.__DTString str, ref System.DateTimeResult result, System.Globalization.DateTimeStyles styles, bool bTimeOnly);
        static /*0x3293dfc*/ bool DateTimeOffsetTimeZonePostProcessing(ref System.__DTString str, ref System.DateTimeResult result, System.Globalization.DateTimeStyles styles);
        static /*0x3294028*/ bool AdjustTimeZoneToUniversal(ref System.DateTimeResult result);
        static /*0x329413c*/ bool AdjustTimeZoneToLocal(ref System.DateTimeResult result, bool bTimeOnly);
        static /*0x3293314*/ bool ParseISO8601(ref System.DateTimeRawInfo raw, ref System.__DTString str, System.Globalization.DateTimeStyles styles, ref System.DateTimeResult result);
        static /*0x3294468*/ bool MatchHebrewDigits(ref System.__DTString str, int digitLen, ref int number);
        static /*0x32943d8*/ bool ParseDigits(ref System.__DTString str, int digitLen, ref int result);
        static /*0x3294578*/ bool ParseDigits(ref System.__DTString str, int minDigitLen, int maxDigitLen, ref int result);
        static /*0x329471c*/ bool ParseFractionExact(ref System.__DTString str, int maxDigitLen, ref double result);
        static /*0x3294980*/ bool ParseSign(ref System.__DTString str, ref bool result);
        static /*0x3294a38*/ bool ParseTimeZoneOffset(ref System.__DTString str, int len, ref System.TimeSpan result);
        static /*0x3294c2c*/ bool MatchAbbreviatedMonthName(ref System.__DTString str, System.Globalization.DateTimeFormatInfo dtfi, ref int result);
        static /*0x3294e10*/ bool MatchMonthName(ref System.__DTString str, System.Globalization.DateTimeFormatInfo dtfi, ref int result);
        static /*0x3295048*/ bool MatchAbbreviatedDayName(ref System.__DTString str, System.Globalization.DateTimeFormatInfo dtfi, ref int result);
        static /*0x32951ac*/ bool MatchDayName(ref System.__DTString str, System.Globalization.DateTimeFormatInfo dtfi, ref int result);
        static /*0x3295310*/ bool MatchEraName(ref System.__DTString str, System.Globalization.DateTimeFormatInfo dtfi, ref int result);
        static /*0x32954ac*/ bool MatchTimeMark(ref System.__DTString str, System.Globalization.DateTimeFormatInfo dtfi, ref System.DateTimeParse.TM result);
        static /*0x3295648*/ bool MatchAbbreviatedTimeMark(ref System.__DTString str, System.Globalization.DateTimeFormatInfo dtfi, ref System.DateTimeParse.TM result);
        static /*0x3295794*/ bool CheckNewValue(ref int currentValue, int newValue, char patternChar, ref System.DateTimeResult result);
        static /*0x3290eac*/ System.DateTime GetDateTimeNow(ref System.DateTimeResult result, ref System.Globalization.DateTimeStyles styles);
        static /*0x3293924*/ bool CheckDefaultDateTime(ref System.DateTimeResult result, ref System.Globalization.Calendar cal, System.Globalization.DateTimeStyles styles);
        static /*0x3295844*/ string ExpandPredefinedFormat(System.ReadOnlySpan<char> format, ref System.Globalization.DateTimeFormatInfo dtfi, ref System.ParsingInfo parseInfo, ref System.DateTimeResult result);
        static /*0x3295c1c*/ bool ParseJapaneseEraStart(ref System.__DTString str, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x3295d24*/ bool ParseByFormat(ref System.__DTString str, ref System.__DTString format, ref System.ParsingInfo parseInfo, System.Globalization.DateTimeFormatInfo dtfi, ref System.DateTimeResult result);
        static /*0x3296e98*/ bool TryParseQuoteString(System.ReadOnlySpan<char> format, int pos, System.Text.StringBuilder result, ref int returnValue);
        static /*0x328dd24*/ bool DoStrictParse(System.ReadOnlySpan<char> s, System.ReadOnlySpan<char> formatParam, System.Globalization.DateTimeStyles styles, System.Globalization.DateTimeFormatInfo dtfi, ref System.DateTimeResult result);
        static /*0x328db50*/ System.Exception GetDateTimeParseException(ref System.DateTimeResult result);

        class MatchNumberDelegate : System.MulticastDelegate
        {
            /*0x32978a0*/ MatchNumberDelegate(object object, nint method);
            /*0x3297954*/ bool Invoke(ref System.__DTString str, int digitLen, ref int result);
        }

        enum DTT
        {
            End = 0,
            NumEnd = 1,
            NumAmpm = 2,
            NumSpace = 3,
            NumDatesep = 4,
            NumTimesep = 5,
            MonthEnd = 6,
            MonthSpace = 7,
            MonthDatesep = 8,
            NumDatesuff = 9,
            NumTimesuff = 10,
            DayOfWeek = 11,
            YearSpace = 12,
            YearDateSep = 13,
            YearEnd = 14,
            TimeZone = 15,
            Era = 16,
            NumUTCTimeMark = 17,
            Unk = 18,
            NumLocalTimeMark = 19,
            Max = 20,
        }

        enum TM
        {
            NotSet = -1,
            AM = 0,
            PM = 1,
        }

        enum DS
        {
            BEGIN = 0,
            N = 1,
            NN = 2,
            D_Nd = 3,
            D_NN = 4,
            D_NNd = 5,
            D_M = 6,
            D_MN = 7,
            D_NM = 8,
            D_MNd = 9,
            D_NDS = 10,
            D_Y = 11,
            D_YN = 12,
            D_YNd = 13,
            D_YM = 14,
            D_YMd = 15,
            D_S = 16,
            T_S = 17,
            T_Nt = 18,
            T_NNt = 19,
            ERROR = 20,
            DX_NN = 21,
            DX_NNN = 22,
            DX_MN = 23,
            DX_NM = 24,
            DX_MNN = 25,
            DX_DS = 26,
            DX_DSN = 27,
            DX_NDS = 28,
            DX_NNDS = 29,
            DX_YNN = 30,
            DX_YMN = 31,
            DX_YN = 32,
            DX_YM = 33,
            TX_N = 34,
            TX_NN = 35,
            TX_NNN = 36,
            TX_TS = 37,
            DX_NNY = 38,
        }

        class <>c
        {
            static /*0x0*/ System.DateTimeParse.<> <>9;
            static /*0x8*/ System.Func<System.DateTimeParse.MatchNumberDelegate> <>9__98_0;

            static /*0x3297968*/ <>c();
            /*0x32979d0*/ <>c();
            /*0x32979d8*/ System.DateTimeParse.MatchNumberDelegate <DoStrictParse>b__98_0();
        }
    }

    struct __DTString
    {
        static /*0x0*/ char[] WhiteSpaceChecks;
        /*0x10*/ System.ReadOnlySpan<char> Value;
        /*0x20*/ int Index;
        /*0x24*/ char m_current;
        /*0x28*/ System.Globalization.CompareInfo m_info;
        /*0x30*/ bool m_checkDigitToken;

        static /*0x3299894*/ __DTString();
        /*0x3297a80*/ __DTString(System.ReadOnlySpan<char> str, System.Globalization.DateTimeFormatInfo dtfi, bool checkDigitToken);
        /*0x3297b0c*/ __DTString(System.ReadOnlySpan<char> str, System.Globalization.DateTimeFormatInfo dtfi);
        /*0x3297a44*/ int get_Length();
        /*0x3297bd4*/ System.Globalization.CompareInfo get_CompareInfo();
        /*0x3297bdc*/ bool GetNext();
        /*0x3297c88*/ bool AtEnd();
        /*0x3297d08*/ bool Advance(int count);
        /*0x3297dc0*/ void GetRegularToken(ref System.TokenType tokenType, ref int tokenValue, System.Globalization.DateTimeFormatInfo dtfi);
        /*0x32980f0*/ System.TokenType GetSeparatorToken(System.Globalization.DateTimeFormatInfo dtfi, ref int indexBeforeSeparator, ref char charBeforeSeparator);
        /*0x3298350*/ bool MatchSpecifiedWord(string target);
        /*0x32984a8*/ bool MatchSpecifiedWords(string target, bool checkWordBoundary, ref int matchLength);
        /*0x3298988*/ bool Match(string str);
        /*0x3298b0c*/ bool Match(char ch);
        /*0x3298be0*/ int MatchLongestWords(string[] words, ref int maxMatchStrLen);
        /*0x3298cdc*/ int GetRepeatCount();
        /*0x3298db8*/ bool GetNextDigit();
        /*0x3298e94*/ char GetChar();
        /*0x3298eb8*/ int GetDigit();
        /*0x3298ee0*/ void SkipWhiteSpaces();
        /*0x32981f4*/ bool SkipWhiteSpaceCurrent();
        /*0x3298fcc*/ void TrimTail();
        /*0x3299138*/ void RemoveTrailingInQuoteSpaces();
        /*0x3299390*/ void RemoveLeadingInQuoteSpaces();
        /*0x329966c*/ System.DTSubString GetSubString();
        /*0x32997e4*/ void ConsumeSubString(System.DTSubString sub);
    }

    enum DTSubStringType
    {
        Unknown = 0,
        Invalid = 1,
        Number = 2,
        End = 3,
        Other = 4,
    }

    struct DTSubString
    {
        /*0x10*/ System.ReadOnlySpan<char> s;
        /*0x20*/ int index;
        /*0x24*/ int length;
        /*0x28*/ System.DTSubStringType type;
        /*0x2c*/ int value;

        /*0x3299928*/ char get_Item(int relativeIndex);
    }

    struct DateTimeToken
    {
        /*0x10*/ System.DateTimeParse.DTT dtt;
        /*0x14*/ System.TokenType suffix;
        /*0x18*/ int num;
    }

    struct DateTimeRawInfo
    {
        /*0x10*/ int* num;
        /*0x18*/ int numCount;
        /*0x1c*/ int month;
        /*0x20*/ int year;
        /*0x24*/ int dayOfWeek;
        /*0x28*/ int era;
        /*0x2c*/ System.DateTimeParse.TM timeMark;
        /*0x30*/ double fraction;
        /*0x38*/ bool hasSameDateAndTimeSeparators;

        /*0x3299950*/ void Init(int* numberBuffer);
        /*0x3299970*/ void AddNumber(int value);
        /*0x3299988*/ int GetNumber(int index);
    }

    enum ParseFailureKind
    {
        None = 0,
        ArgumentNull = 1,
        Format = 2,
        FormatWithParameter = 3,
        FormatWithOriginalDateTime = 4,
        FormatWithFormatSpecifier = 5,
        FormatWithOriginalDateTimeAndParameter = 6,
        FormatBadDateTimeCalendar = 7,
    }

    enum ParseFlags
    {
        HaveYear = 1,
        HaveMonth = 2,
        HaveDay = 4,
        HaveHour = 8,
        HaveMinute = 16,
        HaveSecond = 32,
        HaveTime = 64,
        HaveDate = 128,
        TimeZoneUsed = 256,
        TimeZoneUtc = 512,
        ParsedMonthName = 1024,
        CaptureOffset = 2048,
        YearDefault = 4096,
        Rfc1123Pattern = 8192,
        UtcSortPattern = 16384,
    }

    struct DateTimeResult
    {
        /*0x10*/ int Year;
        /*0x14*/ int Month;
        /*0x18*/ int Day;
        /*0x1c*/ int Hour;
        /*0x20*/ int Minute;
        /*0x24*/ int Second;
        /*0x28*/ double fraction;
        /*0x30*/ int era;
        /*0x34*/ System.ParseFlags flags;
        /*0x38*/ System.TimeSpan timeZoneOffset;
        /*0x40*/ System.Globalization.Calendar calendar;
        /*0x48*/ System.DateTime parsedDate;
        /*0x50*/ System.ParseFailureKind failure;
        /*0x58*/ string failureMessageID;
        /*0x60*/ object failureMessageFormatArgument;
        /*0x68*/ string failureArgumentName;
        /*0x70*/ System.ReadOnlySpan<char> originalDateTimeString;
        /*0x80*/ System.ReadOnlySpan<char> failedFormatSpecifier;

        /*0x3299994*/ void Init(System.ReadOnlySpan<char> originalDateTimeString);
        /*0x32999b8*/ void SetDate(int year, int month, int day);
        /*0x32999c4*/ void SetBadFormatSpecifierFailure();
        /*0x3299a58*/ void SetBadFormatSpecifierFailure(System.ReadOnlySpan<char> failedFormatSpecifier);
        /*0x3299abc*/ void SetBadDateTimeFailure();
        /*0x3299b0c*/ void SetFailure(System.ParseFailureKind failure, string failureMessageID);
        /*0x3299b18*/ void SetFailure(System.ParseFailureKind failure, string failureMessageID, object failureMessageFormatArgument);
        /*0x3299b24*/ void SetFailure(System.ParseFailureKind failure, string failureMessageID, object failureMessageFormatArgument, string failureArgumentName);
    }

    struct ParsingInfo
    {
        /*0x10*/ System.Globalization.Calendar calendar;
        /*0x18*/ int dayOfWeek;
        /*0x1c*/ System.DateTimeParse.TM timeMark;
        /*0x20*/ bool fUseHour12;
        /*0x21*/ bool fUseTwoDigitYear;
        /*0x22*/ bool fAllowInnerWhite;
        /*0x23*/ bool fAllowTrailingWhite;
        /*0x24*/ bool fCustomNumberParser;
        /*0x28*/ System.DateTimeParse.MatchNumberDelegate parseNumberDelegate;

        /*0x3299b34*/ void Init();
    }

    enum TokenType
    {
        NumberToken = 1,
        YearNumberToken = 2,
        Am = 3,
        Pm = 4,
        MonthToken = 5,
        EndOfString = 6,
        DayOfWeekToken = 7,
        TimeZoneToken = 8,
        EraToken = 9,
        DateWordToken = 10,
        UnknownToken = 11,
        HebrewNumber = 12,
        JapaneseEraToken = 13,
        TEraToken = 14,
        IgnorableSymbol = 15,
        SEP_Unk = 256,
        SEP_End = 512,
        SEP_Space = 768,
        SEP_Am = 1024,
        SEP_Pm = 1280,
        SEP_Date = 1536,
        SEP_Time = 1792,
        SEP_YearSuff = 2048,
        SEP_MonthSuff = 2304,
        SEP_DaySuff = 2560,
        SEP_HourSuff = 2816,
        SEP_MinuteSuff = 3072,
        SEP_SecondSuff = 3328,
        SEP_LocalTimeMark = 3584,
        SEP_DateOrOffset = 3840,
        RegularTokenMask = 255,
        SeparatorTokenMask = 65280,
    }

    struct Guid : System.IFormattable, System.IComparable, System.IComparable<System.Guid>, System.IEquatable<System.Guid>, System.ISpanFormattable
    {
        static /*0x0*/ System.Guid Empty;
        /*0x10*/ int _a;
        /*0x14*/ short _b;
        /*0x16*/ short _c;
        /*0x18*/ byte _d;
        /*0x19*/ byte _e;
        /*0x1a*/ byte _f;
        /*0x1b*/ byte _g;
        /*0x1c*/ byte _h;
        /*0x1d*/ byte _i;
        /*0x1e*/ byte _j;
        /*0x1f*/ byte _k;

        static /*0x3299b40*/ System.Guid NewGuid();
        static /*0x329a3b0*/ System.Guid Parse(string input);
        static /*0x329a444*/ System.Guid Parse(System.ReadOnlySpan<char> input);
        static /*0x329a4a8*/ bool TryParse(string input, ref System.Guid result);
        static /*0x329a534*/ bool TryParse(System.ReadOnlySpan<char> input, ref System.Guid result);
        static /*0x329a580*/ bool TryParseExact(string input, string format, ref System.Guid result);
        static /*0x329a644*/ bool TryParseExact(System.ReadOnlySpan<char> input, System.ReadOnlySpan<char> format, ref System.Guid result);
        static /*0x3299fa8*/ bool TryParseGuid(System.ReadOnlySpan<char> guidString, System.Guid.GuidStyles flags, ref System.Guid.GuidResult result);
        static /*0x329aa38*/ bool TryParseGuidWithHexPrefix(System.ReadOnlySpan<char> guidString, ref System.Guid.GuidResult result);
        static /*0x329b138*/ bool TryParseGuidWithNoStyle(System.ReadOnlySpan<char> guidString, ref System.Guid.GuidResult result);
        static /*0x329a7ac*/ bool TryParseGuidWithDashes(System.ReadOnlySpan<char> guidString, ref System.Guid.GuidResult result);
        static /*0x329b914*/ bool StringToShort(System.ReadOnlySpan<char> str, int requiredLength, int flags, ref short result, ref System.Guid.GuidResult parseResult);
        static /*0x329bcac*/ bool StringToShort(System.ReadOnlySpan<char> str, ref int parsePos, int requiredLength, int flags, ref short result, ref System.Guid.GuidResult parseResult);
        static /*0x329b8e8*/ bool StringToInt(System.ReadOnlySpan<char> str, int requiredLength, int flags, ref int result, ref System.Guid.GuidResult parseResult);
        static /*0x329bab4*/ bool StringToInt(System.ReadOnlySpan<char> str, ref int parsePos, int requiredLength, int flags, ref int result, ref System.Guid.GuidResult parseResult);
        static /*0x329b958*/ bool StringToLong(System.ReadOnlySpan<char> str, ref int parsePos, int flags, ref long result, ref System.Guid.GuidResult parseResult);
        static /*0x329b56c*/ System.ReadOnlySpan<char> EatAllWhitespace(System.ReadOnlySpan<char> str);
        static /*0x329b81c*/ bool IsHexPrefix(System.ReadOnlySpan<char> str, int i);
        static /*0x329c4d0*/ bool op_Equality(System.Guid a, System.Guid b);
        static /*0x329c4fc*/ char HexToChar(int a);
        static /*0x329c518*/ int HexsToChars(char* guidChars, int a, int b);
        static /*0x329c594*/ int HexsToCharsHexOutput(char* guidChars, int a, int b);
        /*0x3299b8c*/ Guid(byte[] b);
        /*0x3299c20*/ Guid(System.ReadOnlySpan<byte> b);
        /*0x3299d44*/ Guid(int a, short b, short c, byte[] d);
        /*0x3299e78*/ Guid(int a, short b, short c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
        /*0x3299eb8*/ Guid(string g);
        /*0x329bcf0*/ void WriteByteHelper(System.Span<byte> destination);
        /*0x329be00*/ byte[] ToByteArray();
        /*0x329be94*/ string ToString();
        /*0x329c158*/ int GetHashCode();
        /*0x329c174*/ bool Equals(object o);
        /*0x329c21c*/ bool Equals(System.Guid g);
        /*0x329c260*/ int GetResult(uint me, uint them);
        /*0x329c270*/ int CompareTo(object value);
        /*0x329c400*/ int CompareTo(System.Guid value);
        /*0x329c4f8*/ string ToString(string format);
        /*0x329bedc*/ string ToString(string format, System.IFormatProvider provider);
        /*0x329c630*/ bool TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format);
        /*0x329ca50*/ bool System.ISpanFormattable.TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);

        enum GuidStyles
        {
            None = 0,
            AllowParenthesis = 1,
            AllowBraces = 2,
            AllowDashes = 4,
            AllowHexPrefix = 8,
            RequireParenthesis = 16,
            RequireBraces = 32,
            RequireDashes = 64,
            RequireHexPrefix = 128,
            HexFormat = 160,
            NumberFormat = 0,
            DigitFormat = 64,
            BraceFormat = 96,
            ParenthesisFormat = 80,
            Any = 15,
        }

        enum GuidParseThrowStyle
        {
            None = 0,
            All = 1,
            AllButOverflow = 2,
        }

        enum ParseFailureKind
        {
            None = 0,
            ArgumentNull = 1,
            Format = 2,
            FormatWithParameter = 3,
            NativeException = 4,
            FormatWithInnerException = 5,
        }

        struct GuidResult
        {
            /*0x10*/ System.Guid _parsedGuid;
            /*0x20*/ System.Guid.GuidParseThrowStyle _throwStyle;
            /*0x24*/ System.Guid.ParseFailureKind _failure;
            /*0x28*/ string _failureMessageID;
            /*0x30*/ object _failureMessageFormatArgument;
            /*0x38*/ string _failureArgumentName;
            /*0x40*/ System.Exception _innerException;

            /*0x329ca54*/ void Init(System.Guid.GuidParseThrowStyle canThrow);
            /*0x329bce0*/ void SetFailure(System.Exception nativeException);
            /*0x329a79c*/ void SetFailure(System.Guid.ParseFailureKind failure, string failureMessageID);
            /*0x329b8dc*/ void SetFailure(System.Guid.ParseFailureKind failure, string failureMessageID, object failureMessageFormatArgument);
            /*0x329b4d0*/ void SetFailure(System.Guid.ParseFailureKind failure, string failureMessageID, object failureMessageFormatArgument, string failureArgumentName, System.Exception innerException);
            /*0x329a22c*/ System.Exception GetGuidParseException();
        }
    }

    struct HashCode
    {
        static /*0x0*/ uint s_seed;
        /*0x10*/ uint _v1;
        /*0x14*/ uint _v2;
        /*0x18*/ uint _v3;
        /*0x1c*/ uint _v4;
        /*0x20*/ uint _queue1;
        /*0x24*/ uint _queue2;
        /*0x28*/ uint _queue3;
        /*0x2c*/ uint _length;

        static /*0x329d2bc*/ HashCode();
        static /*0x329ca5c*/ uint GenerateGlobalSeed();
        static /*0x1ffc854*/ int Combine<T1, T2>(T1 value1, T2 value2);
        static /*0x1ffc854*/ int Combine<T1, T2, T3, T4>(T1 value1, T2 value2, T3 value3, T4 value4);
        static /*0x1ffc854*/ int Combine<T1, T2, T3, T4, T5, T6>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6);
        static /*0x1ffc854*/ int Combine<T1, T2, T3, T4, T5, T6, T7, T8>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8);
        static /*0x329ca80*/ uint Rol(uint value, int count);
        static /*0x329ca8c*/ void Initialize(ref uint v1, ref uint v2, ref uint v3, ref uint v4);
        static /*0x329cb40*/ uint Round(uint hash, uint input);
        static /*0x329cbb8*/ uint QueueRound(uint hash, uint queuedValue);
        static /*0x329cc30*/ uint MixState(uint v1, uint v2, uint v3, uint v4);
        static /*0x329ccb8*/ uint MixEmptyState();
        static /*0x329cd1c*/ uint MixFinal(uint hash);
        /*0x1ffc854*/ void Add<T>(T value);
        /*0x329cd44*/ void Add(int value);
        /*0x329cfd4*/ int ToHashCode();
        /*0x329d208*/ int GetHashCode();
        /*0x329d274*/ bool Equals(object obj);
    }

    interface IAsyncResult
    {
        /*0x1f2fe14*/ bool get_IsCompleted();
        /*0x1f30214*/ System.Threading.WaitHandle get_AsyncWaitHandle();
        /*0x1f30214*/ object get_AsyncState();
        /*0x1f2fe14*/ bool get_CompletedSynchronously();
    }

    interface ICloneable
    {
        /*0x1f30214*/ object Clone();
    }

    interface IComparable
    {
        /*0x1f3008c*/ int CompareTo(object obj);
    }

    interface IComparable<T>
    {
        /*0x1ffc854*/ int CompareTo(T other);
    }

    interface IConvertible
    {
        /*0x1f2ffc8*/ System.TypeCode GetTypeCode();
        /*0x1f2fec8*/ bool ToBoolean(System.IFormatProvider provider);
        char ToChar(System.IFormatProvider provider);
        sbyte ToSByte(System.IFormatProvider provider);
        /*0x1f2fec8*/ byte ToByte(System.IFormatProvider provider);
        short ToInt16(System.IFormatProvider provider);
        ushort ToUInt16(System.IFormatProvider provider);
        /*0x1f3008c*/ int ToInt32(System.IFormatProvider provider);
        /*0x1f308ec*/ uint ToUInt32(System.IFormatProvider provider);
        long ToInt64(System.IFormatProvider provider);
        ulong ToUInt64(System.IFormatProvider provider);
        float ToSingle(System.IFormatProvider provider);
        double ToDouble(System.IFormatProvider provider);
        decimal ToDecimal(System.IFormatProvider provider);
        System.DateTime ToDateTime(System.IFormatProvider provider);
        /*0x1f302cc*/ string ToString(System.IFormatProvider provider);
        /*0x1f30394*/ object ToType(System.Type conversionType, System.IFormatProvider provider);
    }

    interface ICustomFormatter
    {
        /*0x1f303d0*/ string Format(string format, object arg, System.IFormatProvider formatProvider);
    }

    interface IDisposable
    {
        /*0x1f309e4*/ void Dispose();
    }

    interface IEquatable<T>
    {
        /*0x1ffc854*/ bool Equals(T other);
    }

    interface IFormatProvider
    {
        /*0x1f302cc*/ object GetFormat(System.Type formatType);
    }

    interface IFormattable
    {
        /*0x1f30394*/ string ToString(string format, System.IFormatProvider formatProvider);
    }

    interface IProgress<T>
    {
        /*0x1ffc854*/ void Report(T value);
    }

    interface ISpanFormattable
    {
        bool TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
    }

    class IndexOutOfRangeException : System.SystemException
    {
        /*0x329d31c*/ IndexOutOfRangeException();
        /*0x329d378*/ IndexOutOfRangeException(string message);
        /*0x329d39c*/ IndexOutOfRangeException(string message, System.Exception innerException);
        /*0x329d3c0*/ IndexOutOfRangeException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class InsufficientExecutionStackException : System.SystemException
    {
        /*0x329d3c8*/ InsufficientExecutionStackException();
        /*0x329d424*/ InsufficientExecutionStackException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    struct Int16 : System.IComparable, System.IConvertible, System.IFormattable, System.IComparable<short>, System.IEquatable<short>, System.ISpanFormattable
    {
        /*0x10*/ short m_value;

        static /*0x329e73c*/ short Parse(string s, System.IFormatProvider provider);
        static /*0x329e964*/ short Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x329e7c8*/ short Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo info);
        static /*0x329ec14*/ bool TryParse(string s, ref short result);
        static /*0x329ed58*/ bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref short result);
        static /*0x329ec94*/ bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo info, ref short result);
        /*0x329d42c*/ int CompareTo(object value);
        /*0x329d4b8*/ int CompareTo(short value);
        /*0x329d4c4*/ bool Equals(object obj);
        /*0x329d50c*/ bool Equals(short obj);
        /*0x329d51c*/ int GetHashCode();
        /*0x329d528*/ string ToString();
        /*0x329d968*/ string ToString(System.IFormatProvider provider);
        /*0x329da00*/ string ToString(string format, System.IFormatProvider provider);
        /*0x329deac*/ bool TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        /*0x329ef88*/ System.TypeCode GetTypeCode();
        /*0x329ef90*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x329efec*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x329f048*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x329f0a4*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x329f100*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x329f108*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x329f164*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x329f1c0*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x329f21c*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x329f278*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x329f2d4*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x329f330*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x329f38c*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x329f3e8*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x329f48c*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);
    }

    struct Int32 : System.IComparable, System.IConvertible, System.IFormattable, System.IComparable<int>, System.IEquatable<int>, System.ISpanFormattable
    {
        /*0x10*/ int m_value;

        static /*0x329f96c*/ int Parse(string s);
        static /*0x329fa2c*/ int Parse(string s, System.Globalization.NumberStyles style);
        static /*0x329fb04*/ int Parse(string s, System.IFormatProvider provider);
        static /*0x329fbd4*/ int Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x329fcb4*/ int Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x329fd50*/ bool TryParse(string s, ref int result);
        static /*0x329fe20*/ bool TryParse(System.ReadOnlySpan<char> s, ref int result);
        static /*0x329fea4*/ bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref int result);
        static /*0x329ff98*/ bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref int result);
        /*0x329f52c*/ int CompareTo(object value);
        /*0x329f5c8*/ int CompareTo(int value);
        /*0x329f5dc*/ bool Equals(object obj);
        /*0x329f624*/ bool Equals(int obj);
        /*0x329f634*/ int GetHashCode();
        /*0x329f63c*/ string ToString();
        /*0x329f6d0*/ string ToString(string format);
        /*0x329f780*/ string ToString(System.IFormatProvider provider);
        /*0x329f818*/ string ToString(string format, System.IFormatProvider provider);
        /*0x329f8cc*/ bool TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        /*0x32a003c*/ System.TypeCode GetTypeCode();
        /*0x32a0044*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x32a00a0*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x32a00fc*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x32a0158*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x32a01b4*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x32a0210*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x32a026c*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x32a0274*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x32a02d0*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x32a032c*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x32a0388*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x32a03e4*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x32a0440*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x32a049c*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x32a051c*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);
    }

    struct Int64 : System.IComparable, System.IConvertible, System.IFormattable, System.IComparable<long>, System.IEquatable<long>, System.ISpanFormattable
    {
        /*0x10*/ long m_value;

        static /*0x32a11a4*/ long Parse(string s);
        static /*0x32a147c*/ long Parse(string s, System.IFormatProvider provider);
        static /*0x32a154c*/ long Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x32a162c*/ bool TryParse(string s, ref long result);
        static /*0x32a1884*/ bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref long result);
        /*0x32a05bc*/ int CompareTo(object value);
        /*0x32a0658*/ int CompareTo(long value);
        /*0x32a066c*/ bool Equals(object obj);
        /*0x32a06b4*/ bool Equals(long obj);
        /*0x32a06c4*/ int GetHashCode();
        /*0x32a06d0*/ string ToString();
        /*0x32a0b0c*/ string ToString(System.IFormatProvider provider);
        /*0x32a0ba4*/ string ToString(string format);
        /*0x32a0c54*/ string ToString(string format, System.IFormatProvider provider);
        /*0x32a0d08*/ bool TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        /*0x32a1978*/ System.TypeCode GetTypeCode();
        /*0x32a1980*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x32a19dc*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x32a1a38*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x32a1a94*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x32a1af0*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x32a1b4c*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x32a1ba8*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x32a1c04*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x32a1c60*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x32a1c68*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x32a1cc4*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x32a1d20*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x32a1d7c*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x32a1dd8*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x32a1e58*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);
    }

    class InvalidCastException : System.SystemException
    {
        /*0x32a1ef8*/ InvalidCastException();
        /*0x329f468*/ InvalidCastException(string message);
        /*0x32a1f54*/ InvalidCastException(string message, System.Exception innerException);
        /*0x32a1f78*/ InvalidCastException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class InvalidOperationException : System.SystemException
    {
        /*0x32a1f80*/ InvalidOperationException();
        /*0x32a1fdc*/ InvalidOperationException(string message);
        /*0x32a2000*/ InvalidOperationException(string message, System.Exception innerException);
        /*0x32a2024*/ InvalidOperationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class InvalidProgramException : System.SystemException
    {
        /*0x32a202c*/ InvalidProgramException();
        /*0x32a2088*/ InvalidProgramException(string message);
        /*0x32a20ac*/ InvalidProgramException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class InvalidTimeZoneException : System.Exception
    {
        /*0x32a20b4*/ InvalidTimeZoneException();
        /*0x32a210c*/ InvalidTimeZoneException(string message);
        /*0x32a2174*/ InvalidTimeZoneException(string message, System.Exception innerException);
        /*0x32a21e4*/ InvalidTimeZoneException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    enum LazyState
    {
        NoneViaConstructor = 0,
        NoneViaFactory = 1,
        NoneException = 2,
        PublicationOnlyViaConstructor = 3,
        PublicationOnlyViaFactory = 4,
        PublicationOnlyWait = 5,
        PublicationOnlyException = 6,
        ExecutionAndPublicationViaConstructor = 7,
        ExecutionAndPublicationViaFactory = 8,
        ExecutionAndPublicationException = 9,
    }

    class LazyHelper
    {
        static /*0x0*/ System.LazyHelper NoneViaConstructor;
        static /*0x8*/ System.LazyHelper NoneViaFactory;
        static /*0x10*/ System.LazyHelper PublicationOnlyViaConstructor;
        static /*0x18*/ System.LazyHelper PublicationOnlyViaFactory;
        static /*0x20*/ System.LazyHelper PublicationOnlyWaitForOtherThreadToPublish;
        /*0x10*/ System.LazyState <State>k__BackingField;
        /*0x18*/ System.Runtime.ExceptionServices.ExceptionDispatchInfo _exceptionDispatch;

        static /*0x32a2530*/ LazyHelper();
        static /*0x32a2304*/ System.LazyHelper Create(System.Threading.LazyThreadSafetyMode mode, bool useDefaultConstructor);
        static /*0x32a2468*/ object CreateViaDefaultConstructor(System.Type type);
        /*0x32a226c*/ LazyHelper(System.LazyState state);
        /*0x32a2294*/ LazyHelper(System.Threading.LazyThreadSafetyMode mode, System.Exception exception);
        /*0x32a2264*/ System.LazyState get_State();
        /*0x32a22ec*/ void ThrowException();
    }

    class Lazy<T>
    {
        /*0x0*/ System.LazyHelper _state;
        /*0x0*/ System.Func<T> _factory;
        /*0x0*/ T _value;

        static /*0x1ffc854*/ T CreateViaDefaultConstructor();
        /*0x1f309e4*/ Lazy();
        /*0x1f30ebc*/ Lazy(System.Func<T> valueFactory);
        /*0x1f30ee8*/ Lazy(System.Func<T> valueFactory, System.Threading.LazyThreadSafetyMode mode);
        Lazy(System.Func<T> valueFactory, System.Threading.LazyThreadSafetyMode mode, bool useDefaultConstructor);
        /*0x1f309e4*/ void ViaConstructor();
        /*0x1f30b78*/ void ViaFactory(System.Threading.LazyThreadSafetyMode mode);
        void ExecutionAndPublication(System.LazyHelper executionAndPublication, bool useDefaultConstructor);
        /*0x1ffc854*/ void PublicationOnly(System.LazyHelper publicationOnly, T possibleValue);
        /*0x1f30ebc*/ void PublicationOnlyViaConstructor(System.LazyHelper initializer);
        /*0x1f30ebc*/ void PublicationOnlyViaFactory(System.LazyHelper initializer);
        /*0x1f309e4*/ void PublicationOnlyWaitForOtherThreadToPublish();
        /*0x1ffc854*/ T CreateValue();
        /*0x1f30214*/ string ToString();
        /*0x1f2fe14*/ bool get_IsValueCreated();
        /*0x1ffc854*/ T get_Value();
    }

    class LazyDebugView<T>
    {
    }

    class Marvin
    {
        static /*0x0*/ ulong <DefaultSeed>k__BackingField;

        static /*0x32a2bf4*/ Marvin();
        static /*0x32a265c*/ int ComputeHash32(System.ReadOnlySpan<byte> data, ulong seed);
        static /*0x32a2708*/ int ComputeHash32(ref byte data, int count, ulong seed);
        static /*0x32a2afc*/ void Block(ref uint rp0, ref uint rp1);
        static /*0x32a2b84*/ uint _rotl(uint value, int shift);
        static /*0x32a2b90*/ ulong get_DefaultSeed();
        static /*0x32a2be8*/ ulong GenerateSeed();
    }

    class Math
    {
        static /*0x0*/ double doubleRoundLimit;
        static /*0x8*/ double[] roundPower10Double;

        static /*0x32a3958*/ Math();
        static /*0x32a2c44*/ int Abs(int value);
        static /*0x32a2cf4*/ long Abs(long value);
        static /*0x32a2d58*/ decimal Abs(decimal value);
        static /*0x32a2ca8*/ void ThrowAbsOverflow();
        static /*0x32a2ddc*/ int DivRem(int a, int b, ref int result);
        static /*0x32a2df0*/ int Clamp(int value, int min, int max);
        static /*0x32a2e90*/ float Clamp(float value, float min, float max);
        static /*0x32a2f3c*/ double Log(double a, double newBase);
        static /*0x32a3010*/ byte Max(byte val1, byte val2);
        static /*0x32a3024*/ decimal Max(decimal val1, decimal val2);
        static /*0x32a30bc*/ double Max(double val1, double val2);
        static /*0x32a30d8*/ short Max(short val1, short val2);
        static /*0x32a30ec*/ int Max(int val1, int val2);
        static /*0x32a30f8*/ long Max(long val1, long val2);
        static /*0x32a3104*/ sbyte Max(sbyte val1, sbyte val2);
        static /*0x32a3118*/ float Max(float val1, float val2);
        static /*0x32a3134*/ ushort Max(ushort val1, ushort val2);
        static /*0x32a3148*/ uint Max(uint val1, uint val2);
        static /*0x32a3154*/ ulong Max(ulong val1, ulong val2);
        static /*0x32a3160*/ byte Min(byte val1, byte val2);
        static /*0x32a3174*/ decimal Min(decimal val1, decimal val2);
        static /*0x32a320c*/ double Min(double val1, double val2);
        static /*0x32a3228*/ short Min(short val1, short val2);
        static /*0x32a323c*/ int Min(int val1, int val2);
        static /*0x32a3248*/ long Min(long val1, long val2);
        static /*0x32a3254*/ sbyte Min(sbyte val1, sbyte val2);
        static /*0x32a3268*/ float Min(float val1, float val2);
        static /*0x32a3284*/ ushort Min(ushort val1, ushort val2);
        static /*0x32a3298*/ uint Min(uint val1, uint val2);
        static /*0x32a32a4*/ ulong Min(ulong val1, ulong val2);
        static /*0x32a32b0*/ decimal Round(decimal d);
        static /*0x32a331c*/ decimal Round(decimal d, int decimals);
        static /*0x32a338c*/ double Round(double a);
        static /*0x32a3410*/ double Round(double value, int digits);
        static /*0x32a3724*/ double Round(double value, System.MidpointRounding mode);
        static /*0x32a3478*/ double Round(double value, int digits, System.MidpointRounding mode);
        static /*0x32a3790*/ int Sign(double value);
        static /*0x32a3808*/ int Sign(int value);
        static /*0x32a3818*/ int Sign(long value);
        static /*0x32a382c*/ decimal Truncate(decimal d);
        static /*0x32a3894*/ double Truncate(double d);
        static /*0x1ffc854*/ void ThrowMinMaxException<T>(T min, T max);
        static /*0x32a3904*/ double Abs(double value);
        static /*0x32a390c*/ float Abs(float value);
        static /*0x32a3914*/ double Acos(double d);
        static /*0x32a3918*/ double Asin(double d);
        static /*0x32a391c*/ double Atan(double d);
        static /*0x32a3920*/ double Atan2(double y, double x);
        static /*0x32a3924*/ double Ceiling(double a);
        static /*0x32a392c*/ double Cos(double d);
        static /*0x32a3930*/ double Exp(double d);
        static /*0x32a3934*/ double Floor(double d);
        static /*0x32a393c*/ double Log(double d);
        static /*0x32a3940*/ double Log10(double d);
        static /*0x32a3944*/ double Pow(double x, double y);
        static /*0x32a3948*/ double Sin(double a);
        static /*0x32a394c*/ double Sqrt(double d);
        static /*0x32a3954*/ double Tan(double a);
        static /*0x32a378c*/ double ModF(double x, double* intptr);
    }

    class MemberAccessException : System.SystemException
    {
        /*0x32a3a0c*/ MemberAccessException();
        /*0x32a3a68*/ MemberAccessException(string message);
        /*0x32a3a8c*/ MemberAccessException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    struct Memory<T> : System.IEquatable<System.Memory<T>>
    {
        /*0x0*/ object _object;
        /*0x0*/ int _index;
        /*0x0*/ int _length;

        static /*0x1ffc854*/ System.Memory<T> op_Implicit(T[] array);
        static /*0x1ffc854*/ System.Memory<T> op_Implicit(System.ArraySegment<T> segment);
        static /*0x1ffc854*/ System.ReadOnlyMemory<T> op_Implicit(System.Memory<T> memory);
        static /*0x1ffc854*/ System.Memory<T> get_Empty();
        static /*0x1f31e78*/ int CombineHashCodes(int left, int right);
        static int CombineHashCodes(int h1, int h2, int h3);
        /*0x1f30ebc*/ Memory(T[] array);
        /*0x1f30ee8*/ Memory(T[] array, int start);
        Memory(T[] array, int start, int length);
        /*0x1f30ee8*/ Memory(System.Buffers.MemoryManager<T> manager, int length);
        Memory(object obj, int start, int length);
        /*0x1f2ffc8*/ int get_Length();
        /*0x1f30214*/ string ToString();
        /*0x1ffc854*/ System.Memory<T> Slice(int start);
        /*0x1ffc854*/ System.Memory<T> Slice(int start, int length);
        /*0x1ffc854*/ System.Span<T> get_Span();
        /*0x1ffc854*/ System.Buffers.MemoryHandle Pin();
        /*0x1f30214*/ T[] ToArray();
        /*0x1f2fec8*/ bool Equals(object obj);
        /*0x1ffc854*/ bool Equals(System.Memory<T> other);
        /*0x1f2ffc8*/ int GetHashCode();
    }

    class MemoryDebugView<T>
    {
    }

    class MemoryExtensions
    {
        static /*0x32a3a94*/ bool EqualsOrdinal(System.ReadOnlySpan<char> span, System.ReadOnlySpan<char> value);
        static /*0x32a3b30*/ bool EqualsOrdinalIgnoreCase(System.ReadOnlySpan<char> span, System.ReadOnlySpan<char> value);
        static /*0x32a3bdc*/ bool Contains(System.ReadOnlySpan<char> source, char value);
        static /*0x32a3c74*/ int ToUpperInvariant(System.ReadOnlySpan<char> source, System.Span<char> destination);
        static /*0x32a3df4*/ bool EndsWith(System.ReadOnlySpan<char> span, System.ReadOnlySpan<char> value, System.StringComparison comparisonType);
        static /*0x1ffc854*/ System.Span<T> AsSpan<T>(T[] array, int start);
        static /*0x32a4080*/ System.ReadOnlySpan<char> AsSpan(string text);
        static /*0x32a40d8*/ System.ReadOnlySpan<char> AsSpan(string text, int start);
        static /*0x32a4164*/ System.ReadOnlySpan<char> AsSpan(string text, int start, int length);
        static /*0x32a4204*/ System.ReadOnlyMemory<char> AsMemory(string text, int start, int length);
        static /*0x329a78c*/ System.ReadOnlySpan<char> Trim(System.ReadOnlySpan<char> span);
        static /*0x32a42ac*/ System.ReadOnlySpan<char> TrimStart(System.ReadOnlySpan<char> span);
        static /*0x32a43c8*/ System.ReadOnlySpan<char> TrimEnd(System.ReadOnlySpan<char> span);
        static /*0x1ffc854*/ int IndexOf<T>(System.Span<T> span, T value);
        static /*0x1ffc854*/ int IndexOf<T>(System.Span<T> span, System.ReadOnlySpan<T> value);
        static /*0x1ffc854*/ int SequenceCompareTo<T>(System.Span<T> span, System.ReadOnlySpan<T> other);
        static /*0x1ffc854*/ int IndexOf<T>(System.ReadOnlySpan<T> span, T value);
        static /*0x1ffc854*/ int IndexOfAny<T>(System.ReadOnlySpan<T> span, System.ReadOnlySpan<T> values);
        static /*0x1ffc854*/ bool SequenceEqual<T>(System.ReadOnlySpan<T> span, System.ReadOnlySpan<T> other);
        static /*0x1ffc854*/ bool StartsWith<T>(System.ReadOnlySpan<T> span, System.ReadOnlySpan<T> value);
        static /*0x1ffc854*/ bool EndsWith<T>(System.ReadOnlySpan<T> span, System.ReadOnlySpan<T> value);
        static /*0x1ffc854*/ void Reverse<T>(System.Span<T> span);
        static /*0x1ffc854*/ System.Span<T> AsSpan<T>(T[] array);
        static /*0x1ffc854*/ System.Span<T> AsSpan<T>(T[] array, int start, int length);
        static /*0x1ffc854*/ System.Memory<T> AsMemory<T>(T[] array);
        static /*0x1ffc854*/ System.Memory<T> AsMemory<T>(T[] array, int start);
        static /*0x1ffc854*/ void CopyTo<T>(T[] source, System.Span<T> destination);
        static /*0x1f31840*/ bool IsTypeComparableAsBytes<T>(ref ulong size);
    }

    class MethodAccessException : System.MemberAccessException
    {
        /*0x32a44fc*/ MethodAccessException();
        /*0x32a4558*/ MethodAccessException(string message);
        /*0x32a457c*/ MethodAccessException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    enum MidpointRounding
    {
        ToEven = 0,
        AwayFromZero = 1,
    }

    class MissingMethodException : System.MissingMemberException
    {
        /*0x32a4584*/ MissingMethodException();
        /*0x32a45e0*/ MissingMethodException(string message);
        /*0x32a4604*/ MissingMethodException(string className, string methodName);
        /*0x32a4648*/ MissingMethodException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x32a4650*/ string get_Message();
    }

    class MulticastNotSupportedException : System.SystemException
    {
        /*0x32a4738*/ MulticastNotSupportedException();
        /*0x32a4794*/ MulticastNotSupportedException(string message);
        /*0x32a47b8*/ MulticastNotSupportedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class NonSerializedAttribute : System.Attribute
    {
        /*0x32a47c0*/ NonSerializedAttribute();
    }

    class NotImplementedException : System.SystemException
    {
        /*0x32a47c8*/ NotImplementedException();
        /*0x32a4824*/ NotImplementedException(string message);
        /*0x32a4848*/ NotImplementedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class NotSupportedException : System.SystemException
    {
        /*0x32a4850*/ NotSupportedException();
        /*0x329d250*/ NotSupportedException(string message);
        /*0x32a48ac*/ NotSupportedException(string message, System.Exception innerException);
        /*0x32a48d0*/ NotSupportedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class NullReferenceException : System.SystemException
    {
        /*0x32a48d8*/ NullReferenceException();
        /*0x32a4934*/ NullReferenceException(string message);
        /*0x32a4958*/ NullReferenceException(string message, System.Exception innerException);
        /*0x32a497c*/ NullReferenceException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    struct Nullable<T>
    {
        /*0x0*/ bool hasValue;
        /*0x0*/ T value;

        static /*0x1ffc854*/ object Box(System.Nullable<T> o);
        static /*0x1ffc854*/ System.Nullable<T> Unbox(object o);
        static /*0x1ffc854*/ System.Nullable<T> UnboxExact(object o);
        /*0x1ffc854*/ Nullable(T value);
        /*0x1f2fe14*/ bool get_HasValue();
        /*0x1ffc854*/ T get_Value();
        /*0x1ffc854*/ T GetValueOrDefault();
        /*0x1ffc854*/ T GetValueOrDefault(T defaultValue);
        /*0x1f2fec8*/ bool Equals(object other);
        /*0x1f2ffc8*/ int GetHashCode();
        /*0x1f30214*/ string ToString();
    }

    class Nullable
    {
        static /*0x32a4984*/ System.Type GetUnderlyingType(System.Type nullableType);
    }

    class Number
    {
        static /*0x0*/ string[] s_posCurrencyFormats;
        static /*0x8*/ string[] s_negCurrencyFormats;
        static /*0x10*/ string[] s_posPercentFormats;
        static /*0x18*/ string[] s_negPercentFormats;
        static /*0x20*/ string[] s_negNumberFormats;
        static /*0x28*/ int[] s_charToHexLookup;
        static /*0x30*/ ulong[] s_rgval64Power10;
        static /*0x38*/ sbyte[] s_rgexp64Power10;
        static /*0x40*/ ulong[] s_rgval64Power10By16;
        static /*0x48*/ short[] s_rgexp64Power10By16;

        static /*0x32b0460*/ Number();
        static /*0x32a4ac4*/ string FormatDecimal(decimal value, System.ReadOnlySpan<char> format, System.Globalization.NumberFormatInfo info);
        static /*0x32a6880*/ bool TryFormatDecimal(decimal value, System.ReadOnlySpan<char> format, System.Globalization.NumberFormatInfo info, System.Span<char> destination, ref int charsWritten);
        static /*0x32a4e34*/ void DecimalToNumber(decimal value, ref System.Number.NumberBuffer number);
        static /*0x32a6b1c*/ string FormatDouble(double value, string format, System.Globalization.NumberFormatInfo info);
        static /*0x32a6fd0*/ bool TryFormatDouble(double value, System.ReadOnlySpan<char> format, System.Globalization.NumberFormatInfo info, System.Span<char> destination, ref int charsWritten);
        static /*0x32a6cd8*/ string FormatDouble(ref System.Text.ValueStringBuilder sb, double value, System.ReadOnlySpan<char> format, System.Globalization.NumberFormatInfo info);
        static /*0x32a7c18*/ string FormatSingle(float value, string format, System.Globalization.NumberFormatInfo info);
        static /*0x32a80d4*/ bool TryFormatSingle(float value, System.ReadOnlySpan<char> format, System.Globalization.NumberFormatInfo info, System.Span<char> destination, ref int charsWritten);
        static /*0x32a7dd4*/ string FormatSingle(ref System.Text.ValueStringBuilder sb, float value, System.ReadOnlySpan<char> format, System.Globalization.NumberFormatInfo info);
        static /*0x32a71a4*/ bool TryCopyTo(string source, System.Span<char> destination, ref int charsWritten);
        static /*0x329d5bc*/ string FormatInt32(int value, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        static /*0x329e33c*/ bool TryFormatInt32(int value, System.ReadOnlySpan<char> format, System.IFormatProvider provider, System.Span<char> destination, ref int charsWritten);
        static /*0x329db74*/ string FormatUInt32(uint value, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        static /*0x329dfc0*/ bool TryFormatUInt32(uint value, System.ReadOnlySpan<char> format, System.IFormatProvider provider, System.Span<char> destination, ref int charsWritten);
        static /*0x32a0764*/ string FormatInt64(long value, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        static /*0x32a0da8*/ bool TryFormatInt64(long value, System.ReadOnlySpan<char> format, System.IFormatProvider provider, System.Span<char> destination, ref int charsWritten);
        static /*0x32a9e4c*/ string FormatUInt64(ulong value, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        static /*0x32aa338*/ bool TryFormatUInt64(ulong value, System.ReadOnlySpan<char> format, System.IFormatProvider provider, System.Span<char> destination, ref int charsWritten);
        static /*0x32aa6b0*/ void Int32ToNumber(int value, ref System.Number.NumberBuffer number);
        static /*0x32a8448*/ string NegativeInt32ToDecStr(int value, int digits, string sNegative);
        static /*0x32a891c*/ bool TryNegativeInt32ToDecStr(int value, int digits, string sNegative, System.Span<char> destination, ref int charsWritten);
        static /*0x32a85f8*/ string Int32ToHexStr(int value, char hexBase, int digits);
        static /*0x32a8b00*/ bool TryInt32ToHexStr(int value, char hexBase, int digits, System.Span<char> destination, ref int charsWritten);
        static /*0x32aa7d8*/ char* Int32ToHexChars(char* buffer, uint value, int hexBase, int digits);
        static /*0x32aa82c*/ void UInt32ToNumber(uint value, ref System.Number.NumberBuffer number);
        static /*0x32a6ac8*/ char* UInt32ToDecChars(char* bufferEnd, uint value, int digits);
        static /*0x32a82a8*/ string UInt32ToDecStr(uint value, int digits);
        static /*0x32a8744*/ bool TryUInt32ToDecStr(uint value, int digits, System.Span<char> destination, ref int charsWritten);
        static /*0x32a943c*/ void Int64ToNumber(long input, ref System.Number.NumberBuffer number);
        static /*0x32a8f28*/ string NegativeInt64ToDecStr(long input, int digits, string sNegative);
        static /*0x32a98d8*/ bool TryNegativeInt64ToDecStr(long input, int digits, string sNegative, System.Span<char> destination, ref int charsWritten);
        static /*0x32a9218*/ string Int64ToHexStr(long value, char hexBase, int digits);
        static /*0x32a9bfc*/ bool TryInt64ToHexStr(long value, char hexBase, int digits, System.Span<char> destination, ref int charsWritten);
        static /*0x32aa180*/ void UInt64ToNumber(ulong value, ref System.Number.NumberBuffer number);
        static /*0x32a8c88*/ string UInt64ToDecStr(ulong value, int digits);
        static /*0x32a9608*/ bool TryUInt64ToDecStr(ulong value, int digits, System.Span<char> destination, ref int charsWritten);
        static /*0x32a4cf0*/ char ParseFormatSpecifier(System.ReadOnlySpan<char> format, ref int digits);
        static /*0x32a506c*/ void NumberToString(ref System.Text.ValueStringBuilder sb, ref System.Number.NumberBuffer number, char format, int nMaxDigits, System.Globalization.NumberFormatInfo info, bool isDecimal);
        static /*0x32a5638*/ void NumberToStringFormat(ref System.Text.ValueStringBuilder sb, ref System.Number.NumberBuffer number, System.ReadOnlySpan<char> format, System.Globalization.NumberFormatInfo info);
        static /*0x32aaa98*/ void FormatCurrency(ref System.Text.ValueStringBuilder sb, ref System.Number.NumberBuffer number, int nMinDigits, int nMaxDigits, System.Globalization.NumberFormatInfo info);
        static /*0x32aad1c*/ void FormatFixed(ref System.Text.ValueStringBuilder sb, ref System.Number.NumberBuffer number, int nMinDigits, int nMaxDigits, System.Globalization.NumberFormatInfo info, int[] groupDigits, string sDecimal, string sGroup);
        static /*0x32ab1cc*/ void FormatNumber(ref System.Text.ValueStringBuilder sb, ref System.Number.NumberBuffer number, int nMinDigits, int nMaxDigits, System.Globalization.NumberFormatInfo info);
        static /*0x32ab420*/ void FormatScientific(ref System.Text.ValueStringBuilder sb, ref System.Number.NumberBuffer number, int nMinDigits, int nMaxDigits, System.Globalization.NumberFormatInfo info, char expChar);
        static /*0x32abdcc*/ void FormatExponent(ref System.Text.ValueStringBuilder sb, System.Globalization.NumberFormatInfo info, int value, char expChar, int minDigits, bool positiveSign);
        static /*0x32ab67c*/ void FormatGeneral(ref System.Text.ValueStringBuilder sb, ref System.Number.NumberBuffer number, int nMinDigits, int nMaxDigits, System.Globalization.NumberFormatInfo info, char expChar, bool bSuppressScientific);
        static /*0x32aba04*/ void FormatPercent(ref System.Text.ValueStringBuilder sb, ref System.Number.NumberBuffer number, int nMinDigits, int nMaxDigits, System.Globalization.NumberFormatInfo info);
        static /*0x32aa988*/ void RoundNumber(ref System.Number.NumberBuffer number, int pos);
        static /*0x32abc88*/ int FindSection(System.ReadOnlySpan<char> format, int section);
        static /*0x32aa984*/ uint Low32(ulong value);
        static /*0x32aa97c*/ uint High32(ulong value);
        static /*0x32aa944*/ uint Int64DivMod1E9(ref ulong value);
        static /*0x32ac098*/ bool NumberToInt32(ref System.Number.NumberBuffer number, ref int value);
        static /*0x32ac154*/ bool NumberToInt64(ref System.Number.NumberBuffer number, ref long value);
        static /*0x32ac20c*/ bool NumberToUInt32(ref System.Number.NumberBuffer number, ref uint value);
        static /*0x32ac2bc*/ bool NumberToUInt64(ref System.Number.NumberBuffer number, ref ulong value);
        static /*0x329ea08*/ int ParseInt32(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info);
        static /*0x32a1264*/ long ParseInt64(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info);
        static /*0x32ad79c*/ uint ParseUInt32(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info);
        static /*0x32adfb0*/ ulong ParseUInt64(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info);
        static /*0x32ae7c4*/ bool ParseNumber(ref char* str, char* strEnd, System.Globalization.NumberStyles styles, ref System.Number.NumberBuffer number, System.Globalization.NumberFormatInfo info, bool parseDecimal);
        static /*0x329ee00*/ bool TryParseInt32(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info, ref int result);
        static /*0x32ac36c*/ bool TryParseInt32IntegerStyle(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info, ref int result, ref bool failureIsOverflow);
        static /*0x32ace78*/ bool TryParseInt64IntegerStyle(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info, ref long result, ref bool failureIsOverflow);
        static /*0x32a16fc*/ bool TryParseInt64(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info, ref long result);
        static /*0x32af128*/ bool TryParseUInt32(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info, ref uint result);
        static /*0x32ad990*/ bool TryParseUInt32IntegerStyle(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info, ref uint result, ref bool failureIsOverflow);
        static /*0x32ac9fc*/ bool TryParseUInt32HexNumberStyle(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info, ref uint result, ref bool failureIsOverflow);
        static /*0x32af2b0*/ bool TryParseUInt64(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info, ref ulong result);
        static /*0x32ae1a4*/ bool TryParseUInt64IntegerStyle(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info, ref ulong result, ref bool failureIsOverflow);
        static /*0x32ad464*/ bool TryParseUInt64HexNumberStyle(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info, ref ulong result, ref bool failureIsOverflow);
        static /*0x32af438*/ decimal ParseDecimal(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info);
        static /*0x32af560*/ bool NumberBufferToDecimal(ref System.Number.NumberBuffer number, ref decimal value);
        static /*0x32af870*/ double ParseDouble(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info);
        static /*0x32afc90*/ float ParseSingle(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info);
        static /*0x32b003c*/ bool TryParseDecimal(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info, ref decimal result);
        static /*0x32b0140*/ bool TryParseDouble(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info, ref double result);
        static /*0x32b0244*/ bool TryParseSingle(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info, ref float result);
        static /*0x32acd34*/ void StringToNumber(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, ref System.Number.NumberBuffer number, System.Globalization.NumberFormatInfo info, bool parseDecimal);
        static /*0x32aef5c*/ bool TryStringToNumber(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, ref System.Number.NumberBuffer number, System.Globalization.NumberFormatInfo info, bool parseDecimal);
        static /*0x32af090*/ bool TrailingZeros(System.ReadOnlySpan<char> value, int index);
        static /*0x32aeec0*/ char* MatchChars(char* p, char* pEnd, string value);
        static /*0x32aeeac*/ bool IsWhite(int ch);
        static /*0x32aef4c*/ bool IsDigit(int ch);
        static /*0x32ac974*/ void ThrowOverflowOrFormatException(bool overflow, string overflowResourceKey);
        static /*0x32afc08*/ bool NumberBufferToDouble(ref System.Number.NumberBuffer number, ref double value);
        static /*0x32b0380*/ uint DigitsToInt(char* p, int count);
        static /*0x32b03b4*/ ulong Mul32x32To64(uint a, uint b);
        static /*0x32b03bc*/ ulong Mul64Lossy(ulong a, ulong b, ref int pexp);
        static /*0x32b0454*/ int abs(int value);
        static /*0x32a7728*/ double NumberToDouble(ref System.Number.NumberBuffer number);
        static /*0x32a727c*/ void DoubleToNumber(double value, int precision, ref System.Number.NumberBuffer number);

        struct NumberBuffer
        {
            /*0x10*/ int precision;
            /*0x14*/ int scale;
            /*0x18*/ int _sign;
            /*0x1c*/ System.Number.NumberBuffer.DigitsAndNullTerminator _digits;
            /*0x82*/ char* _allDigits;

            /*0x32b16c8*/ bool get_sign();
            /*0x32b16d8*/ void set_sign(bool value);
            /*0x32b16e4*/ char* get_digits();

            struct DigitsAndNullTerminator
            {
            }
        }
    }

    class ObjectDisposedException : System.InvalidOperationException
    {
        /*0x90*/ string _objectName;

        /*0x32b16ec*/ ObjectDisposedException();
        /*0x32b1794*/ ObjectDisposedException(string objectName);
        /*0x32b1754*/ ObjectDisposedException(string objectName, string message);
        /*0x32b1808*/ ObjectDisposedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x32b1898*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x32b19ac*/ string get_Message();
        /*0x32b1954*/ string get_ObjectName();
    }

    class ObsoleteAttribute : System.Attribute
    {
        /*0x10*/ string _message;
        /*0x18*/ bool _error;

        /*0x32b1a60*/ ObsoleteAttribute();
        /*0x32b1a8c*/ ObsoleteAttribute(string message);
        /*0x32b1ac4*/ ObsoleteAttribute(string message, bool error);
        /*0x32b1b00*/ string get_Message();
        /*0x32b1b08*/ bool get_IsError();
    }

    class OperationCanceledException : System.SystemException
    {
        /*0x90*/ System.Threading.CancellationToken _cancellationToken;

        /*0x32b1b24*/ OperationCanceledException();
        /*0x32b1bf4*/ OperationCanceledException(string message);
        /*0x32b1c14*/ OperationCanceledException(string message, System.Exception innerException);
        /*0x32b1cb4*/ OperationCanceledException(string message, System.Threading.CancellationToken token);
        /*0x32b1cec*/ OperationCanceledException(string message, System.Exception innerException, System.Threading.CancellationToken token);
        /*0x32b1d24*/ OperationCanceledException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x32b1b10*/ System.Threading.CancellationToken get_CancellationToken();
        /*0x32b1b18*/ void set_CancellationToken(System.Threading.CancellationToken value);
    }

    class OverflowException : System.ArithmeticException
    {
        /*0x32b1da8*/ OverflowException();
        /*0x32b1e04*/ OverflowException(string message);
        /*0x32b1e28*/ OverflowException(string message, System.Exception innerException);
        /*0x32b1e4c*/ OverflowException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class ParamArrayAttribute : System.Attribute
    {
        /*0x32b1e54*/ ParamArrayAttribute();
    }

    struct ParamsArray
    {
        static /*0x0*/ object[] s_oneArgArray;
        static /*0x8*/ object[] s_twoArgArray;
        static /*0x10*/ object[] s_threeArgArray;
        /*0x10*/ object _arg0;
        /*0x18*/ object _arg1;
        /*0x20*/ object _arg2;
        /*0x28*/ object[] _args;

        static /*0x32b21ec*/ ParamsArray();
        /*0x32b1e5c*/ ParamsArray(object arg0);
        /*0x32b1efc*/ ParamsArray(object arg0, object arg1);
        /*0x32b1fa0*/ ParamsArray(object arg0, object arg1, object arg2);
        /*0x32b2050*/ ParamsArray(object[] args);
        /*0x32b2110*/ int get_Length();
        /*0x32b2128*/ object get_Item(int index);
        /*0x32b2198*/ object GetAtSlow(int index);
    }

    class ParseNumbers
    {
        static /*0x32b22a8*/ long StringToLong(System.ReadOnlySpan<char> s, int radix, int flags);
        static /*0x32b22c0*/ long StringToLong(System.ReadOnlySpan<char> s, int radix, int flags, ref int currPos);
        static /*0x32b2894*/ int StringToInt(System.ReadOnlySpan<char> s, int radix, int flags);
        static /*0x32b28ac*/ int StringToInt(System.ReadOnlySpan<char> s, int radix, int flags, ref int currPos);
        static /*0x32b2e54*/ string IntToString(int n, int radix, int width, char paddingChar, int flags);
        static /*0x32b322c*/ string LongToString(long n, int radix, int width, char paddingChar, int flags);
        static /*0x32b2620*/ void EatWhiteSpace(System.ReadOnlySpan<char> s, ref int i);
        static /*0x32b26dc*/ long GrabLongs(int radix, System.ReadOnlySpan<char> s, ref int i, bool isUnsigned);
        static /*0x32b2c64*/ int GrabInts(int radix, System.ReadOnlySpan<char> s, ref int i, bool isUnsigned);
        static /*0x32b36fc*/ void ThrowOverflowInt32Exception();
        static /*0x32b366c*/ void ThrowOverflowInt64Exception();
        static /*0x32b3744*/ void ThrowOverflowUInt32Exception();
        static /*0x32b36b4*/ void ThrowOverflowUInt64Exception();
        static /*0x32b378c*/ bool IsDigit(char c, int radix, ref int result);
    }

    class PlatformNotSupportedException : System.NotSupportedException
    {
        /*0x32b37e0*/ PlatformNotSupportedException();
        /*0x32b383c*/ PlatformNotSupportedException(string message);
        /*0x32b3860*/ PlatformNotSupportedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class Random
    {
        static /*0x0*/ System.Random s_globalRandom;
        [ThreadStatic] static System.Random t_threadRandom;
        /*0x10*/ int _inext;
        /*0x14*/ int _inextp;
        /*0x18*/ int[] _seedArray;

        static /*0x32b4058*/ Random();
        static /*0x32b38c4*/ int GenerateSeed();
        static /*0x32b3cec*/ int GenerateGlobalSeed();
        /*0x32b3868*/ Random();
        /*0x32b3a90*/ Random(int Seed);
        /*0x32b3c3c*/ double Sample();
        /*0x32b3c5c*/ int InternalSample();
        /*0x32b3d10*/ int Next();
        /*0x32b3d14*/ double GetSampleForLargeRange();
        /*0x32b3d60*/ int Next(int minValue, int maxValue);
        /*0x32b3e78*/ int Next(int maxValue);
        /*0x32b3f3c*/ void NextBytes(byte[] buffer);
        /*0x32b3fe8*/ void NextBytes(System.Span<byte> buffer);
    }

    class RankException : System.SystemException
    {
        /*0x32b40e4*/ RankException();
        /*0x32b413c*/ RankException(string message);
        /*0x32b415c*/ RankException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    struct ReadOnlyMemory<T> : System.IEquatable<System.ReadOnlyMemory<T>>
    {
        /*0x0*/ object _object;
        /*0x0*/ int _index;
        /*0x0*/ int _length;

        static /*0x1ffc854*/ System.ReadOnlyMemory<T> op_Implicit(T[] array);
        static /*0x1ffc854*/ System.ReadOnlyMemory<T> op_Implicit(System.ArraySegment<T> segment);
        static /*0x1f31e78*/ int CombineHashCodes(int left, int right);
        static int CombineHashCodes(int h1, int h2, int h3);
        /*0x1f30ebc*/ ReadOnlyMemory(T[] array);
        ReadOnlyMemory(T[] array, int start, int length);
        ReadOnlyMemory(object obj, int start, int length);
        /*0x1f2ffc8*/ int get_Length();
        /*0x1f2fe14*/ bool get_IsEmpty();
        /*0x1f30214*/ string ToString();
        /*0x1ffc854*/ System.ReadOnlyMemory<T> Slice(int start);
        /*0x1ffc854*/ System.ReadOnlyMemory<T> Slice(int start, int length);
        /*0x1ffc854*/ System.ReadOnlySpan<T> get_Span();
        /*0x1ffc854*/ void CopyTo(System.Memory<T> destination);
        /*0x1f30214*/ T[] ToArray();
        /*0x1f2fec8*/ bool Equals(object obj);
        /*0x1ffc854*/ bool Equals(System.ReadOnlyMemory<T> other);
        /*0x1f2ffc8*/ int GetHashCode();
        /*0x1f30394*/ object GetObjectStartLength(ref int start, ref int length);
    }

    struct ReadOnlySpan<T>
    {
        /*0x0*/ System.ByReference<T> _pointer;
        /*0x0*/ int _length;

        static /*0x1ffc854*/ bool op_Equality(System.ReadOnlySpan<T> left, System.ReadOnlySpan<T> right);
        static /*0x1ffc854*/ System.ReadOnlySpan<T> op_Implicit(T[] array);
        static /*0x1ffc854*/ System.ReadOnlySpan<T> get_Empty();
        /*0x1f30ebc*/ ReadOnlySpan(T[] array);
        ReadOnlySpan(T[] array, int start, int length);
        /*0x1ffc854*/ ReadOnlySpan(void* pointer, int length);
        /*0x1f30ee8*/ ReadOnlySpan(ref T ptr, int length);
        /*0x1f30240*/ ref T get_Item(int index);
        /*0x1f30214*/ ref T GetPinnableReference();
        /*0x1ffc854*/ void CopyTo(System.Span<T> destination);
        /*0x1ffc854*/ bool TryCopyTo(System.Span<T> destination);
        /*0x1f30214*/ string ToString();
        /*0x1ffc854*/ System.ReadOnlySpan<T> Slice(int start);
        /*0x1ffc854*/ System.ReadOnlySpan<T> Slice(int start, int length);
        /*0x1f30214*/ T[] ToArray();
        /*0x1f2ffc8*/ int get_Length();
        /*0x1f2fe14*/ bool get_IsEmpty();
        /*0x1f2fec8*/ bool Equals(object obj);
        /*0x1f2ffc8*/ int GetHashCode();
    }

    class ResolveEventArgs : System.EventArgs
    {
        /*0x10*/ string <Name>k__BackingField;
        /*0x18*/ System.Reflection.Assembly <RequestingAssembly>k__BackingField;

        /*0x32b4160*/ ResolveEventArgs(string name);
        /*0x32b41d4*/ ResolveEventArgs(string name, System.Reflection.Assembly requestingAssembly);
    }

    class ResolveEventHandler : System.MulticastDelegate
    {
        /*0x32b425c*/ ResolveEventHandler(object object, nint method);
        /*0x32b4368*/ System.Reflection.Assembly Invoke(object sender, System.ResolveEventArgs args);
    }

    struct SByte : System.IComparable, System.IConvertible, System.IFormattable, System.IComparable<sbyte>, System.IEquatable<sbyte>, System.ISpanFormattable
    {
        /*0x10*/ sbyte m_value;

        static /*0x32b4844*/ sbyte Parse(string s, System.IFormatProvider provider);
        static /*0x32b4a78*/ sbyte Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x32b48e0*/ sbyte Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo info);
        static /*0x32b4b08*/ bool TryParse(string s, ref sbyte result);
        static /*0x32b4c50*/ bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref sbyte result);
        static /*0x32b4b88*/ bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo info, ref sbyte result);
        /*0x32b437c*/ int CompareTo(object obj);
        /*0x32b4408*/ int CompareTo(sbyte value);
        /*0x32b4414*/ bool Equals(object obj);
        /*0x32b445c*/ bool Equals(sbyte obj);
        /*0x32b446c*/ int GetHashCode();
        /*0x32b4478*/ string ToString();
        /*0x32b4510*/ string ToString(System.IFormatProvider provider);
        /*0x32b45ac*/ string ToString(string format, System.IFormatProvider provider);
        /*0x32b4728*/ bool TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        /*0x32b4cf8*/ System.TypeCode GetTypeCode();
        /*0x32b4d00*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x32b4d5c*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x32b4db8*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x32b4dc0*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x32b4e1c*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x32b4e78*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x32b4ed4*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x32b4edc*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x32b4f38*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x32b4f94*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x32b4ff0*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x32b504c*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x32b50a8*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x32b5104*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x32b5188*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);
    }

    class SerializableAttribute : System.Attribute
    {
        /*0x32b5228*/ SerializableAttribute();
    }

    struct Single : System.IComparable, System.IConvertible, System.IFormattable, System.IComparable<float>, System.IEquatable<float>, System.ISpanFormattable
    {
        /*0x10*/ float m_value;

        static /*0x32b5230*/ bool IsFinite(float f);
        static /*0x32b5244*/ bool IsInfinity(float f);
        static /*0x32b525c*/ bool IsNaN(float f);
        static /*0x32b5274*/ bool IsNegativeInfinity(float f);
        static /*0x32b5288*/ bool IsPositiveInfinity(float f);
        static /*0x32b578c*/ float Parse(string s);
        static /*0x32b5840*/ float Parse(string s, System.IFormatProvider provider);
        static /*0x32b5904*/ float Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x32b59d8*/ bool TryParse(string s, ref float result);
        static /*0x32b5d14*/ bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref float result);
        static /*0x32b5a58*/ bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo info, ref float result);
        /*0x32b529c*/ int CompareTo(object value);
        /*0x32b5374*/ int CompareTo(float value);
        /*0x32b53d0*/ bool Equals(object obj);
        /*0x32b5450*/ bool Equals(float obj);
        /*0x32b5494*/ int GetHashCode();
        /*0x32b54ac*/ string ToString();
        /*0x32b5528*/ string ToString(System.IFormatProvider provider);
        /*0x32b55b4*/ string ToString(string format);
        /*0x32b563c*/ string ToString(string format, System.IFormatProvider provider);
        /*0x32b56cc*/ bool TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        /*0x32b5dbc*/ System.TypeCode GetTypeCode();
        /*0x32b5dc4*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x32b5e28*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x32b5eac*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x32b5f10*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x32b5f74*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x32b5fd8*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x32b603c*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x32b60a0*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x32b6104*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x32b6168*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x32b61cc*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x32b61d4*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x32b6238*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x32b629c*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x32b6320*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);
    }

    struct Span<T>
    {
        /*0x0*/ System.ByReference<T> _pointer;
        /*0x0*/ int _length;

        static /*0x1ffc854*/ System.ReadOnlySpan<T> op_Implicit(System.Span<T> span);
        static /*0x1ffc854*/ System.Span<T> op_Implicit(T[] array);
        static /*0x1ffc854*/ System.Span<T> get_Empty();
        /*0x1f30ebc*/ Span(T[] array);
        Span(T[] array, int start, int length);
        /*0x1ffc854*/ Span(void* pointer, int length);
        /*0x1f30ee8*/ Span(ref T ptr, int length);
        /*0x1f30240*/ ref T get_Item(int index);
        /*0x1f30214*/ ref T GetPinnableReference();
        /*0x1f309e4*/ void Clear();
        /*0x1ffc854*/ void Fill(T value);
        /*0x1ffc854*/ void CopyTo(System.Span<T> destination);
        /*0x1ffc854*/ bool TryCopyTo(System.Span<T> destination);
        /*0x1f30214*/ string ToString();
        /*0x1ffc854*/ System.Span<T> Slice(int start);
        /*0x1ffc854*/ System.Span<T> Slice(int start, int length);
        /*0x1f30214*/ T[] ToArray();
        /*0x1f2ffc8*/ int get_Length();
        /*0x1f2fe14*/ bool get_IsEmpty();
        /*0x1f2fec8*/ bool Equals(object obj);
        /*0x1f2ffc8*/ int GetHashCode();
    }

    class SpanDebugView<T>
    {
    }

    class SpanHelpers
    {
        static /*0x32b63c0*/ int IndexOf(ref byte searchSpace, int searchSpaceLength, ref byte value, int valueLength);
        static /*0x32b673c*/ int IndexOfAny(ref byte searchSpace, int searchSpaceLength, ref byte value, int valueLength);
        static /*0x32b6490*/ int IndexOf(ref byte searchSpace, byte value, int length);
        static /*0x32b67b8*/ bool SequenceEqual(ref byte first, ref byte second, ulong length);
        static /*0x32b6928*/ int SequenceCompareTo(ref byte first, int firstLength, ref byte second, int secondLength);
        static /*0x32b6a6c*/ int SequenceCompareTo(ref char first, int firstLength, ref char second, int secondLength);
        static /*0x32b6f0c*/ int IndexOf(ref char searchSpace, char value, int length);
        static /*0x32b757c*/ int LastIndexOf(ref char searchSpace, char value, int length);
        static /*0x32b7b90*/ int LocateFirstFoundChar(System.Numerics.Vector<ushort> match);
        static /*0x32b7d88*/ int LocateFirstFoundChar(ulong match);
        static /*0x32b7da8*/ int LocateLastFoundChar(System.Numerics.Vector<ushort> match);
        static /*0x32b7fa0*/ int LocateLastFoundChar(ulong match);
        static int IndexOf<T>(ref T searchSpace, int searchSpaceLength, ref T value, int valueLength);
        static /*0x1ffc854*/ int IndexOf<T>(ref T searchSpace, T value, int length);
        static int IndexOfAny<T>(ref T searchSpace, int searchSpaceLength, ref T value, int valueLength);
        static /*0x1f31938*/ bool SequenceEqual<T>(ref T first, ref T second, int length);
        static int SequenceCompareTo<T>(ref T first, int firstLength, ref T second, int secondLength);
        static /*0x32b7fcc*/ bool EndsWithCultureHelper(System.ReadOnlySpan<char> span, System.ReadOnlySpan<char> value, System.Globalization.CompareInfo compareInfo);
        static /*0x32b8104*/ bool EndsWithCultureIgnoreCaseHelper(System.ReadOnlySpan<char> span, System.ReadOnlySpan<char> value, System.Globalization.CompareInfo compareInfo);
        static /*0x32b8224*/ bool EndsWithOrdinalIgnoreCaseHelper(System.ReadOnlySpan<char> span, System.ReadOnlySpan<char> value);
        static /*0x32b8328*/ void ClearWithoutReferences(ref byte b, ulong byteLength);
        static /*0x32b8554*/ void ClearWithReferences(ref nint ip, ulong pointerSizeLength);
    }

    class StackOverflowException : System.SystemException
    {
        /*0x32b86a4*/ StackOverflowException();
        /*0x32b86fc*/ StackOverflowException(string message);
        /*0x32b871c*/ StackOverflowException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class StringComparer : System.Collections.IComparer, System.Collections.IEqualityComparer, System.Collections.Generic.IComparer<string>, System.Collections.Generic.IEqualityComparer<string>
    {
        static /*0x0*/ System.CultureAwareComparer s_invariantCulture;
        static /*0x8*/ System.CultureAwareComparer s_invariantCultureIgnoreCase;
        static /*0x10*/ System.OrdinalCaseSensitiveComparer s_ordinal;
        static /*0x18*/ System.OrdinalIgnoreCaseComparer s_ordinalIgnoreCase;

        static /*0x32b8c18*/ StringComparer();
        static /*0x32b8720*/ System.StringComparer get_InvariantCultureIgnoreCase();
        static /*0x32b8778*/ System.StringComparer get_CurrentCultureIgnoreCase();
        static /*0x32b884c*/ System.StringComparer get_Ordinal();
        static /*0x32b88a4*/ System.StringComparer get_OrdinalIgnoreCase();
        static /*0x32b88fc*/ System.StringComparer Create(System.Globalization.CultureInfo culture, bool ignoreCase);
        /*0x32b8c10*/ StringComparer();
        /*0x32b89a8*/ int Compare(object x, object y);
        /*0x32b8b28*/ bool Equals(object x, object y);
        /*0x32b8b8c*/ int GetHashCode(object obj);
        int Compare(string x, string y);
        /*0x1f2ff00*/ bool Equals(string x, string y);
        /*0x1f3008c*/ int GetHashCode(string obj);
    }

    class CultureAwareComparer : System.StringComparer, System.Runtime.Serialization.ISerializable
    {
        /*0x10*/ System.Globalization.CompareInfo _compareInfo;
        /*0x18*/ System.Globalization.CompareOptions _options;

        /*0x32b8804*/ CultureAwareComparer(System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);
        /*0x32b8da0*/ CultureAwareComparer(System.Globalization.CompareInfo compareInfo, System.Globalization.CompareOptions options);
        /*0x32b8e8c*/ CultureAwareComparer(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x32b90a4*/ int Compare(string x, string y);
        /*0x32b90f0*/ bool Equals(string x, string y);
        /*0x32b9144*/ int GetHashCode(string obj);
        /*0x32b91b4*/ bool Equals(object obj);
        /*0x32b9244*/ int GetHashCode();
        /*0x32b9278*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class OrdinalComparer : System.StringComparer
    {
        /*0x10*/ bool _ignoreCase;

        /*0x32b9364*/ OrdinalComparer(bool ignoreCase);
        /*0x32b93d4*/ int Compare(string x, string y);
        /*0x32b9428*/ bool Equals(string x, string y);
        /*0x32b94a0*/ int GetHashCode(string obj);
        /*0x32b9528*/ bool Equals(object obj);
        /*0x32b95b4*/ int GetHashCode();
    }

    class OrdinalCaseSensitiveComparer : System.OrdinalComparer, System.Runtime.Serialization.ISerializable
    {
        /*0x32b8d90*/ OrdinalCaseSensitiveComparer();
        /*0x32b9618*/ int Compare(string x, string y);
        /*0x32b9628*/ bool Equals(string x, string y);
        /*0x32b9638*/ int GetHashCode(string obj);
        /*0x32b965c*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class OrdinalIgnoreCaseComparer : System.OrdinalComparer, System.Runtime.Serialization.ISerializable
    {
        /*0x32b8d98*/ OrdinalIgnoreCaseComparer();
        /*0x32b96fc*/ int Compare(string x, string y);
        /*0x32b9710*/ bool Equals(string x, string y);
        /*0x32b9724*/ int GetHashCode(string obj);
        /*0x32b9788*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    enum StringComparison
    {
        CurrentCulture = 0,
        CurrentCultureIgnoreCase = 1,
        InvariantCulture = 2,
        InvariantCultureIgnoreCase = 3,
        Ordinal = 4,
        OrdinalIgnoreCase = 5,
    }

    enum StringSplitOptions
    {
        None = 0,
        RemoveEmptyEntries = 1,
    }

    class SystemException : System.Exception
    {
        /*0x32b9828*/ SystemException();
        /*0x32b1b7c*/ SystemException(string message);
        /*0x32b1c34*/ SystemException(string message, System.Exception innerException);
        /*0x32b1d28*/ SystemException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class STAThreadAttribute : System.Attribute
    {
        /*0x32b98a8*/ STAThreadAttribute();
    }

    class ThreadStaticAttribute : System.Attribute
    {
        /*0x32b98b0*/ ThreadStaticAttribute();
    }

    struct TimeSpan : System.IComparable, System.IComparable<System.TimeSpan>, System.IEquatable<System.TimeSpan>, System.IFormattable, System.ISpanFormattable
    {
        static /*0x0*/ System.TimeSpan Zero;
        static /*0x8*/ System.TimeSpan MaxValue;
        static /*0x10*/ System.TimeSpan MinValue;
        /*0x10*/ long _ticks;

        static /*0x32ba8d4*/ TimeSpan();
        static /*0x32b9d6c*/ int Compare(System.TimeSpan t1, System.TimeSpan t2);
        static /*0x32b9e58*/ System.TimeSpan FromDays(double value);
        static /*0x32ba0f8*/ System.TimeSpan FromHours(double value);
        static /*0x32b9ebc*/ System.TimeSpan Interval(double value, int scale);
        static /*0x32ba15c*/ System.TimeSpan FromMilliseconds(double value);
        static /*0x32ba1bc*/ System.TimeSpan FromMinutes(double value);
        static /*0x32ba2cc*/ System.TimeSpan FromSeconds(double value);
        static /*0x32ba390*/ System.TimeSpan FromTicks(long value);
        static /*0x32b9940*/ long TimeToTicks(int hour, int minute, int second);
        static /*0x32ba394*/ System.TimeSpan Parse(string s);
        static /*0x32ba3f0*/ System.TimeSpan Parse(string input, System.IFormatProvider formatProvider);
        static /*0x32ba450*/ bool TryParseExact(string input, string format, System.IFormatProvider formatProvider, ref System.TimeSpan result);
        static /*0x32ba710*/ System.TimeSpan op_UnaryNegation(System.TimeSpan t);
        static /*0x32ba7bc*/ System.TimeSpan op_Subtraction(System.TimeSpan t1, System.TimeSpan t2);
        static /*0x32ba824*/ System.TimeSpan op_Addition(System.TimeSpan t1, System.TimeSpan t2);
        static /*0x32ba88c*/ bool op_Equality(System.TimeSpan t1, System.TimeSpan t2);
        static /*0x32ba898*/ bool op_Inequality(System.TimeSpan t1, System.TimeSpan t2);
        static /*0x32ba8a4*/ bool op_LessThan(System.TimeSpan t1, System.TimeSpan t2);
        static /*0x32ba8b0*/ bool op_LessThanOrEqual(System.TimeSpan t1, System.TimeSpan t2);
        static /*0x32ba8bc*/ bool op_GreaterThan(System.TimeSpan t1, System.TimeSpan t2);
        static /*0x32ba8c8*/ bool op_GreaterThanOrEqual(System.TimeSpan t1, System.TimeSpan t2);
        /*0x32b98b8*/ TimeSpan(long ticks);
        /*0x32b98c0*/ TimeSpan(int hours, int minutes, int seconds);
        /*0x32b99d8*/ TimeSpan(int days, int hours, int minutes, int seconds);
        /*0x32b9a60*/ TimeSpan(int days, int hours, int minutes, int seconds, int milliseconds);
        /*0x32b9b18*/ long get_Ticks();
        /*0x32b9b20*/ int get_Days();
        /*0x32b9b4c*/ int get_Hours();
        /*0x32b9b90*/ int get_Milliseconds();
        /*0x32b9bdc*/ int get_Minutes();
        /*0x32b9c24*/ int get_Seconds();
        /*0x32b9c70*/ double get_TotalDays();
        /*0x32b9c88*/ double get_TotalHours();
        /*0x32b9ca0*/ double get_TotalMilliseconds();
        /*0x32b9cd8*/ double get_TotalMinutes();
        /*0x32b9cf0*/ double get_TotalSeconds();
        /*0x32b9d08*/ System.TimeSpan Add(System.TimeSpan ts);
        /*0x32b9d7c*/ int CompareTo(object value);
        /*0x32b9e44*/ int CompareTo(System.TimeSpan value);
        /*0x32b9fb0*/ System.TimeSpan Duration();
        /*0x32ba064*/ bool Equals(object value);
        /*0x32ba0dc*/ bool Equals(System.TimeSpan obj);
        /*0x32ba0ec*/ int GetHashCode();
        /*0x32ba21c*/ System.TimeSpan Negate();
        /*0x32ba32c*/ System.TimeSpan Subtract(System.TimeSpan ts);
        /*0x32ba524*/ string ToString();
        /*0x32ba588*/ string ToString(string format);
        /*0x32ba5f8*/ string ToString(string format, System.IFormatProvider formatProvider);
        /*0x32ba66c*/ bool TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider formatProvider);
    }

    class TimeZone
    {
        static /*0x0*/ System.TimeZone currentTimeZone;
        static /*0x8*/ object s_InternalSyncObject;

        static /*0x32ba92c*/ object get_InternalSyncObject();
        static /*0x32ba9cc*/ System.TimeZone get_CurrentTimeZone();
        static /*0x32bab40*/ System.TimeSpan CalculateUtcOffset(System.DateTime time, System.Globalization.DaylightTime daylightTimes);
        static /*0x32badbc*/ void ClearCachedData();
        /*0x32ba9c4*/ TimeZone();
        System.TimeSpan GetUtcOffset(System.DateTime time);
        /*0x1f30240*/ System.Globalization.DaylightTime GetDaylightChanges(int year);
    }

    enum TimeZoneInfoOptions
    {
        None = 1,
        NoThrowOnInvalidTime = 2,
    }

    class TimeZoneNotFoundException : System.Exception
    {
        /*0x32bae14*/ TimeZoneNotFoundException();
        /*0x32bae6c*/ TimeZoneNotFoundException(string message);
        /*0x32baed4*/ TimeZoneNotFoundException(string message, System.Exception innerException);
        /*0x32baf44*/ TimeZoneNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class TimeoutException : System.SystemException
    {
        /*0x32bafc4*/ TimeoutException();
        /*0x32bb01c*/ TimeoutException(string message);
        /*0x32bb03c*/ TimeoutException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    interface ITupleInternal : System.Runtime.CompilerServices.ITuple
    {
        /*0x1f302cc*/ string ToString(System.Text.StringBuilder sb);
    }

    class Tuple
    {
        static /*0x1ffc854*/ System.Tuple<T1, T2> Create<T1, T2>(T1 item1, T2 item2);
        static /*0x1ffc854*/ System.Tuple<T1, T2, T3> Create<T1, T2, T3>(T1 item1, T2 item2, T3 item3);
        static /*0x32bb040*/ int CombineHashCodes(int h1, int h2);
        static /*0x32bb04c*/ int CombineHashCodes(int h1, int h2, int h3);
        static /*0x32bb060*/ int CombineHashCodes(int h1, int h2, int h3, int h4);
    }

    class Tuple<T1, T2> : System.Collections.IStructuralEquatable, System.Collections.IStructuralComparable, System.IComparable, System.ITupleInternal, System.Runtime.CompilerServices.ITuple
    {
        /*0x0*/ T1 m_Item1;
        /*0x0*/ T2 m_Item2;

        /*0x1ffc854*/ Tuple(T1 item1, T2 item2);
        /*0x1ffc854*/ T1 get_Item1();
        /*0x1ffc854*/ T2 get_Item2();
        /*0x1f2fec8*/ bool Equals(object obj);
        /*0x1f2ff00*/ bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer);
        /*0x1f3008c*/ int System.IComparable.CompareTo(object obj);
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer);
        /*0x1f2ffc8*/ int GetHashCode();
        /*0x1f3008c*/ int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer);
        /*0x1f30214*/ string ToString();
        /*0x1f302cc*/ string System.ITupleInternal.ToString(System.Text.StringBuilder sb);
        /*0x1f2ffc8*/ int System.Runtime.CompilerServices.ITuple.get_Length();
    }

    class Tuple<T1, T2, T3> : System.Collections.IStructuralEquatable, System.Collections.IStructuralComparable, System.IComparable, System.ITupleInternal, System.Runtime.CompilerServices.ITuple
    {
        /*0x0*/ T1 m_Item1;
        /*0x0*/ T2 m_Item2;
        /*0x0*/ T3 m_Item3;

        /*0x1ffc854*/ Tuple(T1 item1, T2 item2, T3 item3);
        /*0x1ffc854*/ T1 get_Item1();
        /*0x1ffc854*/ T2 get_Item2();
        /*0x1ffc854*/ T3 get_Item3();
        /*0x1f2fec8*/ bool Equals(object obj);
        /*0x1f2ff00*/ bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer);
        /*0x1f3008c*/ int System.IComparable.CompareTo(object obj);
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer);
        /*0x1f2ffc8*/ int GetHashCode();
        /*0x1f3008c*/ int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer);
        /*0x1f30214*/ string ToString();
        /*0x1f302cc*/ string System.ITupleInternal.ToString(System.Text.StringBuilder sb);
        /*0x1f2ffc8*/ int System.Runtime.CompilerServices.ITuple.get_Length();
    }

    class Tuple<T1, T2, T3, T4> : System.Collections.IStructuralEquatable, System.Collections.IStructuralComparable, System.IComparable, System.ITupleInternal, System.Runtime.CompilerServices.ITuple
    {
        /*0x0*/ T1 m_Item1;
        /*0x0*/ T2 m_Item2;
        /*0x0*/ T3 m_Item3;
        /*0x0*/ T4 m_Item4;

        /*0x1ffc854*/ Tuple(T1 item1, T2 item2, T3 item3, T4 item4);
        /*0x1ffc854*/ T1 get_Item1();
        /*0x1ffc854*/ T2 get_Item2();
        /*0x1ffc854*/ T3 get_Item3();
        /*0x1ffc854*/ T4 get_Item4();
        /*0x1f2fec8*/ bool Equals(object obj);
        /*0x1f2ff00*/ bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer);
        /*0x1f3008c*/ int System.IComparable.CompareTo(object obj);
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer);
        /*0x1f2ffc8*/ int GetHashCode();
        /*0x1f3008c*/ int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer);
        /*0x1f30214*/ string ToString();
        /*0x1f302cc*/ string System.ITupleInternal.ToString(System.Text.StringBuilder sb);
        /*0x1f2ffc8*/ int System.Runtime.CompilerServices.ITuple.get_Length();
    }

    class Type : System.Reflection.MemberInfo
    {
        static /*0x0*/ System.Reflection.Binder s_defaultBinder;
        static /*0x8*/ char Delimiter;
        static /*0x10*/ System.Type[] EmptyTypes;
        static /*0x18*/ object Missing;
        static /*0x20*/ System.Reflection.MemberFilter FilterAttribute;
        static /*0x28*/ System.Reflection.MemberFilter FilterName;
        static /*0x30*/ System.Reflection.MemberFilter FilterNameIgnoreCase;
        /*0x10*/ System.RuntimeTypeHandle _impl;

        static /*0x32be788*/ Type();
        static /*0x32bb5a4*/ int BinarySearch(System.Array array, object value);
        static /*0x32bb3ec*/ bool IsIntegerType(System.Type t);
        static /*0x32bc7f8*/ bool FilterAttributeImpl(System.Reflection.MemberInfo m, object filterCriteria);
        static /*0x32bcb2c*/ bool FilterNameImpl(System.Reflection.MemberInfo m, object filterCriteria);
        static /*0x32bcc84*/ bool FilterNameIgnoreCaseImpl(System.Reflection.MemberInfo m, object filterCriteria);
        static /*0x32bdbb4*/ System.RuntimeTypeHandle GetTypeHandle(object o);
        static /*0x32bdc2c*/ System.TypeCode GetTypeCode(System.Type type);
        static /*0x32bdd40*/ System.Type GetTypeFromCLSID(System.Guid clsid);
        static /*0x32be11c*/ System.Type MakeGenericSignatureType(System.Type genericTypeDefinition, System.Type[] typeArguments);
        static /*0x32be304*/ System.Reflection.Binder get_DefaultBinder();
        static /*0x32b1978*/ System.Type GetTypeFromHandle(System.RuntimeTypeHandle handle);
        static /*0x32be3c8*/ System.Type internal_from_handle(nint handle);
        static /*0x32be420*/ System.Type GetType(string typeName, bool throwOnError, bool ignoreCase);
        static /*0x32be4ac*/ System.Type GetType(string typeName, bool throwOnError);
        static /*0x32be52c*/ System.Type GetType(string typeName);
        static /*0x32be5a8*/ System.Type GetType(string typeName, System.Func<System.Reflection.AssemblyName, System.Reflection.Assembly> assemblyResolver, System.Func<System.Reflection.Assembly, string, bool, System.Type> typeResolver, bool throwOnError);
        static /*0x32bb3e0*/ bool op_Equality(System.Type left, System.Type right);
        static /*0x32bc090*/ bool op_Inequality(System.Type left, System.Type right);
        static /*0x32bdd88*/ System.Type GetTypeFromCLSID(System.Guid clsid, string server, bool throwOnError);
        /*0x32bcdf0*/ Type();
        /*0x32bb07c*/ bool IsEnumDefined(object value);
        /*0x32bb6e4*/ string GetEnumName(object value);
        /*0x32bb8b0*/ string[] GetEnumNames();
        /*0x32bb580*/ System.Array GetEnumRawConstantValues();
        /*0x32bb954*/ void GetEnumData(ref string[] enumNames, ref System.Array enumValues);
        /*0x32bbee0*/ bool get_IsSerializable();
        /*0x32bc09c*/ bool get_ContainsGenericParameters();
        /*0x32bc1ac*/ System.Type GetRootElementType();
        /*0x32bc1fc*/ bool get_IsVisible();
        /*0x32bc3ec*/ bool IsSubclassOf(System.Type c);
        /*0x32bc48c*/ bool IsAssignableFrom(System.Type c);
        /*0x32bc6d8*/ bool ImplementInterface(System.Type ifaceType);
        /*0x32bcdf8*/ System.Reflection.MemberTypes get_MemberType();
        /*0x32bce00*/ System.Type GetType();
        /*0x1f30214*/ string get_Namespace();
        /*0x1f30214*/ string get_AssemblyQualifiedName();
        /*0x1f30214*/ string get_FullName();
        /*0x1f30214*/ System.Reflection.Assembly get_Assembly();
        /*0x1f30214*/ System.Reflection.Module get_Module();
        /*0x32bc384*/ bool get_IsNested();
        /*0x32bce08*/ System.Type get_DeclaringType();
        /*0x32bce10*/ System.Reflection.MethodBase get_DeclaringMethod();
        /*0x32bce18*/ System.Type get_ReflectedType();
        /*0x1f30214*/ System.Type get_UnderlyingSystemType();
        /*0x32bce20*/ bool get_IsArray();
        /*0x1f2fe14*/ bool IsArrayImpl();
        /*0x32bce30*/ bool get_IsByRef();
        /*0x1f2fe14*/ bool IsByRefImpl();
        /*0x32bce40*/ bool get_IsPointer();
        /*0x1f2fe14*/ bool IsPointerImpl();
        /*0x32bce50*/ bool get_IsConstructedGenericType();
        /*0x32bcec8*/ bool get_IsGenericParameter();
        /*0x32bced0*/ bool get_IsGenericMethodParameter();
        /*0x32bcf1c*/ bool get_IsGenericType();
        /*0x32bcf24*/ bool get_IsGenericTypeDefinition();
        /*0x32bcf2c*/ bool get_IsSZArray();
        /*0x32bcf50*/ bool get_IsVariableBoundArray();
        /*0x32bc19c*/ bool get_HasElementType();
        /*0x1f2fe14*/ bool HasElementTypeImpl();
        /*0x1f30214*/ System.Type GetElementType();
        /*0x32bcf98*/ int GetArrayRank();
        /*0x32bcfe4*/ System.Type GetGenericTypeDefinition();
        /*0x32bd030*/ System.Type[] get_GenericTypeArguments();
        /*0x32bd114*/ System.Type[] GetGenericArguments();
        /*0x32bd160*/ int get_GenericParameterPosition();
        /*0x32bd1ac*/ System.Reflection.GenericParameterAttributes get_GenericParameterAttributes();
        /*0x32bd1e4*/ System.Type[] GetGenericParameterConstraints();
        /*0x32bd25c*/ System.Reflection.TypeAttributes get_Attributes();
        /*0x1f2ffc8*/ System.Reflection.TypeAttributes GetAttributeFlagsImpl();
        /*0x32bd26c*/ bool get_IsAbstract();
        /*0x32bd28c*/ bool get_IsSealed();
        /*0x32bd2ac*/ bool get_IsClass();
        /*0x32bd304*/ bool get_IsNestedAssembly();
        /*0x32bc35c*/ bool get_IsNestedPublic();
        /*0x32bd32c*/ bool get_IsNotPublic();
        /*0x32bc3c4*/ bool get_IsPublic();
        /*0x32bd350*/ bool get_IsExplicitLayout();
        /*0x32bd378*/ bool get_IsCOMObject();
        /*0x1f2fe14*/ bool IsCOMObjectImpl();
        /*0x32bd388*/ bool get_IsContextful();
        /*0x32bd398*/ bool IsContextfulImpl();
        /*0x32bd414*/ bool get_IsCollectible();
        /*0x32bd41c*/ bool get_IsEnum();
        /*0x32bd470*/ bool get_IsMarshalByRef();
        /*0x32bd480*/ bool IsMarshalByRefImpl();
        /*0x32bd4fc*/ bool get_IsPrimitive();
        /*0x1f2fe14*/ bool IsPrimitiveImpl();
        /*0x32bd2f4*/ bool get_IsValueType();
        /*0x32bd50c*/ bool IsValueTypeImpl();
        /*0x32bd560*/ bool get_IsSignatureType();
        /*0x32bd568*/ System.Reflection.ConstructorInfo GetConstructor(System.Type[] types);
        /*0x32bd580*/ System.Reflection.ConstructorInfo GetConstructor(System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        /*0x32bd590*/ System.Reflection.ConstructorInfo GetConstructor(System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        System.Reflection.ConstructorInfo GetConstructorImpl(System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        /*0x32bd69c*/ System.Reflection.ConstructorInfo[] GetConstructors();
        /*0x1f30240*/ System.Reflection.ConstructorInfo[] GetConstructors(System.Reflection.BindingFlags bindingAttr);
        /*0x32bd6b0*/ System.Reflection.EventInfo GetEvent(string name);
        /*0x1f30300*/ System.Reflection.EventInfo GetEvent(string name, System.Reflection.BindingFlags bindingAttr);
        /*0x32bd6c4*/ System.Reflection.FieldInfo GetField(string name);
        /*0x1f30300*/ System.Reflection.FieldInfo GetField(string name, System.Reflection.BindingFlags bindingAttr);
        /*0x32bd6d8*/ System.Reflection.FieldInfo[] GetFields();
        /*0x1f30240*/ System.Reflection.FieldInfo[] GetFields(System.Reflection.BindingFlags bindingAttr);
        /*0x32bd6ec*/ System.Reflection.MemberInfo[] GetMember(string name);
        /*0x32bd700*/ System.Reflection.MemberInfo[] GetMember(string name, System.Reflection.BindingFlags bindingAttr);
        /*0x32bd718*/ System.Reflection.MemberInfo[] GetMember(string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);
        /*0x1f30240*/ System.Reflection.MemberInfo[] GetMembers(System.Reflection.BindingFlags bindingAttr);
        /*0x32bd764*/ System.Reflection.MethodInfo GetMethod(string name);
        /*0x32bd76c*/ System.Reflection.MethodInfo GetMethod(string name, System.Reflection.BindingFlags bindingAttr);
        /*0x32bd7dc*/ System.Reflection.MethodInfo GetMethod(string name, System.Type[] types);
        /*0x32bd7f4*/ System.Reflection.MethodInfo GetMethod(string name, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        /*0x32bd80c*/ System.Reflection.MethodInfo GetMethod(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        /*0x32bd81c*/ System.Reflection.MethodInfo GetMethod(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        System.Reflection.MethodInfo GetMethodImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        /*0x32bd954*/ System.Reflection.MethodInfo[] GetMethods();
        /*0x1f30240*/ System.Reflection.MethodInfo[] GetMethods(System.Reflection.BindingFlags bindingAttr);
        /*0x1f30300*/ System.Type GetNestedType(string name, System.Reflection.BindingFlags bindingAttr);
        /*0x32bd968*/ System.Reflection.PropertyInfo GetProperty(string name);
        /*0x32bd970*/ System.Reflection.PropertyInfo GetProperty(string name, System.Reflection.BindingFlags bindingAttr);
        /*0x32bd9e0*/ System.Reflection.PropertyInfo GetProperty(string name, System.Type returnType);
        /*0x32bdab0*/ System.Reflection.PropertyInfo GetProperty(string name, System.Type returnType, System.Type[] types);
        /*0x32bdac8*/ System.Reflection.PropertyInfo GetProperty(string name, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        /*0x32bdae0*/ System.Reflection.PropertyInfo GetProperty(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        System.Reflection.PropertyInfo GetPropertyImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        /*0x32bdb68*/ System.Reflection.PropertyInfo[] GetProperties();
        /*0x1f30240*/ System.Reflection.PropertyInfo[] GetProperties(System.Reflection.BindingFlags bindingAttr);
        /*0x32bdb7c*/ System.RuntimeTypeHandle get_TypeHandle();
        /*0x32bdc7c*/ System.TypeCode GetTypeCodeImpl();
        System.Guid get_GUID();
        /*0x1f30214*/ System.Type get_BaseType();
        object InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);
        /*0x1f30214*/ System.Type[] GetInterfaces();
        /*0x32bde08*/ bool IsInstanceOfType(object o);
        /*0x32bde44*/ bool IsEquivalentTo(System.Type other);
        /*0x32bde84*/ System.Type GetEnumUnderlyingType();
        /*0x32bdf6c*/ System.Array GetEnumValues();
        /*0x32bdff0*/ System.Type MakeArrayType();
        /*0x32be028*/ System.Type MakeArrayType(int rank);
        /*0x32be060*/ System.Type MakeByRefType();
        /*0x32be098*/ System.Type MakeGenericType(System.Type[] typeArguments);
        /*0x32be0e4*/ System.Type MakePointerType();
        /*0x32be188*/ string ToString();
        /*0x32be1e8*/ bool Equals(object o);
        /*0x32be240*/ int GetHashCode();
        /*0x32be288*/ bool Equals(System.Type o);
        /*0x32be3cc*/ bool get_IsSzArray();
        /*0x32be3d4*/ string FormatTypeName();
        /*0x32be3e8*/ string FormatTypeName(bool serialization);
        /*0x32bc614*/ bool get_IsInterface();
        /*0x32be5cc*/ string get_FullNameOrDefault();
        /*0x32bc004*/ bool IsRuntimeImplemented();
        /*0x32be70c*/ string InternalGetNameIfAvailable(ref System.Type rootCauseForFailure);
        /*0x32be6ec*/ string get_InternalNameIfAvailable();
        /*0x32be718*/ string get_NameOrDefault();
    }

    class TypeAccessException : System.TypeLoadException
    {
        /*0x32be970*/ TypeAccessException();
        /*0x32be9cc*/ TypeAccessException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    enum TypeCode
    {
        Empty = 0,
        Object = 1,
        DBNull = 2,
        Boolean = 3,
        Char = 4,
        SByte = 5,
        Byte = 6,
        Int16 = 7,
        UInt16 = 8,
        Int32 = 9,
        UInt32 = 10,
        Int64 = 11,
        UInt64 = 12,
        Single = 13,
        Double = 14,
        Decimal = 15,
        DateTime = 16,
        String = 18,
    }

    class TypeInitializationException : System.SystemException
    {
        /*0x90*/ string _typeName;

        /*0x32be9d4*/ TypeInitializationException();
        /*0x32bea2c*/ TypeInitializationException(string fullTypeName, System.Exception innerException);
        /*0x32beab8*/ TypeInitializationException(string fullTypeName, string message, System.Exception innerException);
        /*0x32beafc*/ TypeInitializationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x32beb88*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x32bec44*/ string get_TypeName();
    }

    struct UInt16 : System.IComparable, System.IConvertible, System.IFormattable, System.IComparable<ushort>, System.IEquatable<ushort>, System.ISpanFormattable
    {
        /*0x10*/ ushort m_value;

        static /*0x32beff0*/ ushort Parse(string s, System.IFormatProvider provider);
        static /*0x32bf1f4*/ ushort Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x32bf068*/ ushort Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo info);
        static /*0x32bf284*/ bool TryParse(string s, ref ushort result);
        static /*0x32bf3c0*/ bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref ushort result);
        static /*0x32bf304*/ bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo info, ref ushort result);
        /*0x32bec68*/ int CompareTo(object value);
        /*0x32becf4*/ int CompareTo(ushort value);
        /*0x32bed00*/ bool Equals(object obj);
        /*0x32bed48*/ bool Equals(ushort obj);
        /*0x32bed58*/ int GetHashCode();
        /*0x32bed60*/ string ToString();
        /*0x32bedf8*/ string ToString(System.IFormatProvider provider);
        /*0x32bee94*/ string ToString(string format, System.IFormatProvider provider);
        /*0x32bef4c*/ bool TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        /*0x32bf468*/ System.TypeCode GetTypeCode();
        /*0x32bf470*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x32bf4cc*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x32bf528*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x32bf584*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x32bf5e0*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x32bf63c*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x32bf644*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x32bf6a0*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x32bf6fc*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x32bf758*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x32bf7b4*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x32bf810*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x32bf86c*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x32bf8c8*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x32bf94c*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);
    }

    struct UInt32 : System.IComparable, System.IConvertible, System.IFormattable, System.IComparable<uint>, System.IEquatable<uint>, System.ISpanFormattable
    {
        /*0x10*/ uint m_value;

        static /*0x32bfe40*/ uint Parse(string s);
        static /*0x32bfef4*/ uint Parse(string s, System.IFormatProvider provider);
        static /*0x32bffb8*/ uint Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x32c008c*/ bool TryParse(string s, ref uint result);
        static /*0x32c0160*/ bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref uint result);
        /*0x32bf9ec*/ int CompareTo(object value);
        /*0x32bfa88*/ int CompareTo(uint value);
        /*0x32bfa9c*/ bool Equals(object obj);
        /*0x32bfae4*/ bool Equals(uint obj);
        /*0x32bfaf4*/ int GetHashCode();
        /*0x32bfafc*/ string ToString();
        /*0x32bfb94*/ string ToString(System.IFormatProvider provider);
        /*0x32bfc30*/ string ToString(string format);
        /*0x32bfce4*/ string ToString(string format, System.IFormatProvider provider);
        /*0x32bfd9c*/ bool TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        /*0x32c0258*/ System.TypeCode GetTypeCode();
        /*0x32c0260*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x32c02bc*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x32c0318*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x32c0374*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x32c03d0*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x32c042c*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x32c0488*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x32c04e4*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x32c04ec*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x32c0548*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x32c05a4*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x32c0600*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x32c065c*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x32c06b8*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x32c073c*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);
    }

    struct UInt64 : System.IComparable, System.IConvertible, System.IFormattable, System.IComparable<ulong>, System.IEquatable<ulong>, System.ISpanFormattable
    {
        /*0x10*/ ulong m_value;

        static /*0x32c0c34*/ ulong Parse(string s);
        static /*0x32c0ce8*/ ulong Parse(string s, System.Globalization.NumberStyles style);
        static /*0x32c0db4*/ ulong Parse(string s, System.IFormatProvider provider);
        static /*0x32c0e78*/ ulong Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x32c0f4c*/ bool TryParse(string s, ref ulong result);
        static /*0x32c1020*/ bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref ulong result);
        /*0x32c07dc*/ int CompareTo(object value);
        /*0x32c0878*/ int CompareTo(ulong value);
        /*0x32c088c*/ bool Equals(object obj);
        /*0x32c08d4*/ bool Equals(ulong obj);
        /*0x32c08e4*/ int GetHashCode();
        /*0x32c08f0*/ string ToString();
        /*0x32c0988*/ string ToString(System.IFormatProvider provider);
        /*0x32c0a24*/ string ToString(string format);
        /*0x32c0ad8*/ string ToString(string format, System.IFormatProvider provider);
        /*0x32c0b90*/ bool TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        /*0x32c1118*/ System.TypeCode GetTypeCode();
        /*0x32c1120*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x32c117c*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x32c11d8*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x32c1234*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x32c1290*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x32c12ec*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x32c1348*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x32c13a4*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x32c1400*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x32c145c*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x32c1464*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x32c14c0*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x32c151c*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x32c1578*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x32c15fc*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);
    }

    class UnauthorizedAccessException : System.SystemException
    {
        /*0x32c169c*/ UnauthorizedAccessException();
        /*0x32c16f4*/ UnauthorizedAccessException(string message);
        /*0x32c1714*/ UnauthorizedAccessException(string message, System.Exception inner);
        /*0x32c1734*/ UnauthorizedAccessException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class UnhandledExceptionEventArgs : System.EventArgs
    {
        /*0x10*/ object _exception;
        /*0x18*/ bool _isTerminating;

        /*0x32c1738*/ UnhandledExceptionEventArgs(object exception, bool isTerminating);
        /*0x32c17bc*/ object get_ExceptionObject();
        /*0x32c17c4*/ bool get_IsTerminating();
    }

    class UnhandledExceptionEventHandler : System.MulticastDelegate
    {
        /*0x32c17cc*/ UnhandledExceptionEventHandler(object object, nint method);
        /*0x32c18d8*/ void Invoke(object sender, System.UnhandledExceptionEventArgs e);
    }

    interface IValueTupleInternal : System.Runtime.CompilerServices.ITuple
    {
        /*0x1f3008c*/ int GetHashCode(System.Collections.IEqualityComparer comparer);
        /*0x1f30214*/ string ToStringEnd();
    }

    struct ValueTuple : System.IEquatable<System.ValueTuple>, System.Collections.IStructuralEquatable, System.Collections.IStructuralComparable, System.IComparable, System.IComparable<System.ValueTuple>, System.IValueTupleInternal, System.Runtime.CompilerServices.ITuple
    {
        static /*0x1ffc854*/ System.ValueTuple<T1, T2> Create<T1, T2>(T1 item1, T2 item2);
        static /*0x32c1c7c*/ int CombineHashCodes(int h1, int h2);
        static /*0x32c1cf8*/ int CombineHashCodes(int h1, int h2, int h3);
        static /*0x32c1d78*/ int CombineHashCodes(int h1, int h2, int h3, int h4);
        static /*0x32c1e08*/ int CombineHashCodes(int h1, int h2, int h3, int h4, int h5);
        static /*0x32c1ea0*/ int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6);
        static /*0x32c1f48*/ int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7);
        static /*0x32c1ff8*/ int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7, int h8);
        /*0x32c18ec*/ bool Equals(object obj);
        /*0x32c1948*/ bool Equals(System.ValueTuple other);
        /*0x32c1950*/ bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer);
        /*0x32c19ac*/ int System.IComparable.CompareTo(object other);
        /*0x32c1ac0*/ int CompareTo(System.ValueTuple other);
        /*0x32c1ac8*/ int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer);
        /*0x32c1bdc*/ int GetHashCode();
        /*0x32c1be4*/ int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer);
        /*0x32c1bec*/ int System.IValueTupleInternal.GetHashCode(System.Collections.IEqualityComparer comparer);
        /*0x32c1bf4*/ string ToString();
        /*0x32c1c34*/ string System.IValueTupleInternal.ToStringEnd();
        /*0x32c1c74*/ int System.Runtime.CompilerServices.ITuple.get_Length();
    }

    struct ValueTuple<T1> : System.IEquatable<System.ValueTuple<T1>>, System.Collections.IStructuralEquatable, System.Collections.IStructuralComparable, System.IComparable, System.IComparable<System.ValueTuple<T1>>, System.IValueTupleInternal, System.Runtime.CompilerServices.ITuple
    {
        /*0x0*/ T1 Item1;

        /*0x1ffc854*/ ValueTuple(T1 item1);
        /*0x1f2fec8*/ bool Equals(object obj);
        /*0x1ffc854*/ bool Equals(System.ValueTuple<T1> other);
        /*0x1f2ff00*/ bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer);
        /*0x1f3008c*/ int System.IComparable.CompareTo(object other);
        /*0x1ffc854*/ int CompareTo(System.ValueTuple<T1> other);
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer);
        /*0x1f2ffc8*/ int GetHashCode();
        /*0x1f3008c*/ int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer);
        /*0x1f3008c*/ int System.IValueTupleInternal.GetHashCode(System.Collections.IEqualityComparer comparer);
        /*0x1f30214*/ string ToString();
        /*0x1f30214*/ string System.IValueTupleInternal.ToStringEnd();
        /*0x1f2ffc8*/ int System.Runtime.CompilerServices.ITuple.get_Length();
    }

    struct ValueTuple<T1, T2> : System.IEquatable<System.ValueTuple<T1, T2>>, System.Collections.IStructuralEquatable, System.Collections.IStructuralComparable, System.IComparable, System.IComparable<System.ValueTuple<T1, T2>>, System.IValueTupleInternal, System.Runtime.CompilerServices.ITuple
    {
        /*0x0*/ T1 Item1;
        /*0x0*/ T2 Item2;

        /*0x1ffc854*/ ValueTuple(T1 item1, T2 item2);
        /*0x1f2fec8*/ bool Equals(object obj);
        /*0x1ffc854*/ bool Equals(System.ValueTuple<T1, T2> other);
        /*0x1f2ff00*/ bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer);
        /*0x1f3008c*/ int System.IComparable.CompareTo(object other);
        /*0x1ffc854*/ int CompareTo(System.ValueTuple<T1, T2> other);
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer);
        /*0x1f2ffc8*/ int GetHashCode();
        /*0x1f3008c*/ int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer);
        /*0x1f3008c*/ int GetHashCodeCore(System.Collections.IEqualityComparer comparer);
        /*0x1f3008c*/ int System.IValueTupleInternal.GetHashCode(System.Collections.IEqualityComparer comparer);
        /*0x1f30214*/ string ToString();
        /*0x1f30214*/ string System.IValueTupleInternal.ToStringEnd();
        /*0x1f2ffc8*/ int System.Runtime.CompilerServices.ITuple.get_Length();
    }

    struct ValueTuple<T1, T2, T3> : System.IEquatable<System.ValueTuple<T1, T2, T3>>, System.Collections.IStructuralEquatable, System.Collections.IStructuralComparable, System.IComparable, System.IComparable<System.ValueTuple<T1, T2, T3>>, System.IValueTupleInternal, System.Runtime.CompilerServices.ITuple
    {
        /*0x0*/ T1 Item1;
        /*0x0*/ T2 Item2;
        /*0x0*/ T3 Item3;

        /*0x1ffc854*/ ValueTuple(T1 item1, T2 item2, T3 item3);
        /*0x1f2fec8*/ bool Equals(object obj);
        /*0x1ffc854*/ bool Equals(System.ValueTuple<T1, T2, T3> other);
        /*0x1f2ff00*/ bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer);
        /*0x1f3008c*/ int System.IComparable.CompareTo(object other);
        /*0x1ffc854*/ int CompareTo(System.ValueTuple<T1, T2, T3> other);
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer);
        /*0x1f2ffc8*/ int GetHashCode();
        /*0x1f3008c*/ int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer);
        /*0x1f3008c*/ int GetHashCodeCore(System.Collections.IEqualityComparer comparer);
        /*0x1f3008c*/ int System.IValueTupleInternal.GetHashCode(System.Collections.IEqualityComparer comparer);
        /*0x1f30214*/ string ToString();
        /*0x1f30214*/ string System.IValueTupleInternal.ToStringEnd();
        /*0x1f2ffc8*/ int System.Runtime.CompilerServices.ITuple.get_Length();
    }

    struct ValueTuple<T1, T2, T3, T4> : System.IEquatable<System.ValueTuple<T1, T2, T3, T4>>, System.Collections.IStructuralEquatable, System.Collections.IStructuralComparable, System.IComparable, System.IComparable<System.ValueTuple<T1, T2, T3, T4>>, System.IValueTupleInternal, System.Runtime.CompilerServices.ITuple
    {
        /*0x0*/ T1 Item1;
        /*0x0*/ T2 Item2;
        /*0x0*/ T3 Item3;
        /*0x0*/ T4 Item4;

        /*0x1ffc854*/ ValueTuple(T1 item1, T2 item2, T3 item3, T4 item4);
        /*0x1f2fec8*/ bool Equals(object obj);
        /*0x1ffc854*/ bool Equals(System.ValueTuple<T1, T2, T3, T4> other);
        /*0x1f2ff00*/ bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer);
        /*0x1f3008c*/ int System.IComparable.CompareTo(object other);
        /*0x1ffc854*/ int CompareTo(System.ValueTuple<T1, T2, T3, T4> other);
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer);
        /*0x1f2ffc8*/ int GetHashCode();
        /*0x1f3008c*/ int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer);
        /*0x1f3008c*/ int GetHashCodeCore(System.Collections.IEqualityComparer comparer);
        /*0x1f3008c*/ int System.IValueTupleInternal.GetHashCode(System.Collections.IEqualityComparer comparer);
        /*0x1f30214*/ string ToString();
        /*0x1f30214*/ string System.IValueTupleInternal.ToStringEnd();
        /*0x1f2ffc8*/ int System.Runtime.CompilerServices.ITuple.get_Length();
    }

    struct ValueTuple<T1, T2, T3, T4, T5> : System.IEquatable<System.ValueTuple<T1, T2, T3, T4, T5>>, System.Collections.IStructuralEquatable, System.Collections.IStructuralComparable, System.IComparable, System.IComparable<System.ValueTuple<T1, T2, T3, T4, T5>>, System.IValueTupleInternal, System.Runtime.CompilerServices.ITuple
    {
        /*0x0*/ T1 Item1;
        /*0x0*/ T2 Item2;
        /*0x0*/ T3 Item3;
        /*0x0*/ T4 Item4;
        /*0x0*/ T5 Item5;

        /*0x1ffc854*/ ValueTuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
        /*0x1f2fec8*/ bool Equals(object obj);
        /*0x1ffc854*/ bool Equals(System.ValueTuple<T1, T2, T3, T4, T5> other);
        /*0x1f2ff00*/ bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer);
        /*0x1f3008c*/ int System.IComparable.CompareTo(object other);
        /*0x1ffc854*/ int CompareTo(System.ValueTuple<T1, T2, T3, T4, T5> other);
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer);
        /*0x1f2ffc8*/ int GetHashCode();
        /*0x1f3008c*/ int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer);
        /*0x1f3008c*/ int GetHashCodeCore(System.Collections.IEqualityComparer comparer);
        /*0x1f3008c*/ int System.IValueTupleInternal.GetHashCode(System.Collections.IEqualityComparer comparer);
        /*0x1f30214*/ string ToString();
        /*0x1f30214*/ string System.IValueTupleInternal.ToStringEnd();
        /*0x1f2ffc8*/ int System.Runtime.CompilerServices.ITuple.get_Length();
    }

    struct ValueTuple<T1, T2, T3, T4, T5, T6> : System.IEquatable<System.ValueTuple<T1, T2, T3, T4, T5, T6>>, System.Collections.IStructuralEquatable, System.Collections.IStructuralComparable, System.IComparable, System.IComparable<System.ValueTuple<T1, T2, T3, T4, T5, T6>>, System.IValueTupleInternal, System.Runtime.CompilerServices.ITuple
    {
        /*0x0*/ T1 Item1;
        /*0x0*/ T2 Item2;
        /*0x0*/ T3 Item3;
        /*0x0*/ T4 Item4;
        /*0x0*/ T5 Item5;
        /*0x0*/ T6 Item6;

        /*0x1ffc854*/ ValueTuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
        /*0x1f2fec8*/ bool Equals(object obj);
        /*0x1ffc854*/ bool Equals(System.ValueTuple<T1, T2, T3, T4, T5, T6> other);
        /*0x1f2ff00*/ bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer);
        /*0x1f3008c*/ int System.IComparable.CompareTo(object other);
        /*0x1ffc854*/ int CompareTo(System.ValueTuple<T1, T2, T3, T4, T5, T6> other);
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer);
        /*0x1f2ffc8*/ int GetHashCode();
        /*0x1f3008c*/ int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer);
        /*0x1f3008c*/ int GetHashCodeCore(System.Collections.IEqualityComparer comparer);
        /*0x1f3008c*/ int System.IValueTupleInternal.GetHashCode(System.Collections.IEqualityComparer comparer);
        /*0x1f30214*/ string ToString();
        /*0x1f30214*/ string System.IValueTupleInternal.ToStringEnd();
        /*0x1f2ffc8*/ int System.Runtime.CompilerServices.ITuple.get_Length();
    }

    struct ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest> : System.IEquatable<System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest>>, System.Collections.IStructuralEquatable, System.Collections.IStructuralComparable, System.IComparable, System.IComparable<System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest>>, System.IValueTupleInternal, System.Runtime.CompilerServices.ITuple
    {
        /*0x0*/ T1 Item1;
        /*0x0*/ T2 Item2;
        /*0x0*/ T3 Item3;
        /*0x0*/ T4 Item4;
        /*0x0*/ T5 Item5;
        /*0x0*/ T6 Item6;
        /*0x0*/ T7 Item7;
        /*0x0*/ TRest Rest;

        /*0x1ffc854*/ ValueTuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
        /*0x1f2fec8*/ bool Equals(object obj);
        /*0x1ffc854*/ bool Equals(System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest> other);
        /*0x1f2ff00*/ bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer);
        /*0x1f3008c*/ int System.IComparable.CompareTo(object other);
        /*0x1ffc854*/ int CompareTo(System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest> other);
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer);
        /*0x1f2ffc8*/ int GetHashCode();
        /*0x1f3008c*/ int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer);
        /*0x1f3008c*/ int GetHashCodeCore(System.Collections.IEqualityComparer comparer);
        /*0x1f3008c*/ int System.IValueTupleInternal.GetHashCode(System.Collections.IEqualityComparer comparer);
        /*0x1f30214*/ string ToString();
        /*0x1f30214*/ string System.IValueTupleInternal.ToStringEnd();
        /*0x1f2ffc8*/ int System.Runtime.CompilerServices.ITuple.get_Length();
    }

    class Version : System.ICloneable, System.IComparable, System.IComparable<System.Version>, System.IEquatable<System.Version>, System.ISpanFormattable
    {
        /*0x10*/ int _Major;
        /*0x14*/ int _Minor;
        /*0x18*/ int _Build;
        /*0x1c*/ int _Revision;

        static /*0x32c23b4*/ System.Version Parse(string input);
        static /*0x32c31ec*/ bool TryParse(string input, ref System.Version result);
        static /*0x32c2bc0*/ System.Version ParseVersion(System.ReadOnlySpan<char> input, bool throwOnFailure);
        static /*0x32c32a0*/ bool TryParseComponent(System.ReadOnlySpan<char> component, string componentName, bool throwOnFailure, ref int parsedComponent);
        static /*0x32c25dc*/ bool op_Equality(System.Version v1, System.Version v2);
        static /*0x32c3278*/ bool op_Inequality(System.Version v1, System.Version v2);
        static /*0x32c33d4*/ bool op_LessThan(System.Version v1, System.Version v2);
        /*0x32c20b8*/ Version(int major, int minor, int build, int revision);
        /*0x32c21cc*/ Version(int major, int minor, int build);
        /*0x32c22b8*/ Version(int major, int minor);
        /*0x32c2370*/ Version(string version);
        /*0x32c244c*/ Version();
        /*0x32c2470*/ Version(System.Version version);
        /*0x32c24ac*/ object Clone();
        /*0x32c2504*/ int get_Major();
        /*0x32c250c*/ int get_Minor();
        /*0x32c2514*/ int get_Build();
        /*0x32c251c*/ int get_Revision();
        /*0x32c2524*/ int CompareTo(object version);
        /*0x32c25f0*/ int CompareTo(System.Version value);
        /*0x32c2658*/ bool Equals(object obj);
        /*0x32c26bc*/ bool Equals(System.Version obj);
        /*0x32c271c*/ int GetHashCode();
        /*0x32c275c*/ string ToString();
        /*0x32c27ac*/ string ToString(int fieldCount);
        /*0x32c2a38*/ bool TryFormat(System.Span<char> destination, ref int charsWritten);
        /*0x32c2a64*/ bool TryFormat(System.Span<char> destination, int fieldCount, ref int charsWritten);
        /*0x32c2b94*/ bool System.ISpanFormattable.TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        /*0x32c2784*/ int get_DefaultFormatFieldCount();
        /*0x32c27f0*/ System.Text.StringBuilder ToCachedStringBuilder(int fieldCount);
    }

    struct Void
    {
    }

    class NotImplemented
    {
        static /*0x32bce74*/ System.Exception get_ByDesign();
    }

    interface IServiceProvider
    {
        /*0x1f302cc*/ object GetService(System.Type serviceType);
    }

    class ConsoleCancelEventHandler : System.MulticastDelegate
    {
        /*0x32c3434*/ ConsoleCancelEventHandler(object object, nint method);
        /*0x32c3540*/ void Invoke(object sender, System.ConsoleCancelEventArgs e);
    }

    class ConsoleCancelEventArgs : System.EventArgs
    {
        /*0x10*/ System.ConsoleSpecialKey _type;
        /*0x14*/ bool <Cancel>k__BackingField;

        /*0x32c3554*/ ConsoleCancelEventArgs(System.ConsoleSpecialKey type);
        /*0x32c35c8*/ ConsoleCancelEventArgs();
        /*0x32c35c0*/ bool get_Cancel();
    }

    enum ConsoleColor
    {
        Black = 0,
        DarkBlue = 1,
        DarkGreen = 2,
        DarkCyan = 3,
        DarkRed = 4,
        DarkMagenta = 5,
        DarkYellow = 6,
        Gray = 7,
        DarkGray = 8,
        Blue = 9,
        Green = 10,
        Cyan = 11,
        Red = 12,
        Magenta = 13,
        Yellow = 14,
        White = 15,
    }

    enum ConsoleKey
    {
        Backspace = 8,
        Tab = 9,
        Clear = 12,
        Enter = 13,
        Pause = 19,
        Escape = 27,
        Spacebar = 32,
        PageUp = 33,
        PageDown = 34,
        End = 35,
        Home = 36,
        LeftArrow = 37,
        UpArrow = 38,
        RightArrow = 39,
        DownArrow = 40,
        Select = 41,
        Print = 42,
        Execute = 43,
        PrintScreen = 44,
        Insert = 45,
        Delete = 46,
        Help = 47,
        D0 = 48,
        D1 = 49,
        D2 = 50,
        D3 = 51,
        D4 = 52,
        D5 = 53,
        D6 = 54,
        D7 = 55,
        D8 = 56,
        D9 = 57,
        A = 65,
        B = 66,
        C = 67,
        D = 68,
        E = 69,
        F = 70,
        G = 71,
        H = 72,
        I = 73,
        J = 74,
        K = 75,
        L = 76,
        M = 77,
        N = 78,
        O = 79,
        P = 80,
        Q = 81,
        R = 82,
        S = 83,
        T = 84,
        U = 85,
        V = 86,
        W = 87,
        X = 88,
        Y = 89,
        Z = 90,
        LeftWindows = 91,
        RightWindows = 92,
        Applications = 93,
        Sleep = 95,
        NumPad0 = 96,
        NumPad1 = 97,
        NumPad2 = 98,
        NumPad3 = 99,
        NumPad4 = 100,
        NumPad5 = 101,
        NumPad6 = 102,
        NumPad7 = 103,
        NumPad8 = 104,
        NumPad9 = 105,
        Multiply = 106,
        Add = 107,
        Separator = 108,
        Subtract = 109,
        Decimal = 110,
        Divide = 111,
        F1 = 112,
        F2 = 113,
        F3 = 114,
        F4 = 115,
        F5 = 116,
        F6 = 117,
        F7 = 118,
        F8 = 119,
        F9 = 120,
        F10 = 121,
        F11 = 122,
        F12 = 123,
        F13 = 124,
        F14 = 125,
        F15 = 126,
        F16 = 127,
        F17 = 128,
        F18 = 129,
        F19 = 130,
        F20 = 131,
        F21 = 132,
        F22 = 133,
        F23 = 134,
        F24 = 135,
        BrowserBack = 166,
        BrowserForward = 167,
        BrowserRefresh = 168,
        BrowserStop = 169,
        BrowserSearch = 170,
        BrowserFavorites = 171,
        BrowserHome = 172,
        VolumeMute = 173,
        VolumeDown = 174,
        VolumeUp = 175,
        MediaNext = 176,
        MediaPrevious = 177,
        MediaStop = 178,
        MediaPlay = 179,
        LaunchMail = 180,
        LaunchMediaSelect = 181,
        LaunchApp1 = 182,
        LaunchApp2 = 183,
        Oem1 = 186,
        OemPlus = 187,
        OemComma = 188,
        OemMinus = 189,
        OemPeriod = 190,
        Oem2 = 191,
        Oem3 = 192,
        Oem4 = 219,
        Oem5 = 220,
        Oem6 = 221,
        Oem7 = 222,
        Oem8 = 223,
        Oem102 = 226,
        Process = 229,
        Packet = 231,
        Attention = 246,
        CrSel = 247,
        ExSel = 248,
        EraseEndOfFile = 249,
        Play = 250,
        Zoom = 251,
        NoName = 252,
        Pa1 = 253,
        OemClear = 254,
    }

    struct ConsoleKeyInfo
    {
        /*0x10*/ char _keyChar;
        /*0x14*/ System.ConsoleKey _key;
        /*0x18*/ System.ConsoleModifiers _mods;

        /*0x32c3600*/ ConsoleKeyInfo(char keyChar, System.ConsoleKey key, bool shift, bool alt, bool control);
        /*0x32c3694*/ char get_KeyChar();
        /*0x32c369c*/ System.ConsoleKey get_Key();
        /*0x32c36a4*/ bool Equals(object value);
        /*0x32c373c*/ bool Equals(System.ConsoleKeyInfo obj);
        /*0x32c3770*/ int GetHashCode();
    }

    enum ConsoleModifiers
    {
        Alt = 1,
        Shift = 2,
        Control = 4,
    }

    enum ConsoleSpecialKey
    {
        ControlC = 0,
        ControlBreak = 1,
    }

    struct SequencePosition : System.IEquatable<System.SequencePosition>
    {
        /*0x10*/ object _object;
        /*0x18*/ int _integer;

        /*0x32c3784*/ SequencePosition(object object, int integer);
        /*0x32c37ac*/ object GetObject();
        /*0x32c37b4*/ int GetInteger();
        /*0x32c37bc*/ bool Equals(System.SequencePosition other);
        /*0x32c37dc*/ bool Equals(object obj);
        /*0x32c3868*/ int GetHashCode();
    }

    class ThrowHelper
    {
        static /*0x32b48bc*/ void ThrowArgumentNullException(System.ExceptionArgument argument);
        static /*0x32c38e8*/ System.Exception CreateArgumentNullException(System.ExceptionArgument argument);
        static /*0x32c398c*/ void ThrowArrayTypeMismatchException();
        static /*0x32c39b0*/ System.Exception CreateArrayTypeMismatchException();
        static /*0x32c3a04*/ void ThrowArgumentException_DestinationTooShort();
        static /*0x32c3a28*/ System.Exception CreateArgumentException_DestinationTooShort();
        static /*0x32c3a94*/ void ThrowIndexOutOfRangeException();
        static /*0x32c3ab8*/ System.Exception CreateIndexOutOfRangeException();
        static /*0x32c3b0c*/ void ThrowArgumentOutOfRangeException();
        static /*0x32c3b30*/ System.Exception CreateArgumentOutOfRangeException();
        static /*0x32c3b84*/ void ThrowArgumentOutOfRangeException(System.ExceptionArgument argument);
        static /*0x32c3ba8*/ System.Exception CreateArgumentOutOfRangeException(System.ExceptionArgument argument);
        static /*0x32c3c4c*/ void ThrowInvalidOperationException_EndPositionNotReached();
        static /*0x32c3c70*/ System.Exception CreateInvalidOperationException_EndPositionNotReached();
        static /*0x32c3cdc*/ void ThrowObjectDisposedException_ArrayMemoryPoolBuffer();
        static /*0x32c3d00*/ System.Exception CreateObjectDisposedException_ArrayMemoryPoolBuffer();
        static /*0x32c3d68*/ void ThrowNotSupportedException();
        static /*0x32c3d8c*/ System.Exception CreateThrowNotSupportedException();
        static /*0x32c3de0*/ void ThrowWrongKeyTypeArgumentException(object key, System.Type targetType);
        static /*0x32c3eac*/ void ThrowWrongValueTypeArgumentException(object value, System.Type targetType);
        static /*0x32c3f78*/ void ThrowArgumentException(System.ExceptionResource resource);
        static /*0x32c4248*/ void ThrowArgumentException(System.ExceptionResource resource, System.ExceptionArgument argument);
        static /*0x32c4424*/ void ThrowArgumentOutOfRangeException(System.ExceptionArgument argument, System.ExceptionResource resource);
        static /*0x32c44c0*/ void ThrowInvalidOperationException(System.ExceptionResource resource);
        static /*0x32c4510*/ void ThrowSerializationException(System.ExceptionResource resource);
        static /*0x32c4560*/ void ThrowNotSupportedException(System.ExceptionResource resource);
        static /*0x32c45b0*/ void ThrowInvalidOperationException_InvalidOperation_EnumFailedVersion();
        static /*0x32c45fc*/ void ThrowInvalidOperationException_InvalidOperation_EnumOpCantHappen();
        static /*0x32c4648*/ void ThrowInvalidOperationException_InvalidOperation_EnumNotStarted();
        static /*0x32c4694*/ void ThrowInvalidOperationException_InvalidOperation_EnumEnded();
        static /*0x32c46e0*/ void ThrowInvalidOperationException_InvalidOperation_NoValue();
        static /*0x32c472c*/ System.ArgumentOutOfRangeException GetArgumentOutOfRangeException(System.ExceptionArgument argument, string resource);
        static /*0x32c47a8*/ void ThrowArgumentOutOfRange_IndexException();
        static /*0x32c47e0*/ void ThrowIndexArgumentOutOfRange_NeedNonNegNumException();
        static /*0x32c4818*/ void ThrowArgumentException_Argument_InvalidArrayType();
        static /*0x32c4864*/ System.ArgumentException GetAddingDuplicateWithKeyArgumentException(object key);
        static /*0x32c48f4*/ void ThrowAddingDuplicateWithKeyArgumentException(object key);
        static /*0x32c4918*/ System.Collections.Generic.KeyNotFoundException GetKeyNotFoundException(object key);
        static /*0x32c4990*/ void ThrowKeyNotFoundException(object key);
        static /*0x32c4998*/ void ThrowInvalidTypeWithPointersNotSupported(System.Type targetType);
        static /*0x32c49f8*/ void ThrowInvalidOperationException_ConcurrentOperationsNotSupported();
        static /*0x32c4a28*/ System.InvalidOperationException GetInvalidOperationException(string str);
        static /*0x32c4a84*/ void ThrowArraySegmentCtorValidationFailedExceptions(System.Array array, int offset, int count);
        static /*0x32c4aa8*/ System.Exception GetArraySegmentCtorValidationFailedException(System.Array array, int offset, int count);
        static /*0x32c4bfc*/ System.ArgumentException GetArgumentException(System.ExceptionResource resource);
        static /*0x32c4ad8*/ System.ArgumentNullException GetArgumentNullException(System.ExceptionArgument argument);
        static /*0x1f36244*/ void IfNullAndNullsAreIllegalThenThrow<T>(object value, System.ExceptionArgument argName);
        static /*0x32c42ac*/ string GetArgumentName(System.ExceptionArgument argument);
        static /*0x32c4b44*/ System.ArgumentOutOfRangeException GetArgumentOutOfRangeException(System.ExceptionArgument argument, System.ExceptionResource resource);
        static /*0x32c4ca0*/ void ThrowStartIndexArgumentOutOfRange_ArgumentOutOfRange_Index();
        static /*0x32c4ccc*/ void ThrowCountArgumentOutOfRange_ArgumentOutOfRange_Count();
        static /*0x32c3fc8*/ string GetResourceName(System.ExceptionResource resource);
    }

    class AppDomainUnloadedException : System.SystemException
    {
        /*0x32c4cf8*/ AppDomainUnloadedException();
        /*0x32c4d50*/ AppDomainUnloadedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class CannotUnloadAppDomainException : System.SystemException
    {
        /*0x32c4d54*/ CannotUnloadAppDomainException();
        /*0x32c4dac*/ CannotUnloadAppDomainException(string message);
        /*0x32c4dcc*/ CannotUnloadAppDomainException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class OperatingSystem : System.Runtime.Serialization.ISerializable, System.ICloneable
    {
        /*0x10*/ System.Version _version;
        /*0x18*/ System.PlatformID _platform;
        /*0x20*/ string _servicePack;
        /*0x28*/ string _versionString;

        /*0x32c4dd0*/ OperatingSystem(System.PlatformID platform, System.Version version);
        /*0x32c4dd8*/ OperatingSystem(System.PlatformID platform, System.Version version, string servicePack);
        /*0x32c4f24*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x32c4f58*/ System.PlatformID get_Platform();
        /*0x32c4f60*/ object Clone();
        /*0x32c4fd4*/ string ToString();
        /*0x32c4fd8*/ string get_VersionString();
    }

    class MissingFieldException : System.MissingMemberException, System.Runtime.Serialization.ISerializable
    {
        /*0x32c51e8*/ MissingFieldException();
        /*0x32c5268*/ MissingFieldException(string message);
        /*0x32c528c*/ MissingFieldException(string className, string fieldName);
        /*0x32c5328*/ MissingFieldException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x32c54b8*/ string get_Message();
    }

    class MissingMemberException : System.MemberAccessException
    {
        /*0x90*/ string ClassName;
        /*0x98*/ string MemberName;
        /*0xa0*/ byte[] Signature;

        static /*0x32c57c8*/ string FormatSignature(byte[] signature);
        /*0x32c52cc*/ MissingMemberException();
        /*0x32c5244*/ MissingMemberException(string message);
        /*0x32c532c*/ MissingMemberException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x32c5688*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x32c55a0*/ string get_Message();
    }

    class OutOfMemoryException : System.SystemException
    {
        /*0x32c57e0*/ OutOfMemoryException();
        /*0x32c5838*/ OutOfMemoryException(string message);
        /*0x32c5858*/ OutOfMemoryException(string message, System.Exception innerException);
        /*0x32c5878*/ OutOfMemoryException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class Array : System.Collections.ICollection, System.Collections.IEnumerable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.ICloneable
    {
        static /*0x32c587c*/ System.Array CreateInstance(System.Type elementType, long[] lengths);
        static /*0x1f327cc*/ System.Collections.ObjectModel.ReadOnlyCollection<T> AsReadOnly<T>(T[] array);
        static /*0x1f36244*/ void Resize<T>(ref T[] array, int newSize);
        static /*0x32c6a0c*/ int CombineHashCodes(int h1, int h2);
        static /*0x32c6b88*/ int BinarySearch(System.Array array, object value);
        static /*0x1f32888*/ TOutput[] ConvertAll<TInput, TOutput>(TInput[] array, System.Converter<TInput, TOutput> converter);
        static /*0x32c70ac*/ void Copy(System.Array sourceArray, System.Array destinationArray, long length);
        static /*0x32c71e0*/ void Copy(System.Array sourceArray, long sourceIndex, System.Array destinationArray, long destinationIndex, long length);
        static /*0x1f36f18*/ void ForEach<T>(T[] array, System.Action<T> action);
        static /*0x32c7838*/ int BinarySearch(System.Array array, int index, int length, object value);
        static /*0x32c7840*/ int BinarySearch(System.Array array, object value, System.Collections.IComparer comparer);
        static /*0x32c6c18*/ int BinarySearch(System.Array array, int index, int length, object value, System.Collections.IComparer comparer);
        static /*0x32c78dc*/ int GetMedian(int low, int hi);
        static /*0x1ffc854*/ int BinarySearch<T>(T[] array, T value);
        static /*0x1ffc854*/ int BinarySearch<T>(T[] array, T value, System.Collections.Generic.IComparer<T> comparer);
        static /*0x1ffc854*/ int BinarySearch<T>(T[] array, int index, int length, T value);
        static /*0x1ffc854*/ int BinarySearch<T>(T[] array, int index, int length, T value, System.Collections.Generic.IComparer<T> comparer);
        static /*0x32c5e30*/ int IndexOf(System.Array array, object value);
        static /*0x32c7b8c*/ int IndexOf(System.Array array, object value, int startIndex);
        static /*0x32c78e8*/ int IndexOf(System.Array array, object value, int startIndex, int count);
        static /*0x1ffc854*/ int IndexOf<T>(T[] array, T value);
        static /*0x1ffc854*/ int IndexOf<T>(T[] array, T value, int startIndex);
        static /*0x1ffc854*/ int IndexOf<T>(T[] array, T value, int startIndex, int count);
        static /*0x32c7c28*/ int LastIndexOf(System.Array array, object value);
        static /*0x32c7f50*/ int LastIndexOf(System.Array array, object value, int startIndex);
        static /*0x32c7cb0*/ int LastIndexOf(System.Array array, object value, int startIndex, int count);
        static /*0x1ffc854*/ int LastIndexOf<T>(T[] array, T value);
        static /*0x1ffc854*/ int LastIndexOf<T>(T[] array, T value, int startIndex);
        static /*0x1ffc854*/ int LastIndexOf<T>(T[] array, T value, int startIndex, int count);
        static /*0x32c7fa8*/ void Reverse(System.Array array);
        static /*0x32c802c*/ void Reverse(System.Array array, int index, int length);
        static /*0x1f350f8*/ void Reverse<T>(T[] array);
        static /*0x1f36284*/ void Reverse<T>(T[] array, int index, int length);
        static /*0x32c8720*/ void Sort(System.Array array);
        static /*0x32c89e4*/ void Sort(System.Array array, int index, int length);
        static /*0x32c89f8*/ void Sort(System.Array array, System.Collections.IComparer comparer);
        static /*0x32c8a88*/ void Sort(System.Array array, int index, int length, System.Collections.IComparer comparer);
        static /*0x32c8a9c*/ void Sort(System.Array keys, System.Array items);
        static /*0x32c8b2c*/ void Sort(System.Array keys, System.Array items, System.Collections.IComparer comparer);
        static /*0x32c8bc8*/ void Sort(System.Array keys, System.Array items, int index, int length);
        static /*0x32c87ac*/ void Sort(System.Array keys, System.Array items, int index, int length, System.Collections.IComparer comparer);
        static /*0x1f350f8*/ void Sort<T>(T[] array);
        static /*0x1f36284*/ void Sort<T>(T[] array, int index, int length);
        static /*0x1f36f18*/ void Sort<T>(T[] array, System.Collections.Generic.IComparer<T> comparer);
        static /*0x1f36320*/ void Sort<T>(T[] array, int index, int length, System.Collections.Generic.IComparer<T> comparer);
        static /*0x1f36f18*/ void Sort<T>(T[] array, System.Comparison<T> comparison);
        static /*0x1f36f18*/ void Sort<TKey, TValue>(TKey[] keys, TValue[] items);
        static /*0x1f37108*/ void Sort<TKey, TValue>(TKey[] keys, TValue[] items, int index, int length);
        static /*0x1f37400*/ void Sort<TKey, TValue>(TKey[] keys, TValue[] items, System.Collections.Generic.IComparer<TKey> comparer);
        static /*0x1f3714c*/ void Sort<TKey, TValue>(TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer<TKey> comparer);
        static /*0x1f318fc*/ bool Exists<T>(T[] array, System.Predicate<T> match);
        static /*0x1ffc854*/ void Fill<T>(T[] array, T value);
        static /*0x1ffc854*/ void Fill<T>(T[] array, T value, int startIndex, int count);
        static /*0x1ffc854*/ T Find<T>(T[] array, System.Predicate<T> match);
        static /*0x1f32888*/ T[] FindAll<T>(T[] array, System.Predicate<T> match);
        static /*0x1f321f0*/ int FindIndex<T>(T[] array, System.Predicate<T> match);
        static /*0x1f32114*/ int FindIndex<T>(T[] array, int startIndex, System.Predicate<T> match);
        static /*0x1ffc854*/ int FindIndex<T>(T[] array, int startIndex, int count, System.Predicate<T> match);
        static /*0x1ffc854*/ T FindLast<T>(T[] array, System.Predicate<T> match);
        static /*0x1f321f0*/ int FindLastIndex<T>(T[] array, System.Predicate<T> match);
        static /*0x1f32114*/ int FindLastIndex<T>(T[] array, int startIndex, System.Predicate<T> match);
        static /*0x1ffc854*/ int FindLastIndex<T>(T[] array, int startIndex, int count, System.Predicate<T> match);
        static /*0x1f318fc*/ bool TrueForAll<T>(T[] array, System.Predicate<T> match);
        static /*0x32c8df8*/ bool FastCopy(System.Array source, int source_idx, System.Array dest, int dest_idx, int length);
        static /*0x32c8dfc*/ System.Array CreateInstanceImpl(System.Type elementType, int[] lengths, int[] bounds);
        static /*0x32c8e38*/ System.Array UnsafeCreateInstance(System.Type elementType, int[] lengths, int[] lowerBounds);
        static /*0x32c91e0*/ System.Array UnsafeCreateInstance(System.Type elementType, int length1, int length2);
        static /*0x32c926c*/ System.Array UnsafeCreateInstance(System.Type elementType, int[] lengths);
        static /*0x32c9270*/ System.Array CreateInstance(System.Type elementType, int length);
        static /*0x32c91e4*/ System.Array CreateInstance(System.Type elementType, int length1, int length2);
        static /*0x32c92e8*/ System.Array CreateInstance(System.Type elementType, int length1, int length2, int length3);
        static /*0x32c59f0*/ System.Array CreateInstance(System.Type elementType, int[] lengths);
        static /*0x32c8e3c*/ System.Array CreateInstance(System.Type elementType, int[] lengths, int[] lowerBounds);
        static /*0x32c5ef8*/ void Clear(System.Array array, int index, int length);
        static /*0x32c9388*/ void ClearInternal(System.Array a, int index, int count);
        static /*0x32c711c*/ void Copy(System.Array sourceArray, System.Array destinationArray, int length);
        static /*0x32c61a8*/ void Copy(System.Array sourceArray, int sourceIndex, System.Array destinationArray, int destinationIndex, int length);
        static /*0x32c938c*/ System.ArrayTypeMismatchException CreateArrayTypeMismatchException();
        static /*0x32c93e0*/ bool CanAssignArrayElement(System.Type source, System.Type target);
        static /*0x32c94b8*/ void ConstrainedCopy(System.Array sourceArray, int sourceIndex, System.Array destinationArray, int destinationIndex, int length);
        static /*0x1f327a0*/ T[] Empty<T>();
        static /*0x1ffc854*/ int IndexOfImpl<T>(T[] array, T value, int startIndex, int count);
        static /*0x1ffc854*/ int LastIndexOfImpl<T>(T[] array, T value, int startIndex, int count);
        static /*0x32c8bd0*/ void SortImpl(System.Array keys, System.Array items, int index, int length, System.Collections.IComparer comparer);
        static /*0x1ffc854*/ T UnsafeLoad<T>(T[] array, int index);
        static /*0x1ffc854*/ void UnsafeStore<T>(T[] array, int index, T value);
        static /*0x1ffc854*/ R UnsafeMov<S, R>(S instance);
        /*0x32c8d28*/ Array();
        /*0x32c5c40*/ int System.Collections.ICollection.get_Count();
        /*0x32c5c44*/ bool System.Collections.IList.get_IsReadOnly();
        /*0x32c5c4c*/ object System.Collections.IList.get_Item(int index);
        /*0x32c5c50*/ void System.Collections.IList.set_Item(int index, object value);
        /*0x32c5dcc*/ int System.Collections.IList.Add(object value);
        /*0x32c5e18*/ bool System.Collections.IList.Contains(object value);
        /*0x32c5ebc*/ void System.Collections.IList.Clear();
        /*0x32c600c*/ int System.Collections.IList.IndexOf(object value);
        /*0x32c6010*/ void System.Collections.IList.Insert(int index, object value);
        /*0x32c605c*/ void System.Collections.IList.Remove(object value);
        /*0x32c60a8*/ void System.Collections.IList.RemoveAt(int index);
        /*0x32c60f4*/ void CopyTo(System.Array array, int index);
        /*0x32c66ac*/ object Clone();
        /*0x32c66b4*/ int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer);
        /*0x32c6888*/ bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer);
        /*0x32c6a18*/ int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer);
        /*0x32c72a8*/ void CopyTo(System.Array array, long index);
        /*0x32c7318*/ long get_LongLength();
        /*0x32c7380*/ long GetLongLength(int dimension);
        /*0x32c7394*/ object GetValue(long index);
        /*0x32c7404*/ object GetValue(long index1, long index2);
        /*0x32c752c*/ object GetValue(long index1, long index2, long index3);
        /*0x32c7694*/ object GetValue(long[] indices);
        /*0x32c781c*/ bool get_IsFixedSize();
        /*0x32c7824*/ bool get_IsReadOnly();
        /*0x32c782c*/ bool get_IsSynchronized();
        /*0x32c7834*/ object get_SyncRoot();
        /*0x32c8270*/ void SetValue(object value, long index);
        /*0x32c82e0*/ void SetValue(object value, long index1, long index2);
        /*0x32c8418*/ void SetValue(object value, long index1, long index2, long index3);
        /*0x32c8588*/ void SetValue(object value, long[] indices);
        /*0x32c8ccc*/ System.Collections.IEnumerator GetEnumerator();
        /*0x32c8d30*/ int InternalArray__ICollection_get_Count();
        /*0x32c8d34*/ bool InternalArray__ICollection_get_IsReadOnly();
        /*0x32c8d3c*/ ref byte GetRawSzArrayData();
        /*0x1f30214*/ System.Collections.Generic.IEnumerator<T> InternalArray__IEnumerable_GetEnumerator<T>();
        /*0x32c8d50*/ void InternalArray__ICollection_Clear();
        /*0x1ffc854*/ void InternalArray__ICollection_Add<T>(T item);
        /*0x1ffc854*/ bool InternalArray__ICollection_Remove<T>(T item);
        /*0x1ffc854*/ bool InternalArray__ICollection_Contains<T>(T item);
        /*0x1f30ee8*/ void InternalArray__ICollection_CopyTo<T>(T[] array, int arrayIndex);
        /*0x1ffc854*/ T InternalArray__IReadOnlyList_get_Item<T>(int index);
        /*0x32c8d9c*/ int InternalArray__IReadOnlyCollection_get_Count();
        /*0x1ffc854*/ void InternalArray__Insert<T>(int index, T item);
        /*0x32c8da0*/ void InternalArray__RemoveAt(int index);
        /*0x1ffc854*/ int InternalArray__IndexOf<T>(T item);
        /*0x1ffc854*/ T InternalArray__get_Item<T>(int index);
        /*0x1ffc854*/ void InternalArray__set_Item<T>(int index, T item);
        /*0x1f30c88*/ void GetGenericValueImpl<T>(int pos, ref T value);
        /*0x1f30c88*/ void SetGenericValueImpl<T>(int pos, ref T value);
        /*0x32bbd1c*/ int get_Length();
        /*0x32c61a4*/ int get_Rank();
        /*0x32c8dec*/ int GetRank();
        /*0x32c737c*/ int GetLength(int dimension);
        /*0x32c5ef4*/ int GetLowerBound(int dimension);
        /*0x32c7818*/ object GetValue(int[] indices);
        /*0x32c871c*/ void SetValue(object value, int[] indices);
        /*0x32c8df0*/ object GetValueImpl(int pos);
        /*0x32c8df4*/ void SetValueImpl(object value, int pos);
        /*0x32c8e00*/ int GetUpperBound(int dimension);
        /*0x32bbd7c*/ object GetValue(int index);
        /*0x32c74a4*/ object GetValue(int index1, int index2);
        /*0x32c75f4*/ object GetValue(int index1, int index2, int index3);
        /*0x32c5c60*/ void SetValue(object value, int index);
        /*0x32c8380*/ void SetValue(object value, int index1, int index2);
        /*0x32c84e0*/ void SetValue(object value, int index1, int index2, int index3);
        /*0x32c94bc*/ void Initialize();

        class ArrayEnumerator : System.Collections.IEnumerator, System.ICloneable
        {
            /*0x10*/ System.Array _array;
            /*0x18*/ int _index;
            /*0x1c*/ int _endIndex;

            /*0x32c99d8*/ ArrayEnumerator(System.Array array);
            /*0x32c9a30*/ bool MoveNext();
            /*0x32c9a58*/ void Reset();
            /*0x32c9a64*/ object Clone();
            /*0x32c9a6c*/ object get_Current();
        }

        class RawData
        {
            /*0x10*/ nint Bounds;
            /*0x18*/ nint Count;
            /*0x20*/ byte Data;
        }

        struct InternalEnumerator<T> : System.Collections.Generic.IEnumerator<T>, System.IDisposable, System.Collections.IEnumerator
        {
            /*0x0*/ System.Array array;
            /*0x0*/ int idx;

            /*0x1f30ebc*/ InternalEnumerator(System.Array array);
            /*0x1f309e4*/ void Dispose();
            /*0x1f2fe14*/ bool MoveNext();
            /*0x1ffc854*/ T get_Current();
            /*0x1f309e4*/ void System.Collections.IEnumerator.Reset();
            /*0x1f30214*/ object System.Collections.IEnumerator.get_Current();
        }

        class EmptyInternalEnumerator<T> : System.Collections.Generic.IEnumerator<T>, System.IDisposable, System.Collections.IEnumerator
        {
            static /*0x0*/ System.Array.EmptyInternalEnumerator<T> Value;

            static /*0x1f33998*/ EmptyInternalEnumerator();
            /*0x1f309e4*/ EmptyInternalEnumerator();
            /*0x1f309e4*/ void Dispose();
            /*0x1f2fe14*/ bool MoveNext();
            /*0x1ffc854*/ T get_Current();
            /*0x1f30214*/ object System.Collections.IEnumerator.get_Current();
            /*0x1f309e4*/ void System.Collections.IEnumerator.Reset();
        }

        struct SorterObjectArray
        {
            /*0x10*/ object[] keys;
            /*0x18*/ object[] items;
            /*0x20*/ System.Collections.IComparer comparer;

            /*0x32c9b78*/ SorterObjectArray(object[] keys, object[] items, System.Collections.IComparer comparer);
            /*0x32c9c18*/ void SwapIfGreaterWithItems(int a, int b);
            /*0x32c9e98*/ void Swap(int i, int j);
            /*0x32ca04c*/ void Sort(int left, int length);
            /*0x32ca050*/ void IntrospectiveSort(int left, int length);
            /*0x32ca19c*/ void IntroSort(int lo, int hi, int depthLimit);
            /*0x32ca610*/ int PickPivotAndPartition(int lo, int hi);
            /*0x32ca574*/ void Heapsort(int lo, int hi);
            /*0x32ca83c*/ void DownHeap(int i, int n, int lo);
            /*0x32ca2b4*/ void InsertionSort(int lo, int hi);
        }

        struct SorterGenericArray
        {
            /*0x10*/ System.Array keys;
            /*0x18*/ System.Array items;
            /*0x20*/ System.Collections.IComparer comparer;

            /*0x32cabd4*/ SorterGenericArray(System.Array keys, System.Array items, System.Collections.IComparer comparer);
            /*0x32cac74*/ void SwapIfGreaterWithItems(int a, int b);
            /*0x32cae44*/ void Swap(int i, int j);
            /*0x32caf30*/ void Sort(int left, int length);
            /*0x32caf34*/ void IntrospectiveSort(int left, int length);
            /*0x32cb088*/ void IntroSort(int lo, int hi, int depthLimit);
            /*0x32cb41c*/ int PickPivotAndPartition(int lo, int hi);
            /*0x32cb380*/ void Heapsort(int lo, int hi);
            /*0x32cb638*/ void DownHeap(int i, int n, int lo);
            /*0x32cb1a0*/ void InsertionSort(int lo, int hi);
        }
    }

    struct ByReference<T>
    {
        /*0x0*/ nint _value;

        /*0x1f30ebc*/ ByReference(ref T value);
        /*0x1f30214*/ ref T get_Value();
    }

    class MonoTODOAttribute : System.Attribute
    {
        /*0x10*/ string comment;

        /*0x32cb8f8*/ MonoTODOAttribute();
        /*0x32cb908*/ MonoTODOAttribute(string comment);
    }

    class MonoLimitationAttribute : System.MonoTODOAttribute
    {
        /*0x32cb938*/ MonoLimitationAttribute(string comment);
    }

    class AppContext
    {
        static /*0x0*/ System.Collections.Generic.Dictionary<string, System.AppContext.SwitchValueState> s_switchMap;
        static /*0x8*/ bool s_defaultsInitialized;

        static /*0x32cbf14*/ AppContext();
        static /*0x32cb968*/ void InitializeDefaultSwitchValues();
        static /*0x32cbae4*/ bool TryGetSwitch(string switchName, ref bool isEnabled);

        enum SwitchValueState
        {
            HasFalseValue = 1,
            HasTrueValue = 2,
            HasLookedForOverride = 4,
            UnknownValue = 8,
        }
    }

    class AppContextSwitches
    {
        static /*0x0*/ bool SetActorAsReferenceWhenCopyingClaimsIdentity;
        static /*0x1*/ bool NoAsyncCurrentCulture;
        static /*0x2*/ bool EnforceJapaneseEraYearRanges;
        static /*0x3*/ bool FormatJapaneseFirstYearAsANumber;
        static /*0x4*/ bool EnforceLegacyJapaneseDateParsing;
    }

    class LocalDataStoreHolder
    {
        /*0x10*/ System.LocalDataStore m_Store;

        /*0x32cbfc0*/ LocalDataStoreHolder(System.LocalDataStore store);
        /*0x32cbff0*/ void Finalize();
        /*0x32cc098*/ System.LocalDataStore get_Store();
    }

    class LocalDataStoreElement
    {
        /*0x10*/ object m_value;
        /*0x18*/ long m_cookie;

        /*0x32cc0a0*/ LocalDataStoreElement(long cookie);
        /*0x32cc0c8*/ object get_Value();
        /*0x32cc0d0*/ void set_Value(object value);
        /*0x32cc0d8*/ long get_Cookie();
    }

    class LocalDataStore
    {
        /*0x10*/ System.LocalDataStoreElement[] m_DataTable;
        /*0x18*/ System.LocalDataStoreMgr m_Manager;

        /*0x32cc0e0*/ LocalDataStore(System.LocalDataStoreMgr mgr, int InitialCapacity);
        /*0x32cc080*/ void Dispose();
        /*0x32cc270*/ object GetData(System.LocalDataStoreSlot slot);
        /*0x32cc3a0*/ void SetData(System.LocalDataStoreSlot slot, object data);
        /*0x32cc720*/ void FreeData(int slot, long cookie);
        /*0x32cc474*/ System.LocalDataStoreElement PopulateElement(System.LocalDataStoreSlot slot);
    }

    class LocalDataStoreSlot
    {
        /*0x10*/ System.LocalDataStoreMgr m_mgr;
        /*0x18*/ int m_slot;
        /*0x20*/ long m_cookie;

        /*0x32cc79c*/ LocalDataStoreSlot(System.LocalDataStoreMgr mgr, int slot, long cookie);
        /*0x32cc7e8*/ System.LocalDataStoreMgr get_Manager();
        /*0x32cc7f0*/ int get_Slot();
        /*0x32cc7f8*/ long get_Cookie();
        /*0x32cc800*/ void Finalize();
    }

    class LocalDataStoreMgr
    {
        /*0x10*/ bool[] m_SlotInfoTable;
        /*0x18*/ int m_FirstAvailableSlot;
        /*0x20*/ System.Collections.Generic.List<System.LocalDataStore> m_ManagedLocalDataStores;
        /*0x28*/ System.Collections.Generic.Dictionary<string, System.LocalDataStoreSlot> m_KeyToSlotMap;
        /*0x30*/ long m_CookieGenerator;

        /*0x32cd180*/ LocalDataStoreMgr();
        /*0x32cca48*/ System.LocalDataStoreHolder CreateLocalDataStore();
        /*0x32cc164*/ void DeleteLocalDataStore(System.LocalDataStore store);
        /*0x32ccbc8*/ System.LocalDataStoreSlot AllocateDataSlot();
        /*0x32cce28*/ System.LocalDataStoreSlot AllocateNamedDataSlot(string name);
        /*0x32ccf4c*/ System.LocalDataStoreSlot GetNamedDataSlot(string name);
        /*0x32cd074*/ void FreeNamedDataSlot(string name);
        /*0x32cc8a0*/ void FreeDataSlot(int slot, long cookie);
        /*0x32cc334*/ void ValidateSlot(System.LocalDataStoreSlot slot);
        /*0x32cc784*/ int GetSlotTableLength();
    }

    class Activator
    {
        static /*0x32cd28c*/ object CreateInstance(System.Type type, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture);
        static /*0x32cd294*/ object CreateInstance(System.Type type, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
        static /*0x32cdda0*/ object CreateInstance(System.Type type, object[] args);
        static /*0x32cddb8*/ object CreateInstance(System.Type type, object[] args, object[] activationAttributes);
        static /*0x32cddd0*/ object CreateInstance(System.Type type);
        static /*0x32cdddc*/ object CreateInstance(System.Type type, bool nonPublic);
        static /*0x32cdde4*/ object CreateInstance(System.Type type, bool nonPublic, bool wrapExceptions);
        static /*0x1ffc854*/ T CreateInstance<T>();
    }

    class Attribute
    {
        static /*0x32ce074*/ System.Attribute[] InternalGetCustomAttributes(System.Reflection.PropertyInfo element, System.Type type, bool inherit);
        static /*0x32ce120*/ System.Attribute[] InternalGetCustomAttributes(System.Reflection.EventInfo element, System.Type type, bool inherit);
        static /*0x32ce1cc*/ System.Attribute[] InternalParamGetCustomAttributes(System.Reflection.ParameterInfo parameter, System.Type attributeType, bool inherit);
        static /*0x32ce64c*/ bool InternalIsDefined(System.Reflection.PropertyInfo element, System.Type attributeType, bool inherit);
        static /*0x32ce6bc*/ bool InternalIsDefined(System.Reflection.EventInfo element, System.Type attributeType, bool inherit);
        static /*0x32ce72c*/ System.Attribute[] GetCustomAttributes(System.Reflection.MemberInfo element, System.Type type);
        static /*0x32ce734*/ System.Attribute[] GetCustomAttributes(System.Reflection.MemberInfo element, System.Type type, bool inherit);
        static /*0x32cea1c*/ System.Attribute[] GetCustomAttributes(System.Reflection.MemberInfo element);
        static /*0x32cea24*/ System.Attribute[] GetCustomAttributes(System.Reflection.MemberInfo element, bool inherit);
        static /*0x32cec34*/ bool IsDefined(System.Reflection.MemberInfo element, System.Type attributeType);
        static /*0x32cec3c*/ bool IsDefined(System.Reflection.MemberInfo element, System.Type attributeType, bool inherit);
        static /*0x32cef04*/ System.Attribute GetCustomAttribute(System.Reflection.MemberInfo element, System.Type attributeType);
        static /*0x32cef0c*/ System.Attribute GetCustomAttribute(System.Reflection.MemberInfo element, System.Type attributeType, bool inherit);
        static /*0x32cef94*/ System.Attribute[] GetCustomAttributes(System.Reflection.ParameterInfo element, System.Type attributeType, bool inherit);
        static /*0x32cf23c*/ System.Attribute[] GetCustomAttributes(System.Reflection.ParameterInfo element, bool inherit);
        static /*0x32cf3f4*/ System.Attribute[] GetCustomAttributes(System.Reflection.Module element, bool inherit);
        static /*0x32cf544*/ System.Attribute[] GetCustomAttributes(System.Reflection.Module element, System.Type attributeType, bool inherit);
        static /*0x32cf788*/ System.Attribute[] GetCustomAttributes(System.Reflection.Assembly element, System.Type attributeType);
        static /*0x32cf790*/ System.Attribute[] GetCustomAttributes(System.Reflection.Assembly element, System.Type attributeType, bool inherit);
        static /*0x32cf9b0*/ System.Attribute[] GetCustomAttributes(System.Reflection.Assembly element);
        static /*0x32cf9b8*/ System.Attribute[] GetCustomAttributes(System.Reflection.Assembly element, bool inherit);
        static /*0x32cfadc*/ System.Attribute GetCustomAttribute(System.Reflection.Assembly element, System.Type attributeType);
        static /*0x32cfae4*/ System.Attribute GetCustomAttribute(System.Reflection.Assembly element, System.Type attributeType, bool inherit);
        static /*0x32cfdb0*/ bool AreFieldValuesEqual(object thisValue, object thatValue);
        /*0x32cb900*/ Attribute();
        /*0x32cfb6c*/ bool Equals(object obj);
        /*0x32cff64*/ int GetHashCode();
        /*0x32d0090*/ object get_TypeId();
        /*0x32d0098*/ bool Match(object obj);
        /*0x32d00a4*/ bool IsDefaultAttribute();
    }

    class Buffer
    {
        static /*0x32d00ac*/ bool InternalBlockCopy(System.Array src, int srcOffsetBytes, System.Array dst, int dstOffsetBytes, int byteCount);
        static /*0x32d00b0*/ int IndexOfByte(byte* src, byte value, int index, int count);
        static /*0x32d01d4*/ int _ByteLength(System.Array array);
        static /*0x32d01d8*/ void ZeroMemory(byte* src, long len);
        static /*0x32d01fc*/ void Memcpy(byte* pDest, int destIndex, byte[] src, int srcIndex, int len);
        static /*0x32d032c*/ void InternalMemcpy(byte* dest, byte* src, int count);
        static /*0x32d0330*/ int ByteLength(System.Array array);
        static /*0x32d03c4*/ void BlockCopy(System.Array src, int srcOffset, System.Array dst, int dstOffset, int count);
        static /*0x32d056c*/ void MemoryCopy(void* source, void* destination, long destinationSizeInBytes, long sourceBytesToCopy);
        static /*0x32d061c*/ void memcpy4(byte* dest, byte* src, int size);
        static /*0x32d06b0*/ void memcpy2(byte* dest, byte* src, int size);
        static /*0x32d0734*/ void memcpy1(byte* dest, byte* src, int size);
        static /*0x32d0230*/ void Memcpy(byte* dest, byte* src, int len);
        static /*0x32d05f4*/ void Memmove(byte* dest, byte* src, uint len);
        static /*0x1ffc854*/ void Memmove<T>(ref T destination, ref T source, ulong elementCount);
    }

    class ContextBoundObject : System.MarshalByRefObject
    {
        /*0x32d07e8*/ ContextBoundObject();
    }

    class ContextStaticAttribute : System.Attribute
    {
        /*0x32d07f0*/ ContextStaticAttribute();
    }

    class DefaultBinder : System.Reflection.Binder
    {
        static /*0x0*/ System.DefaultBinder.Primitives[] _primitiveConversions;

        static /*0x32d5df8*/ DefaultBinder();
        static /*0x32d4c74*/ System.Reflection.MethodBase ExactBinding(System.Reflection.MethodBase[] match, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        static /*0x32d5038*/ System.Reflection.PropertyInfo ExactPropertyBinding(System.Reflection.PropertyInfo[] match, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        static /*0x32d4414*/ int FindMostSpecific(System.Reflection.ParameterInfo[] p1, int[] paramOrder1, System.Type paramArrayType1, System.Reflection.ParameterInfo[] p2, int[] paramOrder2, System.Type paramArrayType2, System.Type[] types, object[] args);
        static /*0x32d4080*/ int FindMostSpecificType(System.Type c1, System.Type c2, System.Type t);
        static /*0x32d2d5c*/ int FindMostSpecificMethod(System.Reflection.MethodBase m1, int[] paramOrder1, System.Type paramArrayType1, System.Reflection.MethodBase m2, int[] paramOrder2, System.Type paramArrayType2, System.Type[] types, object[] args);
        static /*0x32d3360*/ int FindMostSpecificField(System.Reflection.FieldInfo cur1, System.Reflection.FieldInfo cur2);
        static /*0x32d4804*/ int FindMostSpecificProperty(System.Reflection.PropertyInfo cur1, System.Reflection.PropertyInfo cur2);
        static /*0x32d52e0*/ bool CompareMethodSigAndName(System.Reflection.MethodBase m1, System.Reflection.MethodBase m2);
        static /*0x32d5414*/ int GetHierarchyDepth(System.Type t);
        static /*0x32d4eec*/ System.Reflection.MethodBase FindMostDerivedNewSlotMeth(System.Reflection.MethodBase[] match, int cMatches);
        static /*0x32d2be4*/ void ReorderParams(int[] paramOrder, object[] vars);
        static /*0x32d2840*/ bool CreateParamOrder(int[] paramOrder, System.Reflection.ParameterInfo[] pars, string[] names);
        static /*0x32d3e54*/ bool CanConvertPrimitive(System.RuntimeType source, System.RuntimeType target);
        static /*0x32d2a94*/ bool CanConvertPrimitiveObjectToType(object source, System.RuntimeType type);
        static /*0x32d5488*/ bool CompareMethodSig(System.Reflection.MethodBase m1, System.Reflection.MethodBase m2);
        static /*0x32d5cc8*/ bool CanChangePrimitive(System.Type source, System.Type target);
        static /*0x32d5d2c*/ bool CanPrimitiveWiden(System.Type source, System.Type target);
        /*0x32d5df0*/ DefaultBinder();
        /*0x32d07f8*/ System.Reflection.MethodBase BindToMethod(System.Reflection.BindingFlags bindingAttr, System.Reflection.MethodBase[] match, ref object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo cultureInfo, string[] names, ref object state);
        /*0x32d2ed8*/ System.Reflection.FieldInfo BindToField(System.Reflection.BindingFlags bindingAttr, System.Reflection.FieldInfo[] match, object value, System.Globalization.CultureInfo cultureInfo);
        /*0x32d3448*/ System.Reflection.PropertyInfo SelectProperty(System.Reflection.BindingFlags bindingAttr, System.Reflection.PropertyInfo[] match, System.Type returnType, System.Type[] indexes, System.Reflection.ParameterModifier[] modifiers);
        /*0x32d48ec*/ object ChangeType(object value, System.Type type, System.Globalization.CultureInfo cultureInfo);
        /*0x32d4944*/ void ReorderArgumentArray(ref object[] args, object state);
        /*0x32d55bc*/ System.Reflection.MethodBase SelectMethod(System.Reflection.BindingFlags bindingAttr, System.Reflection.MethodBase[] match, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);

        class BinderState
        {
            /*0x10*/ int[] m_argsMap;
            /*0x18*/ int m_originalSize;
            /*0x1c*/ bool m_isParamArray;

            /*0x32d2b98*/ BinderState(int[] argsMap, int originalSize, bool isParamArray);
        }

        enum Primitives
        {
            Boolean = 8,
            Char = 16,
            SByte = 32,
            Byte = 64,
            Int16 = 128,
            UInt16 = 256,
            Int32 = 512,
            UInt32 = 1024,
            Int64 = 2048,
            UInt64 = 4096,
            Single = 8192,
            Double = 16384,
            Decimal = 32768,
            DateTime = 65536,
            String = 262144,
        }

        class <>c
        {
            static /*0x0*/ System.DefaultBinder.<> <>9;
            static /*0x8*/ System.Predicate<System.Type> <>9__2_0;

            static /*0x32d5e98*/ <>c();
            /*0x32d5f00*/ <>c();
            /*0x32d5f08*/ bool <SelectProperty>b__2_0(System.Type t);
        }
    }

    class Empty : System.Runtime.Serialization.ISerializable
    {
        static /*0x0*/ System.Empty Value;

        static /*0x32d5fc4*/ Empty();
        /*0x32d5f3c*/ Empty();
        /*0x32d5f44*/ string ToString();
        /*0x32d5f5c*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class Enum : System.IComparable, System.IFormattable, System.IConvertible
    {
        static string enumSeperator = ", ";
        static /*0x0*/ char[] enumSeperatorCharArray;

        static /*0x32da6e4*/ Enum();
        static /*0x32d602c*/ System.Enum.ValuesAndNames GetCachedValuesAndNames(System.RuntimeType enumType, bool getNames);
        static /*0x32d61c4*/ string InternalFormattedHexString(object value);
        static /*0x32d6650*/ string InternalFormat(System.RuntimeType eT, object value);
        static /*0x32d67fc*/ string InternalFlagsFormat(System.RuntimeType eT, object value);
        static /*0x32d69f4*/ ulong ToUInt64(object value);
        static /*0x32d6b60*/ int InternalCompareTo(object o1, object o2);
        static /*0x32d6b64*/ System.RuntimeType InternalGetUnderlyingType(System.RuntimeType enumType);
        static /*0x32d617c*/ bool GetEnumValuesAndNames(System.RuntimeType enumType, ref ulong[] values, ref string[] names);
        static /*0x32d6b68*/ object InternalBoxEnum(System.RuntimeType enumType, long value);
        static /*0x1f318fc*/ bool TryParse<TEnum>(string value, ref TEnum result);
        static /*0x1ffc854*/ bool TryParse<TEnum>(string value, bool ignoreCase, ref TEnum result);
        static /*0x32d6b6c*/ object Parse(System.Type enumType, string value);
        static /*0x32d6bb0*/ object Parse(System.Type enumType, string value, bool ignoreCase);
        static /*0x32d6cb4*/ bool TryParseEnum(System.Type enumType, string value, bool ignoreCase, ref System.Enum.EnumResult parseResult);
        static /*0x32d7568*/ System.Type GetUnderlyingType(System.Type enumType);
        static /*0x32d7c50*/ System.Array GetValues(System.Type enumType);
        static /*0x32d7cf0*/ ulong[] InternalGetValues(System.RuntimeType enumType);
        static /*0x32d674c*/ string GetName(System.Type enumType, object value);
        static /*0x32d7d34*/ string[] GetNames(System.Type enumType);
        static /*0x32d7dd4*/ string[] InternalGetNames(System.RuntimeType enumType);
        static /*0x32d7608*/ object ToObject(System.Type enumType, object value);
        static /*0x32d8cdc*/ bool IsDefined(System.Type enumType, object value);
        static /*0x32d8d8c*/ string Format(System.Type enumType, object value, string format);
        static /*0x32d7fbc*/ object ToObject(System.Type enumType, sbyte value);
        static /*0x32d8160*/ object ToObject(System.Type enumType, short value);
        static /*0x32d7e18*/ object ToObject(System.Type enumType, int value);
        static /*0x32d864c*/ object ToObject(System.Type enumType, byte value);
        static /*0x32d87f0*/ object ToObject(System.Type enumType, ushort value);
        static /*0x32d84a8*/ object ToObject(System.Type enumType, uint value);
        static /*0x32d8304*/ object ToObject(System.Type enumType, long value);
        static /*0x32d7aac*/ object ToObject(System.Type enumType, ulong value);
        static /*0x32d8994*/ object ToObject(System.Type enumType, char value);
        static /*0x32d8b38*/ object ToObject(System.Type enumType, bool value);
        static /*0x1ffc854*/ TEnum Parse<TEnum>(string value);
        static /*0x1ffc854*/ TEnum Parse<TEnum>(string value, bool ignoreCase);
        static /*0x32da5ec*/ bool TryParse(System.Type enumType, string value, bool ignoreCase, ref object result);
        static /*0x32da690*/ bool TryParse(System.Type enumType, string value, ref object result);
        /*0x32da6dc*/ Enum();
        /*0x32d9314*/ object get_value();
        /*0x32d9310*/ object GetValue();
        /*0x32d9318*/ bool InternalHasFlag(System.Enum flags);
        /*0x32d931c*/ int get_hashcode();
        /*0x32d9320*/ bool Equals(object obj);
        /*0x32d9328*/ int GetHashCode();
        /*0x32d932c*/ string ToString();
        /*0x32d93ec*/ string ToString(string format, System.IFormatProvider provider);
        /*0x32d9634*/ int CompareTo(object target);
        /*0x32d93f0*/ string ToString(string format);
        /*0x32d9800*/ string ToString(System.IFormatProvider provider);
        /*0x32d980c*/ bool HasFlag(System.Enum flag);
        /*0x32d998c*/ System.TypeCode GetTypeCode();
        /*0x32d9c7c*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x32d9d1c*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x32d9dbc*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x32d9e5c*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x32d9efc*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x32d9f9c*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x32da03c*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x32da0dc*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x32da17c*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x32da21c*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x32da2bc*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x32da35c*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x32da3fc*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x32da49c*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x32da57c*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);

        enum ParseFailureKind
        {
            None = 0,
            Argument = 1,
            ArgumentNull = 2,
            ArgumentWithParameter = 3,
            UnhandledException = 4,
        }

        struct EnumResult
        {
            /*0x10*/ object parsedEnum;
            /*0x18*/ bool canThrow;
            /*0x1c*/ System.Enum.ParseFailureKind m_failure;
            /*0x20*/ string m_failureMessageID;
            /*0x28*/ string m_failureParameter;
            /*0x30*/ object m_failureMessageFormatArgument;
            /*0x38*/ System.Exception m_innerException;

            /*0x32d6c6c*/ void Init(bool canMethodThrow);
            /*0x32d7a9c*/ void SetFailure(System.Exception unhandledException);
            /*0x32d74a0*/ void SetFailure(System.Enum.ParseFailureKind failure, string failureParameter);
            /*0x32d74fc*/ void SetFailure(System.Enum.ParseFailureKind failure, string failureMessageID, object failureMessageFormatArgument);
            /*0x32d7324*/ System.Exception GetEnumParseException();
        }

        class ValuesAndNames
        {
            /*0x10*/ ulong[] Values;
            /*0x18*/ string[] Names;

            /*0x32d6180*/ ValuesAndNames(ulong[] values, string[] names);
        }
    }

    class Exception : System.Runtime.Serialization.ISerializable
    {
        static int _COMPlusExceptionCode = -532462766;
        static /*0x0*/ object s_EDILock;
        /*0x10*/ string _className;
        /*0x18*/ string _message;
        /*0x20*/ System.Collections.IDictionary _data;
        /*0x28*/ System.Exception _innerException;
        /*0x30*/ string _helpURL;
        /*0x38*/ object _stackTrace;
        /*0x40*/ string _stackTraceString;
        /*0x48*/ string _remoteStackTraceString;
        /*0x50*/ int _remoteStackIndex;
        /*0x58*/ object _dynamicMethods;
        /*0x60*/ int _HResult;
        /*0x68*/ string _source;
        /*0x70*/ System.Runtime.Serialization.SafeSerializationManager _safeSerializationManager;
        /*0x78*/ System.Diagnostics.StackTrace[] captured_traces;
        /*0x80*/ nint[] native_trace_ips;
        /*0x88*/ int caught_in_unmanaged;

        static /*0x32dbba4*/ Exception();
        static /*0x32dba2c*/ string GetMessageFromNativeResources(System.Exception.ExceptionMessageKind kind);
        static /*0x32dbba0*/ void ReportUnhandledException(System.Exception exception);
        /*0x32da7fc*/ Exception();
        /*0x32da818*/ Exception(string message);
        /*0x32da850*/ Exception(string message, System.Exception innerException);
        /*0x32da89c*/ Exception(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x32da760*/ void Init();
        /*0x32dade4*/ string get_Message();
        /*0x32daf24*/ System.Collections.IDictionary get_Data();
        /*0x32daed8*/ string GetClassName();
        /*0x32daf9c*/ System.Exception GetBaseException();
        /*0x32dafb0*/ System.Exception get_InnerException();
        /*0x32dafb8*/ System.Reflection.MethodBase get_TargetSite();
        /*0x32db064*/ string get_StackTrace();
        /*0x32db06c*/ string GetStackTrace(bool needFileInfo);
        /*0x32db0c0*/ void SetErrorCode(int hr);
        /*0x32db0c8*/ string get_Source();
        /*0x32db1e0*/ string ToString();
        /*0x32db1ec*/ string ToString(bool needFileLineInfo, bool needMessage);
        /*0x32db438*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x32db8b0*/ void OnDeserialized(System.Runtime.Serialization.StreamingContext context);
        /*0x32db0b8*/ string StripFileInfo(string stackTrace, bool isRemoteStackTrace);
        /*0x32db940*/ void RestoreExceptionDispatchInfo(System.Runtime.ExceptionServices.ExceptionDispatchInfo exceptionDispatchInfo);
        /*0x32dba1c*/ int get_HResult();
        /*0x32dba24*/ void set_HResult(int value);
        /*0x32daf94*/ System.Type GetType();
        /*0x32dbab0*/ System.Exception FixRemotingException();

        enum ExceptionMessageKind
        {
            ThreadAbort = 1,
            ThreadInterrupted = 2,
            OutOfMemory = 3,
        }
    }

    enum GCCollectionMode
    {
        Default = 0,
        Forced = 1,
        Optimized = 2,
    }

    class GC
    {
        static /*0x0*/ object EPHEMERON_TOMBSTONE;

        static /*0x32dc124*/ GC();
        static /*0x32dbc20*/ int GetCollectionCount(int generation);
        static /*0x32dbc24*/ int GetMaxGeneration();
        static /*0x32dbc28*/ void InternalCollect(int generation);
        static /*0x32dbc2c*/ void register_ephemeron_array(System.Runtime.CompilerServices.Ephemeron[] array);
        static /*0x32dbc30*/ object get_ephemeron_tombstone();
        static /*0x32dbc34*/ void GetMemoryInfo(ref uint highMemLoadThreshold, ref ulong totalPhysicalMem, ref uint lastRecordedMemLoad, ref nuint lastRecordedHeapSize, ref nuint lastRecordedFragmentation);
        static /*0x32dbc50*/ void Collect(int generation);
        static /*0x32dbd10*/ void Collect();
        static /*0x32dbca8*/ void Collect(int generation, System.GCCollectionMode mode);
        static /*0x32dbdac*/ void Collect(int generation, System.GCCollectionMode mode, bool blocking);
        static /*0x32dbe18*/ void Collect(int generation, System.GCCollectionMode mode, bool blocking, bool compacting);
        static /*0x32dbf18*/ int CollectionCount(int generation);
        static /*0x32dbfd4*/ void KeepAlive(object obj);
        static /*0x32dbd60*/ int get_MaxGeneration();
        static /*0x32dbfd8*/ void WaitForPendingFinalizers();
        static /*0x32dbfdc*/ void _SuppressFinalize(object o);
        static /*0x32dbfe0*/ void SuppressFinalize(object obj);
        static /*0x32dc080*/ void _ReRegisterForFinalize(object o);
        static /*0x32dc084*/ void ReRegisterForFinalize(object obj);
    }

    enum TypeNameFormatFlags
    {
        FormatBasic = 0,
        FormatNamespace = 1,
        FormatFullInst = 2,
        FormatAssembly = 4,
        FormatSignature = 8,
        FormatNoVersion = 16,
        FormatAngleBrackets = 64,
        FormatStubInfo = 128,
        FormatGenericParam = 256,
        FormatSerialization = 259,
    }

    enum TypeNameKind
    {
        Name = 0,
        ToString = 1,
        SerializationName = 2,
        FullName = 3,
    }

    class RuntimeType : System.Reflection.TypeInfo, System.Runtime.Serialization.ISerializable, System.ICloneable
    {
        static System.Reflection.BindingFlags MemberBindingMask = 255;
        static System.Reflection.BindingFlags InvocationMask = 65280;
        static System.Reflection.BindingFlags BinderNonCreateInstance = 15616;
        static System.Reflection.BindingFlags BinderGetSetProperty = 12288;
        static System.Reflection.BindingFlags BinderSetInvokeProperty = 8448;
        static System.Reflection.BindingFlags BinderGetSetField = 3072;
        static System.Reflection.BindingFlags BinderSetInvokeField = 2304;
        static System.Reflection.BindingFlags BinderNonFieldGetSet = 16773888;
        static System.Reflection.BindingFlags ClassicBindingMask = 61696;
        static int GenericParameterCountAny = -1;
        static /*0x0*/ System.RuntimeType ValueType;
        static /*0x8*/ System.RuntimeType EnumType;
        static /*0x10*/ System.RuntimeType ObjectType;
        static /*0x18*/ System.RuntimeType StringType;
        static /*0x20*/ System.RuntimeType DelegateType;
        static /*0x28*/ System.Type[] s_SICtorParamTypes;
        static /*0x30*/ System.Func<System.Type, System.Type[], System.Type> MakeTypeBuilderInstantiation;
        static /*0x38*/ System.RuntimeType s_typedRef;
        /*0x18*/ System.MonoTypeInfo type_info;
        /*0x20*/ object GenericCache;
        /*0x28*/ System.Reflection.RuntimeConstructorInfo m_serializationCtor;

        static /*0x32e51f4*/ RuntimeType();
        static /*0x32dc17c*/ System.RuntimeType GetType(string typeName, bool throwOnError, bool ignoreCase, bool reflectionOnly, ref System.Threading.StackCrawlMark stackMark);
        static /*0x32dc1e4*/ void ThrowIfTypeNeverValidGenericArgument(System.RuntimeType type);
        static /*0x32dc308*/ void SanityCheckGenericArguments(System.RuntimeType[] genericArguments, System.RuntimeType[] genericParamters);
        static /*0x32dc50c*/ void SplitName(string fullname, ref string name, ref string ns);
        static /*0x32dc63c*/ System.Reflection.BindingFlags FilterPreCalculate(bool isPublic, bool isInherited, bool isStatic);
        static /*0x32dc678*/ void FilterHelper(System.Reflection.BindingFlags bindingFlags, ref string name, bool allowPrefixLookup, ref bool prefixLookup, ref bool ignoreCase, ref System.RuntimeType.MemberListType listType);
        static /*0x32dc7b0*/ void FilterHelper(System.Reflection.BindingFlags bindingFlags, ref string name, ref bool ignoreCase, ref System.RuntimeType.MemberListType listType);
        static /*0x32dc83c*/ bool FilterApplyPrefixLookup(System.Reflection.MemberInfo memberInfo, string name, bool ignoreCase);
        static /*0x32dc8a8*/ bool FilterApplyBase(System.Reflection.MemberInfo memberInfo, System.Reflection.BindingFlags bindingFlags, bool isPublic, bool isNonProtectedInternal, bool isStatic, string name, bool prefixLookup);
        static /*0x32dca98*/ bool FilterApplyType(System.Type type, System.Reflection.BindingFlags bindingFlags, string name, bool prefixLookup, string ns);
        static /*0x32dcbb0*/ bool FilterApplyMethodInfo(System.Reflection.RuntimeMethodInfo method, System.Reflection.BindingFlags bindingFlags, System.Reflection.CallingConventions callConv, System.Type[] argumentTypes);
        static /*0x32dce24*/ bool FilterApplyConstructorInfo(System.Reflection.RuntimeConstructorInfo constructor, System.Reflection.BindingFlags bindingFlags, System.Reflection.CallingConventions callConv, System.Type[] argumentTypes);
        static /*0x32dcc30*/ bool FilterApplyMethodBase(System.Reflection.MethodBase methodBase, System.Reflection.BindingFlags methodFlags, System.Reflection.BindingFlags bindingFlags, System.Reflection.CallingConventions callConv, System.Type[] argumentTypes);
        static /*0x32cd48c*/ bool op_Equality(System.RuntimeType left, System.RuntimeType right);
        static /*0x32cfda4*/ bool op_Inequality(System.RuntimeType left, System.RuntimeType right);
        static /*0x32e3d24*/ object IsConvertibleToPrimitiveType(object value, System.Type targetType);
        static /*0x32e4474*/ System.Type MakePointerType(System.Type type);
        static /*0x32e4758*/ object CreateInstanceForAnotherGenericParameter(System.Type genericType, System.RuntimeType genericArgument);
        static /*0x32e177c*/ System.Type MakeGenericType(System.Type gt, System.Type[] types);
        static /*0x32e4884*/ void GetGUID(System.Type type, byte[] guid);
        static /*0x32e4934*/ System.Type GetTypeFromCLSIDImpl(System.Guid clsid, string server, bool throwOnError);
        static /*0x32e49d4*/ System.TypeCode GetTypeCodeImplInternal(System.Type type);
        static /*0x32e39c8*/ object CreateInstanceInternal(System.Type type);
        /*0x32dcea4*/ RuntimeType();
        /*0x32dcee4*/ System.RuntimeType.ListBuilder<System.Reflection.MethodInfo> GetMethodCandidates(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.CallingConventions callConv, System.Type[] types, int genericParamCount, bool allowPrefixLookup);
        /*0x32dd420*/ System.RuntimeType.ListBuilder<System.Reflection.ConstructorInfo> GetConstructorCandidates(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.CallingConventions callConv, System.Type[] types, bool allowPrefixLookup);
        /*0x32dd8d4*/ System.RuntimeType.ListBuilder<System.Reflection.PropertyInfo> GetPropertyCandidates(string name, System.Reflection.BindingFlags bindingAttr, System.Type[] types, bool allowPrefixLookup);
        /*0x32dddbc*/ System.RuntimeType.ListBuilder<System.Reflection.EventInfo> GetEventCandidates(string name, System.Reflection.BindingFlags bindingAttr, bool allowPrefixLookup);
        /*0x32de1f0*/ System.RuntimeType.ListBuilder<System.Reflection.FieldInfo> GetFieldCandidates(string name, System.Reflection.BindingFlags bindingAttr, bool allowPrefixLookup);
        /*0x32de6a4*/ System.RuntimeType.ListBuilder<System.Type> GetNestedTypeCandidates(string fullname, System.Reflection.BindingFlags bindingAttr, bool allowPrefixLookup);
        /*0x32debd0*/ System.Reflection.MethodInfo[] GetMethods(System.Reflection.BindingFlags bindingAttr);
        /*0x32dec5c*/ System.Reflection.ConstructorInfo[] GetConstructors(System.Reflection.BindingFlags bindingAttr);
        /*0x32decf0*/ System.Reflection.PropertyInfo[] GetProperties(System.Reflection.BindingFlags bindingAttr);
        /*0x32ded74*/ System.Reflection.FieldInfo[] GetFields(System.Reflection.BindingFlags bindingAttr);
        /*0x32dedf4*/ System.Reflection.MemberInfo[] GetMembers(System.Reflection.BindingFlags bindingAttr);
        /*0x32df0d8*/ System.Reflection.ConstructorInfo GetConstructorImpl(System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        /*0x32df2f0*/ System.Reflection.PropertyInfo GetPropertyImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        /*0x32df580*/ System.Reflection.EventInfo GetEvent(string name, System.Reflection.BindingFlags bindingAttr);
        /*0x32df748*/ System.Reflection.FieldInfo GetField(string name, System.Reflection.BindingFlags bindingAttr);
        /*0x32dfa34*/ System.Type GetNestedType(string fullname, System.Reflection.BindingFlags bindingAttr);
        /*0x32dfc1c*/ System.Reflection.MemberInfo[] GetMember(string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);
        /*0x32e0090*/ System.Reflection.Module get_Module();
        /*0x32e0098*/ System.Reflection.RuntimeModule GetRuntimeModule();
        /*0x32e00a0*/ System.Reflection.Assembly get_Assembly();
        /*0x32e00a8*/ System.Reflection.RuntimeAssembly GetRuntimeAssembly();
        /*0x32e00b0*/ System.RuntimeTypeHandle get_TypeHandle();
        /*0x32e00d0*/ bool IsInstanceOfType(object o);
        /*0x32e00d8*/ bool IsAssignableFrom(System.Reflection.TypeInfo typeInfo);
        /*0x32e0164*/ bool IsAssignableFrom(System.Type c);
        /*0x32e023c*/ bool IsEquivalentTo(System.Type other);
        /*0x32e02e8*/ System.Type get_BaseType();
        /*0x32e02ec*/ System.RuntimeType GetBaseType();
        /*0x32e04cc*/ System.Type get_UnderlyingSystemType();
        /*0x32e04d0*/ System.Reflection.TypeAttributes GetAttributeFlagsImpl();
        /*0x32e04d8*/ bool IsContextfulImpl();
        /*0x32e04e0*/ bool IsByRefImpl();
        /*0x32e04e8*/ bool IsPrimitiveImpl();
        /*0x32e04f0*/ bool IsPointerImpl();
        /*0x32e04f8*/ bool IsCOMObjectImpl();
        /*0x32e0504*/ bool IsValueTypeImpl();
        /*0x32e05d4*/ bool get_IsEnum();
        /*0x32e0648*/ bool HasElementTypeImpl();
        /*0x32e0650*/ System.Reflection.GenericParameterAttributes get_GenericParameterAttributes();
        /*0x32e0714*/ bool get_IsSzArray();
        /*0x32e071c*/ bool IsArrayImpl();
        /*0x32e0724*/ int GetArrayRank();
        /*0x32e07a8*/ System.Type GetElementType();
        /*0x32e07b0*/ string[] GetEnumNames();
        /*0x32e08c0*/ System.Array GetEnumValues();
        /*0x32e0a10*/ System.Type GetEnumUnderlyingType();
        /*0x32e0abc*/ bool IsEnumDefined(object value);
        /*0x32e0fac*/ string GetEnumName(object value);
        /*0x32e1180*/ System.RuntimeType[] GetGenericArgumentsInternal();
        /*0x32e11f4*/ System.Type[] GetGenericArguments();
        /*0x32e129c*/ System.Type MakeGenericType(System.Type[] instantiation);
        /*0x32e1780*/ bool get_IsGenericTypeDefinition();
        /*0x32e1788*/ bool get_IsGenericParameter();
        /*0x32e1790*/ int get_GenericParameterPosition();
        /*0x32e1814*/ System.Type GetGenericTypeDefinition();
        /*0x32e1898*/ bool get_IsGenericType();
        /*0x32e18a0*/ bool get_IsConstructedGenericType();
        /*0x32e18e8*/ object InvokeMember(string name, System.Reflection.BindingFlags bindingFlags, System.Reflection.Binder binder, object target, object[] providedArgs, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParams);
        /*0x32e2ab8*/ bool Equals(object obj);
        /*0x32e2ac4*/ object Clone();
        /*0x32e2ac8*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x32e2b2c*/ object[] GetCustomAttributes(bool inherit);
        /*0x32e2bcc*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
        /*0x32e2d60*/ bool IsDefined(System.Type attributeType, bool inherit);
        /*0x32e2ef4*/ string FormatTypeName(bool serialization);
        /*0x32e30ac*/ System.Reflection.MemberTypes get_MemberType();
        /*0x32e30f0*/ System.Type get_ReflectedType();
        /*0x32e30fc*/ int get_MetadataToken();
        /*0x32e3104*/ void CreateInstanceCheckThis();
        /*0x32cd498*/ object CreateInstanceImpl(System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, ref System.Threading.StackCrawlMark stackMark);
        /*0x32cdf5c*/ object CreateInstanceDefaultCtor(bool publicOnly, bool skipCheckThis, bool fillCache, bool wrapExceptions, ref System.Threading.StackCrawlMark stackMark);
        /*0x32e3334*/ System.Reflection.RuntimeConstructorInfo GetDefaultConstructor();
        /*0x32e29e0*/ string GetDefaultMemberName();
        /*0x32e34d8*/ System.Reflection.RuntimeConstructorInfo GetSerializationCtor();
        /*0x32e32f8*/ object CreateInstanceSlow(bool publicOnly, bool wrapExceptions, bool skipCheckThis, bool fillCache);
        /*0x32e3708*/ object CreateInstanceMono(bool nonPublic, bool wrapExceptions);
        /*0x32e39cc*/ object CheckValue(object value, System.Reflection.Binder binder, System.Globalization.CultureInfo culture, System.Reflection.BindingFlags invokeAttr);
        /*0x32e3b10*/ object TryConvertToType(object value, ref bool failed);
        /*0x32e3060*/ string GetCachedName(System.TypeNameKind kind);
        /*0x32e43b4*/ System.Type make_array_type(int rank);
        /*0x32e43b8*/ System.Type MakeArrayType();
        /*0x32e43c0*/ System.Type MakeArrayType(int rank);
        /*0x32e4408*/ System.Type make_byref_type();
        /*0x32e440c*/ System.Type MakeByRefType();
        /*0x32e4478*/ System.Type MakePointerType();
        /*0x32e455c*/ bool get_ContainsGenericParameters();
        /*0x32e4664*/ System.Type[] GetGenericParameterConstraints();
        /*0x32e4878*/ nint GetMethodsByName_native(nint namePtr, System.Reflection.BindingFlags bindingAttr, System.RuntimeType.MemberListType listType);
        /*0x32dd13c*/ System.Reflection.RuntimeMethodInfo[] GetMethodsByName(string name, System.Reflection.BindingFlags bindingAttr, System.RuntimeType.MemberListType listType, System.RuntimeType reflectedType);
        /*0x32e487c*/ nint GetPropertiesByName_native(nint name, System.Reflection.BindingFlags bindingAttr, System.RuntimeType.MemberListType listType);
        /*0x32e4880*/ nint GetConstructors_native(System.Reflection.BindingFlags bindingAttr);
        /*0x32dd69c*/ System.Reflection.RuntimeConstructorInfo[] GetConstructors_internal(System.Reflection.BindingFlags bindingAttr, System.RuntimeType reflectedType);
        /*0x32ddad8*/ System.Reflection.RuntimePropertyInfo[] GetPropertiesByName(string name, System.Reflection.BindingFlags bindingAttr, System.RuntimeType.MemberListType listType, System.RuntimeType reflectedType);
        /*0x32e4888*/ System.Guid get_GUID();
        /*0x32e4980*/ System.TypeCode GetTypeCodeImpl();
        /*0x32e49d8*/ string ToString();
        /*0x32e32f0*/ bool IsGenericCOMObjectImpl();
        /*0x32e49e8*/ System.Reflection.MethodBase get_DeclaringMethod();
        /*0x32e49e4*/ string getFullName(bool full_name, bool assembly_qualified);
        /*0x32e11f0*/ System.Type[] GetGenericArgumentsInternal(bool runtimeArray);
        /*0x32e06d0*/ System.Reflection.GenericParameterAttributes GetGenericParameterAttributes();
        /*0x32e1810*/ int GetGenericParameterPosition();
        /*0x32e49ec*/ nint GetEvents_native(nint name, System.RuntimeType.MemberListType listType);
        /*0x32e49f0*/ nint GetFields_native(nint name, System.Reflection.BindingFlags bindingAttr, System.RuntimeType.MemberListType listType);
        /*0x32de3c0*/ System.Reflection.RuntimeFieldInfo[] GetFields_internal(string name, System.Reflection.BindingFlags bindingAttr, System.RuntimeType.MemberListType listType, System.RuntimeType reflectedType);
        /*0x32ddf88*/ System.Reflection.RuntimeEventInfo[] GetEvents_internal(string name, System.Reflection.BindingFlags bindingAttr, System.RuntimeType.MemberListType listType, System.RuntimeType reflectedType);
        /*0x32e49f4*/ System.Type[] GetInterfaces();
        /*0x32e49f8*/ nint GetNestedTypes_native(nint name, System.Reflection.BindingFlags bindingAttr, System.RuntimeType.MemberListType listType);
        /*0x32de858*/ System.RuntimeType[] GetNestedTypes_internal(string displayName, System.Reflection.BindingFlags bindingAttr, System.RuntimeType.MemberListType listType);
        /*0x32e49fc*/ string get_AssemblyQualifiedName();
        /*0x32e4a08*/ System.Type get_DeclaringType();
        /*0x32e4a0c*/ string get_Name();
        /*0x32e4a10*/ string get_Namespace();
        /*0x32e4a14*/ int GetHashCode();
        /*0x32e4abc*/ string get_FullName();
        /*0x32e4bac*/ bool get_IsSZArray();
        /*0x32e4c04*/ bool IsSubclassOf(System.Type type);
        /*0x32e4cf8*/ System.Reflection.MethodInfo GetMethodImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConv, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        /*0x32e4d28*/ System.Reflection.MethodInfo GetMethodImplCommon(string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConv, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        /*0x32e4fe8*/ System.RuntimeType.ListBuilder<System.Reflection.MethodInfo> GetMethodCandidates(string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.CallingConventions callConv, System.Type[] types, bool allowPrefixLookup);

        enum MemberListType
        {
            All = 0,
            CaseSensitive = 1,
            CaseInsensitive = 2,
            HandleToInfo = 3,
        }

        struct ListBuilder<T>
        {
            /*0x0*/ T[] _items;
            /*0x0*/ T _item;
            /*0x0*/ int _count;
            /*0x0*/ int _capacity;

            /*0x1f30b78*/ ListBuilder(int capacity);
            /*0x1ffc854*/ T get_Item(int index);
            /*0x1f30214*/ T[] ToArray();
            /*0x1f30ee8*/ void CopyTo(object[] array, int index);
            /*0x1f2ffc8*/ int get_Count();
            /*0x1ffc854*/ void Add(T item);
        }
    }

    class ReflectionOnlyType : System.RuntimeType
    {
        /*0x32e5590*/ ReflectionOnlyType();
        /*0x32e55e8*/ System.RuntimeTypeHandle get_TypeHandle();
    }

    class SharedStatics
    {
        static /*0x0*/ System.SharedStatics _sharedStatics;
        /*0x10*/ System.Security.Util.Tokenizer.StringMaker _maker;

        static /*0x32e5930*/ SharedStatics();
        static /*0x32e5644*/ System.Security.Util.Tokenizer.StringMaker GetSharedStringMaker();
        static /*0x32e57f0*/ void ReleaseSharedStringMaker(ref System.Security.Util.Tokenizer.StringMaker maker);
        /*0x32e563c*/ SharedStatics();
    }

    enum ExceptionArgument
    {
        obj = 0,
        dictionary = 1,
        dictionaryCreationThreshold = 2,
        array = 3,
        info = 4,
        key = 5,
        collection = 6,
        list = 7,
        match = 8,
        converter = 9,
        queue = 10,
        stack = 11,
        capacity = 12,
        index = 13,
        startIndex = 14,
        value = 15,
        count = 16,
        arrayIndex = 17,
        name = 18,
        mode = 19,
        item = 20,
        options = 21,
        view = 22,
        sourceBytesToCopy = 23,
        start = 24,
        pointer = 25,
        ownedMemory = 26,
        text = 27,
        length = 28,
        comparer = 29,
        comparable = 30,
        exceptions = 31,
        exception = 32,
        action = 33,
        comparison = 34,
        startSegment = 35,
        endSegment = 36,
        endIndex = 37,
        task = 38,
        source = 39,
        state = 40,
        culture = 41,
        destination = 42,
        byteOffset = 43,
        minimumBufferSize = 44,
        offset = 45,
        values = 46,
        comparisonType = 47,
        s = 48,
        input = 49,
        format = 50,
    }

    enum ExceptionResource
    {
        Argument_ImplementIComparable = 0,
        Argument_InvalidType = 1,
        Argument_InvalidArgumentForComparison = 2,
        Argument_InvalidRegistryKeyPermissionCheck = 3,
        ArgumentOutOfRange_NeedNonNegNum = 4,
        Arg_ArrayPlusOffTooSmall = 5,
        Arg_NonZeroLowerBound = 6,
        Arg_RankMultiDimNotSupported = 7,
        Arg_RegKeyDelHive = 8,
        Arg_RegKeyStrLenBug = 9,
        Arg_RegSetStrArrNull = 10,
        Arg_RegSetMismatchedKind = 11,
        Arg_RegSubKeyAbsent = 12,
        Arg_RegSubKeyValueAbsent = 13,
        Argument_AddingDuplicate = 14,
        Serialization_InvalidOnDeser = 15,
        Serialization_MissingKeys = 16,
        Serialization_NullKey = 17,
        Argument_InvalidArrayType = 18,
        NotSupported_KeyCollectionSet = 19,
        NotSupported_ValueCollectionSet = 20,
        ArgumentOutOfRange_SmallCapacity = 21,
        ArgumentOutOfRange_Index = 22,
        Argument_InvalidOffLen = 23,
        Argument_ItemNotExist = 24,
        ArgumentOutOfRange_Count = 25,
        ArgumentOutOfRange_InvalidThreshold = 26,
        ArgumentOutOfRange_ListInsert = 27,
        NotSupported_ReadOnlyCollection = 28,
        InvalidOperation_CannotRemoveFromStackOrQueue = 29,
        InvalidOperation_EmptyQueue = 30,
        InvalidOperation_EnumOpCantHappen = 31,
        InvalidOperation_EnumFailedVersion = 32,
        InvalidOperation_EmptyStack = 33,
        ArgumentOutOfRange_BiggerThanCollection = 34,
        InvalidOperation_EnumNotStarted = 35,
        InvalidOperation_EnumEnded = 36,
        NotSupported_SortedListNestedWrite = 37,
        InvalidOperation_NoValue = 38,
        InvalidOperation_RegRemoveSubKey = 39,
        Security_RegistryPermission = 40,
        UnauthorizedAccess_RegistryNoWrite = 41,
        ObjectDisposed_RegKeyClosed = 42,
        NotSupported_InComparableType = 43,
        Argument_InvalidRegistryOptionsCheck = 44,
        Argument_InvalidRegistryViewCheck = 45,
        TaskT_TransitionToFinal_AlreadyCompleted = 46,
        TaskCompletionSourceT_TrySetException_NullException = 47,
        TaskCompletionSourceT_TrySetException_NoExceptions = 48,
        NotSupported_StringComparison = 49,
        InvalidOperation_NullArray = 50,
    }

    struct TypedReference
    {
        /*0x10*/ System.RuntimeTypeHandle type;
        /*0x18*/ nint Value;
        /*0x20*/ nint Type;

        static /*0x32e598c*/ System.TypedReference MakeTypedReference(object target, System.Reflection.FieldInfo[] flds);
        static /*0x32e5db8*/ void InternalMakeTypedReference(void* result, object target, nint[] flds, System.RuntimeType lastFieldType);
        static /*0x32e5e88*/ void SetTypedReference(System.TypedReference target, object value);
        /*0x32e5dbc*/ int GetHashCode();
        /*0x32e5e18*/ bool Equals(object o);
        /*0x32e5e68*/ bool get_IsNull();
    }

    class TypeLoadException : System.SystemException, System.Runtime.Serialization.ISerializable
    {
        /*0x90*/ string ClassName;
        /*0x98*/ string AssemblyName;
        /*0xa0*/ string MessageArg;
        /*0xa8*/ int ResourceId;

        /*0x32e5ed4*/ TypeLoadException();
        /*0x32e5f34*/ TypeLoadException(string message);
        /*0x32e60a0*/ TypeLoadException(string className, string assemblyName);
        /*0x32e60ac*/ TypeLoadException(string className, string assemblyName, string messageArg, int resourceId);
        /*0x32e6134*/ TypeLoadException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x32e5f5c*/ string get_Message();
        /*0x32e5f74*/ void SetMessageField();
        /*0x32e629c*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class UnitySerializationHolder : System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IObjectReference
    {
        /*0x10*/ System.Type[] m_instantiation;
        /*0x18*/ int[] m_elementTypes;
        /*0x20*/ int m_genericParameterPosition;
        /*0x28*/ System.Type m_declaringType;
        /*0x30*/ System.Reflection.MethodBase m_declaringMethod;
        /*0x38*/ string m_data;
        /*0x40*/ string m_assemblyName;
        /*0x48*/ int m_unityType;

        static /*0x32e644c*/ System.RuntimeType AddElementTypes(System.Runtime.Serialization.SerializationInfo info, System.RuntimeType type);
        static /*0x32e67c4*/ void GetUnitySerializationInfo(System.Runtime.Serialization.SerializationInfo info, int unityType);
        static /*0x32e68e8*/ void GetUnitySerializationInfo(System.Runtime.Serialization.SerializationInfo info, System.RuntimeType type);
        static /*0x32e6c48*/ void GetUnitySerializationInfo(System.Runtime.Serialization.SerializationInfo info, int unityType, string data, System.Reflection.RuntimeAssembly assembly);
        /*0x32e6da4*/ UnitySerializationHolder(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x32e66d4*/ System.Type MakeElementTypes(System.Type type);
        /*0x32e7248*/ void ThrowInsufficientInformation(string field);
        /*0x32e734c*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x32e739c*/ object GetRealObject(System.Runtime.Serialization.StreamingContext context);
    }

    class AppContextDefaultValues
    {
        static /*0x0*/ string SwitchEnforceJapaneseEraYearRanges;
        static /*0x8*/ string SwitchFormatJapaneseFirstYearAsANumber;
        static /*0x10*/ string SwitchEnforceLegacyJapaneseDateParsing;

        static /*0x32e78d8*/ AppContextDefaultValues();
        static /*0x32e78c8*/ void PopulateDefaultValues();
        static /*0x32e78cc*/ bool TryGetSwitchOverride(string switchName, ref bool overrideValue);
    }

    class AppDomain : System.MarshalByRefObject
    {
        static /*0x0*/ string _process_guid;
        [ThreadStatic] static System.Collections.Generic.Dictionary<string, object> type_resolve_in_progress;
        [ThreadStatic] static System.Collections.Generic.Dictionary<string, object> assembly_resolve_in_progress;
        [ThreadStatic] static System.Collections.Generic.Dictionary<string, object> assembly_resolve_in_progress_refonly;
        /*0x18*/ nint _mono_app_domain;
        /*0x20*/ object _evidence;
        /*0x28*/ object _granted;
        /*0x30*/ int _principalPolicy;
        /*0x38*/ System.AssemblyLoadEventHandler AssemblyLoad;
        /*0x40*/ System.ResolveEventHandler AssemblyResolve;
        /*0x48*/ System.EventHandler DomainUnload;
        /*0x50*/ System.EventHandler ProcessExit;
        /*0x58*/ System.ResolveEventHandler ResourceResolve;
        /*0x60*/ System.ResolveEventHandler TypeResolve;
        /*0x68*/ System.UnhandledExceptionEventHandler UnhandledException;
        /*0x70*/ System.EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs> FirstChanceException;
        /*0x78*/ object _domain_manager;
        /*0x80*/ System.ResolveEventHandler ReflectionOnlyAssemblyResolve;
        /*0x88*/ object _activation;
        /*0x90*/ object _applicationIdentity;
        /*0x98*/ System.Collections.Generic.List<string> compatibility_switch;

        static /*0x32e7998*/ bool IsAppXModel();
        static /*0x32e79ac*/ System.AppDomain getCurDomain();
        static /*0x32e79b0*/ System.AppDomain get_CurrentDomain();
        static /*0x32e7af4*/ System.AppDomain InternalSetDomainByID(int domain_id);
        static /*0x32e7af8*/ System.AppDomain InternalSetDomain(System.AppDomain context);
        static /*0x32e7afc*/ void InternalPushDomainRefByID(int domain_id);
        static /*0x32e7b00*/ void InternalPopDomainRef();
        static /*0x32e7b04*/ System.Runtime.Remoting.Contexts.Context InternalSetContext(System.Runtime.Remoting.Contexts.Context context);
        static /*0x32e7b08*/ System.Runtime.Remoting.Contexts.Context InternalGetContext();
        static /*0x32e7b0c*/ System.Runtime.Remoting.Contexts.Context InternalGetDefaultContext();
        static /*0x32e7b10*/ string InternalGetProcessGuid(string newguid);
        static /*0x32e7b14*/ object InvokeInDomainByID(int domain_id, System.Reflection.MethodInfo method, object obj, object[] args);
        static /*0x32e7ca8*/ string GetProcessGuid();
        static /*0x32e7d40*/ bool InternalIsFinalizingForUnload(int domain_id);
        /*0x32e79a0*/ AppDomain();
        /*0x32e79a8*/ string getFriendlyName();
        /*0x32e79b4*/ System.Reflection.Assembly[] GetAssemblies(bool refOnly);
        /*0x32e79b8*/ System.Reflection.Assembly[] GetAssemblies();
        /*0x32e79c0*/ object GetData(string name);
        /*0x32e79c4*/ object InitializeLifetimeService();
        /*0x32e79cc*/ System.Reflection.Assembly LoadAssembly(string assemblyRef, System.Security.Policy.Evidence securityEvidence, bool refOnly, ref System.Threading.StackCrawlMark stackMark);
        /*0x32e79d0*/ System.Reflection.Assembly Load(string assemblyString);
        /*0x32e79f4*/ System.Reflection.Assembly Load(string assemblyString, System.Security.Policy.Evidence assemblySecurity, bool refonly, ref System.Threading.StackCrawlMark stackMark);
        /*0x32e7d44*/ bool IsFinalizingForUnload();
        /*0x32e7d58*/ int getDomainID();
        /*0x32e7d60*/ string ToString();
        /*0x32e7d64*/ void DoAssemblyLoad(System.Reflection.Assembly assembly);
        /*0x32e7df4*/ System.Reflection.Assembly DoAssemblyResolve(string name, System.Reflection.Assembly requestingAssembly, bool refonly);
        /*0x32e8154*/ System.Reflection.Assembly DoTypeResolve(string name);
        /*0x32e8448*/ System.Reflection.Assembly DoResourceResolve(string name, System.Reflection.Assembly requesting);
        /*0x32e8584*/ void DoDomainUnload();
        /*0x32e85a8*/ byte[] GetMarshalledDomainObjRef();
        /*0x32e8674*/ void ProcessMessageInDomain(byte[] arrRequest, System.Runtime.Remoting.Messaging.CADMethodCallMessage cadMsg, ref byte[] arrResponse, ref System.Runtime.Remoting.Messaging.CADMethodReturnMessage cadMrm);
        /*0x32e87b0*/ void add_DomainUnload(System.EventHandler value);
        /*0x32e899c*/ void remove_DomainUnload(System.EventHandler value);
        /*0x32e8b84*/ void add_UnhandledException(System.UnhandledExceptionEventHandler value);
        /*0x32e8c1c*/ void remove_UnhandledException(System.UnhandledExceptionEventHandler value);
        /*0x32e8cb4*/ bool get_IsHomogenous();
        /*0x32e8cbc*/ bool get_IsFullyTrusted();
    }

    class CompatibilitySwitches
    {
        static /*0x0*/ bool IsAppEarlierThanWindowsPhone8;
    }

    class Environment
    {
        static string mono_corlib_version = "1A5E0066-58DC-428A-B21C-0AD6CDAE2789";
        static /*0x0*/ string nl;
        static /*0x8*/ System.OperatingSystem os;

        static /*0x32e5638*/ string GetResourceString(string key);
        static /*0x32e72dc*/ string GetResourceString(string key, object[] values);
        static /*0x32e8cc4*/ string GetResourceStringEncodingName(int codePage);
        static /*0x32e8e3c*/ string get_CurrentDirectory();
        static /*0x32e8e44*/ int get_CurrentManagedThreadId();
        static /*0x32e8e64*/ bool get_HasShutdownStarted();
        static /*0x32e8e68*/ string get_MachineName();
        static /*0x32e8e6c*/ string GetNewLine();
        static /*0x32e8e70*/ string get_NewLine();
        static /*0x32e8ee8*/ System.PlatformID get_Platform();
        static /*0x32e8eec*/ string GetOSVersionString();
        static /*0x32e8ef0*/ System.OperatingSystem get_OSVersion();
        static /*0x32e8fb4*/ System.Version CreateVersionFromString(string info);
        static /*0x32e91b0*/ string get_StackTrace();
        static /*0x32e921c*/ int get_TickCount();
        static /*0x32e9220*/ string get_UserDomainName();
        static /*0x32e9224*/ string get_UserName();
        static /*0x32e9228*/ void Exit(int exitCode);
        static /*0x32e922c*/ string[] GetCommandLineArgs();
        static /*0x32e9230*/ string internalGetEnvironmentVariable_native(nint variable);
        static /*0x32e9234*/ string internalGetEnvironmentVariable(string variable);
        static /*0x32e92f0*/ string GetEnvironmentVariable(string variable);
        static /*0x32e92f4*/ System.Collections.IDictionary GetEnvironmentVariables();
        static /*0x32e93c4*/ string GetFolderPath(System.Environment.SpecialFolder folder);
        static /*0x32e9400*/ string GetWindowsFolderPath(int folder);
        static /*0x32e93cc*/ string GetFolderPath(System.Environment.SpecialFolder folder, System.Environment.SpecialFolderOption option);
        static /*0x32e98d4*/ string ReadXdgUserDir(string config_dir, string home_dir, string key, string fallback);
        static /*0x32e941c*/ string UnixGetFolderPath(System.Environment.SpecialFolder folder, System.Environment.SpecialFolderOption option);
        static /*0x32e9d40*/ void FailFast(string message, System.Exception exception);
        static /*0x32e9d48*/ void FailFast(string message, System.Exception exception, string errorSource);
        static /*0x32e9d4c*/ int get_ProcessorCount();
        static /*0x32e9404*/ bool get_IsRunningOnWindows();
        static /*0x32e93c0*/ string[] GetEnvironmentVariableNames();
        static /*0x32e9d50*/ string GetMachineConfigPath();
        static /*0x32e9d3c*/ string internalGetHome();
        static /*0x32e9d54*/ int GetPageSize();
        static /*0x32e9d58*/ bool get_IsUnix();
        static /*0x32e9d80*/ string GetStackTrace(System.Exception e, bool needFileInfo);

        enum SpecialFolder
        {
            MyDocuments = 5,
            Desktop = 0,
            MyComputer = 17,
            Programs = 2,
            Personal = 5,
            Favorites = 6,
            Startup = 7,
            Recent = 8,
            SendTo = 9,
            StartMenu = 11,
            MyMusic = 13,
            DesktopDirectory = 16,
            Templates = 21,
            ApplicationData = 26,
            LocalApplicationData = 28,
            InternetCache = 32,
            Cookies = 33,
            History = 34,
            CommonApplicationData = 35,
            System = 37,
            ProgramFiles = 38,
            MyPictures = 39,
            CommonProgramFiles = 43,
            MyVideos = 14,
            NetworkShortcuts = 19,
            Fonts = 20,
            CommonStartMenu = 22,
            CommonPrograms = 23,
            CommonStartup = 24,
            CommonDesktopDirectory = 25,
            PrinterShortcuts = 27,
            Windows = 36,
            UserProfile = 40,
            SystemX86 = 41,
            ProgramFilesX86 = 42,
            CommonProgramFilesX86 = 44,
            CommonTemplates = 45,
            CommonDocuments = 46,
            CommonAdminTools = 47,
            AdminTools = 48,
            CommonMusic = 53,
            CommonPictures = 54,
            CommonVideos = 55,
            Resources = 56,
            LocalizedResources = 57,
            CommonOemLinks = 58,
            CDBurning = 59,
        }

        enum SpecialFolderOption
        {
            None = 0,
            DoNotVerify = 16384,
            Create = 32768,
        }
    }

    class MonoTypeInfo
    {
        /*0x10*/ string full_name;
        /*0x18*/ System.Reflection.RuntimeConstructorInfo default_ctor;

        /*0x32e9e18*/ MonoTypeInfo();
    }

    class TypeNameParser
    {
        static /*0x32e9e1c*/ System.Type GetType(string typeName, System.Func<System.Reflection.AssemblyName, System.Reflection.Assembly> assemblyResolver, System.Func<System.Reflection.Assembly, string, bool, System.Type> typeResolver, bool throwOnError, bool ignoreCase, ref System.Threading.StackCrawlMark stackMark);
    }

    class AppDomainSetup
    {
        /*0x10*/ string application_base;
        /*0x18*/ string application_name;
        /*0x20*/ string cache_path;
        /*0x28*/ string configuration_file;
        /*0x30*/ string dynamic_base;
        /*0x38*/ string license_file;
        /*0x40*/ string private_bin_path;
        /*0x48*/ string private_bin_path_probe;
        /*0x50*/ string shadow_copy_directories;
        /*0x58*/ string shadow_copy_files;
        /*0x60*/ bool publisher_policy;
        /*0x61*/ bool path_changed;
        /*0x64*/ int loader_optimization;
        /*0x68*/ bool disallow_binding_redirects;
        /*0x69*/ bool disallow_code_downloads;
        /*0x70*/ object _activationArguments;
        /*0x78*/ object domain_initializer;
        /*0x80*/ object application_trust;
        /*0x88*/ string[] domain_initializer_args;
        /*0x90*/ bool disallow_appbase_probe;
        /*0x98*/ byte[] configuration_bytes;
        /*0xa0*/ byte[] serialized_non_primitives;
        /*0xa8*/ string manager_assembly;
        /*0xb0*/ string manager_type;
        /*0xb8*/ string[] partial_visible_assemblies;
        /*0xc0*/ string <TargetFrameworkName>k__BackingField;

        /*0x32ea9b0*/ AppDomainSetup();
    }

    struct ArgIterator
    {
        /*0x10*/ nint sig;
        /*0x18*/ nint args;
        /*0x20*/ int next_arg;
        /*0x24*/ int num_args;

        /*0x32ea9b4*/ bool Equals(object o);
        /*0x32eaa00*/ int GetHashCode();
    }

    class Console
    {
        static /*0x0*/ System.IO.TextWriter stdout;
        static /*0x8*/ System.IO.TextWriter stderr;
        static /*0x10*/ System.IO.TextReader stdin;
        static /*0x18*/ bool IsRunningOnAndroid;
        static /*0x20*/ System.Text.Encoding inputEncoding;
        static /*0x28*/ System.Text.Encoding outputEncoding;
        static /*0x30*/ System.ConsoleCancelEventHandler cancel_event;

        static /*0x32eaa10*/ Console();
        static /*0x32ead58*/ void SetupStreams(System.Text.Encoding inputEncoding, System.Text.Encoding outputEncoding);
        static /*0x32eb434*/ System.IO.Stream Open(nint handle, System.IO.FileAccess access, int bufferSize);
        static /*0x32eb3a4*/ System.IO.Stream OpenStandardError(int bufferSize);
        static /*0x32eb284*/ System.IO.Stream OpenStandardInput(int bufferSize);
        static /*0x32eb314*/ System.IO.Stream OpenStandardOutput(int bufferSize);
        static /*0x32eb584*/ void SetError(System.IO.TextWriter newError);
        static /*0x32eb668*/ void SetOut(System.IO.TextWriter newOut);
        static /*0x32eb754*/ void WriteLine(string value);
        static /*0x32eb7c8*/ System.Text.Encoding get_InputEncoding();
        static /*0x32eb820*/ System.Text.Encoding get_OutputEncoding();
        static /*0x32eb878*/ System.ConsoleKeyInfo ReadKey();
        static /*0x32eb8d0*/ System.ConsoleKeyInfo ReadKey(bool intercept);
        static /*0x32eba04*/ void DoConsoleCancelEvent();

        class WindowsConsole
        {
            static /*0x0*/ bool ctrlHandlerAdded;
            static /*0x8*/ System.Console.WindowsConsole.WindowsCancelHandler cancelHandler;

            static /*0x32ebd24*/ WindowsConsole();
            static /*0x32ebbf8*/ int GetConsoleCP();
            static /*0x32ebc5c*/ int GetConsoleOutputCP();
            static /*0x32ebcc4*/ bool DoWindowsConsoleCancelEvent(int keyCode);
            static /*0x32eacc0*/ int GetInputCodePage();
            static /*0x32ead0c*/ int GetOutputCodePage();

            class WindowsCancelHandler : System.MulticastDelegate
            {
                /*0x32ebdc4*/ WindowsCancelHandler(object object, nint method);
                /*0x32ebe64*/ bool Invoke(int keyCode);
            }
        }
    }

    class ConsoleDriver
    {
        static /*0x0*/ System.IConsoleDriver driver;
        static /*0x8*/ bool is_console;
        static /*0x9*/ bool called_isatty;

        static /*0x32ebe78*/ ConsoleDriver();
        static /*0x32ebf48*/ System.IConsoleDriver CreateNullConsoleDriver();
        static /*0x32ebf88*/ System.IConsoleDriver CreateWindowsConsoleDriver();
        static /*0x32ebfdc*/ System.IConsoleDriver CreateTermInfoDriver(string term);
        static /*0x32eb92c*/ System.ConsoleKeyInfo ReadKey(bool intercept);
        static /*0x32eb144*/ bool get_IsConsole();
        static /*0x32ec3d8*/ bool Isatty(nint handle);
        static /*0x32ec3dc*/ int InternalKeyAvailable(int ms_timeout);
        static /*0x32ec3e0*/ bool TtySetup(string keypadXmit, string teardown, ref byte[] control_characters, ref int* address);
        static /*0x32ec3e4*/ bool SetEcho(bool wantEcho);
    }

    class DelegateData
    {
        /*0x10*/ System.Type target_type;
        /*0x18*/ string method_name;
        /*0x20*/ bool curried_first_arg;

        /*0x32ec3e8*/ DelegateData();
    }

    class Delegate : System.ICloneable, System.Runtime.Serialization.ISerializable
    {
        /*0x10*/ nint method_ptr;
        /*0x18*/ nint invoke_impl;
        /*0x20*/ object m_target;
        /*0x28*/ nint method;
        /*0x30*/ nint delegate_trampoline;
        /*0x38*/ nint extra_arg;
        /*0x40*/ nint method_code;
        /*0x48*/ nint interp_method;
        /*0x50*/ nint interp_invoke_impl;
        /*0x58*/ System.Reflection.MethodInfo method_info;
        /*0x60*/ System.Reflection.MethodInfo original_method_info;
        /*0x68*/ System.DelegateData data;
        /*0x70*/ bool method_is_virtual;

        static /*0x32ec404*/ System.Delegate CreateDelegate_internal(System.Type type, object target, System.Reflection.MethodInfo info, bool throwOnBindFailure);
        static /*0x32ec408*/ bool arg_type_match(System.Type delArgType, System.Type argType);
        static /*0x32ec568*/ bool arg_type_match_this(System.Type delArgType, System.Type argType, bool boxedThis);
        static /*0x32ec6a4*/ bool return_type_match(System.Type delReturnType, System.Type returnType);
        static /*0x32ec87c*/ System.Delegate CreateDelegate(System.Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure, bool allowClosed);
        static /*0x32ed0ec*/ System.Delegate CreateDelegate(System.Type type, object firstArgument, System.Reflection.MethodInfo method);
        static /*0x32ed0f8*/ System.Delegate CreateDelegate(System.Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);
        static /*0x32ed10c*/ System.Delegate CreateDelegate(System.Type type, System.Reflection.MethodInfo method);
        static /*0x32ed120*/ System.Delegate CreateDelegate(System.Type type, object target, string method);
        static /*0x32ed134*/ System.Reflection.MethodInfo GetCandidateMethod(System.Type type, System.Type target, string method, System.Reflection.BindingFlags bflags, bool ignoreCase, bool throwOnBindFailure);
        static /*0x32ed584*/ System.Delegate CreateDelegate(System.Type type, System.Type target, string method, bool ignoreCase, bool throwOnBindFailure);
        static /*0x32ed680*/ System.Delegate CreateDelegate(System.Type type, System.Type target, string method);
        static /*0x32ed68c*/ System.Delegate CreateDelegate(System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);
        static /*0x32ed12c*/ System.Delegate CreateDelegate(System.Type type, object target, string method, bool ignoreCase);
        static /*0x32e8848*/ System.Delegate Combine(System.Delegate a, System.Delegate b);
        static /*0x32ee168*/ System.Delegate Combine(System.Delegate[] delegates);
        static /*0x32e8a34*/ System.Delegate Remove(System.Delegate source, System.Delegate value);
        static /*0x32ee244*/ bool op_Equality(System.Delegate d1, System.Delegate d2);
        static /*0x32ee26c*/ bool op_Inequality(System.Delegate d1, System.Delegate d2);
        static /*0x32ee2a8*/ System.MulticastDelegate AllocDelegateLike_internal(System.Delegate d);
        /*0x32ec3ec*/ System.Reflection.MethodInfo get_Method();
        /*0x32ec3f8*/ System.Reflection.MethodInfo GetVirtualMethod_internal();
        /*0x32ec3fc*/ object get_Target();
        /*0x32ed764*/ object DynamicInvoke(object[] args);
        /*0x32ed770*/ void InitializeDelegateData();
        /*0x32ed864*/ object DynamicInvokeImpl(object[] args);
        /*0x32edb68*/ object Clone();
        /*0x32edb70*/ bool Equals(object obj);
        /*0x32edd0c*/ int GetHashCode();
        /*0x32edd84*/ System.Reflection.MethodInfo GetMethodImpl();
        /*0x32ede7c*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x32ee0cc*/ System.Delegate[] GetInvocationList();
        /*0x32ee1cc*/ System.Delegate CombineImpl(System.Delegate d);
        /*0x32ee220*/ System.Delegate RemoveImpl(System.Delegate d);
    }

    class DelegateSerializationHolder : System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IObjectReference
    {
        /*0x10*/ System.Delegate _delegate;

        static /*0x32ede80*/ void GetDelegateData(System.Delegate instance, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext ctx);
        /*0x32ee2ac*/ DelegateSerializationHolder(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext ctx);
        /*0x32ee878*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x32ee8b0*/ object GetRealObject(System.Runtime.Serialization.StreamingContext context);

        class DelegateEntry
        {
            /*0x10*/ string type;
            /*0x18*/ string assembly;
            /*0x20*/ object target;
            /*0x28*/ string targetTypeAssembly;
            /*0x30*/ string targetTypeName;
            /*0x38*/ string methodName;
            /*0x40*/ System.DelegateSerializationHolder.DelegateEntry delegateEntry;

            /*0x32ee714*/ DelegateEntry(System.Delegate del, string targetLabel);
            /*0x32ee4c4*/ System.Delegate DeserializeDelegate(System.Runtime.Serialization.SerializationInfo info, int index);
        }
    }

    class EmptyArray<T>
    {
        static /*0x0*/ T[] Value;

        static /*0x1f33998*/ EmptyArray();
    }

    enum SByteEnum
    {
    }

    enum Int16Enum
    {
    }

    enum Int32Enum
    {
    }

    enum Int64Enum
    {
    }

    enum ByteEnum
    {
    }

    enum UInt16Enum
    {
    }

    enum UInt32Enum
    {
    }

    enum UInt64Enum
    {
    }

    interface IConsoleDriver
    {
        System.ConsoleKeyInfo ReadKey(bool intercept);
    }

    struct IntPtr : System.Runtime.Serialization.ISerializable, System.IEquatable<nint>
    {
        static /*0x0*/ nint Zero;
        /*0x10*/ void* m_value;

        static /*0x32ee934*/ int get_Size();
        static /*0x32eea84*/ bool op_Equality(nint value1, nint value2);
        static /*0x32eea90*/ bool op_Inequality(nint value1, nint value2);
        static /*0x32eea9c*/ nint op_Explicit(int value);
        static /*0x32eeaa4*/ nint op_Explicit(long value);
        static /*0x32eeaa8*/ nint op_Explicit(void* value);
        static /*0x32eeaac*/ int op_Explicit(nint value);
        static /*0x32eeab0*/ long op_Explicit(nint value);
        static /*0x32eeab4*/ void* op_Explicit(nint value);
        static /*0x32eeab8*/ nint Add(nint pointer, int offset);
        static /*0x32eeac0*/ nint op_Addition(nint pointer, int offset);
        static /*0x32eeac8*/ nint op_Subtraction(nint pointer, int offset);
        /*0x32ee8b8*/ IntPtr(int value);
        /*0x32ee8c4*/ IntPtr(long value);
        /*0x32ee8cc*/ IntPtr(void* value);
        /*0x32ee8d4*/ IntPtr(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x32ee93c*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x32ee9e4*/ bool Equals(object obj);
        /*0x32eaa08*/ int GetHashCode();
        /*0x32eea30*/ int ToInt32();
        /*0x32ee9dc*/ long ToInt64();
        /*0x32eea38*/ void* ToPointer();
        /*0x32eea40*/ string ToString();
        /*0x32eea64*/ string ToString(string format);
        /*0x32eead0*/ bool IsNull();
        /*0x32eeae0*/ bool System.IEquatable<System.IntPtr>.Equals(nint other);
    }

    class KnownTerminals
    {
        static /*0x32eeaf0*/ byte[] get_linux();
        static /*0x32eeb60*/ byte[] get_xterm();
        static /*0x32eebd0*/ byte[] get_ansi();
    }

    class MarshalByRefObject
    {
        /*0x10*/ object _identity;

        /*0x32e79a4*/ MarshalByRefObject();
        /*0x32eec40*/ System.Runtime.Remoting.ServerIdentity get_ObjectIdentity();
        /*0x32eec78*/ void set_ObjectIdentity(System.Runtime.Remoting.ServerIdentity value);
        /*0x32eecb0*/ System.Runtime.Remoting.ObjRef CreateObjRef(System.Type requestedType);
        /*0x32eece8*/ object InitializeLifetimeService();
    }

    class MonoAsyncCall
    {
        /*0x10*/ object msg;
        /*0x18*/ nint cb_method;
        /*0x20*/ object cb_target;
        /*0x28*/ object state;
        /*0x30*/ object res;
        /*0x38*/ object out_args;

        /*0x32eed20*/ MonoAsyncCall();
    }

    class MonoCustomAttrs
    {
        static /*0x0*/ System.Reflection.Assembly corlib;
        static /*0x8*/ System.AttributeUsageAttribute DefaultAttributeUsage;
        [ThreadStatic] static System.Collections.Generic.Dictionary<System.Type, System.AttributeUsageAttribute> usage_cache;

        static /*0x32f28e4*/ MonoCustomAttrs();
        static /*0x32eed24*/ bool IsUserCattrProvider(object obj);
        static /*0x32eeee0*/ System.Attribute[] GetCustomAttributesInternal(System.Reflection.ICustomAttributeProvider obj, System.Type attributeType, bool pseudoAttrs);
        static /*0x32eeee4*/ object[] GetPseudoCustomAttributes(System.Reflection.ICustomAttributeProvider obj, System.Type attributeType);
        static /*0x32ef1e0*/ object[] GetPseudoCustomAttributes(System.Type type);
        static /*0x32ef354*/ object[] GetCustomAttributesBase(System.Reflection.ICustomAttributeProvider obj, System.Type attributeType, bool inheritedOnly);
        static /*0x32ef4f8*/ object[] GetCustomAttributes(System.Reflection.ICustomAttributeProvider obj, System.Type attributeType, bool inherit);
        static /*0x32f0358*/ object[] GetCustomAttributes(System.Reflection.ICustomAttributeProvider obj, bool inherit);
        static /*0x32f04c8*/ System.Reflection.CustomAttributeData[] GetCustomAttributesDataInternal(System.Reflection.ICustomAttributeProvider obj);
        static /*0x32f04cc*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributesData(System.Reflection.ICustomAttributeProvider obj, bool inherit);
        static /*0x32f07b4*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributesData(System.Reflection.ICustomAttributeProvider obj, System.Type attributeType, bool inherit);
        static /*0x32f05f0*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributesDataBase(System.Reflection.ICustomAttributeProvider obj, System.Type attributeType, bool inheritedOnly);
        static /*0x32f19d8*/ System.Reflection.CustomAttributeData[] GetPseudoCustomAttributesData(System.Reflection.ICustomAttributeProvider obj, System.Type attributeType);
        static /*0x32f1cd8*/ System.Reflection.CustomAttributeData[] GetPseudoCustomAttributesData(System.Type type);
        static /*0x32f1f0c*/ bool IsDefined(System.Reflection.ICustomAttributeProvider obj, System.Type attributeType, bool inherit);
        static /*0x32f2194*/ bool IsDefinedInternal(System.Reflection.ICustomAttributeProvider obj, System.Type AttributeType);
        static /*0x32f2198*/ System.Reflection.PropertyInfo GetBasePropertyDefinition(System.Reflection.RuntimePropertyInfo property);
        static /*0x32f2494*/ System.Reflection.EventInfo GetBaseEventDefinition(System.Reflection.RuntimeEventInfo evt);
        static /*0x32efe48*/ System.Reflection.ICustomAttributeProvider GetBase(System.Reflection.ICustomAttributeProvider obj);
        static /*0x32f26a4*/ System.AttributeUsageAttribute RetrieveAttributeUsageNoCache(System.Type attributeType);
        static /*0x32f01b4*/ System.AttributeUsageAttribute RetrieveAttributeUsage(System.Type attributeType);

        class AttributeInfo
        {
            /*0x10*/ System.AttributeUsageAttribute _usage;
            /*0x18*/ int _inheritanceLevel;

            /*0x32f032c*/ AttributeInfo(System.AttributeUsageAttribute usage, int inheritanceLevel);
            /*0x32f295c*/ System.AttributeUsageAttribute get_Usage();
            /*0x32f2964*/ int get_InheritanceLevel();
        }
    }

    class MonoListItem
    {
        /*0x10*/ System.MonoListItem next;
        /*0x18*/ object data;

        /*0x32f296c*/ MonoListItem();
    }

    class MonoType : System.RuntimeType
    {
    }

    class MulticastDelegate : System.Delegate
    {
        /*0x78*/ System.Delegate[] delegates;

        /*0x32f2970*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x32f2974*/ object DynamicInvokeImpl(object[] args);
        /*0x32f2a0c*/ bool Equals(object obj);
        /*0x32f2b30*/ int GetHashCode();
        /*0x32f2b34*/ System.Reflection.MethodInfo GetMethodImpl();
        /*0x32f2b7c*/ System.Delegate[] GetInvocationList();
        /*0x32f2c54*/ System.Delegate CombineImpl(System.Delegate follow);
        /*0x32f2f24*/ int LastIndexOf(System.Delegate[] haystack, System.Delegate[] needle);
        /*0x32f3050*/ System.Delegate RemoveImpl(System.Delegate value);
    }

    class NullConsoleDriver : System.IConsoleDriver
    {
        static /*0x0*/ System.ConsoleKeyInfo EmptyConsoleKeyInfo;

        static /*0x32f33a8*/ NullConsoleDriver();
        /*0x32ec034*/ NullConsoleDriver();
        /*0x32f334c*/ System.ConsoleKeyInfo ReadKey(bool intercept);
    }

    class Object
    {
        static /*0x32f3438*/ bool Equals(object objA, object objB);
        static /*0x32f3490*/ bool ReferenceEquals(object objA, object objB);
        static /*0x32f346c*/ int InternalGetHashCode(object o);
        /*0x32e5640*/ Object();
        /*0x32f342c*/ bool Equals(object obj);
        /*0x32f3464*/ void Finalize();
        /*0x32f3468*/ int GetHashCode();
        /*0x32e5db4*/ System.Type GetType();
        /*0x32edb6c*/ object MemberwiseClone();
        /*0x32f3470*/ string ToString();
        /*0x32f349c*/ void FieldGetter(string typeName, string fieldName, ref object val);
        /*0x32f34a0*/ void FieldSetter(string typeName, string fieldName, object val);
    }

    enum PlatformID
    {
        Win32S = 0,
        Win32Windows = 1,
        Win32NT = 2,
        WinCE = 3,
        Unix = 4,
        Xbox = 5,
        MacOSX = 6,
    }

    struct RuntimeArgumentHandle
    {
        /*0x10*/ nint args;
    }

    struct RuntimeFieldHandle : System.Runtime.Serialization.ISerializable
    {
        /*0x10*/ nint value;

        static /*0x32f38ac*/ void SetValueInternal(System.Reflection.FieldInfo fi, object obj, object value);
        static /*0x32f38b0*/ void SetValue(System.Reflection.RuntimeFieldInfo field, object obj, object value, System.RuntimeType fieldType, System.Reflection.FieldAttributes fieldAttr, System.RuntimeType declaringType, ref bool domainInitialized);
        static /*0x32f38b4*/ void SetValueDirect(System.Reflection.RuntimeFieldInfo field, System.RuntimeType fieldType, void* pTypedRef, object value, System.RuntimeType contextType);
        /*0x32f34a4*/ RuntimeFieldHandle(nint v);
        /*0x32f34ac*/ RuntimeFieldHandle(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x32f3628*/ nint get_Value();
        /*0x32f3630*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x32f37b4*/ bool Equals(object obj);
        /*0x32f38a4*/ int GetHashCode();
    }

    struct RuntimeMethodHandle : System.Runtime.Serialization.ISerializable
    {
        /*0x10*/ nint value;

        static /*0x32f3cc0*/ string ConstructInstantiation(System.Reflection.RuntimeMethodInfo method, System.TypeNameFormatFlags format);
        /*0x32f38b8*/ RuntimeMethodHandle(nint v);
        /*0x32f38c0*/ RuntimeMethodHandle(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x32f3a3c*/ nint get_Value();
        /*0x32f3a44*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x32f3bc8*/ bool Equals(object obj);
        /*0x32f3cb8*/ int GetHashCode();
        /*0x32f3e18*/ bool IsNullHandle();
    }

    struct RuntimeTypeHandle : System.Runtime.Serialization.ISerializable
    {
        /*0x10*/ nint value;

        static /*0x32f4244*/ System.Reflection.TypeAttributes GetAttributes(System.RuntimeType type);
        static /*0x32f4248*/ int GetMetadataToken(System.RuntimeType type);
        static /*0x32f424c*/ int GetToken(System.RuntimeType type);
        static /*0x32f4250*/ System.Type GetGenericTypeDefinition_impl(System.RuntimeType type);
        static /*0x32f4254*/ System.Type GetGenericTypeDefinition(System.RuntimeType type);
        static /*0x32f4258*/ bool IsPrimitive(System.RuntimeType type);
        static /*0x32f4284*/ bool IsByRef(System.RuntimeType type);
        static /*0x32f42a0*/ bool IsPointer(System.RuntimeType type);
        static /*0x32f42bc*/ bool IsArray(System.RuntimeType type);
        static /*0x32f42dc*/ bool IsSzArray(System.RuntimeType type);
        static /*0x32f42f8*/ bool HasElementType(System.RuntimeType type);
        static /*0x32f4280*/ System.Reflection.CorElementType GetCorElementType(System.RuntimeType type);
        static /*0x32f4334*/ bool HasInstantiation(System.RuntimeType type);
        static /*0x32f4338*/ bool IsComObject(System.RuntimeType type);
        static /*0x32f433c*/ bool IsInstanceOfType(System.RuntimeType type, object o);
        static /*0x32f4340*/ bool HasReferences(System.RuntimeType type);
        static /*0x32f4344*/ bool IsComObject(System.RuntimeType type, bool isGenericCOM);
        static /*0x32f4354*/ bool IsContextful(System.RuntimeType type);
        static /*0x32f43d4*/ bool IsEquivalentTo(System.RuntimeType rtType1, System.RuntimeType rtType2);
        static /*0x32f43dc*/ bool IsInterface(System.RuntimeType type);
        static /*0x32f43fc*/ int GetArrayRank(System.RuntimeType type);
        static /*0x32f4400*/ System.Reflection.RuntimeAssembly GetAssembly(System.RuntimeType type);
        static /*0x32f4404*/ System.RuntimeType GetElementType(System.RuntimeType type);
        static /*0x32f4408*/ System.Reflection.RuntimeModule GetModule(System.RuntimeType type);
        static /*0x32f440c*/ bool IsGenericVariable(System.RuntimeType type);
        static /*0x32f4410*/ System.RuntimeType GetBaseType(System.RuntimeType type);
        static /*0x32f4414*/ bool CanCastTo(System.RuntimeType type, System.RuntimeType target);
        static /*0x32f4424*/ bool type_is_assignable_from(System.Type a, System.Type b);
        static /*0x32f4428*/ bool IsGenericTypeDefinition(System.RuntimeType type);
        static /*0x32f442c*/ nint GetGenericParameterInfo(System.RuntimeType type);
        static /*0x32f4430*/ bool IsSubclassOf(System.RuntimeType childType, System.RuntimeType baseType);
        static /*0x32f4450*/ bool is_subclass_of(nint childType, nint baseType);
        static /*0x32f4454*/ System.RuntimeType internal_from_name(string name, ref System.Threading.StackCrawlMark stackMark, System.Reflection.Assembly callerAssembly, bool throwOnError, bool ignoreCase, bool reflectionOnly);
        static /*0x32f4458*/ System.RuntimeType GetTypeByName(string typeName, bool throwOnError, bool ignoreCase, bool reflectionOnly, ref System.Threading.StackCrawlMark stackMark, bool loadTypeFromPartialName);
        /*0x32f3e28*/ RuntimeTypeHandle(nint val);
        /*0x32f3e30*/ RuntimeTypeHandle(System.RuntimeType type);
        /*0x32f3e48*/ RuntimeTypeHandle(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x32f3fc4*/ nint get_Value();
        /*0x32f3fcc*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x32f414c*/ bool Equals(object obj);
        /*0x32f423c*/ int GetHashCode();
    }

    class TermInfoDriver : System.IConsoleDriver
    {
        static /*0x0*/ int* native_terminal_size;
        static /*0x8*/ int terminal_size;
        static /*0x10*/ string[] locations;
        static /*0x18*/ int[] _consoleColorToAnsiCode;
        /*0x10*/ System.TermInfoReader reader;
        /*0x18*/ int cursorLeft;
        /*0x1c*/ int cursorTop;
        /*0x20*/ string title;
        /*0x28*/ string titleFormat;
        /*0x30*/ bool cursorVisible;
        /*0x38*/ string csrVisible;
        /*0x40*/ string csrInvisible;
        /*0x48*/ string clear;
        /*0x50*/ string bell;
        /*0x58*/ string term;
        /*0x60*/ System.IO.StreamReader stdin;
        /*0x68*/ System.IO.CStreamWriter stdout;
        /*0x70*/ int windowWidth;
        /*0x74*/ int windowHeight;
        /*0x78*/ int bufferHeight;
        /*0x7c*/ int bufferWidth;
        /*0x80*/ char[] buffer;
        /*0x88*/ int readpos;
        /*0x8c*/ int writepos;
        /*0x90*/ string keypadXmit;
        /*0x98*/ string keypadLocal;
        /*0xa0*/ bool inited;
        /*0xa8*/ object initLock;
        /*0xb0*/ bool initKeys;
        /*0xb8*/ string origPair;
        /*0xc0*/ string origColors;
        /*0xc8*/ string cursorAddress;
        /*0xd0*/ System.ConsoleColor fgcolor;
        /*0xd8*/ string setfgcolor;
        /*0xe0*/ string setbgcolor;
        /*0xe8*/ int maxColors;
        /*0xec*/ bool noGetPosition;
        /*0xf0*/ System.Collections.Hashtable keymap;
        /*0xf8*/ System.ByteMatcher rootmap;
        /*0x100*/ int rl_startx;
        /*0x104*/ int rl_starty;
        /*0x108*/ byte[] control_characters;
        /*0x110*/ char[] echobuf;
        /*0x118*/ int echon;

        static /*0x32f95d8*/ TermInfoDriver();
        static /*0x32f47a0*/ string TryTermInfoDir(string dir, string term);
        static /*0x32f48b8*/ string SearchTerminfo(string term);
        /*0x32ec038*/ TermInfoDriver(string term);
        /*0x32f4a20*/ void WriteConsole(string str);
        /*0x32f4d50*/ bool get_Initialized();
        /*0x32f4d58*/ void Init();
        /*0x32f5920*/ void IncrementX();
        /*0x32f59e4*/ void WriteSpecialKey(System.ConsoleKeyInfo key);
        /*0x32f5cf0*/ void WriteSpecialKey(char c);
        /*0x32f5ea4*/ bool IsSpecialKey(System.ConsoleKeyInfo key);
        /*0x32f5f30*/ bool IsSpecialKey(char c);
        /*0x32f5690*/ void GetCursorPosition();
        /*0x32f6054*/ void CheckWindowDimensions();
        /*0x32f59b8*/ int get_WindowHeight();
        /*0x32f598c*/ int get_WindowWidth();
        /*0x32f5f5c*/ void AddToBuffer(int b);
        /*0x32f6174*/ void AdjustBuffer();
        /*0x32f5d1c*/ System.ConsoleKeyInfo CreateKeyInfoFromInt(int n, bool alt);
        /*0x32f6188*/ object GetKeyFromBuffer(bool cooked);
        /*0x32f68f0*/ System.ConsoleKeyInfo ReadKeyInternal(ref bool fresh);
        /*0x32f6c28*/ bool InputPending();
        /*0x32f6c54*/ void QueueEcho(char c);
        /*0x32f6d34*/ void Echo(System.ConsoleKeyInfo key);
        /*0x32f6d88*/ void EchoFlush();
        /*0x32f6dbc*/ int Read(char[] dest, int index, int count);
        /*0x32f70e8*/ System.ConsoleKeyInfo ReadKey(bool intercept);
        /*0x32f714c*/ string ReadLine();
        /*0x32f733c*/ string ReadToEnd();
        /*0x32f7154*/ string ReadUntilConditionInternal(bool haltOnNewLine);
        /*0x32f5af4*/ void SetCursorPosition(int left, int top);
        /*0x32f74d8*/ void CreateKeyMap();
        /*0x32f6ab0*/ void InitKeys();
        /*0x32f9404*/ void AddStringMapping(System.TermInfoStrings s);
    }

    class ParameterizedStrings
    {
        [ThreadStatic] static System.ParameterizedStrings.LowLevelStack _cachedStack;

        static /*0x32f7374*/ string Evaluate(string format, System.ParameterizedStrings.FormatParam[] args);
        static /*0x32f97fc*/ string EvaluateInternal(string format, ref int pos, System.ParameterizedStrings.FormatParam[] args, System.ParameterizedStrings.LowLevelStack stack, ref System.ParameterizedStrings.FormatParam[] dynamicVars, ref System.ParameterizedStrings.FormatParam[] staticVars);
        static /*0x32fa5d8*/ bool AsBool(int i);
        static /*0x32fa5d0*/ int AsInt(bool b);
        static /*0x32fa5e4*/ string StringFromAsciiBytes(byte[] buffer, int offset, int length);
        static /*0x32fa6d8*/ int snprintf(byte* str, nint size, string format, string arg1);
        static /*0x32fa7a4*/ int snprintf(byte* str, nint size, string format, int arg1);
        static /*0x32fa1c4*/ string FormatPrintF(string format, object arg);
        static /*0x32fa4b4*/ System.ParameterizedStrings.FormatParam[] GetDynamicOrStaticVariables(char c, ref System.ParameterizedStrings.FormatParam[] dynamicVars, ref System.ParameterizedStrings.FormatParam[] staticVars, ref int index);

        struct FormatParam
        {
            /*0x10*/ int _int32;
            /*0x18*/ string _string;

            static /*0x32f7344*/ System.ParameterizedStrings.FormatParam op_Implicit(int value);
            /*0x32fa85c*/ FormatParam(int value);
            /*0x32fa86c*/ FormatParam(int intValue, string stringValue);
            /*0x32fa87c*/ int get_Int32();
            /*0x32fa168*/ string get_String();
            /*0x32fa18c*/ object get_Object();
        }

        class LowLevelStack
        {
            /*0x10*/ System.ParameterizedStrings.FormatParam[] _arr;
            /*0x18*/ int _count;

            /*0x32f977c*/ LowLevelStack();
            /*0x32fa0dc*/ System.ParameterizedStrings.FormatParam Pop();
            /*0x32fa3c4*/ void Push(System.ParameterizedStrings.FormatParam item);
            /*0x32f97d4*/ void Clear();
        }
    }

    class ByteMatcher
    {
        /*0x10*/ System.Collections.Hashtable map;
        /*0x18*/ System.Collections.Hashtable starts;

        /*0x32f9380*/ ByteMatcher();
        /*0x32f9450*/ void AddMapping(System.TermInfoStrings key, byte[] val);
        /*0x32f9550*/ void Sort();
        /*0x32f644c*/ bool StartsWith(int c);
        /*0x32f64a4*/ System.TermInfoStrings Match(char[] buffer, int offset, int length, ref int used);
    }

    enum TermInfoNumbers
    {
        Columns = 0,
        InitTabs = 1,
        Lines = 2,
        LinesOfMemory = 3,
        MagicCookieGlitch = 4,
        PaddingBaudRate = 5,
        VirtualTerminal = 6,
        WidthStatusLine = 7,
        NumLabels = 8,
        LabelHeight = 9,
        LabelWidth = 10,
        MaxAttributes = 11,
        MaximumWindows = 12,
        MaxColors = 13,
        MaxPairs = 14,
        NoColorVideo = 15,
        BufferCapacity = 16,
        DotVertSpacing = 17,
        DotHorzSpacing = 18,
        MaxMicroAddress = 19,
        MaxMicroJump = 20,
        MicroColSize = 21,
        MicroLineSize = 22,
        NumberOfPins = 23,
        OutputResChar = 24,
        OutputResLine = 25,
        OutputResHorzInch = 26,
        OutputResVertInch = 27,
        PrintRate = 28,
        WideCharSize = 29,
        Buttons = 30,
        BitImageEntwining = 31,
        BitImageType = 32,
        Last = 33,
    }

    class TermInfoReader
    {
        /*0x10*/ int boolSize;
        /*0x14*/ int numSize;
        /*0x18*/ int strOffsets;
        /*0x20*/ byte[] buffer;
        /*0x28*/ int booleansOffset;
        /*0x2c*/ int intOffset;

        /*0x32f4a40*/ TermInfoReader(string term, string filename);
        /*0x32f4cc0*/ TermInfoReader(string term, byte[] buffer);
        /*0x32fa978*/ void DetermineVersion(short magic);
        /*0x32fa884*/ void ReadHeader(byte[] buffer, ref int position);
        /*0x32fa944*/ void ReadNames(byte[] buffer, ref int position);
        /*0x32f5640*/ int Get(System.TermInfoNumbers number);
        /*0x32f55bc*/ string Get(System.TermInfoStrings tstr);
        /*0x32f9554*/ byte[] GetStringBytes(System.TermInfoStrings tstr);
        /*0x32faa18*/ short GetInt16(byte[] buffer, int offset);
        /*0x32faa64*/ string GetString(byte[] buffer, int offset);
        /*0x32faae0*/ byte[] GetStringBytes(byte[] buffer, int offset);
    }

    enum TermInfoStrings
    {
        BackTab = 0,
        Bell = 1,
        CarriageReturn = 2,
        ChangeScrollRegion = 3,
        ClearAllTabs = 4,
        ClearScreen = 5,
        ClrEol = 6,
        ClrEos = 7,
        ColumnAddress = 8,
        CommandCharacter = 9,
        CursorAddress = 10,
        CursorDown = 11,
        CursorHome = 12,
        CursorInvisible = 13,
        CursorLeft = 14,
        CursorMemAddress = 15,
        CursorNormal = 16,
        CursorRight = 17,
        CursorToLl = 18,
        CursorUp = 19,
        CursorVisible = 20,
        DeleteCharacter = 21,
        DeleteLine = 22,
        DisStatusLine = 23,
        DownHalfLine = 24,
        EnterAltCharsetMode = 25,
        EnterBlinkMode = 26,
        EnterBoldMode = 27,
        EnterCaMode = 28,
        EnterDeleteMode = 29,
        EnterDimMode = 30,
        EnterInsertMode = 31,
        EnterSecureMode = 32,
        EnterProtectedMode = 33,
        EnterReverseMode = 34,
        EnterStandoutMode = 35,
        EnterUnderlineMode = 36,
        EraseChars = 37,
        ExitAltCharsetMode = 38,
        ExitAttributeMode = 39,
        ExitCaMode = 40,
        ExitDeleteMode = 41,
        ExitInsertMode = 42,
        ExitStandoutMode = 43,
        ExitUnderlineMode = 44,
        FlashScreen = 45,
        FormFeed = 46,
        FromStatusLine = 47,
        Init1string = 48,
        Init2string = 49,
        Init3string = 50,
        InitFile = 51,
        InsertCharacter = 52,
        InsertLine = 53,
        InsertPadding = 54,
        KeyBackspace = 55,
        KeyCatab = 56,
        KeyClear = 57,
        KeyCtab = 58,
        KeyDc = 59,
        KeyDl = 60,
        KeyDown = 61,
        KeyEic = 62,
        KeyEol = 63,
        KeyEos = 64,
        KeyF0 = 65,
        KeyF1 = 66,
        KeyF10 = 67,
        KeyF2 = 68,
        KeyF3 = 69,
        KeyF4 = 70,
        KeyF5 = 71,
        KeyF6 = 72,
        KeyF7 = 73,
        KeyF8 = 74,
        KeyF9 = 75,
        KeyHome = 76,
        KeyIc = 77,
        KeyIl = 78,
        KeyLeft = 79,
        KeyLl = 80,
        KeyNpage = 81,
        KeyPpage = 82,
        KeyRight = 83,
        KeySf = 84,
        KeySr = 85,
        KeyStab = 86,
        KeyUp = 87,
        KeypadLocal = 88,
        KeypadXmit = 89,
        LabF0 = 90,
        LabF1 = 91,
        LabF10 = 92,
        LabF2 = 93,
        LabF3 = 94,
        LabF4 = 95,
        LabF5 = 96,
        LabF6 = 97,
        LabF7 = 98,
        LabF8 = 99,
        LabF9 = 100,
        MetaOff = 101,
        MetaOn = 102,
        Newline = 103,
        PadChar = 104,
        ParmDch = 105,
        ParmDeleteLine = 106,
        ParmDownCursor = 107,
        ParmIch = 108,
        ParmIndex = 109,
        ParmInsertLine = 110,
        ParmLeftCursor = 111,
        ParmRightCursor = 112,
        ParmRindex = 113,
        ParmUpCursor = 114,
        PkeyKey = 115,
        PkeyLocal = 116,
        PkeyXmit = 117,
        PrintScreen = 118,
        PrtrOff = 119,
        PrtrOn = 120,
        RepeatChar = 121,
        Reset1string = 122,
        Reset2string = 123,
        Reset3string = 124,
        ResetFile = 125,
        RestoreCursor = 126,
        RowAddress = 127,
        SaveCursor = 128,
        ScrollForward = 129,
        ScrollReverse = 130,
        SetAttributes = 131,
        SetTab = 132,
        SetWindow = 133,
        Tab = 134,
        ToStatusLine = 135,
        UnderlineChar = 136,
        UpHalfLine = 137,
        InitProg = 138,
        KeyA1 = 139,
        KeyA3 = 140,
        KeyB2 = 141,
        KeyC1 = 142,
        KeyC3 = 143,
        PrtrNon = 144,
        CharPadding = 145,
        AcsChars = 146,
        PlabNorm = 147,
        KeyBtab = 148,
        EnterXonMode = 149,
        ExitXonMode = 150,
        EnterAmMode = 151,
        ExitAmMode = 152,
        XonCharacter = 153,
        XoffCharacter = 154,
        EnaAcs = 155,
        LabelOn = 156,
        LabelOff = 157,
        KeyBeg = 158,
        KeyCancel = 159,
        KeyClose = 160,
        KeyCommand = 161,
        KeyCopy = 162,
        KeyCreate = 163,
        KeyEnd = 164,
        KeyEnter = 165,
        KeyExit = 166,
        KeyFind = 167,
        KeyHelp = 168,
        KeyMark = 169,
        KeyMessage = 170,
        KeyMove = 171,
        KeyNext = 172,
        KeyOpen = 173,
        KeyOptions = 174,
        KeyPrevious = 175,
        KeyPrint = 176,
        KeyRedo = 177,
        KeyReference = 178,
        KeyRefresh = 179,
        KeyReplace = 180,
        KeyRestart = 181,
        KeyResume = 182,
        KeySave = 183,
        KeySuspend = 184,
        KeyUndo = 185,
        KeySbeg = 186,
        KeyScancel = 187,
        KeyScommand = 188,
        KeyScopy = 189,
        KeyScreate = 190,
        KeySdc = 191,
        KeySdl = 192,
        KeySelect = 193,
        KeySend = 194,
        KeySeol = 195,
        KeySexit = 196,
        KeySfind = 197,
        KeyShelp = 198,
        KeyShome = 199,
        KeySic = 200,
        KeySleft = 201,
        KeySmessage = 202,
        KeySmove = 203,
        KeySnext = 204,
        KeySoptions = 205,
        KeySprevious = 206,
        KeySprint = 207,
        KeySredo = 208,
        KeySreplace = 209,
        KeySright = 210,
        KeySrsume = 211,
        KeySsave = 212,
        KeySsuspend = 213,
        KeySundo = 214,
        ReqForInput = 215,
        KeyF11 = 216,
        KeyF12 = 217,
        KeyF13 = 218,
        KeyF14 = 219,
        KeyF15 = 220,
        KeyF16 = 221,
        KeyF17 = 222,
        KeyF18 = 223,
        KeyF19 = 224,
        KeyF20 = 225,
        KeyF21 = 226,
        KeyF22 = 227,
        KeyF23 = 228,
        KeyF24 = 229,
        KeyF25 = 230,
        KeyF26 = 231,
        KeyF27 = 232,
        KeyF28 = 233,
        KeyF29 = 234,
        KeyF30 = 235,
        KeyF31 = 236,
        KeyF32 = 237,
        KeyF33 = 238,
        KeyF34 = 239,
        KeyF35 = 240,
        KeyF36 = 241,
        KeyF37 = 242,
        KeyF38 = 243,
        KeyF39 = 244,
        KeyF40 = 245,
        KeyF41 = 246,
        KeyF42 = 247,
        KeyF43 = 248,
        KeyF44 = 249,
        KeyF45 = 250,
        KeyF46 = 251,
        KeyF47 = 252,
        KeyF48 = 253,
        KeyF49 = 254,
        KeyF50 = 255,
        KeyF51 = 256,
        KeyF52 = 257,
        KeyF53 = 258,
        KeyF54 = 259,
        KeyF55 = 260,
        KeyF56 = 261,
        KeyF57 = 262,
        KeyF58 = 263,
        KeyF59 = 264,
        KeyF60 = 265,
        KeyF61 = 266,
        KeyF62 = 267,
        KeyF63 = 268,
        ClrBol = 269,
        ClearMargins = 270,
        SetLeftMargin = 271,
        SetRightMargin = 272,
        LabelFormat = 273,
        SetClock = 274,
        DisplayClock = 275,
        RemoveClock = 276,
        CreateWindow = 277,
        GotoWindow = 278,
        Hangup = 279,
        DialPhone = 280,
        QuickDial = 281,
        Tone = 282,
        Pulse = 283,
        FlashHook = 284,
        FixedPause = 285,
        WaitTone = 286,
        User0 = 287,
        User1 = 288,
        User2 = 289,
        User3 = 290,
        User4 = 291,
        User5 = 292,
        User6 = 293,
        User7 = 294,
        User8 = 295,
        User9 = 296,
        OrigPair = 297,
        OrigColors = 298,
        InitializeColor = 299,
        InitializePair = 300,
        SetColorPair = 301,
        SetForeground = 302,
        SetBackground = 303,
        ChangeCharPitch = 304,
        ChangeLinePitch = 305,
        ChangeResHorz = 306,
        ChangeResVert = 307,
        DefineChar = 308,
        EnterDoublewideMode = 309,
        EnterDraftQuality = 310,
        EnterItalicsMode = 311,
        EnterLeftwardMode = 312,
        EnterMicroMode = 313,
        EnterNearLetterQuality = 314,
        EnterNormalQuality = 315,
        EnterShadowMode = 316,
        EnterSubscriptMode = 317,
        EnterSuperscriptMode = 318,
        EnterUpwardMode = 319,
        ExitDoublewideMode = 320,
        ExitItalicsMode = 321,
        ExitLeftwardMode = 322,
        ExitMicroMode = 323,
        ExitShadowMode = 324,
        ExitSubscriptMode = 325,
        ExitSuperscriptMode = 326,
        ExitUpwardMode = 327,
        MicroColumnAddress = 328,
        MicroDown = 329,
        MicroLeft = 330,
        MicroRight = 331,
        MicroRowAddress = 332,
        MicroUp = 333,
        OrderOfPins = 334,
        ParmDownMicro = 335,
        ParmLeftMicro = 336,
        ParmRightMicro = 337,
        ParmUpMicro = 338,
        SelectCharSet = 339,
        SetBottomMargin = 340,
        SetBottomMarginParm = 341,
        SetLeftMarginParm = 342,
        SetRightMarginParm = 343,
        SetTopMargin = 344,
        SetTopMarginParm = 345,
        StartBitImage = 346,
        StartCharSetDef = 347,
        StopBitImage = 348,
        StopCharSetDef = 349,
        SubscriptCharacters = 350,
        SuperscriptCharacters = 351,
        TheseCauseCr = 352,
        ZeroMotion = 353,
        CharSetNames = 354,
        KeyMouse = 355,
        MouseInfo = 356,
        ReqMousePos = 357,
        GetMouse = 358,
        SetAForeground = 359,
        SetABackground = 360,
        PkeyPlab = 361,
        DeviceType = 362,
        CodeSetInit = 363,
        Set0DesSeq = 364,
        Set1DesSeq = 365,
        Set2DesSeq = 366,
        Set3DesSeq = 367,
        SetLrMargin = 368,
        SetTbMargin = 369,
        BitImageRepeat = 370,
        BitImageNewline = 371,
        BitImageCarriageReturn = 372,
        ColorNames = 373,
        DefineBitImageRegion = 374,
        EndBitImageRegion = 375,
        SetColorBand = 376,
        SetPageLength = 377,
        DisplayPcChar = 378,
        EnterPcCharsetMode = 379,
        ExitPcCharsetMode = 380,
        EnterScancodeMode = 381,
        ExitScancodeMode = 382,
        PcTermOptions = 383,
        ScancodeEscape = 384,
        AltScancodeEsc = 385,
        EnterHorizontalHlMode = 386,
        EnterLeftHlMode = 387,
        EnterLowHlMode = 388,
        EnterRightHlMode = 389,
        EnterTopHlMode = 390,
        EnterVerticalHlMode = 391,
        SetAAttributes = 392,
        SetPglenInch = 393,
        Last = 394,
    }

    interface TypeName : System.IEquatable<System.TypeName>
    {
        /*0x1f30214*/ string get_DisplayName();
    }

    interface TypeIdentifier : System.TypeName, System.IEquatable<System.TypeName>
    {
        /*0x1f30214*/ string get_InternalName();
    }

    class TypeNames
    {
        class ATypeName : System.TypeName, System.IEquatable<System.TypeName>
        {
            /*0x32facf0*/ ATypeName();
            /*0x1f30214*/ string get_DisplayName();
            /*0x32fab98*/ bool Equals(System.TypeName other);
            /*0x32fac68*/ int GetHashCode();
            /*0x32fac90*/ bool Equals(object other);
        }
    }

    class TypeIdentifiers
    {
        static /*0x32facf4*/ System.TypeIdentifier FromDisplay(string displayName);

        class Display : System.TypeNames.ATypeName, System.TypeIdentifier, System.TypeName, System.IEquatable<System.TypeName>
        {
            /*0x10*/ string displayName;
            /*0x18*/ string internal_name;

            /*0x32fad60*/ Display(string displayName);
            /*0x32fad84*/ string get_DisplayName();
            /*0x32fad8c*/ string get_InternalName();
            /*0x32fadcc*/ string GetInternalName();
        }
    }

    interface ModifierSpec
    {
        /*0x1f302cc*/ System.Type Resolve(System.Type type);
        /*0x1f302cc*/ System.Text.StringBuilder Append(System.Text.StringBuilder sb);
    }

    class ArraySpec : System.ModifierSpec
    {
        /*0x10*/ int dimensions;
        /*0x14*/ bool bound;

        /*0x32faec8*/ ArraySpec(int dimensions, bool bound);
        /*0x32faed4*/ System.Type Resolve(System.Type type);
        /*0x32faf4c*/ System.Text.StringBuilder Append(System.Text.StringBuilder sb);
        /*0x32faff0*/ string ToString();
    }

    class PointerSpec : System.ModifierSpec
    {
        /*0x10*/ int pointer_level;

        /*0x32fb060*/ PointerSpec(int pointer_level);
        /*0x32fb068*/ System.Type Resolve(System.Type type);
        /*0x32fb0bc*/ System.Text.StringBuilder Append(System.Text.StringBuilder sb);
        /*0x32fb0dc*/ string ToString();
    }

    class TypeSpec
    {
        /*0x10*/ System.TypeIdentifier name;
        /*0x18*/ string assembly_name;
        /*0x20*/ System.Collections.Generic.List<System.TypeIdentifier> nested;
        /*0x28*/ System.Collections.Generic.List<System.TypeSpec> generic_params;
        /*0x30*/ System.Collections.Generic.List<System.ModifierSpec> modifier_spec;
        /*0x38*/ bool is_byref;
        /*0x40*/ string display_fullname;

        static /*0x32e9e6c*/ System.TypeSpec Parse(string typeName);
        static /*0x32fadd4*/ string UnescapeInternalName(string displayName);
        static /*0x32fc584*/ void SkipSpace(string name, ref int pos);
        static /*0x32fc614*/ void BoundCheck(int idx, string s);
        static /*0x32fc4d4*/ System.TypeIdentifier ParsedTypeIdentifier(string displayName);
        static /*0x32fb8b8*/ System.TypeSpec Parse(string name, ref int p, bool is_recurse, bool allow_aqn);
        /*0x32fc698*/ TypeSpec();
        /*0x32fb14c*/ bool get_HasModifiers();
        /*0x32fb15c*/ string GetDisplayFullName(System.TypeSpec.DisplayNameFormat flags);
        /*0x32fb660*/ System.Text.StringBuilder GetModifierString(System.Text.StringBuilder sb);
        /*0x32fb61c*/ string get_DisplayFullName();
        /*0x32e9f3c*/ System.Type Resolve(System.Func<System.Reflection.AssemblyName, System.Reflection.Assembly> assemblyResolver, System.Func<System.Reflection.Assembly, string, bool, System.Type> typeResolver, bool throwOnError, bool ignoreCase, ref System.Threading.StackCrawlMark stackMark);
        /*0x32fc3e4*/ void AddName(string type_name);
        /*0x32fc4d8*/ void AddModifier(System.ModifierSpec md);

        enum DisplayNameFormat
        {
            Default = 0,
            WANT_ASSEMBLY = 1,
            NO_MODIFIERS = 2,
        }
    }

    struct UIntPtr : System.Runtime.Serialization.ISerializable, System.IEquatable<nuint>
    {
        static /*0x0*/ nuint Zero;
        /*0x10*/ void* _pointer;

        static /*0x32fc810*/ UIntPtr();
        static /*0x32fc7d8*/ bool op_Equality(nuint value1, nuint value2);
        static /*0x32fc7e4*/ bool op_Inequality(nuint value1, nuint value2);
        static /*0x32fc7f0*/ nuint op_Explicit(ulong value);
        static /*0x32fc7f4*/ void* op_Explicit(nuint value);
        static /*0x32fc7f8*/ nuint op_Explicit(uint value);
        static /*0x32fc6a4*/ int get_Size();
        /*0x32fc69c*/ UIntPtr(ulong value);
        /*0x32fc6ac*/ UIntPtr(uint value);
        /*0x32fc6b8*/ UIntPtr(void* value);
        /*0x32fc6c0*/ bool Equals(object obj);
        /*0x32fc70c*/ int GetHashCode();
        /*0x32fc714*/ void* ToPointer();
        /*0x32fc71c*/ string ToString();
        /*0x32fc738*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x32fc800*/ bool System.IEquatable<System.UIntPtr>.Equals(nuint other);
    }

    class ValueType
    {
        static /*0x32fc830*/ bool InternalEquals(object o1, object o2, ref object[] fields);
        static /*0x32fc834*/ bool DefaultEquals(object o1, object o2);
        static /*0x32fc9ec*/ int InternalGetHashCode(object o, ref object[] fields);
        /*0x32fc828*/ ValueType();
        /*0x32fc9e8*/ bool Equals(object obj);
        /*0x32fc9f0*/ int GetHashCode();
        /*0x32fca68*/ string ToString();
    }

    struct Variant
    {
        /*0x10*/ short vt;
        /*0x12*/ ushort wReserved1;
        /*0x14*/ ushort wReserved2;
        /*0x16*/ ushort wReserved3;
        /*0x18*/ long llVal;
        /*0x18*/ int lVal;
        /*0x18*/ byte bVal;
        /*0x18*/ short iVal;
        /*0x18*/ float fltVal;
        /*0x18*/ double dblVal;
        /*0x18*/ short boolVal;
        /*0x18*/ nint bstrVal;
        /*0x18*/ sbyte cVal;
        /*0x18*/ ushort uiVal;
        /*0x18*/ uint ulVal;
        /*0x18*/ ulong ullVal;
        /*0x18*/ int intVal;
        /*0x18*/ uint uintVal;
        /*0x18*/ nint pdispVal;
        /*0x18*/ System.BRECORD bRecord;

        /*0x32fca90*/ void Clear();
    }

    struct BRECORD
    {
        /*0x10*/ nint pvRecord;
        /*0x18*/ nint pRecInfo;
    }

    class WeakReference : System.Runtime.Serialization.ISerializable
    {
        /*0x10*/ bool isLongReference;
        /*0x18*/ System.Runtime.InteropServices.GCHandle gcHandle;

        /*0x32fcb2c*/ WeakReference();
        /*0x32fcb34*/ WeakReference(object target);
        /*0x32fcb70*/ WeakReference(object target, bool trackResurrection);
        /*0x32fcbb0*/ WeakReference(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x32fcb04*/ void AllocateHandle(object target);
        /*0x32fcccc*/ bool get_IsAlive();
        /*0x32fccec*/ object get_Target();
        /*0x32fcd18*/ void set_Target(object value);
        /*0x32fcd74*/ bool get_TrackResurrection();
        /*0x32fcd7c*/ void Finalize();
        /*0x32fce08*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class WeakReference<T> : System.Runtime.Serialization.ISerializable
    {
        /*0x0*/ System.Runtime.InteropServices.GCHandle handle;
        /*0x0*/ bool trackResurrection;

        /*0x1ffc854*/ WeakReference(T target);
        /*0x1ffc854*/ WeakReference(T target, bool trackResurrection);
        WeakReference(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x1ffc854*/ void SetTarget(T target);
        /*0x1f2fec8*/ bool TryGetTarget(ref T target);
        /*0x1f309e4*/ void Finalize();
    }

    struct InputRecord
    {
        /*0x10*/ short EventType;
        /*0x12*/ bool KeyDown;
        /*0x14*/ short RepeatCount;
        /*0x16*/ short VirtualKeyCode;
        /*0x18*/ short VirtualScanCode;
        /*0x1a*/ char Character;
        /*0x1c*/ int ControlKeyState;
        /*0x20*/ int pad1;
        /*0x24*/ bool pad2;
    }

    struct Coord
    {
        /*0x10*/ short X;
        /*0x12*/ short Y;
    }

    struct SmallRect
    {
        /*0x10*/ short Left;
        /*0x12*/ short Top;
        /*0x14*/ short Right;
        /*0x16*/ short Bottom;
    }

    struct ConsoleScreenBufferInfo
    {
        /*0x10*/ System.Coord Size;
        /*0x14*/ System.Coord CursorPosition;
        /*0x18*/ short Attribute;
        /*0x1a*/ System.SmallRect Window;
        /*0x22*/ System.Coord MaxWindowSize;
    }

    enum Handles
    {
        STD_INPUT = -10,
        STD_OUTPUT = -11,
        STD_ERROR = -12,
    }

    class WindowsConsoleDriver : System.IConsoleDriver
    {
        /*0x10*/ nint inputHandle;
        /*0x18*/ nint outputHandle;
        /*0x20*/ short defaultAttribute;

        static /*0x32fd344*/ bool IsModifierKey(short virtualKeyCode);
        static /*0x32fcfe4*/ nint GetStdHandle(System.Handles handle);
        static /*0x32fd068*/ bool GetConsoleScreenBufferInfo(nint handle, ref System.ConsoleScreenBufferInfo info);
        static /*0x32fd23c*/ bool ReadConsoleInput(nint handle, ref System.InputRecord record, int length, ref int nread);
        /*0x32fcf88*/ WindowsConsoleDriver();
        /*0x32fd0fc*/ System.ConsoleKeyInfo ReadKey(bool intercept);
    }

    class __ComObject
    {
        /*0x32fd378*/ __ComObject();
    }

    struct Decimal : System.IFormattable, System.IComparable, System.IConvertible, System.IComparable<decimal>, System.IEquatable<decimal>, System.Runtime.Serialization.IDeserializationCallback, System.ISpanFormattable
    {
        static /*0x0*/ decimal Zero;
        static /*0x10*/ decimal One;
        static /*0x20*/ decimal MinusOne;
        static /*0x30*/ decimal MaxValue;
        static /*0x40*/ decimal MinValue;
        /*0x10*/ int flags;
        /*0x14*/ int hi;
        /*0x18*/ int lo;
        /*0x1c*/ int mid;
        /*0x18*/ ulong ulomidLE;

        static /*0x3302c38*/ Decimal();
        static /*0x32fd420*/ ref System.Decimal.DecCalc AsMutable(ref decimal d);
        static /*0x32fd424*/ uint DecDivMod1E9(ref decimal value);
        static /*0x32fdeb8*/ bool IsValid(int flags);
        static /*0x32fe160*/ decimal Abs(ref decimal d);
        static /*0x32fe174*/ decimal Add(decimal d1, decimal d2);
        static /*0x32fe8e0*/ int Compare(decimal d1, decimal d2);
        static /*0x32fec50*/ decimal Divide(decimal d1, decimal d2);
        static /*0x32ffc38*/ decimal Parse(string s, System.IFormatProvider provider);
        static /*0x32ffd0c*/ decimal Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x32ffdf0*/ bool TryParse(string s, ref decimal result);
        static /*0x32ffec4*/ bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref decimal result);
        static /*0x32fffbc*/ int[] GetBits(decimal d);
        static /*0x3300058*/ ref decimal Max(ref decimal d1, ref decimal d2);
        static /*0x33000c8*/ ref decimal Min(ref decimal d1, ref decimal d2);
        static /*0x3300138*/ decimal Multiply(decimal d1, decimal d2);
        static /*0x33006ec*/ decimal Negate(decimal d);
        static /*0x33006f4*/ decimal Round(decimal d, int decimals);
        static /*0x3300788*/ decimal Round(ref decimal d, int decimals, System.MidpointRounding mode);
        static /*0x3300c3c*/ byte ToByte(decimal value);
        static /*0x3300f3c*/ sbyte ToSByte(decimal value);
        static /*0x330124c*/ short ToInt16(decimal value);
        static /*0x33013c4*/ double ToDouble(decimal d);
        static /*0x33010b4*/ int ToInt32(decimal d);
        static /*0x3301544*/ long ToInt64(decimal d);
        static /*0x33016ec*/ ushort ToUInt16(decimal value);
        static /*0x3300db4*/ uint ToUInt32(decimal d);
        static /*0x3301864*/ ulong ToUInt64(decimal d);
        static /*0x3301a00*/ float ToSingle(decimal d);
        static /*0x3301adc*/ decimal Truncate(decimal d);
        static /*0x3301bdc*/ void Truncate(ref decimal d);
        static /*0x3301c74*/ decimal op_Implicit(byte value);
        static /*0x3301c84*/ decimal op_Implicit(sbyte value);
        static /*0x3301c98*/ decimal op_Implicit(short value);
        static /*0x3301cac*/ decimal op_Implicit(ushort value);
        static /*0x3301cbc*/ decimal op_Implicit(char value);
        static /*0x3301ccc*/ decimal op_Implicit(int value);
        static /*0x3301ce0*/ decimal op_Implicit(uint value);
        static /*0x3301cf0*/ decimal op_Implicit(long value);
        static /*0x3301d04*/ decimal op_Implicit(ulong value);
        static /*0x3301d10*/ decimal op_Explicit(float value);
        static /*0x3301d54*/ decimal op_Explicit(double value);
        static /*0x3301d98*/ int op_Explicit(decimal value);
        static /*0x3301dfc*/ long op_Explicit(decimal value);
        static /*0x3301e60*/ ulong op_Explicit(decimal value);
        static /*0x3301ec4*/ float op_Explicit(decimal value);
        static /*0x3301f28*/ double op_Explicit(decimal value);
        static /*0x3301f8c*/ decimal op_UnaryNegation(decimal d);
        static /*0x3301f94*/ decimal op_Increment(decimal d);
        static /*0x3302004*/ decimal op_Addition(decimal d1, decimal d2);
        static /*0x33020b8*/ decimal op_Subtraction(decimal d1, decimal d2);
        static /*0x330216c*/ decimal op_Multiply(decimal d1, decimal d2);
        static /*0x330221c*/ decimal op_Division(decimal d1, decimal d2);
        static /*0x33022cc*/ bool op_Equality(decimal d1, decimal d2);
        static /*0x330235c*/ bool op_Inequality(decimal d1, decimal d2);
        static /*0x33023ec*/ bool op_LessThan(decimal d1, decimal d2);
        static /*0x3302478*/ bool op_LessThanOrEqual(decimal d1, decimal d2);
        static /*0x3302508*/ bool op_GreaterThan(decimal d1, decimal d2);
        static /*0x3302598*/ bool op_GreaterThanOrEqual(decimal d1, decimal d2);
        /*0x32fd548*/ Decimal(int value);
        /*0x32fd560*/ Decimal(uint value);
        /*0x32fd56c*/ Decimal(long value);
        /*0x32fd58c*/ Decimal(ulong value);
        /*0x32fd594*/ Decimal(float value);
        /*0x32fda20*/ Decimal(double value);
        /*0x32fded4*/ Decimal(int[] bits);
        /*0x32fe00c*/ Decimal(int lo, int mid, int hi, bool isNegative, byte scale);
        /*0x32fe150*/ Decimal(ref decimal d, int flags);
        /*0x32fd3b8*/ uint get_High();
        /*0x32fd3c0*/ uint get_Low();
        /*0x32fd3c8*/ uint get_Mid();
        /*0x32fd3d0*/ bool get_IsNegative();
        /*0x32fd3dc*/ int get_Scale();
        /*0x32fd3e4*/ ulong get_Low64();
        /*0x32fe09c*/ void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
        /*0x32fea90*/ int CompareTo(object value);
        /*0x32febc0*/ int CompareTo(decimal value);
        /*0x32ff550*/ bool Equals(object value);
        /*0x32ff62c*/ bool Equals(decimal value);
        /*0x32ff6c4*/ int GetHashCode();
        /*0x32ff864*/ string ToString();
        /*0x32ff910*/ string ToString(string format);
        /*0x32ff9d8*/ string ToString(System.IFormatProvider provider);
        /*0x32ffa94*/ string ToString(string format, System.IFormatProvider provider);
        /*0x32ffb6c*/ bool TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        /*0x3302628*/ System.TypeCode GetTypeCode();
        /*0x3302630*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x3302690*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x3302714*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x3302774*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x33027d4*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x3302834*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x3302894*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x33028f4*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x3302954*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x33029b4*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x3302a14*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x3302a74*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x3302ad4*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x3302ae0*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x3302b64*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);

        struct DecCalc
        {
            static /*0x0*/ uint[] s_powers10;
            static /*0x8*/ ulong[] s_ulongPowers10;
            static /*0x10*/ double[] s_doublePowers10;
            static /*0x18*/ System.Decimal.DecCalc.PowerOvfl[] PowerOvflValues;
            /*0x10*/ uint uflags;
            /*0x14*/ uint uhi;
            /*0x18*/ uint ulo;
            /*0x1c*/ uint umid;
            /*0x18*/ ulong ulomidLE;

            static /*0x33046d0*/ DecCalc();
            static /*0x3302d10*/ uint GetExponent(float f);
            static /*0x3302d1c*/ uint GetExponent(double d);
            static /*0x3302d28*/ ulong UInt32x32To64(uint a, uint b);
            static /*0x3302d30*/ void UInt64x64To128(ulong a, ulong b, ref System.Decimal.DecCalc result);
            static /*0x3302e58*/ uint Div96By32(ref System.Decimal.DecCalc.Buf12 bufNum, uint den);
            static /*0x3302ed8*/ bool Div96ByConst(ref ulong high64, ref uint low, uint pow);
            static /*0x3302f14*/ void Unscale(ref uint low, ref ulong high64, ref int scale);
            static /*0x33031a0*/ uint Div96By64(ref System.Decimal.DecCalc.Buf12 bufNum, ulong den);
            static /*0x330329c*/ uint Div128By96(ref System.Decimal.DecCalc.Buf16 bufNum, ref System.Decimal.DecCalc.Buf12 bufDen);
            static /*0x33033c4*/ uint IncreaseScale(ref System.Decimal.DecCalc.Buf12 bufNum, uint power);
            static /*0x330344c*/ void IncreaseScale64(ref System.Decimal.DecCalc.Buf12 bufNum, uint power);
            static /*0x33034c4*/ int ScaleResult(System.Decimal.DecCalc.Buf24* bufRes, uint hiRes, int scale);
            static /*0x33040e8*/ uint DivByConst(uint* result, uint hiRes, ref uint quotient, ref uint remainder, uint power);
            static /*0x3304138*/ int LeadingZeroCount(uint value);
            static /*0x330419c*/ int OverflowUnscale(ref System.Decimal.DecCalc.Buf12 bufQuo, int scale, bool sticky);
            static /*0x33042f4*/ int SearchScale(ref System.Decimal.DecCalc.Buf12 bufQuo, int scale);
            static /*0x33042c4*/ bool Add32To96(ref System.Decimal.DecCalc.Buf12 bufNum, uint value);
            static /*0x32fe228*/ void DecAddSub(ref System.Decimal.DecCalc d1, ref System.Decimal.DecCalc d2, bool sign);
            static /*0x32fe968*/ int VarDecCmp(ref decimal d1, ref decimal d2);
            static /*0x33044fc*/ int VarDecCmpSub(ref decimal d1, ref decimal d2);
            static /*0x33001e8*/ void VarDecMul(ref System.Decimal.DecCalc d1, ref System.Decimal.DecCalc d2);
            static /*0x32fd61c*/ void VarDecFromR4(float input, ref System.Decimal.DecCalc result);
            static /*0x32fdaa8*/ void VarDecFromR8(double input, ref System.Decimal.DecCalc result);
            static /*0x3301a80*/ float VarR4FromDec(ref decimal value);
            static /*0x3301444*/ double VarR8FromDec(ref decimal value);
            static /*0x32ff718*/ int GetHashCode(ref decimal d);
            static /*0x32fed00*/ void VarDecDiv(ref System.Decimal.DecCalc d1, ref System.Decimal.DecCalc d2);
            static /*0x3300948*/ void InternalRound(ref System.Decimal.DecCalc d, uint scale, System.Decimal.DecCalc.RoundingMode mode);
            static /*0x32fd4ec*/ uint DecDivMod1E9(ref System.Decimal.DecCalc value);
            /*0x3302cc4*/ uint get_High();
            /*0x3302ccc*/ void set_High(uint value);
            /*0x3302cd4*/ uint get_Low();
            /*0x3302cdc*/ void set_Low(uint value);
            /*0x3302ce4*/ uint get_Mid();
            /*0x3302cec*/ void set_Mid(uint value);
            /*0x3302cf4*/ bool get_IsNegative();
            /*0x3302d00*/ ulong get_Low64();
            /*0x3302d08*/ void set_Low64(ulong value);

            enum RoundingMode
            {
                ToEven = 0,
                AwayFromZero = 1,
                Truncate = 2,
                Floor = 3,
                Ceiling = 4,
            }

            struct PowerOvfl
            {
                /*0x10*/ uint Hi;
                /*0x18*/ ulong MidLo;

                /*0x3304910*/ PowerOvfl(uint hi, uint mid, uint lo);
            }

            struct Buf12
            {
                /*0x10*/ uint U0;
                /*0x14*/ uint U1;
                /*0x18*/ uint U2;
                /*0x10*/ ulong ulo64LE;
                /*0x14*/ ulong uhigh64LE;

                /*0x3302ec8*/ ulong get_Low64();
                /*0x3302ed0*/ void set_Low64(ulong value);
                /*0x3302eb8*/ ulong get_High64();
                /*0x3302ec0*/ void set_High64(ulong value);
            }

            struct Buf16
            {
                /*0x10*/ uint U0;
                /*0x14*/ uint U1;
                /*0x18*/ uint U2;
                /*0x1c*/ uint U3;
                /*0x10*/ ulong ulo64LE;
                /*0x18*/ ulong uhigh64LE;

                /*0x33033b4*/ ulong get_Low64();
                /*0x33033bc*/ void set_Low64(ulong value);
                /*0x33033ac*/ ulong get_High64();
                /*0x33046c8*/ void set_High64(ulong value);
            }

            struct Buf24
            {
                /*0x10*/ uint U0;
                /*0x14*/ uint U1;
                /*0x18*/ uint U2;
                /*0x1c*/ uint U3;
                /*0x20*/ uint U4;
                /*0x24*/ uint U5;
                /*0x10*/ ulong ulo64LE;
                /*0x18*/ ulong umid64LE;
                /*0x20*/ ulong uhigh64LE;

                /*0x33044f4*/ ulong get_Low64();
                /*0x33044e4*/ void set_Low64(ulong value);
                /*0x33044ec*/ void set_Mid64(ulong value);
                /*0x33046c0*/ void set_High64(ulong value);
            }
        }
    }

    namespace Threading
    {
        class AbandonedMutexException : System.SystemException
        {
            /*0x8c*/ int _mutexIndex;
            /*0x90*/ System.Threading.Mutex _mutex;

            /*0x3304924*/ AbandonedMutexException();
            /*0x3304988*/ AbandonedMutexException(int location, System.Threading.WaitHandle handle);
            /*0x3304a94*/ AbandonedMutexException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x3304a08*/ void SetupException(int location, System.Threading.WaitHandle handle);
        }

        class AsyncLocal<T> : System.Threading.IAsyncLocal
        {
            /*0x0*/ System.Action<System.Threading.AsyncLocalValueChangedArgs<T>> m_valueChangedHandler;

            /*0x1f30ebc*/ AsyncLocal(System.Action<System.Threading.AsyncLocalValueChangedArgs<T>> valueChangedHandler);
            /*0x1ffc854*/ void set_Value(T value);
            void System.Threading.IAsyncLocal.OnValueChanged(object previousValueObj, object currentValueObj, bool contextChanged);
        }

        interface IAsyncLocal
        {
            void OnValueChanged(object previousValue, object currentValue, bool contextChanged);
        }

        struct AsyncLocalValueChangedArgs<T>
        {
            /*0x0*/ T <PreviousValue>k__BackingField;
            /*0x0*/ T <CurrentValue>k__BackingField;
            /*0x0*/ bool <ThreadContextChanged>k__BackingField;

            /*0x1ffc854*/ AsyncLocalValueChangedArgs(T previousValue, T currentValue, bool contextChanged);
            /*0x1ffc854*/ T get_CurrentValue();
        }

        class AutoResetEvent : System.Threading.EventWaitHandle
        {
            /*0x3304aa4*/ AutoResetEvent(bool initialState);
        }

        enum EventResetMode
        {
            AutoReset = 0,
            ManualReset = 1,
        }

        class LazyInitializer
        {
            static /*0x1ffc854*/ T EnsureInitialized<T>(ref T target);
            static /*0x1ffc854*/ T EnsureInitializedCore<T>(ref T target);
            static /*0x1ffc854*/ T EnsureInitialized<T>(ref T target, System.Func<T> valueFactory);
            static /*0x1ffc854*/ T EnsureInitializedCore<T>(ref T target, System.Func<T> valueFactory);
            static /*0x1ffc854*/ T EnsureInitialized<T>(ref T target, ref bool initialized, ref object syncLock, System.Func<T> valueFactory);
            static /*0x1ffc854*/ T EnsureInitializedCore<T>(ref T target, ref bool initialized, ref object syncLock, System.Func<T> valueFactory);
            static /*0x1ffc854*/ T EnsureInitialized<T>(ref T target, ref object syncLock, System.Func<T> valueFactory);
            static /*0x1ffc854*/ T EnsureInitializedCore<T>(ref T target, ref object syncLock, System.Func<T> valueFactory);
            static /*0x3304ab8*/ object EnsureLockInitialized(ref object syncLock);
        }

        enum LazyThreadSafetyMode
        {
            None = 0,
            PublicationOnly = 1,
            ExecutionAndPublication = 2,
        }

        class LockRecursionException : System.Exception
        {
            /*0x3304b30*/ LockRecursionException();
            /*0x3304b88*/ LockRecursionException(string message);
            /*0x3304bf0*/ LockRecursionException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class ManualResetEvent : System.Threading.EventWaitHandle
        {
            /*0x3304c70*/ ManualResetEvent(bool initialState);
        }

        class ParameterizedThreadStart : System.MulticastDelegate
        {
            /*0x3304c7c*/ ParameterizedThreadStart(object object, nint method);
            /*0x3304d84*/ void Invoke(object obj);
        }

        class SemaphoreFullException : System.SystemException
        {
            /*0x3304d98*/ SemaphoreFullException();
            /*0x3304de4*/ SemaphoreFullException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class SendOrPostCallback : System.MulticastDelegate
        {
            /*0x3304dec*/ SendOrPostCallback(object object, nint method);
            /*0x3304ef4*/ void Invoke(object state);
        }

        class SynchronizationLockException : System.SystemException
        {
            /*0x3304f08*/ SynchronizationLockException();
            /*0x3304f64*/ SynchronizationLockException(string message);
            /*0x3304f88*/ SynchronizationLockException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        enum ThreadPriority
        {
            Lowest = 0,
            BelowNormal = 1,
            Normal = 2,
            AboveNormal = 3,
            Highest = 4,
        }

        class ThreadStart : System.MulticastDelegate
        {
            /*0x3304f90*/ ThreadStart(object object, nint method);
            /*0x330502c*/ void Invoke();
        }

        enum ThreadState
        {
            Running = 0,
            StopRequested = 1,
            SuspendRequested = 2,
            Background = 4,
            Unstarted = 8,
            Stopped = 16,
            WaitSleepJoin = 32,
            Suspended = 64,
            AbortRequested = 128,
            Aborted = 256,
        }

        class ThreadStateException : System.SystemException
        {
            /*0x3305040*/ ThreadStateException();
            /*0x330509c*/ ThreadStateException(string message);
            /*0x33050c0*/ ThreadStateException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class Timeout
        {
            static /*0x0*/ System.TimeSpan InfiniteTimeSpan;

            static /*0x33050c8*/ Timeout();
        }

        class WaitHandleCannotBeOpenedException : System.ApplicationException
        {
            /*0x3305138*/ WaitHandleCannotBeOpenedException();
            /*0x3305194*/ WaitHandleCannotBeOpenedException(string message);
            /*0x33051b8*/ WaitHandleCannotBeOpenedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        struct CancellationToken
        {
            static /*0x0*/ System.Action<object> s_actionToActionObjShunt;
            /*0x10*/ System.Threading.CancellationTokenSource _source;

            static /*0x3305c74*/ CancellationToken();
            static /*0x33051c0*/ System.Threading.CancellationToken get_None();
            static /*0x3305ad4*/ bool op_Equality(System.Threading.CancellationToken left, System.Threading.CancellationToken right);
            static /*0x3305b38*/ bool op_Inequality(System.Threading.CancellationToken left, System.Threading.CancellationToken right);
            /*0x3305220*/ CancellationToken(System.Threading.CancellationTokenSource source);
            /*0x3305228*/ CancellationToken(bool canceled);
            /*0x33051c8*/ bool get_IsCancellationRequested();
            /*0x3305210*/ bool get_CanBeCanceled();
            /*0x33052c4*/ System.Threading.CancellationTokenRegistration Register(System.Action callback);
            /*0x33054e8*/ System.Threading.CancellationTokenRegistration Register(System.Action<object> callback, object state);
            /*0x3305584*/ System.Threading.CancellationTokenRegistration InternalRegisterWithoutEC(System.Action<object> callback, object state);
            /*0x33053bc*/ System.Threading.CancellationTokenRegistration Register(System.Action<object> callback, object state, bool useSynchronizationContext, bool useExecutionContext);
            /*0x33059a8*/ bool Equals(System.Threading.CancellationToken other);
            /*0x33059b8*/ bool Equals(object other);
            /*0x3305a60*/ int GetHashCode();
            /*0x3305b9c*/ void ThrowIfCancellationRequested();
            /*0x3305c1c*/ void ThrowOperationCanceledException();

            class <>c
            {
                static /*0x0*/ System.Threading.CancellationToken.<> <>9;

                static /*0x3305d44*/ <>c();
                /*0x3305dac*/ <>c();
                /*0x3305db4*/ void <.cctor>b__26_0(object obj);
            }
        }

        class ManualResetEventSlim : System.IDisposable
        {
            static /*0x0*/ System.Action<object> s_cancellationTokenCallback;
            /*0x10*/ object m_lock;
            /*0x18*/ System.Threading.ManualResetEvent m_eventObj;
            /*0x20*/ int m_combinedState;

            static /*0x33071c4*/ ManualResetEventSlim();
            static /*0x3307040*/ void CancellationTokenCallback(object obj);
            static /*0x33061fc*/ int ExtractStatePortionAndShiftRight(int state, int mask, int rightBitShiftCount);
            static /*0x33060a8*/ int ExtractStatePortion(int state, int mask);
            /*0x3306324*/ ManualResetEventSlim(bool initialState);
            /*0x3306450*/ ManualResetEventSlim(bool initialState, int spinCount);
            /*0x3305e20*/ System.Threading.WaitHandle get_WaitHandle();
            /*0x330604c*/ bool get_IsSet();
            /*0x33060b0*/ void set_IsSet(bool value);
            /*0x33061a0*/ int get_SpinCount();
            /*0x3306208*/ void set_SpinCount(int value);
            /*0x330623c*/ int get_Waiters();
            /*0x3306298*/ void set_Waiters(int value);
            /*0x33063a0*/ void Initialize(bool initialState, int spinCount);
            /*0x3306568*/ void EnsureLockObjectCreated();
            /*0x3305ebc*/ bool LazyInitializeEvent();
            /*0x3306660*/ void Set();
            /*0x3306668*/ void Set(bool duringCancellation);
            /*0x3306878*/ bool Wait(int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);
            /*0x3306ec8*/ void Dispose();
            /*0x3306f34*/ void Dispose(bool disposing);
            /*0x3305e5c*/ void ThrowIfDisposed();
            /*0x33060d0*/ void UpdateStateAtomically(int newBits, int updateBitsMask);
        }

        struct NativeOverlapped
        {
            /*0x10*/ nint InternalLow;
            /*0x18*/ nint InternalHigh;
            /*0x20*/ int OffsetLow;
            /*0x24*/ int OffsetHigh;
            /*0x28*/ nint EventHandle;
        }

        struct SpinWait
        {
            static /*0x0*/ int SpinCountforSpinBeforeWait;
            /*0x10*/ int _count;

            static /*0x3307490*/ SpinWait();
            /*0x3307264*/ int get_Count();
            /*0x330726c*/ bool get_NextSpinWillYield();
            /*0x330716c*/ void SpinOnce();
            /*0x3306d90*/ void SpinOnce(int sleep1Threshold);
            /*0x33072e4*/ void SpinOnceCore(int sleep1Threshold);
        }

        class PlatformHelper
        {
            static /*0x0*/ int s_processorCount;
            static /*0x4*/ int s_lastProcessorCountRefreshTicks;
            static /*0x8*/ bool IsSingleProcessor;

            static /*0x3307600*/ PlatformHelper();
            static /*0x3307514*/ int get_ProcessorCount();
        }

        class TimeoutHelper
        {
            static /*0x3306d88*/ uint GetTime();
            static /*0x3306e88*/ int UpdateTimeOut(uint startTime, int originalWaitMillisecondsTimeout);
        }

        struct CancellationTokenRegistration : System.IEquatable<System.Threading.CancellationTokenRegistration>, System.IDisposable
        {
            /*0x10*/ System.Threading.CancellationCallbackInfo m_callbackInfo;
            /*0x18*/ System.Threading.SparselyPopulatedArrayAddInfo<System.Threading.CancellationCallbackInfo> m_registrationInfo;

            /*0x3307654*/ CancellationTokenRegistration(System.Threading.CancellationCallbackInfo callbackInfo, System.Threading.SparselyPopulatedArrayAddInfo<System.Threading.CancellationCallbackInfo> registrationInfo);
            /*0x330768c*/ bool Unregister();
            /*0x3307708*/ void Dispose();
            /*0x3307858*/ bool Equals(object obj);
            /*0x33078e8*/ bool Equals(System.Threading.CancellationTokenRegistration other);
            /*0x3307968*/ int GetHashCode();
        }

        class CancellationTokenSource : System.IDisposable
        {
            static /*0x0*/ System.Threading.CancellationTokenSource s_canceledSource;
            static /*0x8*/ System.Threading.CancellationTokenSource s_neverCanceledSource;
            static /*0x10*/ int s_nLists;
            static /*0x18*/ System.Threading.TimerCallback s_timerCallback;
            /*0x10*/ System.Threading.ManualResetEvent _kernelEvent;
            /*0x18*/ System.Threading.SparselyPopulatedArray<System.Threading.CancellationCallbackInfo> _registeredCallbacksLists;
            /*0x20*/ int _state;
            /*0x24*/ int _threadIDExecutingCallbacks;
            /*0x28*/ bool _disposed;
            /*0x30*/ System.Threading.CancellationCallbackInfo _executingCallback;
            /*0x38*/ System.Threading.Timer _timer;

            static /*0x3308dc8*/ CancellationTokenSource();
            static /*0x3307f20*/ void TimerCallbackLogic(object obj);
            static /*0x3308140*/ void ThrowObjectDisposedException();
            static /*0x33089a8*/ System.Threading.CancellationTokenSource CreateLinkedTokenSource(System.Threading.CancellationToken token1, System.Threading.CancellationToken token2);
            static /*0x3308cfc*/ System.Threading.CancellationTokenSource CreateLinkedTokenSource(System.Threading.CancellationToken token);
            /*0x3307ac8*/ CancellationTokenSource();
            /*0x3307afc*/ CancellationTokenSource(int millisecondsDelay);
            /*0x33051f4*/ bool get_IsCancellationRequested();
            /*0x330779c*/ bool get_IsCancellationCompleted();
            /*0x33079f8*/ bool get_IsDisposed();
            /*0x33077b8*/ int get_ThreadIDExecutingCallbacks();
            /*0x3307a00*/ void set_ThreadIDExecutingCallbacks(int value);
            /*0x3307a24*/ System.Threading.CancellationToken get_Token();
            /*0x3307ab0*/ System.Threading.CancellationCallbackInfo get_ExecutingCallback();
            /*0x3307b88*/ void InitializeWithTimer(int millisecondsDelay);
            /*0x3307c44*/ void Cancel();
            /*0x3307c60*/ void Cancel(bool throwOnFirstException);
            /*0x3307d38*/ void CancelAfter(int millisecondsDelay);
            /*0x3308038*/ void Dispose();
            /*0x33080a4*/ void Dispose(bool disposing);
            /*0x3307a54*/ void ThrowIfDisposed();
            /*0x33056ac*/ System.Threading.CancellationTokenRegistration InternalRegister(System.Action<object> callback, object stateForCallback, System.Threading.SynchronizationContext targetSyncContext, System.Threading.ExecutionContext executionContext);
            /*0x3307c88*/ void NotifyCancellation(bool throwOnFirstException);
            /*0x3308230*/ void ExecuteCallbackHandlers(bool throwOnFirstException);
            /*0x3308828*/ void CancellationCallbackCoreWork_OnSyncContext(object obj);
            /*0x330876c*/ void CancellationCallbackCoreWork(System.Threading.CancellationCallbackCoreWorkArguments args);
            /*0x33077d0*/ void WaitForCallbackToComplete(System.Threading.CancellationCallbackInfo callbackInfo);

            class Linked1CancellationTokenSource : System.Threading.CancellationTokenSource
            {
                /*0x40*/ System.Threading.CancellationTokenRegistration _reg1;

                /*0x3308ab8*/ Linked1CancellationTokenSource(System.Threading.CancellationToken token1);
                /*0x3308f58*/ void Dispose(bool disposing);
            }

            class Linked2CancellationTokenSource : System.Threading.CancellationTokenSource
            {
                /*0x40*/ System.Threading.CancellationTokenRegistration _reg1;
                /*0x58*/ System.Threading.CancellationTokenRegistration _reg2;

                /*0x3308bbc*/ Linked2CancellationTokenSource(System.Threading.CancellationToken token1, System.Threading.CancellationToken token2);
                /*0x3308f8c*/ void Dispose(bool disposing);
            }

            class LinkedNCancellationTokenSource : System.Threading.CancellationTokenSource
            {
                static /*0x0*/ System.Action<object> s_linkedTokenCancelDelegate;

                static /*0x3308fc8*/ LinkedNCancellationTokenSource();

                class <>c
                {
                    static /*0x0*/ System.Threading.CancellationTokenSource.LinkedNCancellationTokenSource.<> <>9;

                    static /*0x3309098*/ <>c();
                    /*0x3309100*/ <>c();
                    /*0x3309108*/ void <.cctor>b__4_0(object s);
                }
            }
        }

        struct CancellationCallbackCoreWorkArguments
        {
            /*0x10*/ System.Threading.SparselyPopulatedArrayFragment<System.Threading.CancellationCallbackInfo> _currArrayFragment;
            /*0x18*/ int _currArrayIndex;

            /*0x3308744*/ CancellationCallbackCoreWorkArguments(System.Threading.SparselyPopulatedArrayFragment<System.Threading.CancellationCallbackInfo> currArrayFragment, int currArrayIndex);
        }

        class CancellationCallbackInfo
        {
            static /*0x0*/ System.Threading.ContextCallback s_executionContextCallback;
            /*0x10*/ System.Action<object> Callback;
            /*0x18*/ object StateForCallback;
            /*0x20*/ System.Threading.ExecutionContext TargetExecutionContext;
            /*0x28*/ System.Threading.CancellationTokenSource CancellationTokenSource;

            static /*0x3309374*/ void ExecutionContextCallback(object obj);
            /*0x3308190*/ CancellationCallbackInfo(System.Action<object> callback, object stateForCallback, System.Threading.ExecutionContext targetExecutionContext, System.Threading.CancellationTokenSource cancellationTokenSource);
            /*0x33088a4*/ void ExecuteCallback();

            class WithSyncContext : System.Threading.CancellationCallbackInfo
            {
                /*0x30*/ System.Threading.SynchronizationContext TargetSyncContext;

                /*0x3308204*/ WithSyncContext(System.Action<object> callback, object stateForCallback, System.Threading.ExecutionContext targetExecutionContext, System.Threading.CancellationTokenSource cancellationTokenSource, System.Threading.SynchronizationContext targetSyncContext);
            }
        }

        class SparselyPopulatedArray<T>
        {
            /*0x0*/ System.Threading.SparselyPopulatedArrayFragment<T> _head;
            /*0x0*/ System.Threading.SparselyPopulatedArrayFragment<T> _tail;

            /*0x1f30b78*/ SparselyPopulatedArray(int initialSize);
            /*0x1f30214*/ System.Threading.SparselyPopulatedArrayFragment<T> get_Tail();
            /*0x1ffc854*/ System.Threading.SparselyPopulatedArrayAddInfo<T> Add(T element);
        }

        struct SparselyPopulatedArrayAddInfo<T>
        {
            /*0x0*/ System.Threading.SparselyPopulatedArrayFragment<T> _source;
            /*0x0*/ int _index;

            /*0x1f30ee8*/ SparselyPopulatedArrayAddInfo(System.Threading.SparselyPopulatedArrayFragment<T> source, int index);
            /*0x1f30214*/ System.Threading.SparselyPopulatedArrayFragment<T> get_Source();
            /*0x1f2ffc8*/ int get_Index();
        }

        class SparselyPopulatedArrayFragment<T>
        {
            /*0x0*/ T[] _elements;
            /*0x0*/ int _freeCount;
            /*0x0*/ System.Threading.SparselyPopulatedArrayFragment<T> _next;
            /*0x0*/ System.Threading.SparselyPopulatedArrayFragment<T> _prev;

            /*0x1f30b78*/ SparselyPopulatedArrayFragment(int size);
            /*0x1f30c88*/ SparselyPopulatedArrayFragment(int size, System.Threading.SparselyPopulatedArrayFragment<T> prev);
            /*0x1ffc854*/ T get_Item(int index);
            /*0x1f2ffc8*/ int get_Length();
            /*0x1f30214*/ System.Threading.SparselyPopulatedArrayFragment<T> get_Prev();
            /*0x1ffc854*/ T SafeAtomicRemove(int index, T expectedElement);
        }

        struct LockHolder : System.IDisposable
        {
            /*0x10*/ System.Threading.Lock _lock;

            static /*0x3309400*/ System.Threading.LockHolder Hold(System.Threading.Lock l);
            /*0x3309448*/ void Dispose();
        }

        class Lock
        {
            /*0x10*/ object _lock;

            /*0x3309470*/ Lock();
            /*0x3309440*/ void Acquire();
            /*0x3309460*/ void Release();
        }

        class SemaphoreSlim : System.IDisposable
        {
            static /*0x0*/ System.Threading.Tasks.Task<bool> s_trueTask;
            static /*0x8*/ System.Threading.Tasks.Task<bool> s_falseTask;
            static /*0x10*/ System.Action<object> s_cancellationTokenCanceledEventHandler;
            /*0x10*/ int m_currentCount;
            /*0x14*/ int m_maxCount;
            /*0x18*/ int m_waitCount;
            /*0x20*/ object m_lockObj;
            /*0x28*/ System.Threading.ManualResetEvent m_waitHandle;
            /*0x30*/ System.Threading.SemaphoreSlim.TaskNode m_asyncHead;
            /*0x38*/ System.Threading.SemaphoreSlim.TaskNode m_asyncTail;

            static /*0x330a960*/ SemaphoreSlim();
            static /*0x330a730*/ void QueueWaiterTask(System.Threading.SemaphoreSlim.TaskNode waiterTask);
            static /*0x330a844*/ void CancellationTokenCanceledEventHandler(object obj);
            static /*0x330966c*/ string GetResourceString(string str);
            /*0x33094dc*/ SemaphoreSlim(int initialCount, int maxCount);
            /*0x3309674*/ void Wait();
            /*0x3309bd0*/ bool Wait(int millisecondsTimeout);
            /*0x3309680*/ bool Wait(int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);
            /*0x3309f80*/ bool WaitUntilCountOrTimeout(int millisecondsTimeout, uint startTime, System.Threading.CancellationToken cancellationToken);
            /*0x330a0a4*/ System.Threading.Tasks.Task WaitAsync();
            /*0x3309c4c*/ System.Threading.Tasks.Task<bool> WaitAsync(int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);
            /*0x330a0b0*/ System.Threading.SemaphoreSlim.TaskNode CreateAndAddAsyncWaiter();
            /*0x330a2fc*/ bool RemoveAsyncWaiter(System.Threading.SemaphoreSlim.TaskNode task);
            /*0x330a160*/ System.Threading.Tasks.Task<bool> WaitUntilCountOrTimeoutAsync(System.Threading.SemaphoreSlim.TaskNode asyncWaiter, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);
            /*0x330a3e4*/ int Release();
            /*0x330a3ec*/ int Release(int releaseCount);
            /*0x330a73c*/ void Dispose();
            /*0x330a7a8*/ void Dispose(bool disposing);
            /*0x3309bd8*/ void CheckDispose();

            class TaskNode : System.Threading.Tasks.Task<bool>, System.Threading.IThreadPoolWorkItem
            {
                /*0x58*/ System.Threading.SemaphoreSlim.TaskNode Prev;
                /*0x60*/ System.Threading.SemaphoreSlim.TaskNode Next;

                /*0x330a2b4*/ TaskNode();
                /*0x330aab0*/ void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
                /*0x330ab10*/ void System.Threading.IThreadPoolWorkItem.MarkAborted(System.Threading.ThreadAbortException tae);
            }

            struct <WaitUntilCountOrTimeoutAsync>d__32 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder<bool> <>t__builder;
                /*0x30*/ System.Threading.CancellationToken cancellationToken;
                /*0x38*/ System.Threading.SemaphoreSlim.TaskNode asyncWaiter;
                /*0x40*/ int millisecondsTimeout;
                /*0x48*/ System.Threading.SemaphoreSlim <>4__this;
                /*0x50*/ System.Threading.CancellationTokenSource <cts>5__2;
                /*0x58*/ object <>7__wrap2;
                /*0x60*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter<System.Threading.Tasks.Task> <>u__1;
                /*0x70*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter<bool> <>u__2;

                /*0x330ab14*/ void MoveNext();
                /*0x330b3e4*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }
        }

        struct SpinLock
        {
            static /*0x0*/ int MAXIMUM_WAITERS;
            /*0x10*/ int m_owner;

            static /*0x330c1c4*/ SpinLock();
            /*0x330b460*/ SpinLock(bool enableThreadOwnerTracking);
            /*0x330b498*/ void Enter(ref bool lockTaken);
            /*0x330ba68*/ void TryEnter(int millisecondsTimeout, ref bool lockTaken);
            /*0x330b59c*/ void ContinueTryEnter(int millisecondsTimeout, ref bool lockTaken);
            /*0x330bd10*/ void DecrementWaiters();
            /*0x330bba4*/ void ContinueTryEnterWithThreadTracking(int millisecondsTimeout, uint startTime, ref bool lockTaken);
            /*0x330bee0*/ void Exit();
            /*0x330c06c*/ void Exit(bool useMemoryBarrier);
            /*0x330bf5c*/ void ExitSlowPath(bool useMemoryBarrier);
            /*0x330c0f4*/ bool get_IsHeldByCurrentThread();
            /*0x330bb88*/ bool get_IsThreadOwnerTrackingEnabled();

            class SystemThreading_SpinLockDebugView
            {
            }
        }

        class ThreadLocal<T> : System.IDisposable
        {
            static /*0x0*/ System.Threading.ThreadLocal.IdManager<T> s_idManager;
            [ThreadStatic] static System.Threading.ThreadLocal.LinkedSlotVolatile<T> ts_slotArray;
            [ThreadStatic] static System.Threading.ThreadLocal.FinalizationHelper<T> ts_finalizationHelper;
            /*0x0*/ System.Func<T> m_valueFactory;
            /*0x0*/ int m_idComplement;
            /*0x0*/ bool m_initialized;
            /*0x0*/ System.Threading.ThreadLocal.LinkedSlot<T> m_linkedSlot;
            /*0x0*/ bool m_trackAllValues;

            static /*0x1f33998*/ ThreadLocal();
            static /*0x1f31e40*/ int GetNewTableSize(int minSize);
            /*0x1f309e4*/ ThreadLocal();
            /*0x1f30ebc*/ ThreadLocal(System.Func<T> valueFactory);
            void Initialize(System.Func<T> valueFactory, bool trackAllValues);
            /*0x1f309e4*/ void Finalize();
            /*0x1f309e4*/ void Dispose();
            /*0x1f30a84*/ void Dispose(bool disposing);
            /*0x1f30214*/ string ToString();
            /*0x1ffc854*/ T get_Value();
            /*0x1ffc854*/ void set_Value(T value);
            /*0x1ffc854*/ T GetValueSlow();
            /*0x1ffc854*/ void SetValueSlow(T value, System.Threading.ThreadLocal.LinkedSlotVolatile<T> slotArray);
            /*0x1ffc854*/ void CreateLinkedSlot(System.Threading.ThreadLocal.LinkedSlotVolatile<T> slotArray, int id, T value);
            /*0x1f2fe14*/ bool get_IsValueCreated();
            /*0x1f30ee8*/ void GrowTable(ref System.Threading.ThreadLocal.LinkedSlotVolatile<T> table, int minLength);

            struct LinkedSlotVolatile<T>
            {
                /*0x0*/ System.Threading.ThreadLocal.LinkedSlot<T> Value;
            }

            class LinkedSlot<T>
            {
                /*0x0*/ System.Threading.ThreadLocal.LinkedSlot<T> Next;
                /*0x0*/ System.Threading.ThreadLocal.LinkedSlot<T> Previous;
                /*0x0*/ System.Threading.ThreadLocal.LinkedSlotVolatile<T> SlotArray;
                /*0x0*/ T Value;

                /*0x1f30ebc*/ LinkedSlot(System.Threading.ThreadLocal.LinkedSlotVolatile<T> slotArray);
            }

            class IdManager<T>
            {
                /*0x0*/ int m_nextIdToTry;
                /*0x0*/ System.Collections.Generic.List<bool> m_freeIds;

                /*0x1f309e4*/ IdManager();
                /*0x1f2ffc8*/ int GetId();
                /*0x1f30b78*/ void ReturnId(int id);
            }

            class FinalizationHelper<T>
            {
                /*0x0*/ System.Threading.ThreadLocal.LinkedSlotVolatile<T> SlotArray;
                /*0x0*/ bool m_trackAllValues;

                FinalizationHelper(System.Threading.ThreadLocal.LinkedSlotVolatile<T> slotArray, bool trackAllValues);
                /*0x1f309e4*/ void Finalize();
            }
        }

        class SystemThreading_ThreadLocalDebugView<T>
        {
        }

        class EventWaitHandle : System.Threading.WaitHandle
        {
            /*0x3304ab0*/ EventWaitHandle(bool initialState, System.Threading.EventResetMode mode);
            /*0x330c210*/ EventWaitHandle(bool initialState, System.Threading.EventResetMode mode, string name);
            /*0x330a048*/ bool Reset();
            /*0x3306604*/ bool Set();
        }

        class ContextCallback : System.MulticastDelegate
        {
            /*0x330918c*/ ContextCallback(object object, nint method);
            /*0x330c4b8*/ void Invoke(object state);
        }

        struct ExecutionContextSwitcher
        {
            /*0x10*/ System.Threading.ExecutionContext.Reader outerEC;
            /*0x18*/ bool outerECBelongsToScope;
            /*0x20*/ object hecsw;
            /*0x28*/ System.Threading.Thread thread;

            /*0x330c4cc*/ bool UndoNoThrow();
            /*0x330c554*/ void Undo();
        }

        class ExecutionContext : System.IDisposable, System.Runtime.Serialization.ISerializable
        {
            static /*0x0*/ System.Threading.ExecutionContext s_dummyDefaultEC;
            static /*0x8*/ System.Threading.ExecutionContext Default;
            /*0x10*/ System.Threading.SynchronizationContext _syncContext;
            /*0x18*/ System.Threading.SynchronizationContext _syncContextNoFlow;
            /*0x20*/ System.Runtime.Remoting.Messaging.LogicalCallContext _logicalCallContext;
            /*0x28*/ System.Runtime.Remoting.Messaging.IllogicalCallContext _illogicalCallContext;
            /*0x30*/ System.Threading.ExecutionContext.Flags _flags;
            /*0x38*/ System.Collections.Generic.Dictionary<System.Threading.IAsyncLocal, object> _localValues;
            /*0x40*/ System.Collections.Generic.List<System.Threading.IAsyncLocal> _localChangeNotifications;

            static /*0x330deec*/ ExecutionContext();
            static /*0x330cc98*/ void SetLocalValue(System.Threading.IAsyncLocal local, object newValue, bool needChangeNotifications);
            static /*0x330c65c*/ void OnAsyncLocalContextChanged(System.Threading.ExecutionContext previous, System.Threading.ExecutionContext current);
            static /*0x3309294*/ void Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state);
            static /*0x330d0cc*/ void Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx);
            static /*0x330d344*/ void RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state);
            static /*0x330d148*/ void RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx);
            static /*0x330d6a4*/ void EstablishCopyOnWriteScope(ref System.Threading.ExecutionContextSwitcher ecsw);
            static /*0x330d454*/ void EstablishCopyOnWriteScope(System.Threading.Thread currentThread, bool knownNullWindowsIdentity, ref System.Threading.ExecutionContextSwitcher ecsw);
            static /*0x330d4c0*/ System.Threading.ExecutionContextSwitcher SetExecutionContext(System.Threading.ExecutionContext executionContext, bool preserveSyncCtx);
            static /*0x330da40*/ bool IsFlowSuppressed();
            static /*0x330565c*/ System.Threading.ExecutionContext Capture();
            static /*0x330dc54*/ System.Threading.ExecutionContext FastCapture();
            static /*0x330da80*/ System.Threading.ExecutionContext Capture(ref System.Threading.StackCrawlMark stackMark, System.Threading.ExecutionContext.CaptureOptions options);
            /*0x330cc60*/ ExecutionContext();
            /*0x330cc68*/ ExecutionContext(bool isPreAllocatedDefault);
            /*0x330ddd8*/ ExecutionContext(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x330cc04*/ bool get_isNewCapture();
            /*0x330cc18*/ void set_isNewCapture(bool value);
            /*0x330cc28*/ bool get_isFlowSuppressed();
            /*0x330cc34*/ void set_isFlowSuppressed(bool value);
            /*0x330cc54*/ bool get_IsPreAllocatedDefault();
            /*0x330cfb8*/ System.Runtime.Remoting.Messaging.LogicalCallContext get_LogicalCallContext();
            /*0x330d028*/ void set_LogicalCallContext(System.Runtime.Remoting.Messaging.LogicalCallContext value);
            /*0x330d030*/ System.Runtime.Remoting.Messaging.IllogicalCallContext get_IllogicalCallContext();
            /*0x330d0a0*/ void set_IllogicalCallContext(System.Runtime.Remoting.Messaging.IllogicalCallContext value);
            /*0x330d0a8*/ System.Threading.SynchronizationContext get_SynchronizationContext();
            /*0x330d0b0*/ void set_SynchronizationContext(System.Threading.SynchronizationContext value);
            /*0x330d0b8*/ System.Threading.SynchronizationContext get_SynchronizationContextNoFlow();
            /*0x330d0c0*/ void set_SynchronizationContextNoFlow(System.Threading.SynchronizationContext value);
            /*0x330d0c8*/ void Dispose();
            /*0x330d788*/ System.Threading.ExecutionContext CreateCopy();
            /*0x330d900*/ System.Threading.ExecutionContext CreateMutableCopy();
            /*0x330dcd8*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x330d3dc*/ bool IsDefaultFTContext(bool ignoreSyncCtx);

            enum Flags
            {
                None = 0,
                IsNewCapture = 1,
                IsFlowSuppressed = 2,
                IsPreAllocatedDefault = 4,
            }

            struct Reader
            {
                /*0x10*/ System.Threading.ExecutionContext m_ec;

                /*0x330df84*/ Reader(System.Threading.ExecutionContext ec);
                /*0x330df8c*/ System.Threading.ExecutionContext DangerousGetRawExecutionContext();
                /*0x330d3b4*/ bool get_IsNull();
                /*0x330d3c4*/ bool IsDefaultFTContext(bool ignoreSyncCtx);
                /*0x330df94*/ bool get_IsFlowSuppressed();
                /*0x330d728*/ System.Threading.SynchronizationContext get_SynchronizationContext();
                /*0x330d740*/ System.Threading.SynchronizationContext get_SynchronizationContextNoFlow();
                /*0x330dca4*/ System.Runtime.Remoting.Messaging.LogicalCallContext.Reader get_LogicalCallContext();
                /*0x330d42c*/ bool HasSameLocalValues(System.Threading.ExecutionContext other);
            }

            enum CaptureOptions
            {
                None = 0,
                IgnoreSyncCtx = 1,
                OptimizeDefaultCase = 2,
            }
        }

        class Monitor
        {
            static /*0x3309468*/ void Enter(object obj);
            static /*0x33065e8*/ void Enter(object obj, ref bool lockTaken);
            static /*0x330dfb0*/ void ThrowLockTakenException();
            static /*0x330946c*/ void Exit(object obj);
            static /*0x330e028*/ void TryEnter(object obj, ref bool lockTaken);
            static /*0x330e0d8*/ bool Wait(object obj, int millisecondsTimeout, bool exitContext);
            static /*0x3306ec0*/ bool Wait(object obj, int millisecondsTimeout);
            static /*0x330a6dc*/ void Pulse(object obj);
            static /*0x3306824*/ void PulseAll(object obj);
            static /*0x330e2a4*/ bool Monitor_test_synchronised(object obj);
            static /*0x330e2a8*/ void Monitor_pulse(object obj);
            static /*0x330e1e4*/ void ObjPulse(object obj);
            static /*0x330e2ac*/ void Monitor_pulse_all(object obj);
            static /*0x330e244*/ void ObjPulseAll(object obj);
            static /*0x330e2b0*/ bool Monitor_wait(object obj, int ms);
            static /*0x330e134*/ bool ObjWait(bool exitContext, int millisecondsTimeout, object obj);
            static /*0x330e2b4*/ void try_enter_with_atomic_var(object obj, int millisecondsTimeout, ref bool lockTaken);
            static /*0x330e044*/ void ReliableEnterTimeout(object obj, int timeout, ref bool lockTaken);
            static /*0x330e01c*/ void ReliableEnter(object obj, ref bool lockTaken);
        }

        enum SynchronizationContextProperties
        {
            None = 0,
            RequireWaitNotification = 1,
        }

        class SynchronizationContext
        {
            /*0x10*/ System.Threading.SynchronizationContextProperties _props;

            static /*0x330e4e4*/ int WaitHelper(nint[] waitHandles, bool waitAll, int millisecondsTimeout);
            static /*0x330e570*/ void SetSynchronizationContext(System.Threading.SynchronizationContext syncContext);
            static /*0x3305620*/ System.Threading.SynchronizationContext get_Current();
            static /*0x330e604*/ System.Threading.SynchronizationContext get_CurrentNoFlow();
            static /*0x330e5b8*/ System.Threading.SynchronizationContext GetThreadLocalContext();
            static /*0x330e7f4*/ System.Threading.SynchronizationContext get_CurrentExplicit();
            /*0x330e2b8*/ SynchronizationContext();
            /*0x330e2c0*/ bool IsWaitNotificationRequired();
            /*0x330e2cc*/ void Send(System.Threading.SendOrPostCallback d, object state);
            /*0x330e2f0*/ void Post(System.Threading.SendOrPostCallback d, object state);
            /*0x330e47c*/ void OperationStarted();
            /*0x330e480*/ void OperationCompleted();
            /*0x330e484*/ int Wait(nint[] waitHandles, bool waitAll, int millisecondsTimeout);
            /*0x330e7a0*/ System.Threading.SynchronizationContext CreateCopy();
        }

        class OSSpecificSynchronizationContext : System.Threading.SynchronizationContext
        {
            static /*0x0*/ System.Runtime.CompilerServices.ConditionalWeakTable<object, System.Threading.OSSpecificSynchronizationContext> s_ContextCache;
            /*0x18*/ object m_OSSynchronizationContext;

            static /*0x330ed14*/ OSSpecificSynchronizationContext();
            static /*0x330e640*/ System.Threading.OSSpecificSynchronizationContext Get();
            static /*0x330e7f8*/ void InvocationEntry(nint arg);
            static /*0x330ea0c*/ object GetOSContext();
            static /*0x330ecec*/ void PostInternal(object osSynchronizationContext, nint callback, nint arg);
            /*0x330e9dc*/ OSSpecificSynchronizationContext(object osContext);
            /*0x330ea10*/ System.Threading.SynchronizationContext CreateCopy();
            /*0x330ea7c*/ void Send(System.Threading.SendOrPostCallback d, object state);
            /*0x330eab4*/ void Post(System.Threading.SendOrPostCallback d, object state);

            class InvocationEntryDelegate : System.MulticastDelegate
            {
                /*0x330ec08*/ InvocationEntryDelegate(object object, nint method);
                /*0x330edac*/ void Invoke(nint arg);
            }

            class InvocationContext
            {
                /*0x10*/ System.Threading.SendOrPostCallback m_Delegate;
                /*0x18*/ object m_State;

                /*0x330eca8*/ InvocationContext(System.Threading.SendOrPostCallback d, object state);
                /*0x330ecf0*/ void Invoke();
            }

            class <>c
            {
                static /*0x0*/ System.Threading.OSSpecificSynchronizationContext.<> <>9;
                static /*0x8*/ System.Runtime.CompilerServices.ConditionalWeakTable.CreateValueCallback<object, System.Threading.OSSpecificSynchronizationContext> <>9__3_0;

                static /*0x330edc0*/ <>c();
                /*0x330ee28*/ <>c();
                /*0x330ee30*/ System.Threading.OSSpecificSynchronizationContext <Get>b__3_0(object _osContext);
            }
        }

        class ThreadHelper
        {
            static /*0x0*/ System.Threading.ContextCallback _ccb;
            /*0x10*/ System.Delegate _start;
            /*0x18*/ object _startArg;
            /*0x20*/ System.Threading.ExecutionContext _executionContext;

            static /*0x330f1d0*/ ThreadHelper();
            static /*0x330eed0*/ void ThreadStart_Context(object state);
            /*0x330ee98*/ ThreadHelper(System.Delegate start);
            /*0x330eec8*/ void SetExecutionContextHelper(System.Threading.ExecutionContext ec);
            /*0x330efcc*/ void ThreadStart(object obj);
            /*0x330f0dc*/ void ThreadStart();
        }

        class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject
        {
            static /*0x0*/ System.LocalDataStoreMgr s_LocalDataStoreMgr;
            static /*0x8*/ System.Threading.AsyncLocal<System.Globalization.CultureInfo> s_asyncLocalCurrentCulture;
            static /*0x10*/ System.Threading.AsyncLocal<System.Globalization.CultureInfo> s_asyncLocalCurrentUICulture;
            [ThreadStatic] static System.LocalDataStoreHolder s_LocalDataStore;
            [ThreadStatic] static System.Globalization.CultureInfo m_CurrentCulture;
            [ThreadStatic] static System.Globalization.CultureInfo m_CurrentUICulture;
            [ThreadStatic] static System.Threading.Thread current_thread;
            /*0x10*/ System.Threading.InternalThread internal_thread;
            /*0x18*/ object m_ThreadStartArg;
            /*0x20*/ object pending_exception;
            /*0x28*/ System.MulticastDelegate m_Delegate;
            /*0x30*/ System.Threading.ExecutionContext m_ExecutionContext;
            /*0x38*/ bool m_ExecutionContextBelongsToOuterScope;
            /*0x40*/ System.Security.Principal.IPrincipal principal;
            /*0x48*/ int principal_version;

            static /*0x330f26c*/ void AsyncLocalSetCurrentCulture(System.Threading.AsyncLocalValueChangedArgs<System.Globalization.CultureInfo> args);
            static /*0x330f360*/ void AsyncLocalSetCurrentUICulture(System.Threading.AsyncLocalValueChangedArgs<System.Globalization.CultureInfo> args);
            static /*0x330fa18*/ void SleepInternal(int millisecondsTimeout);
            static /*0x330bddc*/ void Sleep(int millisecondsTimeout);
            static /*0x330fa1c*/ bool YieldInternal();
            static /*0x330be54*/ bool Yield();
            static /*0x330fe08*/ void nativeInitCultureAccessors();
            static /*0x3310194*/ void MemoryBarrier();
            static /*0x33101c0*/ System.Runtime.Remoting.Contexts.Context get_CurrentContext();
            static /*0x33101c8*/ void GetCurrentThread_icall(ref System.Threading.Thread thread);
            static /*0x33101cc*/ System.Threading.Thread GetCurrentThread();
            static /*0x330be58*/ System.Threading.Thread get_CurrentThread();
            static /*0x33101e4*/ int get_CurrentThreadId();
            static /*0x3310208*/ int GetDomainID();
            static /*0x3310354*/ void SetName_icall(System.Threading.InternalThread thread, char* name, int nameLength);
            static /*0x3310358*/ void SetName_internal(System.Threading.InternalThread thread, string name);
            static /*0x33103c8*/ void Abort_internal(System.Threading.InternalThread thread, object stateInfo);
            static /*0x33103f4*/ void SpinWait_nop();
            static /*0x330bdb4*/ void SpinWait(int iterations);
            static /*0x331034c*/ void SetState(System.Threading.InternalThread thread, System.Threading.ThreadState set);
            static /*0x3310350*/ void ClrState(System.Threading.InternalThread thread, System.Threading.ThreadState clr);
            static /*0x331027c*/ System.Threading.ThreadState GetState(System.Threading.InternalThread thread);
            static /*0x33103f8*/ int SystemMaxStackStize();
            static /*0x330fa20*/ int GetProcessDefaultStackSize(int maxStackSize);
            static /*0x330b54c*/ void BeginCriticalRegion();
            static /*0x330bb38*/ void EndCriticalRegion();
            /*0x330f454*/ Thread(System.Threading.ThreadStart start);
            /*0x330f5f4*/ Thread(System.Threading.ParameterizedThreadStart start);
            /*0x330f670*/ Thread(System.Threading.ParameterizedThreadStart start, int maxStackSize);
            /*0x330f758*/ void Start();
            /*0x330f840*/ void Start(object parameter);
            /*0x330f774*/ void Start(ref System.Threading.StackCrawlMark stackMark);
            /*0x330c610*/ System.Threading.ExecutionContext.Reader GetExecutionContextReader();
            /*0x330d70c*/ bool get_ExecutionContextBelongsToCurrentScope();
            /*0x330d71c*/ void set_ExecutionContextBelongsToCurrentScope(bool value);
            /*0x330cf2c*/ System.Threading.ExecutionContext GetMutableExecutionContext();
            /*0x330d758*/ void SetExecutionContext(System.Threading.ExecutionContext value, bool belongsToCurrentScope);
            /*0x330c62c*/ void SetExecutionContext(System.Threading.ExecutionContext.Reader value, bool belongsToCurrentScope);
            /*0x330f98c*/ void set_Priority(System.Threading.ThreadPriority value);
            /*0x330f990*/ void SetPriorityNative(int priority);
            /*0x330f994*/ bool JoinInternal(int millisecondsTimeout);
            /*0x330f998*/ void Join();
            /*0x330f9a0*/ bool Join(int millisecondsTimeout);
            /*0x330f4d0*/ void SetStartHelper(System.Delegate start, int maxStackSize);
            /*0x330fb18*/ System.Globalization.CultureInfo get_CurrentUICulture();
            /*0x330fbf0*/ void set_CurrentUICulture(System.Globalization.CultureInfo value);
            /*0x330fb44*/ System.Globalization.CultureInfo GetCurrentUICultureNoAppX();
            /*0x330fecc*/ System.Globalization.CultureInfo get_CurrentCulture();
            /*0x330ffa4*/ void set_CurrentCulture(System.Globalization.CultureInfo value);
            /*0x330fef8*/ System.Globalization.CultureInfo GetCurrentCultureNoAppX();
            /*0x3310198*/ void ConstructInternalThread();
            /*0x331019c*/ System.Threading.InternalThread get_Internal();
            /*0x331020c*/ bool Thread_internal(System.MulticastDelegate start);
            /*0x3310210*/ void Finalize();
            /*0x3310218*/ bool get_IsThreadPoolThread();
            /*0x331021c*/ bool get_IsThreadPoolThreadInternal();
            /*0x3310248*/ bool get_IsAlive();
            /*0x3310280*/ void set_IsBackground(bool value);
            /*0x3310394*/ void set_Name(string value);
            /*0x33103cc*/ void Abort();
            /*0x330f91c*/ void StartInternal(object principal, ref System.Threading.StackCrawlMark stackMark);
            /*0x330facc*/ void SetStart(System.MulticastDelegate start, int maxStackSize);
            /*0x330beb4*/ int get_ManagedThreadId();
            /*0x33103fc*/ int GetHashCode();
            /*0x33102dc*/ System.Threading.ThreadState ValidateThreadState();
        }

        enum StackCrawlMark
        {
            LookForMe = 0,
            LookForMyCaller = 1,
            LookForMyCallersCaller = 2,
            LookForThread = 3,
        }

        class ThreadAbortException : System.SystemException
        {
            /*0x3310400*/ ThreadAbortException();
            /*0x331047c*/ ThreadAbortException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class ThreadInterruptedException : System.SystemException
        {
            /*0x3310484*/ ThreadInterruptedException();
            /*0x3310500*/ ThreadInterruptedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        interface IThreadPoolWorkItem
        {
            /*0x1f309e4*/ void ExecuteWorkItem();
            /*0x1f30ebc*/ void MarkAborted(System.Threading.ThreadAbortException tae);
        }

        class WaitCallback : System.MulticastDelegate
        {
            /*0x330e374*/ WaitCallback(object object, nint method);
            /*0x3310508*/ void Invoke(object state);
        }

        class WaitOrTimerCallback : System.MulticastDelegate
        {
            /*0x331051c*/ WaitOrTimerCallback(object object, nint method);
            /*0x3310628*/ void Invoke(object state, bool timedOut);
        }

        class ThreadPoolGlobals
        {
            static /*0x0*/ int processorCount;
            static /*0x4*/ bool vmTpInitialized;
            static /*0x5*/ bool enableWorkerTracking;
            static /*0x8*/ System.Threading.ThreadPoolWorkQueue workQueue;

            static /*0x331063c*/ ThreadPoolGlobals();
        }

        class ThreadPoolWorkQueue
        {
            static /*0x0*/ System.Threading.ThreadPoolWorkQueue.SparseArray<System.Threading.ThreadPoolWorkQueue.WorkStealingQueue> allThreadQueues;
            /*0x10*/ System.Threading.ThreadPoolWorkQueue.QueueSegment queueHead;
            /*0x18*/ System.Threading.ThreadPoolWorkQueue.QueueSegment queueTail;
            /*0x20*/ int numOutstandingThreadRequests;

            static /*0x3311c64*/ ThreadPoolWorkQueue();
            static /*0x33117fc*/ bool Dispatch();
            /*0x33106c4*/ ThreadPoolWorkQueue();
            /*0x3310748*/ System.Threading.ThreadPoolWorkQueueThreadLocals EnsureCurrentThreadHasQueue();
            /*0x33107d8*/ void EnsureThreadRequested();
            /*0x3310878*/ void MarkThreadRequestSatisfied();
            /*0x33108c4*/ void Enqueue(System.Threading.IThreadPoolWorkItem callback, bool forceGlobal);
            /*0x3310f24*/ bool LocalFindAndPop(System.Threading.IThreadPoolWorkItem callback);
            /*0x33112e4*/ void Dequeue(System.Threading.ThreadPoolWorkQueueThreadLocals tl, ref System.Threading.IThreadPoolWorkItem callback, ref bool missedSteal);

            class SparseArray<T>
            {
                /*0x0*/ T[] m_array;

                /*0x1f30b78*/ SparseArray(int initialSize);
                /*0x1f30214*/ T[] get_Current();
                /*0x1ffc854*/ int Add(T e);
                /*0x1ffc854*/ void Remove(T e);
            }

            class WorkStealingQueue
            {
                /*0x10*/ System.Threading.IThreadPoolWorkItem[] m_array;
                /*0x18*/ int m_mask;
                /*0x1c*/ int m_headIndex;
                /*0x20*/ int m_tailIndex;
                /*0x24*/ System.Threading.SpinLock m_foreignLock;

                /*0x3311fe8*/ WorkStealingQueue();
                /*0x3310a00*/ void LocalPush(System.Threading.IThreadPoolWorkItem obj);
                /*0x3310f94*/ bool LocalFindAndPop(System.Threading.IThreadPoolWorkItem obj);
                /*0x33114b4*/ bool LocalPop(ref System.Threading.IThreadPoolWorkItem obj);
                /*0x33117f4*/ bool TrySteal(ref System.Threading.IThreadPoolWorkItem obj, ref bool missedSteal);
                /*0x3311d00*/ bool TrySteal(ref System.Threading.IThreadPoolWorkItem obj, ref bool missedSteal, int millisecondsTimeout);
            }

            class QueueSegment
            {
                /*0x10*/ System.Threading.IThreadPoolWorkItem[] nodes;
                /*0x18*/ int indexes;
                /*0x20*/ System.Threading.ThreadPoolWorkQueue.QueueSegment Next;

                /*0x33123a4*/ QueueSegment();
                /*0x3312300*/ void GetIndexes(ref int upper, ref int lower);
                /*0x3312334*/ bool CompareExchangeIndexes(ref int prevUpper, int newUpper, ref int prevLower, int newLower);
                /*0x3312408*/ bool IsUsedUp();
                /*0x3312448*/ bool TryEnqueue(System.Threading.IThreadPoolWorkItem node);
                /*0x3312504*/ bool TryDequeue(ref System.Threading.IThreadPoolWorkItem node);
            }
        }

        class ThreadPoolWorkQueueThreadLocals
        {
            [ThreadStatic] static System.Threading.ThreadPoolWorkQueueThreadLocals threadLocals;
            /*0x10*/ System.Threading.ThreadPoolWorkQueue workQueue;
            /*0x18*/ System.Threading.ThreadPoolWorkQueue.WorkStealingQueue workStealingQueue;
            /*0x20*/ System.Random random;

            /*0x331265c*/ ThreadPoolWorkQueueThreadLocals(System.Threading.ThreadPoolWorkQueue tpq);
            /*0x331279c*/ void CleanUp();
            /*0x331286c*/ void Finalize();
        }

        class _ThreadPoolWaitCallback
        {
            static /*0x3312928*/ bool PerformWaitCallback();
        }

        class QueueUserWorkItemCallback : System.Threading.IThreadPoolWorkItem
        {
            static /*0x0*/ System.Threading.ContextCallback ccb;
            /*0x10*/ System.Threading.WaitCallback callback;
            /*0x18*/ System.Threading.ExecutionContext context;
            /*0x20*/ object state;

            static /*0x3312bc4*/ QueueUserWorkItemCallback();
            static /*0x3312b4c*/ void WaitCallback_Context(object state);
            /*0x3312978*/ QueueUserWorkItemCallback(System.Threading.WaitCallback waitCallback, object stateObj, bool compressStack, ref System.Threading.StackCrawlMark stackMark);
            /*0x3312a64*/ void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
            /*0x3312b48*/ void System.Threading.IThreadPoolWorkItem.MarkAborted(System.Threading.ThreadAbortException tae);
        }

        class ThreadPool
        {
            static /*0x3312c64*/ System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce, ref System.Threading.StackCrawlMark stackMark, bool compressStack);
            static /*0x3312f70*/ System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
            static /*0x3312ff0*/ System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, System.TimeSpan timeout, bool executeOnlyOnce);
            static /*0x3312f20*/ bool QueueUserWorkItem(System.Threading.WaitCallback callBack, object state);
            static /*0x331323c*/ bool QueueUserWorkItem(System.Threading.WaitCallback callBack);
            static /*0x3312f48*/ bool UnsafeQueueUserWorkItem(System.Threading.WaitCallback callBack, object state);
            static /*0x1ffc854*/ bool QueueUserWorkItem<TState>(System.Action<TState> callBack, TState state, bool preferLocal);
            static /*0x3313120*/ bool QueueUserWorkItemHelper(System.Threading.WaitCallback callBack, object state, ref System.Threading.StackCrawlMark stackMark, bool compressStack, bool forceGlobal);
            static /*0x33132fc*/ void UnsafeQueueCustomWorkItem(System.Threading.IThreadPoolWorkItem workItem, bool forceGlobal);
            static /*0x331337c*/ bool TryPopCustomWorkItem(System.Threading.IThreadPoolWorkItem workItem);
            static /*0x331341c*/ bool RequestWorkerThread();
            static /*0x3313268*/ void EnsureVMInitialized();
            static /*0x3313424*/ bool NotifyWorkItemComplete();
            static /*0x3313428*/ void ReportThreadStatus(bool isWorking);
            static /*0x331342c*/ void NotifyWorkItemProgress();
            static /*0x331343c*/ void NotifyWorkItemProgressNative();
            static /*0x3313440*/ void NotifyWorkItemQueued();
            static /*0x3313420*/ void InitializeVMTp(ref bool enableWorkerTracking);
            static /*0x3313444*/ bool get_IsThreadPoolThread();

            class <>c__DisplayClass17_0<TState>
            {
                /*0x0*/ System.Action<TState> callBack;

                /*0x1f309e4*/ <>c__DisplayClass17_0();
                /*0x1f30ebc*/ void <QueueUserWorkItem>b__0(object x);
            }
        }

        class WaitHandle : System.MarshalByRefObject, System.IDisposable
        {
            static int WaitTimeout = 258;
            static int MAX_WAITHANDLES = 64;
            static int WAIT_OBJECT_0 = 0;
            static int WAIT_ABANDONED = 128;
            static int WAIT_FAILED = 2147483647;
            static int ERROR_TOO_MANY_POSTS = 298;
            static int ERROR_NOT_OWNED_BY_CALLER = 299;
            static int MaxWaitHandles = 64;
            static /*0x0*/ nint InvalidHandle;
            /*0x18*/ nint waitHandle;
            /*0x20*/ Microsoft.Win32.SafeHandles.SafeWaitHandle safeWaitHandle;
            /*0x28*/ bool hasThreadAffinity;

            static /*0x3314780*/ WaitHandle();
            static /*0x3313924*/ bool InternalWaitOne(System.Runtime.InteropServices.SafeHandle waitableSafeHandle, long millisecondsTimeout, bool hasThreadAffinity, bool exitContext);
            static /*0x3313c28*/ int WaitAny(System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);
            static /*0x3314464*/ int WaitAny(System.Threading.WaitHandle[] waitHandles, System.TimeSpan timeout, bool exitContext);
            static /*0x3314590*/ int WaitAny(System.Threading.WaitHandle[] waitHandles);
            static /*0x33145ec*/ int WaitAny(System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);
            static /*0x3313bf0*/ void ThrowAbandonedMutexException();
            static /*0x3314418*/ void ThrowAbandonedMutexException(int location, System.Threading.WaitHandle handle);
            static /*0x3313a10*/ int WaitOneNative(System.Runtime.InteropServices.SafeHandle waitableSafeHandle, uint millisecondsTimeout, bool hasThreadAffinity, bool exitContext);
            static /*0x3313f18*/ int WaitMultiple(System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext, bool WaitAll);
            static /*0x331477c*/ int Wait_internal(nint* handles, int numHandles, bool waitAll, int ms);
            /*0x3313464*/ WaitHandle();
            /*0x3313480*/ void Init();
            /*0x33134f8*/ void set_Handle(nint value);
            /*0x33135f0*/ Microsoft.Win32.SafeHandles.SafeWaitHandle get_SafeWaitHandle();
            /*0x33136a8*/ void SetHandleInternal(Microsoft.Win32.SafeHandles.SafeWaitHandle handle);
            /*0x33136e8*/ bool WaitOne(int millisecondsTimeout, bool exitContext);
            /*0x33137e8*/ bool WaitOne(System.TimeSpan timeout, bool exitContext);
            /*0x33138f0*/ bool WaitOne();
            /*0x3313904*/ bool WaitOne(int millisecondsTimeout);
            /*0x3313914*/ bool WaitOne(System.TimeSpan timeout);
            /*0x3313768*/ bool WaitOne(long timeout, bool exitContext);
            /*0x3314654*/ void Close();
            /*0x33146c4*/ void Dispose(bool explicitDisposing);
            /*0x331470c*/ void Dispose();
        }

        class Interlocked
        {
            static /*0x33123a0*/ int CompareExchange(ref int location1, int value, int comparand);
            static /*0x33147d4*/ int CompareExchange(ref int location1, int value, int comparand, ref bool succeeded);
            static /*0x33147d8*/ void CompareExchange(ref object location1, ref object value, ref object comparand, ref object result);
            static /*0x33147dc*/ object CompareExchange(ref object location1, object value, object comparand);
            static /*0x3314808*/ float CompareExchange(ref float location1, float value, float comparand);
            static /*0x331480c*/ int Decrement(ref int location);
            static /*0x3314810*/ int Increment(ref int location);
            static /*0x3314814*/ long Increment(ref long location);
            static /*0x3314818*/ int Exchange(ref int location1, int value);
            static /*0x331481c*/ void Exchange(ref object location1, ref object value, ref object result);
            static /*0x3314820*/ object Exchange(ref object location1, object value);
            static /*0x3314844*/ float Exchange(ref float location1, float value);
            static /*0x3314848*/ long CompareExchange(ref long location1, long value, long comparand);
            static /*0x331484c*/ nint CompareExchange(ref nint location1, nint value, nint comparand);
            static /*0x3314850*/ double CompareExchange(ref double location1, double value, double comparand);
            static /*0x1ffc854*/ T CompareExchange<T>(ref T location1, T value, T comparand);
            static /*0x3314854*/ long Exchange(ref long location1, long value);
            static /*0x3314858*/ nint Exchange(ref nint location1, nint value);
            static /*0x331485c*/ double Exchange(ref double location1, double value);
            static /*0x1ffc854*/ T Exchange<T>(ref T location1, T value);
            static /*0x3314860*/ long Read(ref long location);
            static /*0x3314864*/ int Add(ref int location1, int value);
            static /*0x3314868*/ long Add(ref long location1, long value);
            static /*0x331486c*/ void MemoryBarrier();
        }

        class LockQueue
        {
            /*0x10*/ System.Threading.ReaderWriterLock rwlock;
            /*0x18*/ int lockCount;

            /*0x3314874*/ LockQueue(System.Threading.ReaderWriterLock rwlock);
            /*0x33148a4*/ bool Wait(int timeout);
            /*0x3314a38*/ bool get_IsEmpty();
            /*0x3314afc*/ void Pulse();
        }

        class Mutex : System.Threading.WaitHandle
        {
        }

        class NativeEventCalls
        {
            static /*0x3314bb4*/ nint CreateEvent_internal(bool manual, bool initial, string name, ref int errorCode);
            static /*0x3314c08*/ nint CreateEvent_icall(bool manual, bool initial, char* name, int name_length, ref int errorCode);
            static /*0x3314c0c*/ bool SetEvent(Microsoft.Win32.SafeHandles.SafeWaitHandle handle);
            static /*0x3314cec*/ bool SetEvent_internal(nint handle);
            static /*0x3314cf0*/ bool ResetEvent(Microsoft.Win32.SafeHandles.SafeWaitHandle handle);
            static /*0x3314dd0*/ bool ResetEvent_internal(nint handle);
            static /*0x3314dd4*/ void CloseEvent_internal(nint handle);
        }

        class ReaderWriterLock : System.Runtime.ConstrainedExecution.CriticalFinalizerObject
        {
            /*0x10*/ int seq_num;
            /*0x14*/ int state;
            /*0x18*/ int readers;
            /*0x1c*/ int writer_lock_owner;
            /*0x20*/ System.Threading.LockQueue writer_queue;
            /*0x28*/ System.Collections.Hashtable reader_locks;

            /*0x3314dd8*/ ReaderWriterLock();
            /*0x3314ecc*/ void Finalize();
            /*0x3314ed4*/ void AcquireWriterLock(int millisecondsTimeout);
            /*0x3314edc*/ void AcquireWriterLock(int millisecondsTimeout, int initialLockCount);
            /*0x33150b8*/ void ReleaseWriterLock();
            /*0x33151e0*/ void ReleaseWriterLock(int releaseCount);
            /*0x3315084*/ bool HasWriterLock();
        }

        class RegisteredWaitHandle : System.MarshalByRefObject
        {
            /*0x18*/ System.Threading.WaitHandle _waitObject;
            /*0x20*/ System.Threading.WaitOrTimerCallback _callback;
            /*0x28*/ object _state;
            /*0x30*/ System.Threading.WaitHandle _finalEvent;
            /*0x38*/ System.Threading.ManualResetEvent _cancelEvent;
            /*0x40*/ System.TimeSpan _timeout;
            /*0x48*/ int _callsInProcess;
            /*0x4c*/ bool _executeOnlyOnce;
            /*0x4d*/ bool _unregistered;

            /*0x3312e2c*/ RegisteredWaitHandle(System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callback, object state, System.TimeSpan timeout, bool executeOnlyOnce);
            /*0x3315240*/ void Wait(object state);
            /*0x33157c4*/ void DoCallBack(object timedOut);
            /*0x33158a0*/ bool Unregister(System.Threading.WaitHandle waitObject);
        }

        class InternalThread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject
        {
            /*0x10*/ int lock_thread_id;
            /*0x18*/ nint handle;
            /*0x20*/ nint native_handle;
            /*0x28*/ nint name_chars;
            /*0x30*/ int name_free;
            /*0x34*/ int name_length;
            /*0x38*/ System.Threading.ThreadState state;
            /*0x40*/ object abort_exc;
            /*0x48*/ int abort_state_handle;
            /*0x50*/ long thread_id;
            /*0x58*/ nint debugger_thread;
            /*0x60*/ nuint static_data;
            /*0x68*/ nint runtime_thread_info;
            /*0x70*/ object current_appcontext;
            /*0x78*/ object root_domain_thread;
            /*0x80*/ byte[] _serialized_principal;
            /*0x88*/ int _serialized_principal_version;
            /*0x90*/ nint appdomain_refs;
            /*0x98*/ int interruption_requested;
            /*0xa0*/ nint longlived;
            /*0xa8*/ bool threadpool_thread;
            /*0xa9*/ bool thread_interrupt_requested;
            /*0xac*/ int stack_size;
            /*0xb0*/ byte apartment_state;
            /*0xb4*/ int critical_region_level;
            /*0xb8*/ int managed_id;
            /*0xbc*/ int small_id;
            /*0xc0*/ nint manage_callback;
            /*0xc8*/ nint flags;
            /*0xd0*/ nint thread_pinning_ref;
            /*0xd8*/ nint abort_protected_block_count;
            /*0xe0*/ int priority;
            /*0xe8*/ nint owned_mutex;
            /*0xf0*/ nint suspended_event;
            /*0xf8*/ int self_suspended;
            /*0x100*/ nint thread_state;
            /*0x108*/ nint netcore0;
            /*0x110*/ nint netcore1;
            /*0x118*/ nint netcore2;
            /*0x120*/ nint last;

            /*0x3315a34*/ InternalThread();
            /*0x33159ac*/ void Thread_free_internal();
            /*0x33159b0*/ void Finalize();
        }

        class Timer : System.MarshalByRefObject, System.IDisposable
        {
            /*0x18*/ System.Threading.TimerCallback callback;
            /*0x20*/ object state;
            /*0x28*/ long due_time_ms;
            /*0x30*/ long period_ms;
            /*0x38*/ long next_run;
            /*0x40*/ bool disposed;
            /*0x41*/ bool is_dead;
            /*0x42*/ bool is_added;

            static /*0x3315a44*/ System.Threading.Timer.Scheduler get_scheduler();
            static /*0x331603c*/ long GetTimeMonotonic();
            /*0x3315acc*/ Timer(System.Threading.TimerCallback callback, object state, int dueTime, int period);
            /*0x3315bbc*/ Timer(System.Threading.TimerCallback callback, object state, System.TimeSpan dueTime, System.TimeSpan period);
            /*0x3315b18*/ void Init(System.Threading.TimerCallback callback, object state, long dueTime, long period);
            /*0x3315e58*/ bool Change(int dueTime, int period);
            /*0x3315e78*/ bool Change(System.TimeSpan dueTime, System.TimeSpan period);
            /*0x3315f30*/ void Dispose();
            /*0x3315c90*/ bool Change(long dueTime, long period, bool first);
            /*0x33161d8*/ void KeepRootedWhileScheduled();

            struct TimerComparer : System.Collections.IComparer, System.Collections.Generic.IComparer<System.Threading.Timer>
            {
                /*0x33161dc*/ int System.Collections.IComparer.Compare(object x, object y);
                /*0x3316274*/ int Compare(System.Threading.Timer tx, System.Threading.Timer ty);
            }

            class Scheduler
            {
                static /*0x0*/ System.Threading.Timer.Scheduler instance;
                /*0x10*/ bool needReSort;
                /*0x18*/ System.Collections.Generic.List<System.Threading.Timer> list;
                /*0x20*/ long current_next_run;
                /*0x28*/ System.Threading.ManualResetEvent changed;

                static /*0x3316bdc*/ Scheduler();
                static /*0x33168c8*/ System.Threading.Timer.Scheduler get_Instance();
                static /*0x3316aa0*/ void TimerCB(object o);
                /*0x3316920*/ Scheduler();
                /*0x33162e4*/ void InitScheduler();
                /*0x33163ec*/ void WakeupScheduler();
                /*0x3316404*/ void SchedulerThread();
                /*0x3315f68*/ void Remove(System.Threading.Timer timer);
                /*0x3316040*/ void Change(System.Threading.Timer timer, long new_next_run);
                /*0x33169f8*/ void Add(System.Threading.Timer timer);
                /*0x33169c8*/ void InternalRemove(System.Threading.Timer timer);
                /*0x3316b18*/ void FireTimer(System.Threading.Timer timer);
                /*0x3316538*/ int RunSchedulerLoop();
            }
        }

        class TimerCallback : System.MulticastDelegate
        {
            /*0x3316c40*/ TimerCallback(object object, nint method);
            /*0x3316d48*/ void Invoke(object state);
        }

        class Volatile
        {
            static /*0x3316d5c*/ bool Read(ref bool location);
            static /*0x3316d74*/ void Write(ref bool location, bool value);
            static /*0x3316d98*/ int Read(ref int location);
            static /*0x3316db0*/ void Write(ref int location, int value);
            static /*0x1ffc854*/ T Read<T>(ref T location);
            static /*0x1ffc854*/ void Write<T>(ref T location, T value);
            static /*0x3316dd4*/ long Read(ref long location);

            struct VolatileBoolean
            {
                /*0x10*/ bool Value;
            }

            struct VolatileInt32
            {
                /*0x10*/ int Value;
            }

            struct VolatileObject
            {
                /*0x10*/ object Value;
            }
        }

        namespace Tasks
        {
            class TaskCanceledException : System.OperationCanceledException
            {
                /*0x98*/ System.Threading.Tasks.Task _canceledTask;

                /*0x3316dec*/ TaskCanceledException();
                /*0x3316e38*/ TaskCanceledException(System.Threading.Tasks.Task task);
                /*0x3316ee4*/ TaskCanceledException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            }

            class TaskCompletionSource<TResult>
            {
                /*0x0*/ System.Threading.Tasks.Task<TResult> _task;

                /*0x1f309e4*/ TaskCompletionSource();
                /*0x1f30b78*/ TaskCompletionSource(System.Threading.Tasks.TaskCreationOptions creationOptions);
                /*0x1f30ebc*/ TaskCompletionSource(object state);
                /*0x1f30ee8*/ TaskCompletionSource(object state, System.Threading.Tasks.TaskCreationOptions creationOptions);
                /*0x1f30214*/ System.Threading.Tasks.Task<TResult> get_Task();
                /*0x1f309e4*/ void SpinUntilCompleted();
                /*0x1f2fec8*/ bool TrySetException(System.Exception exception);
                /*0x1f30ebc*/ void SetException(System.Exception exception);
                /*0x1ffc854*/ bool TrySetResult(TResult result);
                /*0x1ffc854*/ void SetResult(TResult result);
                /*0x1f2fe14*/ bool TrySetCanceled();
                /*0x1ffc854*/ bool TrySetCanceled(System.Threading.CancellationToken cancellationToken);
                /*0x1f309e4*/ void SetCanceled();
            }

            class TaskSchedulerException : System.Exception
            {
                /*0x3316eec*/ TaskSchedulerException();
                /*0x3316f5c*/ TaskSchedulerException(System.Exception innerException);
                /*0x3316fdc*/ TaskSchedulerException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            }

            class TaskToApm
            {
                static /*0x331705c*/ System.IAsyncResult Begin(System.Threading.Tasks.Task task, System.AsyncCallback callback, object state);
                static /*0x3317310*/ void End(System.IAsyncResult asyncResult);
                static /*0x1ffc854*/ TResult End<TResult>(System.IAsyncResult asyncResult);
                static /*0x3317200*/ void InvokeCallbackWhenTaskCompletes(System.Threading.Tasks.Task antecedent, System.AsyncCallback callback, System.IAsyncResult asyncResult);

                class TaskWrapperAsyncResult : System.IAsyncResult
                {
                    /*0x10*/ System.Threading.Tasks.Task Task;
                    /*0x18*/ object _state;
                    /*0x20*/ bool _completedSynchronously;

                    /*0x33171a8*/ TaskWrapperAsyncResult(System.Threading.Tasks.Task task, object state, bool completedSynchronously);
                    /*0x3317460*/ object System.IAsyncResult.get_AsyncState();
                    /*0x3317468*/ bool System.IAsyncResult.get_CompletedSynchronously();
                    /*0x3317470*/ bool System.IAsyncResult.get_IsCompleted();
                    /*0x3317484*/ System.Threading.WaitHandle System.IAsyncResult.get_AsyncWaitHandle();
                }

                class <>c__DisplayClass3_0
                {
                    /*0x10*/ System.AsyncCallback callback;
                    /*0x18*/ System.IAsyncResult asyncResult;

                    /*0x3317428*/ <>c__DisplayClass3_0();
                    /*0x3317528*/ void <InvokeCallbackWhenTaskCompletes>b__0();
                }
            }

            struct ValueTask : System.IEquatable<System.Threading.Tasks.ValueTask>
            {
                static /*0x0*/ System.Threading.Tasks.Task s_canceledTask;
                /*0x10*/ object _obj;
                /*0x18*/ short _token;
                /*0x1a*/ bool _continueOnCapturedContext;

                static /*0x33180dc*/ ValueTask();
                static /*0x331754c*/ System.Threading.Tasks.Task get_CompletedTask();
                /*0x33175d4*/ ValueTask(System.Threading.Tasks.Task task);
                /*0x3317618*/ ValueTask(System.Threading.Tasks.Sources.IValueTaskSource source, short token);
                /*0x3317660*/ ValueTask(object obj, short token, bool continueOnCapturedContext);
                /*0x3317690*/ int GetHashCode();
                /*0x33176a8*/ bool Equals(object obj);
                /*0x3317760*/ bool Equals(System.Threading.Tasks.ValueTask other);
                /*0x3317784*/ System.Threading.Tasks.Task AsTask();
                /*0x3317850*/ System.Threading.Tasks.Task GetTaskForValueTaskSource(System.Threading.Tasks.Sources.IValueTaskSource t);
                /*0x3317d14*/ bool get_IsCompleted();
                /*0x3317e18*/ bool get_IsCompletedSuccessfully();
                /*0x3317f50*/ void ThrowIfCompletedUnsuccessfully();
                /*0x3318054*/ System.Runtime.CompilerServices.ValueTaskAwaiter GetAwaiter();
                /*0x3318084*/ System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);

                class ValueTaskSourceAsTask : System.Threading.Tasks.Task<System.Threading.Tasks.VoidTaskResult>
                {
                    static /*0x0*/ System.Action<object> s_completionAction;
                    /*0x58*/ System.Threading.Tasks.Sources.IValueTaskSource _source;
                    /*0x60*/ short _token;

                    static /*0x33181c8*/ ValueTaskSourceAsTask();
                    /*0x3317be8*/ ValueTaskSourceAsTask(System.Threading.Tasks.Sources.IValueTaskSource source, short token);

                    class <>c
                    {
                        static /*0x0*/ System.Threading.Tasks.ValueTask.ValueTaskSourceAsTask.<> <>9;

                        static /*0x3318298*/ <>c();
                        /*0x3318300*/ <>c();
                        /*0x3318308*/ void <.cctor>b__4_0(object state);
                    }
                }
            }

            struct ValueTask<TResult> : System.IEquatable<System.Threading.Tasks.ValueTask<TResult>>
            {
                static /*0x0*/ System.Threading.Tasks.Task<TResult> s_canceledTask;
                /*0x0*/ object _obj;
                /*0x0*/ TResult _result;
                /*0x0*/ short _token;
                /*0x0*/ bool _continueOnCapturedContext;

                /*0x1ffc854*/ ValueTask(TResult result);
                /*0x1f30ebc*/ ValueTask(System.Threading.Tasks.Task<TResult> task);
                /*0x1ffc854*/ ValueTask(System.Threading.Tasks.Sources.IValueTaskSource<TResult> source, short token);
                /*0x1ffc854*/ ValueTask(object obj, TResult result, short token, bool continueOnCapturedContext);
                /*0x1f2ffc8*/ int GetHashCode();
                /*0x1f2fec8*/ bool Equals(object obj);
                /*0x1ffc854*/ bool Equals(System.Threading.Tasks.ValueTask<TResult> other);
                /*0x1f30214*/ System.Threading.Tasks.Task<TResult> AsTask();
                /*0x1f302cc*/ System.Threading.Tasks.Task<TResult> GetTaskForValueTaskSource(System.Threading.Tasks.Sources.IValueTaskSource<TResult> t);
                /*0x1f2fe14*/ bool get_IsCompleted();
                /*0x1f2fe14*/ bool get_IsCompletedSuccessfully();
                /*0x1ffc854*/ TResult get_Result();
                /*0x1ffc854*/ System.Runtime.CompilerServices.ValueTaskAwaiter<TResult> GetAwaiter();
                /*0x1ffc854*/ System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable<TResult> ConfigureAwait(bool continueOnCapturedContext);
                /*0x1f30214*/ string ToString();

                class ValueTaskSourceAsTask<TResult> : System.Threading.Tasks.Task<TResult>
                {
                    static /*0x0*/ System.Action<object> s_completionAction;
                    /*0x0*/ System.Threading.Tasks.Sources.IValueTaskSource<TResult> _source;
                    /*0x0*/ short _token;

                    static /*0x1f33998*/ ValueTaskSourceAsTask();
                    /*0x1ffc854*/ ValueTaskSourceAsTask(System.Threading.Tasks.Sources.IValueTaskSource<TResult> source, short token);

                    class <>c<TResult>
                    {
                        static /*0x0*/ System.Threading.Tasks.ValueTask.ValueTaskSourceAsTask.<>c<TResult> <>9;

                        static /*0x1f33998*/ <>c();
                        /*0x1f309e4*/ <>c();
                        /*0x1f30ebc*/ void <.cctor>b__4_0(object state);
                    }
                }
            }

            class TaskAwaiters
            {
                static /*0x3318630*/ System.Threading.Tasks.ForceAsyncAwaiter ForceAsync(System.Threading.Tasks.Task task);
            }

            struct ForceAsyncAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion
            {
                /*0x10*/ System.Threading.Tasks.Task _task;

                /*0x331864c*/ ForceAsyncAwaiter(System.Threading.Tasks.Task task);
                /*0x3318654*/ System.Threading.Tasks.ForceAsyncAwaiter GetAwaiter();
                /*0x331865c*/ bool get_IsCompleted();
                /*0x3318664*/ void GetResult();
                /*0x33186a4*/ void UnsafeOnCompleted(System.Action action);
            }

            class DebuggerSupport
            {
                static /*0x0*/ System.Collections.Generic.LowLevelDictionary<int, System.Threading.Tasks.Task> s_activeTasks;
                static /*0x8*/ object s_activeTasksLock;

                static /*0x3318b90*/ DebuggerSupport();
                static /*0x33186f8*/ bool get_LoggingOn();
                static /*0x3318700*/ void TraceOperationCreation(System.Threading.Tasks.CausalityTraceLevel traceLevel, System.Threading.Tasks.Task task, string operationName, ulong relatedContext);
                static /*0x3318704*/ void TraceOperationCompletion(System.Threading.Tasks.CausalityTraceLevel traceLevel, System.Threading.Tasks.Task task, Internal.Runtime.Augments.AsyncStatus status);
                static /*0x3318708*/ void TraceOperationRelation(System.Threading.Tasks.CausalityTraceLevel traceLevel, System.Threading.Tasks.Task task, System.Threading.Tasks.CausalityRelation relation);
                static /*0x331870c*/ void TraceSynchronousWorkStart(System.Threading.Tasks.CausalityTraceLevel traceLevel, System.Threading.Tasks.Task task, System.Threading.Tasks.CausalitySynchronousWork work);
                static /*0x3318710*/ void TraceSynchronousWorkCompletion(System.Threading.Tasks.CausalityTraceLevel traceLevel, System.Threading.Tasks.CausalitySynchronousWork work);
                static /*0x3318714*/ void AddToActiveTasks(System.Threading.Tasks.Task task);
                static /*0x33187a8*/ void AddToActiveTasksNonInlined(System.Threading.Tasks.Task task);
                static /*0x331899c*/ void RemoveFromActiveTasks(System.Threading.Tasks.Task task);
                static /*0x3318a30*/ void RemoveFromActiveTasksNonInlined(System.Threading.Tasks.Task task);
            }

            class Task<TResult> : System.Threading.Tasks.Task
            {
                static /*0x0*/ System.Threading.Tasks.TaskFactory<TResult> s_defaultFactory;
                /*0x0*/ TResult m_result;

                static /*0x1ffc854*/ System.Threading.Tasks.Task<TResult> StartNew(System.Threading.Tasks.Task parent, System.Func<TResult> function, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.InternalTaskOptions internalOptions, System.Threading.Tasks.TaskScheduler scheduler);
                static /*0x1ffc854*/ System.Threading.Tasks.Task<TResult> StartNew(System.Threading.Tasks.Task parent, System.Func<object, TResult> function, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.InternalTaskOptions internalOptions, System.Threading.Tasks.TaskScheduler scheduler);
                static /*0x1f327a0*/ System.Threading.Tasks.TaskFactory<TResult> get_Factory();
                /*0x1f309e4*/ Task();
                /*0x1f30ee8*/ Task(object state, System.Threading.Tasks.TaskCreationOptions options);
                /*0x1ffc854*/ Task(TResult result);
                /*0x1ffc854*/ Task(bool canceled, TResult result, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.CancellationToken ct);
                /*0x1ffc854*/ Task(System.Func<object, TResult> function, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);
                /*0x1ffc854*/ Task(System.Func<TResult> valueSelector, System.Threading.Tasks.Task parent, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.InternalTaskOptions internalOptions, System.Threading.Tasks.TaskScheduler scheduler);
                /*0x1ffc854*/ Task(System.Delegate valueSelector, object state, System.Threading.Tasks.Task parent, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.InternalTaskOptions internalOptions, System.Threading.Tasks.TaskScheduler scheduler);
                /*0x1ffc854*/ bool TrySetResult(TResult result);
                /*0x1ffc854*/ void DangerousSetResult(TResult result);
                /*0x1ffc854*/ TResult get_Result();
                /*0x1ffc854*/ TResult get_ResultOnSuccess();
                /*0x1ffc854*/ TResult GetResultCore(bool waitCompletionNotification);
                /*0x1f309e4*/ void InnerInvoke();
                /*0x1ffc854*/ System.Runtime.CompilerServices.TaskAwaiter<TResult> GetAwaiter();
                /*0x1ffc854*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable<TResult> ConfigureAwait(bool continueOnCapturedContext);
                /*0x1f302cc*/ System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>> continuationAction);
                /*0x1f30394*/ System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>> continuationAction, System.Threading.Tasks.TaskScheduler scheduler);
                /*0x1ffc854*/ System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>> continuationAction, System.Threading.Tasks.TaskScheduler scheduler, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                /*0x1f302cc*/ System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, TNewResult> continuationFunction);
                /*0x1f30300*/ System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, TNewResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                /*0x1ffc854*/ System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, TNewResult> continuationFunction, System.Threading.Tasks.TaskScheduler scheduler, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
            }

            class SystemThreadingTasks_FutureDebugView<TResult>
            {
            }

            class TaskFactory<TResult>
            {
                /*0x0*/ System.Threading.CancellationToken m_defaultCancellationToken;
                /*0x0*/ System.Threading.Tasks.TaskScheduler m_defaultScheduler;
                /*0x0*/ System.Threading.Tasks.TaskCreationOptions m_defaultCreationOptions;
                /*0x0*/ System.Threading.Tasks.TaskContinuationOptions m_defaultContinuationOptions;

                static /*0x1ffc854*/ void FromAsyncCoreLogic(System.IAsyncResult iar, System.Func<System.IAsyncResult, TResult> endFunction, System.Action<System.IAsyncResult> endAction, System.Threading.Tasks.Task<TResult> promise, bool requiresSynchronization);
                static /*0x1ffc854*/ System.Threading.Tasks.Task<TResult> FromAsyncImpl(System.Func<System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endFunction, System.Action<System.IAsyncResult> endAction, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);
                static /*0x1ffc854*/ System.Threading.Tasks.Task<TResult> FromAsyncImpl<TArg1>(System.Func<TArg1, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endFunction, System.Action<System.IAsyncResult> endAction, TArg1 arg1, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);
                static /*0x1ffc854*/ System.Threading.Tasks.Task<TResult> FromAsyncImpl<TArg1, TArg2>(System.Func<TArg1, TArg2, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endFunction, System.Action<System.IAsyncResult> endAction, TArg1 arg1, TArg2 arg2, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);
                static /*0x1ffc854*/ System.Threading.Tasks.Task<TResult> FromAsyncTrim<TInstance, TArgs>(TInstance thisRef, TArgs args, System.Func<TInstance, TArgs, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<TInstance, System.IAsyncResult, TResult> endMethod);
                /*0x1f309e4*/ TaskFactory();
                /*0x1ffc854*/ TaskFactory(System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                /*0x1f303d0*/ System.Threading.Tasks.Task<TResult> FromAsync(System.Func<System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, object state);
                /*0x1ffc854*/ System.Threading.Tasks.Task<TResult> FromAsync<TArg1>(System.Func<TArg1, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, object state);

                class FromAsyncTrimPromise`1<TResult, TInstance> : System.Threading.Tasks.Task<TResult>
                {
                    static /*0x0*/ System.AsyncCallback s_completeFromAsyncResult;
                    /*0x0*/ TInstance m_thisRef;
                    /*0x0*/ System.Func<TInstance, System.IAsyncResult, TResult> m_endMethod;

                    static /*0x1f33998*/ FromAsyncTrimPromise`1();
                    static /*0x1f350f8*/ void CompleteFromAsyncResult(System.IAsyncResult asyncResult);
                    /*0x1ffc854*/ FromAsyncTrimPromise`1(TInstance thisRef, System.Func<TInstance, System.IAsyncResult, TResult> endMethod);
                    /*0x1ffc854*/ void Complete(TInstance thisRef, System.Func<TInstance, System.IAsyncResult, TResult> endMethod, System.IAsyncResult asyncResult, bool requiresSynchronization);
                }

                class <>c__DisplayClass35_0<TResult>
                {
                    /*0x0*/ System.Func<System.IAsyncResult, TResult> endFunction;
                    /*0x0*/ System.Action<System.IAsyncResult> endAction;
                    /*0x0*/ System.Threading.Tasks.Task<TResult> promise;

                    /*0x1f309e4*/ <>c__DisplayClass35_0();
                    /*0x1f30ebc*/ void <FromAsyncImpl>b__0(System.IAsyncResult iar);
                }

                class <>c__DisplayClass38_0`1<TResult, TArg1>
                {
                    /*0x0*/ System.Func<System.IAsyncResult, TResult> endFunction;
                    /*0x0*/ System.Action<System.IAsyncResult> endAction;
                    /*0x0*/ System.Threading.Tasks.Task<TResult> promise;

                    /*0x1f309e4*/ <>c__DisplayClass38_0`1();
                    /*0x1f30ebc*/ void <FromAsyncImpl>b__0(System.IAsyncResult iar);
                }

                class <>c__DisplayClass41_0`2<TResult, TArg1, TArg2>
                {
                    /*0x0*/ System.Func<System.IAsyncResult, TResult> endFunction;
                    /*0x0*/ System.Action<System.IAsyncResult> endAction;
                    /*0x0*/ System.Threading.Tasks.Task<TResult> promise;

                    /*0x1f309e4*/ <>c__DisplayClass41_0`2();
                    /*0x1f30ebc*/ void <FromAsyncImpl>b__0(System.IAsyncResult iar);
                }
            }

            enum TaskStatus
            {
                Created = 0,
                WaitingForActivation = 1,
                WaitingToRun = 2,
                Running = 3,
                WaitingForChildrenToComplete = 4,
                RanToCompletion = 5,
                Canceled = 6,
                Faulted = 7,
            }

            class Task : System.Threading.IThreadPoolWorkItem, System.IAsyncResult, System.IDisposable
            {
                static /*0x0*/ int s_taskIdCounter;
                static /*0x8*/ object s_taskCompletionSentinel;
                static /*0x10*/ bool s_asyncDebuggingEnabled;
                static /*0x18*/ System.Action<object> s_taskCancelCallback;
                static /*0x20*/ System.Func<System.Threading.Tasks.Task.ContingentProperties> s_createContingentProperties;
                static /*0x28*/ System.Threading.Tasks.TaskFactory <Factory>k__BackingField;
                static /*0x30*/ System.Threading.Tasks.Task <CompletedTask>k__BackingField;
                static /*0x38*/ System.Predicate<System.Threading.Tasks.Task> s_IsExceptionObservedByParentPredicate;
                static /*0x40*/ System.Threading.ContextCallback s_ecCallback;
                static /*0x48*/ System.Predicate<object> s_IsTaskContinuationNullPredicate;
                static /*0x50*/ System.Collections.Generic.Dictionary<int, System.Threading.Tasks.Task> s_currentActiveTasks;
                static /*0x58*/ object s_activeTasksLock;
                [ThreadStatic] static System.Threading.Tasks.Task t_currentTask;
                [ThreadStatic] static System.Threading.Tasks.StackGuard t_stackGuard;
                /*0x10*/ int m_taskId;
                /*0x18*/ System.Delegate m_action;
                /*0x20*/ object m_stateObject;
                /*0x28*/ System.Threading.Tasks.TaskScheduler m_taskScheduler;
                /*0x30*/ System.Threading.Tasks.Task m_parent;
                /*0x38*/ int m_stateFlags;
                /*0x40*/ object m_continuationObject;
                /*0x48*/ System.Threading.Tasks.Task.ContingentProperties m_contingentProperties;

                static /*0x3320190*/ Task();
                static /*0x33197f4*/ void TaskCancelCallback(object o);
                static /*0x3319fc4*/ System.Threading.Tasks.TaskCreationOptions OptionsMethod(int flags);
                static /*0x331a258*/ System.Threading.Tasks.Task InternalStartNew(System.Threading.Tasks.Task creatingTask, System.Delegate action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskScheduler scheduler, System.Threading.Tasks.TaskCreationOptions options, System.Threading.Tasks.InternalTaskOptions internalOptions);
                static /*0x331a56c*/ System.Threading.Tasks.Task get_InternalCurrent();
                static /*0x331a5c4*/ System.Threading.Tasks.Task InternalCurrentIfAttached(System.Threading.Tasks.TaskCreationOptions creationOptions);
                static /*0x331a65c*/ System.Threading.Tasks.StackGuard get_CurrentStackGuard();
                static /*0x331aac8*/ bool IsCompletedMethod(int flags);
                static /*0x331ac6c*/ System.Threading.Tasks.TaskFactory get_Factory();
                static /*0x331acc4*/ System.Threading.Tasks.Task get_CompletedTask();
                static /*0x331cb68*/ void ExecutionContextCallback(object obj);
                static /*0x331d0bc*/ System.Runtime.CompilerServices.YieldAwaitable Yield();
                static /*0x331e474*/ void CreationOptionsFromContinuationOptions(System.Threading.Tasks.TaskContinuationOptions continuationOptions, ref System.Threading.Tasks.TaskCreationOptions creationOptions, ref System.Threading.Tasks.InternalTaskOptions internalOptions);
                static /*0x1ffc854*/ System.Threading.Tasks.Task<TResult> FromResult<TResult>(TResult result);
                static /*0x3317b7c*/ System.Threading.Tasks.Task FromException(System.Exception exception);
                static /*0x1f327cc*/ System.Threading.Tasks.Task<TResult> FromException<TResult>(System.Exception exception);
                static /*0x331ed68*/ System.Threading.Tasks.Task FromCancellation(System.Threading.CancellationToken cancellationToken);
                static /*0x3318174*/ System.Threading.Tasks.Task FromCanceled(System.Threading.CancellationToken cancellationToken);
                static System.Threading.Tasks.Task<TResult> FromCancellation<TResult>(System.Threading.CancellationToken cancellationToken);
                static System.Threading.Tasks.Task<TResult> FromCanceled<TResult>(System.Threading.CancellationToken cancellationToken);
                static /*0x1f327cc*/ System.Threading.Tasks.Task<TResult> FromCancellation<TResult>(System.OperationCanceledException exception);
                static /*0x331ee48*/ System.Threading.Tasks.Task Run(System.Action action);
                static /*0x1f327cc*/ System.Threading.Tasks.Task<TResult> Run<TResult>(System.Func<TResult> function);
                static /*0x331ef18*/ System.Threading.Tasks.Task Run(System.Func<System.Threading.Tasks.Task> function);
                static /*0x331ef70*/ System.Threading.Tasks.Task Run(System.Func<System.Threading.Tasks.Task> function, System.Threading.CancellationToken cancellationToken);
                static /*0x1f327cc*/ System.Threading.Tasks.Task<TResult> Run<TResult>(System.Func<System.Threading.Tasks.Task<TResult>> function);
                static /*0x1ffc854*/ System.Threading.Tasks.Task<TResult> Run<TResult>(System.Func<System.Threading.Tasks.Task<TResult>> function, System.Threading.CancellationToken cancellationToken);
                static /*0x331f1a8*/ System.Threading.Tasks.Task Delay(int millisecondsDelay);
                static /*0x331f200*/ System.Threading.Tasks.Task Delay(int millisecondsDelay, System.Threading.CancellationToken cancellationToken);
                static /*0x331f6c8*/ System.Threading.Tasks.Task<System.Threading.Tasks.Task> WhenAny(System.Threading.Tasks.Task[] tasks);
                static /*0x331fa9c*/ System.Threading.Tasks.Task<System.Threading.Tasks.Task> WhenAny(System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task> tasks);
                static System.Threading.Tasks.Task<TResult> CreateUnwrapPromise<TResult>(System.Threading.Tasks.Task outerTask, bool lookForOce);
                static /*0x331fec8*/ bool AddToActiveTasks(System.Threading.Tasks.Task task);
                static /*0x3320034*/ void RemoveFromActiveTasks(int taskId);
                /*0x3318c64*/ Task(bool canceled, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.CancellationToken ct);
                /*0x3318d58*/ Task();
                /*0x3318d80*/ Task(object state, System.Threading.Tasks.TaskCreationOptions creationOptions, bool promiseStyle);
                /*0x3319050*/ Task(System.Delegate action, object state, System.Threading.Tasks.Task parent, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.InternalTaskOptions internalOptions, System.Threading.Tasks.TaskScheduler scheduler);
                /*0x3318ea8*/ void TaskConstructorCore(System.Delegate action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.InternalTaskOptions internalOptions, System.Threading.Tasks.TaskScheduler scheduler);
                /*0x33191a8*/ void AssignCancellationToken(System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.Task antecedent, System.Threading.Tasks.TaskContinuation continuation);
                /*0x33185bc*/ bool TrySetCanceled(System.Threading.CancellationToken tokenToRecord);
                /*0x3317b24*/ bool TrySetCanceled(System.Threading.CancellationToken tokenToRecord, object cancellationException);
                /*0x33185c4*/ bool TrySetException(object exceptionObject);
                /*0x331959c*/ System.Threading.Tasks.TaskCreationOptions get_Options();
                /*0x3319bf8*/ bool AtomicStateUpdate(int newBits, int illegalBits);
                /*0x3319fcc*/ bool AtomicStateUpdate(int newBits, int illegalBits, ref int oldFlags);
                /*0x331a0a4*/ void SetNotificationForWaitCompletion(bool enabled);
                /*0x331a17c*/ bool NotifyDebuggerOfWaitCompletionIfNecessary();
                /*0x331a20c*/ bool get_IsWaitNotificationEnabledOrNotRanToCompletion();
                /*0x331a234*/ bool get_ShouldNotifyDebuggerOfWaitCompletion();
                /*0x331a1cc*/ bool get_IsWaitNotificationEnabled();
                /*0x331a1e4*/ void NotifyDebuggerOfWaitCompletion();
                /*0x331a24c*/ bool MarkStarted();
                /*0x3319134*/ void AddNewChild();
                /*0x33197b0*/ void DisregardChild();
                /*0x331890c*/ int get_Id();
                /*0x331a720*/ System.AggregateException get_Exception();
                /*0x331a8c4*/ System.Threading.Tasks.TaskStatus get_Status();
                /*0x331a924*/ bool get_IsCanceled();
                /*0x331a944*/ bool get_IsCancellationRequested();
                /*0x331955c*/ System.Threading.Tasks.Task.ContingentProperties EnsureContingentPropertiesInitialized(bool needsProtection);
                /*0x331a9d0*/ System.Threading.Tasks.Task.ContingentProperties EnsureContingentPropertiesInitializedCore(bool needsProtection);
                /*0x3316ec0*/ System.Threading.CancellationToken get_CancellationToken();
                /*0x331aab0*/ bool get_IsCancellationAcknowledged();
                /*0x3317144*/ bool get_IsCompleted();
                /*0x3317f28*/ bool get_IsCompletedSuccessfully();
                /*0x3319120*/ System.Threading.Tasks.TaskCreationOptions get_CreationOptions();
                /*0x331aad8*/ System.Threading.WaitHandle System.IAsyncResult.get_AsyncWaitHandle();
                /*0x331ac54*/ object get_AsyncState();
                /*0x331ac5c*/ bool System.IAsyncResult.get_CompletedSynchronously();
                /*0x331ac64*/ System.Threading.Tasks.TaskScheduler get_ExecutingTaskScheduler();
                /*0x331ab5c*/ System.Threading.ManualResetEventSlim get_CompletedEvent();
                /*0x331ad1c*/ bool get_ExceptionRecorded();
                /*0x331a75c*/ bool get_IsFaulted();
                /*0x331ad8c*/ System.Threading.ExecutionContext get_CapturedContext();
                /*0x33194ac*/ void set_CapturedContext(System.Threading.ExecutionContext value);
                /*0x331adfc*/ void Dispose();
                /*0x331ae68*/ void Dispose(bool disposing);
                /*0x331a360*/ void ScheduleAndStart(bool needsProtection);
                /*0x3319e14*/ void AddException(object exceptionObject);
                /*0x331afcc*/ void AddException(object exceptionObject, bool representsCancellation);
                /*0x331a774*/ System.AggregateException GetExceptions(bool includeTaskCanceledExceptions);
                /*0x331b39c*/ System.Collections.ObjectModel.ReadOnlyCollection<System.Runtime.ExceptionServices.ExceptionDispatchInfo> GetExceptionDispatchInfos();
                /*0x331b548*/ System.Runtime.ExceptionServices.ExceptionDispatchInfo GetCancellationExceptionDispatchInfo();
                /*0x331b578*/ void ThrowIfExceptional(bool includeTaskCanceledExceptions);
                /*0x331b5bc*/ void UpdateExceptionObservedStatus();
                /*0x331b690*/ bool get_IsExceptionObservedByParent();
                /*0x331b6a8*/ bool get_IsDelegateInvoked();
                /*0x3319e1c*/ void Finish(bool bUserDelegateExecuted);
                /*0x331b6c0*/ void FinishStageTwo();
                /*0x331be9c*/ void FinishStageThree();
                /*0x331befc*/ void ProcessChildCompletion(System.Threading.Tasks.Task childTask);
                /*0x331b938*/ void AddExceptionsFromChildren();
                /*0x331c6b0*/ void Execute();
                /*0x331c864*/ void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
                /*0x331c86c*/ bool ExecuteEntry(bool bPreventDoubleExecution);
                /*0x331cbe0*/ void InnerInvoke();
                /*0x331c75c*/ void HandleException(System.Exception unhandledException);
                /*0x331740c*/ System.Runtime.CompilerServices.TaskAwaiter GetAwaiter();
                /*0x3317430*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);
                /*0x331ccc0*/ void SetContinuationForAwait(System.Action continuationAction, bool continueOnCapturedContext, bool flowExecutionContext);
                /*0x331d0c4*/ void Wait();
                /*0x331d220*/ bool Wait(int millisecondsTimeout);
                /*0x331d0d0*/ bool Wait(int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);
                /*0x331d7d0*/ bool WrappedTryRunInline();
                /*0x331d228*/ bool InternalWait(int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);
                /*0x331db18*/ bool SpinThenBlockingWait(int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);
                /*0x331dcd0*/ bool SpinWait(int millisecondsTimeout);
                /*0x33195f8*/ bool InternalCancel(bool bCancelNonExecutingOnly);
                /*0x331dedc*/ void RecordInternalCancellationRequest();
                /*0x331df24*/ void RecordInternalCancellationRequest(System.Threading.CancellationToken tokenToRecord);
                /*0x3319cb8*/ void RecordInternalCancellationRequest(System.Threading.CancellationToken tokenToRecord, object cancellationException);
                /*0x3319cf4*/ void CancellationCleanupLogic();
                /*0x331cc94*/ void SetCancellationAcknowledged();
                /*0x331c0b4*/ void FinishContinuations();
                /*0x331e1a4*/ void LogFinishCompletionNotification();
                /*0x331e1f8*/ System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task> continuationAction);
                /*0x331e460*/ System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task> continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                /*0x331e30c*/ System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task> continuationAction, System.Threading.Tasks.TaskScheduler scheduler, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                /*0x331e7ac*/ System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task, object> continuationAction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                /*0x331e7c0*/ System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task, object> continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                /*0x1f302cc*/ System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, TResult> continuationFunction);
                /*0x1ffc854*/ System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.Tasks.TaskScheduler scheduler, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                /*0x331e650*/ void ContinueWithCore(System.Threading.Tasks.Task continuationTask, System.Threading.Tasks.TaskScheduler scheduler, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions options);
                /*0x331ea64*/ void AddCompletionAction(System.Threading.Tasks.ITaskCompletionAction action);
                /*0x331de08*/ void AddCompletionAction(System.Threading.Tasks.ITaskCompletionAction action, bool addBeforeOthers);
                /*0x331ea6c*/ bool AddTaskContinuationComplex(object tc, bool addBeforeOthers);
                /*0x331cfc8*/ bool AddTaskContinuation(object tc, bool addBeforeOthers);
                /*0x33199b0*/ void RemoveContinuation(object continuationObject);
                /*0x3320180*/ void MarkAborted(System.Threading.ThreadAbortException e);
                /*0x331c988*/ void ExecuteWithThreadLocal(ref System.Threading.Tasks.Task currentTaskSlot);

                class ContingentProperties
                {
                    /*0x10*/ System.Threading.ExecutionContext m_capturedContext;
                    /*0x18*/ System.Threading.ManualResetEventSlim m_completionEvent;
                    /*0x20*/ System.Threading.Tasks.TaskExceptionHolder m_exceptionsHolder;
                    /*0x28*/ System.Threading.CancellationToken m_cancellationToken;
                    /*0x30*/ object m_cancellationRegistration;
                    /*0x38*/ int m_internalCancellationRequested;
                    /*0x3c*/ int m_completionCountdown;
                    /*0x40*/ System.Collections.Generic.LowLevelListWithIList<System.Threading.Tasks.Task> m_exceptionalChildren;

                    /*0x3318d34*/ ContingentProperties();
                    /*0x331bd40*/ void SetCompleted();
                    /*0x331bd68*/ void UnregisterCancellationCallback();
                }

                class SetOnInvokeMres : System.Threading.ManualResetEventSlim, System.Threading.Tasks.ITaskCompletionAction
                {
                    /*0x331dda8*/ SetOnInvokeMres();
                    /*0x33204d8*/ void Invoke(System.Threading.Tasks.Task completingTask);
                    /*0x33204e0*/ bool get_InvokeMayRunArbitraryCode();
                }

                class DelayPromise : System.Threading.Tasks.Task<System.Threading.Tasks.VoidTaskResult>
                {
                    /*0x58*/ System.Threading.CancellationToken Token;
                    /*0x60*/ System.Threading.CancellationTokenRegistration Registration;
                    /*0x78*/ System.Threading.Timer Timer;

                    /*0x331f5a8*/ DelayPromise(System.Threading.CancellationToken token);
                    /*0x33204e8*/ void Complete();
                }

                class <>c
                {
                    static /*0x0*/ System.Threading.Tasks.Task.<> <>9;
                    static /*0x8*/ System.Action<object> <>9__247_0;
                    static /*0x10*/ System.Threading.TimerCallback <>9__247_1;

                    static /*0x332064c*/ <>c();
                    /*0x33206b4*/ <>c();
                    /*0x33206bc*/ void <Delay>b__247_0(object state);
                    /*0x332071c*/ void <Delay>b__247_1(object state);
                    /*0x332077c*/ System.Threading.Tasks.Task.ContingentProperties <.cctor>b__271_0();
                    /*0x33207e0*/ bool <.cctor>b__271_1(System.Threading.Tasks.Task t);
                    /*0x3320800*/ bool <.cctor>b__271_2(object tc);
                }
            }

            class CompletionActionInvoker : System.Threading.IThreadPoolWorkItem
            {
                /*0x10*/ System.Threading.Tasks.ITaskCompletionAction m_action;
                /*0x18*/ System.Threading.Tasks.Task m_completingTask;

                /*0x331e160*/ CompletionActionInvoker(System.Threading.Tasks.ITaskCompletionAction action, System.Threading.Tasks.Task completingTask);
                /*0x332080c*/ void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
                /*0x33208b4*/ void MarkAborted(System.Threading.ThreadAbortException e);
            }

            class SystemThreadingTasks_TaskDebugView
            {
            }

            enum TaskCreationOptions
            {
                None = 0,
                PreferFairness = 1,
                LongRunning = 2,
                AttachedToParent = 4,
                DenyChildAttach = 8,
                HideScheduler = 16,
                RunContinuationsAsynchronously = 64,
            }

            enum InternalTaskOptions
            {
                None = 0,
                InternalOptionsMask = 65280,
                ContinuationTask = 512,
                PromiseTask = 1024,
                LazyCancellation = 4096,
                QueuedByRuntime = 8192,
                DoNotDispose = 16384,
            }

            enum TaskContinuationOptions
            {
                None = 0,
                PreferFairness = 1,
                LongRunning = 2,
                AttachedToParent = 4,
                DenyChildAttach = 8,
                HideScheduler = 16,
                LazyCancellation = 32,
                RunContinuationsAsynchronously = 64,
                NotOnRanToCompletion = 65536,
                NotOnFaulted = 131072,
                NotOnCanceled = 262144,
                OnlyOnRanToCompletion = 393216,
                OnlyOnFaulted = 327680,
                OnlyOnCanceled = 196608,
                ExecuteSynchronously = 524288,
            }

            class StackGuard
            {
                /*0x10*/ int m_inliningDepth;

                /*0x331a718*/ StackGuard();
                /*0x33208b8*/ bool TryBeginInliningScope();
                /*0x33208f8*/ void EndInliningScope();
            }

            struct VoidTaskResult
            {
            }

            interface ITaskCompletionAction
            {
                /*0x1f30ebc*/ void Invoke(System.Threading.Tasks.Task completingTask);
                /*0x1f2fe14*/ bool get_InvokeMayRunArbitraryCode();
            }

            class UnwrapPromise<TResult> : System.Threading.Tasks.Task<TResult>, System.Threading.Tasks.ITaskCompletionAction
            {
                /*0x0*/ byte _state;
                /*0x0*/ bool _lookForOce;

                UnwrapPromise(System.Threading.Tasks.Task outerTask, bool lookForOce);
                /*0x1f30ebc*/ void Invoke(System.Threading.Tasks.Task completingTask);
                /*0x1f30ebc*/ void InvokeCore(System.Threading.Tasks.Task completingTask);
                /*0x1f30ebc*/ void InvokeCoreAsync(System.Threading.Tasks.Task completingTask);
                /*0x1f30ebc*/ void ProcessCompletedOuterTask(System.Threading.Tasks.Task task);
                bool TrySetFromTask(System.Threading.Tasks.Task task, bool lookForOce);
                /*0x1f30ebc*/ void ProcessInnerTask(System.Threading.Tasks.Task task);
                /*0x1f2fe14*/ bool get_InvokeMayRunArbitraryCode();

                class <>c<TResult>
                {
                    static /*0x0*/ System.Threading.Tasks.UnwrapPromise.<>c<TResult> <>9;
                    static /*0x0*/ System.Threading.WaitCallback <>9__8_0;

                    static /*0x1f33998*/ <>c();
                    /*0x1f309e4*/ <>c();
                    /*0x1f30ebc*/ void <InvokeCoreAsync>b__8_0(object state);
                }
            }

            class ContinuationTaskFromTask : System.Threading.Tasks.Task
            {
                /*0x50*/ System.Threading.Tasks.Task m_antecedent;

                /*0x331e594*/ ContinuationTaskFromTask(System.Threading.Tasks.Task antecedent, System.Delegate action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.InternalTaskOptions internalOptions);
                /*0x332090c*/ void InnerInvoke();
            }

            class ContinuationResultTaskFromTask<TResult> : System.Threading.Tasks.Task<TResult>
            {
                /*0x0*/ System.Threading.Tasks.Task m_antecedent;

                /*0x1ffc854*/ ContinuationResultTaskFromTask(System.Threading.Tasks.Task antecedent, System.Delegate function, object state, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.InternalTaskOptions internalOptions);
                /*0x1f309e4*/ void InnerInvoke();
            }

            class ContinuationTaskFromResultTask<TAntecedentResult> : System.Threading.Tasks.Task
            {
                /*0x0*/ System.Threading.Tasks.Task<TAntecedentResult> m_antecedent;

                /*0x1ffc854*/ ContinuationTaskFromResultTask(System.Threading.Tasks.Task<TAntecedentResult> antecedent, System.Delegate action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.InternalTaskOptions internalOptions);
                /*0x1f309e4*/ void InnerInvoke();
            }

            class ContinuationResultTaskFromResultTask<TAntecedentResult, TResult> : System.Threading.Tasks.Task<TResult>
            {
                /*0x0*/ System.Threading.Tasks.Task<TAntecedentResult> m_antecedent;

                /*0x1ffc854*/ ContinuationResultTaskFromResultTask(System.Threading.Tasks.Task<TAntecedentResult> antecedent, System.Delegate function, object state, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.InternalTaskOptions internalOptions);
                /*0x1f309e4*/ void InnerInvoke();
            }

            class TaskContinuation
            {
                static /*0x33209e8*/ void InlineIfPossibleOrElseQueue(System.Threading.Tasks.Task task, bool needsProtection);
                /*0x3320b2c*/ TaskContinuation();
                void Run(System.Threading.Tasks.Task completedTask, bool bCanInlineContinuationTask);
            }

            class StandardTaskContinuation : System.Threading.Tasks.TaskContinuation
            {
                /*0x10*/ System.Threading.Tasks.Task m_task;
                /*0x18*/ System.Threading.Tasks.TaskContinuationOptions m_options;
                /*0x20*/ System.Threading.Tasks.TaskScheduler m_taskScheduler;

                /*0x331e920*/ StandardTaskContinuation(System.Threading.Tasks.Task task, System.Threading.Tasks.TaskContinuationOptions options, System.Threading.Tasks.TaskScheduler scheduler);
                /*0x3320b34*/ void Run(System.Threading.Tasks.Task completedTask, bool bCanInlineContinuationTask);
            }

            class SynchronizationContextAwaitTaskContinuation : System.Threading.Tasks.AwaitTaskContinuation
            {
                static /*0x0*/ System.Threading.SendOrPostCallback s_postCallback;
                static /*0x8*/ System.Threading.ContextCallback s_postActionCallback;
                /*0x20*/ System.Threading.SynchronizationContext m_syncContext;

                static /*0x33211ec*/ SynchronizationContextAwaitTaskContinuation();
                static /*0x3321090*/ void PostAction(object state);
                static /*0x3321124*/ System.Threading.ContextCallback GetPostActionCallback();
                /*0x331cebc*/ SynchronizationContextAwaitTaskContinuation(System.Threading.SynchronizationContext context, System.Action action, bool flowExecutionContext);
                /*0x3320d74*/ void Run(System.Threading.Tasks.Task ignored, bool canInlineContinuationTask);

                class <>c
                {
                    static /*0x0*/ System.Threading.Tasks.SynchronizationContextAwaitTaskContinuation.<> <>9;

                    static /*0x33212bc*/ <>c();
                    /*0x3321324*/ <>c();
                    /*0x332132c*/ void <.cctor>b__7_0(object state);
                }
            }

            class TaskSchedulerAwaitTaskContinuation : System.Threading.Tasks.AwaitTaskContinuation
            {
                /*0x20*/ System.Threading.Tasks.TaskScheduler m_scheduler;

                /*0x331cf94*/ TaskSchedulerAwaitTaskContinuation(System.Threading.Tasks.TaskScheduler scheduler, System.Action action, bool flowExecutionContext);
                /*0x3321398*/ void Run(System.Threading.Tasks.Task ignored, bool canInlineContinuationTask);

                class <>c
                {
                    static /*0x0*/ System.Threading.Tasks.TaskSchedulerAwaitTaskContinuation.<> <>9;
                    static /*0x8*/ System.Action<object> <>9__2_0;

                    static /*0x3321788*/ <>c();
                    /*0x33217f0*/ <>c();
                    /*0x33217f8*/ void <Run>b__2_0(object state);
                }
            }

            class AwaitTaskContinuation : System.Threading.Tasks.TaskContinuation, System.Threading.IThreadPoolWorkItem
            {
                static /*0x0*/ System.Threading.ContextCallback s_invokeActionCallback;
                /*0x10*/ System.Threading.ExecutionContext m_capturedContext;
                /*0x18*/ System.Action m_action;

                static /*0x3321940*/ bool get_IsValidLocationForInlining();
                static /*0x3321b9c*/ void InvokeAction(object state);
                static /*0x3321c08*/ System.Threading.ContextCallback GetInvokeActionCallback();
                static /*0x331dfc8*/ void RunOrScheduleAction(System.Action action, bool allowInlining, ref System.Threading.Tasks.Task currentTask);
                static /*0x331d05c*/ void UnsafeScheduleAction(System.Action action);
                static /*0x33218e8*/ void ThrowAsyncIfNecessary(System.Exception exc);
                /*0x3320cd0*/ AwaitTaskContinuation(System.Action action, bool flowExecutionContext);
                /*0x3321700*/ System.Threading.Tasks.Task CreateTask(System.Action<object> action, object state, System.Threading.Tasks.TaskScheduler scheduler);
                /*0x33215dc*/ void Run(System.Threading.Tasks.Task ignored, bool canInlineContinuationTask);
                /*0x3321a68*/ void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
                /*0x3320ee8*/ void RunCallback(System.Threading.ContextCallback callback, object state, ref System.Threading.Tasks.Task currentTask);
                /*0x3321cb8*/ void MarkAborted(System.Threading.ThreadAbortException e);
            }

            class TaskExceptionHolder
            {
                static /*0x0*/ bool s_failFastOnUnobservedException;
                /*0x10*/ System.Threading.Tasks.Task m_task;
                /*0x18*/ System.Collections.Generic.LowLevelListWithIList<System.Runtime.ExceptionServices.ExceptionDispatchInfo> m_faultExceptions;
                /*0x20*/ System.Runtime.ExceptionServices.ExceptionDispatchInfo m_cancellationException;
                /*0x28*/ bool m_isHandled;

                static /*0x3322684*/ TaskExceptionHolder();
                static /*0x3321cbc*/ bool ShouldFailFastOnUnobservedException();
                /*0x331b17c*/ TaskExceptionHolder(System.Threading.Tasks.Task task);
                /*0x3321cc4*/ void Finalize();
                /*0x331ad70*/ bool get_ContainsFaultList();
                /*0x331b1ac*/ void Add(object exceptionObject, bool representsCancellation);
                /*0x3322078*/ void SetCancellationException(object exceptionObject);
                /*0x332213c*/ void AddFaultException(object exceptionObject);
                /*0x332260c*/ void MarkAsUnhandled();
                /*0x331af50*/ void MarkAsHandled(bool calledFromFinalizer);
                /*0x331b1b8*/ System.AggregateException CreateExceptionObject(bool calledFromFinalizer, System.Exception includeThisException);
                /*0x331b4bc*/ System.Collections.ObjectModel.ReadOnlyCollection<System.Runtime.ExceptionServices.ExceptionDispatchInfo> GetExceptionDispatchInfos();
                /*0x332267c*/ System.Runtime.ExceptionServices.ExceptionDispatchInfo GetCancellationExceptionDispatchInfo();
            }

            class TaskFactory
            {
                /*0x10*/ System.Threading.CancellationToken m_defaultCancellationToken;
                /*0x18*/ System.Threading.Tasks.TaskScheduler m_defaultScheduler;
                /*0x20*/ System.Threading.Tasks.TaskCreationOptions m_defaultCreationOptions;
                /*0x24*/ System.Threading.Tasks.TaskContinuationOptions m_defaultContinuationOptions;

                static /*0x33228e4*/ void CheckCreationOptions(System.Threading.Tasks.TaskCreationOptions creationOptions);
                static /*0x3322b20*/ void CheckFromAsyncOptions(System.Threading.Tasks.TaskCreationOptions creationOptions, bool hasBeginMethod);
                static /*0x331f864*/ System.Threading.Tasks.Task<System.Threading.Tasks.Task> CommonCWAnyLogic(System.Collections.Generic.IList<System.Threading.Tasks.Task> tasks);
                static /*0x33227e8*/ void CheckMultiTaskContinuationOptions(System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                /*0x33204c4*/ TaskFactory();
                /*0x332277c*/ TaskFactory(System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                /*0x33226cc*/ System.Threading.Tasks.TaskScheduler GetDefaultScheduler(System.Threading.Tasks.Task currTask);
                /*0x3322940*/ System.Threading.Tasks.Task StartNew(System.Action action, System.Threading.CancellationToken cancellationToken);
                /*0x3322a04*/ System.Threading.Tasks.Task StartNew(System.Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                /*0x3322a90*/ System.Threading.Tasks.Task StartNew(System.Action<object> action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                /*0x1ffc854*/ System.Threading.Tasks.Task<TResult> StartNew<TResult>(System.Func<TResult> function, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                /*0x1f30394*/ System.Threading.Tasks.Task<TResult> StartNew<TResult>(System.Func<object, TResult> function, object state);
                /*0x1ffc854*/ System.Threading.Tasks.Task<TResult> StartNew<TResult>(System.Func<object, TResult> function, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                /*0x1ffc854*/ System.Threading.Tasks.Task FromAsync<TArg1>(System.Func<TArg1, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Action<System.IAsyncResult> endMethod, TArg1 arg1, object state);
                /*0x1ffc854*/ System.Threading.Tasks.Task FromAsync<TArg1>(System.Func<TArg1, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Action<System.IAsyncResult> endMethod, TArg1 arg1, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);
                /*0x1ffc854*/ System.Threading.Tasks.Task FromAsync<TArg1, TArg2>(System.Func<TArg1, TArg2, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Action<System.IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
                /*0x1ffc854*/ System.Threading.Tasks.Task FromAsync<TArg1, TArg2>(System.Func<TArg1, TArg2, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Action<System.IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);

                class CompleteOnInvokePromise : System.Threading.Tasks.Task<System.Threading.Tasks.Task>, System.Threading.Tasks.ITaskCompletionAction
                {
                    /*0x58*/ System.Collections.Generic.IList<System.Threading.Tasks.Task> _tasks;

                    /*0x3322c08*/ CompleteOnInvokePromise(System.Collections.Generic.IList<System.Threading.Tasks.Task> tasks);
                    /*0x3322d28*/ void Invoke(System.Threading.Tasks.Task completingTask);
                    /*0x3322f74*/ bool get_InvokeMayRunArbitraryCode();
                }
            }

            class TaskScheduler
            {
                static /*0x0*/ System.Threading.Tasks.TaskScheduler s_defaultTaskScheduler;
                static /*0x8*/ int s_taskSchedulerIdCounter;
                static /*0x10*/ System.EventHandler<System.Threading.Tasks.UnobservedTaskExceptionEventArgs> _unobservedTaskException;
                static /*0x18*/ System.Threading.Lock _unobservedTaskExceptionLockObject;
                /*0x10*/ int m_taskSchedulerId;

                static /*0x3322ff0*/ TaskScheduler();
                static /*0x3322f98*/ System.Threading.Tasks.TaskScheduler get_Default();
                static /*0x331e26c*/ System.Threading.Tasks.TaskScheduler get_Current();
                static /*0x331cef0*/ System.Threading.Tasks.TaskScheduler get_InternalCurrent();
                static /*0x3321f2c*/ void PublishUnobservedTaskException(object sender, System.Threading.Tasks.UnobservedTaskExceptionEventArgs ueea);
                /*0x3322f90*/ TaskScheduler();
                /*0x1f30ebc*/ void QueueTask(System.Threading.Tasks.Task task);
                bool TryExecuteTaskInline(System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);
                /*0x331d8a0*/ bool TryRunInline(System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);
                /*0x3322f7c*/ bool TryDequeue(System.Threading.Tasks.Task task);
                /*0x3322f84*/ void NotifyWorkItemProgress();
                /*0x3322f88*/ bool get_RequiresAtomicStartTransition();
                /*0x331da84*/ int get_Id();

                class SystemThreadingTasks_TaskSchedulerDebugView
                {
                }
            }

            class UnobservedTaskExceptionEventArgs : System.EventArgs
            {
                /*0x10*/ System.AggregateException m_exception;
                /*0x18*/ bool m_observed;

                /*0x3321eb8*/ UnobservedTaskExceptionEventArgs(System.AggregateException exception);
            }

            class ThreadPoolTaskScheduler : System.Threading.Tasks.TaskScheduler
            {
                static /*0x0*/ System.Threading.ParameterizedThreadStart s_longRunningThreadWork;

                static /*0x33233cc*/ ThreadPoolTaskScheduler();
                /*0x33230ac*/ ThreadPoolTaskScheduler();
                /*0x3323104*/ void QueueTask(System.Threading.Tasks.Task task);
                /*0x33232d0*/ bool TryExecuteTaskInline(System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);
                /*0x33233ac*/ bool TryDequeue(System.Threading.Tasks.Task task);
                /*0x33233b4*/ void NotifyWorkItemProgress();
                /*0x33233c4*/ bool get_RequiresAtomicStartTransition();

                class <>c
                {
                    static /*0x0*/ System.Threading.Tasks.ThreadPoolTaskScheduler.<> <>9;

                    static /*0x332349c*/ <>c();
                    /*0x3323504*/ <>c();
                    /*0x332350c*/ void <.cctor>b__10_0(object s);
                }
            }

            enum CausalityTraceLevel
            {
                Required = 0,
                Important = 1,
                Verbose = 2,
            }

            enum AsyncCausalityStatus
            {
                Started = 0,
                Completed = 1,
                Canceled = 2,
                Error = 3,
            }

            enum CausalityRelation
            {
                AssignDelegate = 0,
                Join = 1,
                Choice = 2,
                Cancel = 3,
                Error = 4,
            }

            enum CausalitySynchronousWork
            {
                CompletionNotification = 0,
                ProgressNotification = 1,
                Execution = 2,
            }

            class AsyncCausalityTracer
            {
                static /*0x3320184*/ bool get_LoggingOn();
                static /*0x3323590*/ void TraceOperationCreation(System.Threading.Tasks.CausalityTraceLevel traceLevel, int taskId, string operationName, ulong relatedContext);
                static /*0x3323594*/ void TraceOperationCompletion(System.Threading.Tasks.CausalityTraceLevel traceLevel, int taskId, System.Threading.Tasks.AsyncCausalityStatus status);
                static /*0x3323598*/ void TraceSynchronousWorkStart(System.Threading.Tasks.CausalityTraceLevel traceLevel, int taskId, System.Threading.Tasks.CausalitySynchronousWork work);
                static /*0x332018c*/ void TraceSynchronousWorkCompletion(System.Threading.Tasks.CausalityTraceLevel traceLevel, System.Threading.Tasks.CausalitySynchronousWork work);
            }

            namespace Sources
            {
                enum ValueTaskSourceOnCompletedFlags
                {
                    None = 0,
                    UseSchedulingContext = 1,
                    FlowExecutionContext = 2,
                }

                enum ValueTaskSourceStatus
                {
                    Pending = 0,
                    Succeeded = 1,
                    Faulted = 2,
                    Canceled = 3,
                }

                interface IValueTaskSource
                {
                    System.Threading.Tasks.Sources.ValueTaskSourceStatus GetStatus(short token);
                    void OnCompleted(System.Action<object> continuation, object state, short token, System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags flags);
                    void GetResult(short token);
                }

                interface IValueTaskSource<TResult>
                {
                    System.Threading.Tasks.Sources.ValueTaskSourceStatus GetStatus(short token);
                    void OnCompleted(System.Action<object> continuation, object state, short token, System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags flags);
                    /*0x1ffc854*/ TResult GetResult(short token);
                }
            }
        }
    }

    namespace Text
    {
        class ASCIIEncoding : System.Text.Encoding
        {
            static /*0x0*/ System.Text.ASCIIEncoding.ASCIIEncodingSealed s_default;

            static /*0x3325704*/ ASCIIEncoding();
            /*0x332359c*/ ASCIIEncoding();
            /*0x33235a8*/ void SetDefaultFallbacks();
            /*0x3323700*/ int GetByteCount(char[] chars, int index, int count);
            /*0x3323888*/ int GetByteCount(string chars);
            /*0x3323914*/ int GetByteCount(char* chars, int count);
            /*0x33239e4*/ int GetBytes(string chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
            /*0x3323c2c*/ int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
            /*0x3323ea0*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
            /*0x3323f98*/ int GetCharCount(byte[] bytes, int index, int count);
            /*0x3324120*/ int GetCharCount(byte* bytes, int count);
            /*0x33241f0*/ int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
            /*0x3324468*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
            /*0x3324560*/ string GetString(byte[] bytes, int byteIndex, int byteCount);
            /*0x33246f4*/ int GetByteCount(char* chars, int charCount, System.Text.EncoderNLS encoder);
            /*0x3324ae8*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, System.Text.EncoderNLS encoder);
            /*0x3324f58*/ int GetCharCount(byte* bytes, int count, System.Text.DecoderNLS decoder);
            /*0x33250fc*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount, System.Text.DecoderNLS decoder);
            /*0x332539c*/ int GetMaxByteCount(int charCount);
            /*0x3325498*/ int GetMaxCharCount(int byteCount);
            /*0x3325594*/ System.Text.Decoder GetDecoder();
            /*0x332564c*/ System.Text.Encoder GetEncoder();

            class ASCIIEncodingSealed : System.Text.ASCIIEncoding
            {
                /*0x332577c*/ ASCIIEncodingSealed();
            }
        }

        class Decoder
        {
            /*0x10*/ System.Text.DecoderFallback _fallback;
            /*0x18*/ System.Text.DecoderFallbackBuffer _fallbackBuffer;

            /*0x33257d8*/ Decoder();
            /*0x33257e0*/ System.Text.DecoderFallback get_Fallback();
            /*0x33250a8*/ System.Text.DecoderFallbackBuffer get_FallbackBuffer();
            /*0x33257e8*/ bool get_InternalHasFallbackBuffer();
            /*0x33257f8*/ void Reset();
            int GetCharCount(byte[] bytes, int index, int count);
            /*0x3325918*/ int GetCharCount(byte[] bytes, int index, int count, bool flush);
            /*0x3325924*/ int GetCharCount(byte* bytes, int count, bool flush);
            int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
            /*0x3325a80*/ int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, bool flush);
            /*0x3325a8c*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount, bool flush);
            /*0x3325c94*/ int GetChars(System.ReadOnlySpan<byte> bytes, System.Span<char> chars, bool flush);
            /*0x3325d74*/ void Convert(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, int charCount, bool flush, ref int bytesUsed, ref int charsUsed, ref bool completed);
            /*0x3326050*/ void Convert(byte* bytes, int byteCount, char* chars, int charCount, bool flush, ref int bytesUsed, ref int charsUsed, ref bool completed);
        }

        class InternalDecoderBestFitFallback : System.Text.DecoderFallback
        {
            /*0x10*/ System.Text.Encoding _encoding;
            /*0x18*/ char[] _arrayBestFit;
            /*0x20*/ char _cReplacement;

            /*0x3326270*/ InternalDecoderBestFitFallback(System.Text.Encoding encoding);
            /*0x33262b0*/ System.Text.DecoderFallbackBuffer CreateFallbackBuffer();
            /*0x3326450*/ int get_MaxCharCount();
            /*0x3326458*/ bool Equals(object value);
            /*0x33264fc*/ int GetHashCode();
        }

        class InternalDecoderBestFitFallbackBuffer : System.Text.DecoderFallbackBuffer
        {
            static /*0x0*/ object s_InternalSyncObject;
            /*0x20*/ char _cBestFit;
            /*0x24*/ int _iCount;
            /*0x28*/ int _iSize;
            /*0x30*/ System.Text.InternalDecoderBestFitFallback _oFallback;

            static /*0x332651c*/ object get_InternalSyncObject();
            /*0x3326308*/ InternalDecoderBestFitFallbackBuffer(System.Text.InternalDecoderBestFitFallback fallback);
            /*0x33265b8*/ bool Fallback(byte[] bytesUnknown, int index);
            /*0x3326744*/ char GetNextChar();
            /*0x3326784*/ int get_Remaining();
            /*0x3326790*/ void Reset();
            /*0x33267a0*/ int InternalFallback(byte[] bytes, byte* pBytes);
            /*0x33265f8*/ char TryBestFit(byte[] bytesCheck);
        }

        class DecoderExceptionFallback : System.Text.DecoderFallback
        {
            /*0x33267a8*/ DecoderExceptionFallback();
            /*0x33267b0*/ System.Text.DecoderFallbackBuffer CreateFallbackBuffer();
            /*0x332680c*/ int get_MaxCharCount();
            /*0x3326814*/ bool Equals(object value);
            /*0x3326870*/ int GetHashCode();
        }

        class DecoderExceptionFallbackBuffer : System.Text.DecoderFallbackBuffer
        {
            /*0x3326804*/ DecoderExceptionFallbackBuffer();
            /*0x3326878*/ bool Fallback(byte[] bytesUnknown, int index);
            /*0x3326a4c*/ char GetNextChar();
            /*0x3326a54*/ int get_Remaining();
            /*0x3326880*/ void Throw(byte[] bytesUnknown, int index);
        }

        class DecoderFallbackException : System.ArgumentException
        {
            /*0x98*/ byte[] _bytesUnknown;
            /*0xa0*/ int _index;

            /*0x3326a98*/ DecoderFallbackException();
            /*0x3326a5c*/ DecoderFallbackException(string message, byte[] bytesUnknown, int index);
            /*0x3326af4*/ DecoderFallbackException(System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);
        }

        class DecoderFallback
        {
            static /*0x0*/ System.Text.DecoderFallback s_replacementFallback;
            static /*0x8*/ System.Text.DecoderFallback s_exceptionFallback;

            static /*0x332366c*/ System.Text.DecoderFallback get_ReplacementFallback();
            static /*0x3326b44*/ System.Text.DecoderFallback get_ExceptionFallback();
            /*0x33262a8*/ DecoderFallback();
            /*0x1f30214*/ System.Text.DecoderFallbackBuffer CreateFallbackBuffer();
            /*0x1f2ffc8*/ int get_MaxCharCount();
        }

        class DecoderFallbackBuffer
        {
            /*0x10*/ byte* byteStart;
            /*0x18*/ char* charEnd;

            /*0x33265b0*/ DecoderFallbackBuffer();
            bool Fallback(byte[] bytesUnknown, int index);
            char GetNextChar();
            /*0x1f2ffc8*/ int get_Remaining();
            /*0x3326be0*/ void Reset();
            /*0x332538c*/ void InternalReset();
            /*0x33250f4*/ void InternalInitialize(byte* byteStart, char* charEnd);
            /*0x3326c08*/ bool InternalFallback(byte[] bytes, byte* pBytes, ref char* chars);
            /*0x3326d64*/ int InternalFallback(byte[] bytes, byte* pBytes);
            /*0x3326ea0*/ void ThrowLastBytesRecursive(byte[] bytesUnknown);
        }

        class DecoderNLS : System.Text.Decoder
        {
            /*0x20*/ System.Text.Encoding _encoding;
            /*0x28*/ bool _mustFlush;
            /*0x29*/ bool _throwOnOverflow;
            /*0x2c*/ int _bytesUsed;

            /*0x33255ec*/ DecoderNLS(System.Text.Encoding encoding);
            /*0x332708c*/ void Reset();
            /*0x33270a4*/ int GetCharCount(byte[] bytes, int index, int count);
            /*0x33270b4*/ int GetCharCount(byte[] bytes, int index, int count, bool flush);
            /*0x3327280*/ int GetCharCount(byte* bytes, int count, bool flush);
            /*0x3327370*/ int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
            /*0x3327380*/ int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, bool flush);
            /*0x3327604*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount, bool flush);
            /*0x332771c*/ void Convert(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, int charCount, bool flush, ref int bytesUsed, ref int charsUsed, ref bool completed);
            /*0x33279d8*/ void Convert(byte* bytes, int byteCount, char* chars, int charCount, bool flush, ref int bytesUsed, ref int charsUsed, ref bool completed);
            /*0x3327b7c*/ bool get_MustFlush();
            /*0x3327b84*/ bool get_HasState();
            /*0x3327b8c*/ void ClearMustFlush();
        }

        class DecoderReplacementFallback : System.Text.DecoderFallback, System.Runtime.Serialization.ISerializable
        {
            /*0x10*/ string _strDefault;

            /*0x3326afc*/ DecoderReplacementFallback();
            /*0x3327d20*/ DecoderReplacementFallback(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x3327b94*/ DecoderReplacementFallback(string replacement);
            /*0x3327e44*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x3327ea0*/ string get_DefaultString();
            /*0x3327ea8*/ System.Text.DecoderFallbackBuffer CreateFallbackBuffer();
            /*0x3327f40*/ int get_MaxCharCount();
            /*0x3327f58*/ bool Equals(object value);
            /*0x3327fcc*/ int GetHashCode();
        }

        class DecoderReplacementFallbackBuffer : System.Text.DecoderFallbackBuffer
        {
            /*0x20*/ string _strDefault;
            /*0x28*/ int _fallbackCount;
            /*0x2c*/ int _fallbackIndex;

            /*0x3327f00*/ DecoderReplacementFallbackBuffer(System.Text.DecoderReplacementFallback fallback);
            /*0x3327fe8*/ bool Fallback(byte[] bytesUnknown, int index);
            /*0x3328028*/ char GetNextChar();
            /*0x332807c*/ int get_Remaining();
            /*0x3328088*/ void Reset();
            /*0x3328098*/ int InternalFallback(byte[] bytes, byte* pBytes);
        }

        class Encoder
        {
            /*0x10*/ System.Text.EncoderFallback _fallback;
            /*0x18*/ System.Text.EncoderFallbackBuffer _fallbackBuffer;

            /*0x33280b0*/ Encoder();
            /*0x33280b8*/ System.Text.EncoderFallback get_Fallback();
            /*0x3324a30*/ System.Text.EncoderFallbackBuffer get_FallbackBuffer();
            /*0x3324a20*/ bool get_InternalHasFallbackBuffer();
            /*0x33280c0*/ void Reset();
            int GetByteCount(char[] chars, int index, int count, bool flush);
            /*0x33281a4*/ int GetByteCount(char* chars, int count, bool flush);
            int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, bool flush);
            /*0x3328300*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, bool flush);
            /*0x3328504*/ void Convert(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, int byteCount, bool flush, ref int charsUsed, ref int bytesUsed, ref bool completed);
            /*0x33287e0*/ void Convert(char* chars, int charCount, byte* bytes, int byteCount, bool flush, ref int charsUsed, ref int bytesUsed, ref bool completed);
        }

        class InternalEncoderBestFitFallback : System.Text.EncoderFallback
        {
            /*0x10*/ System.Text.Encoding _encoding;
            /*0x18*/ char[] _arrayBestFit;

            /*0x3328a00*/ InternalEncoderBestFitFallback(System.Text.Encoding encoding);
            /*0x3328a38*/ System.Text.EncoderFallbackBuffer CreateFallbackBuffer();
            /*0x3328bd8*/ int get_MaxCharCount();
            /*0x3328be0*/ bool Equals(object value);
            /*0x3328ca0*/ int GetHashCode();
        }

        class InternalEncoderBestFitFallbackBuffer : System.Text.EncoderFallbackBuffer
        {
            static /*0x0*/ object s_InternalSyncObject;
            /*0x30*/ char _cBestFit;
            /*0x38*/ System.Text.InternalEncoderBestFitFallback _oFallback;
            /*0x40*/ int _iCount;
            /*0x44*/ int _iSize;

            static /*0x3328cc0*/ object get_InternalSyncObject();
            /*0x3328a90*/ InternalEncoderBestFitFallbackBuffer(System.Text.InternalEncoderBestFitFallback fallback);
            /*0x3328d5c*/ bool Fallback(char charUnknown, int index);
            /*0x3328e60*/ bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
            /*0x3328ff4*/ char GetNextChar();
            /*0x3329034*/ bool MovePrevious();
            /*0x3329060*/ int get_Remaining();
            /*0x332906c*/ void Reset();
            /*0x3328d8c*/ char TryBestFit(char cUnknown);
        }

        class EncoderExceptionFallback : System.Text.EncoderFallback
        {
            /*0x3329080*/ EncoderExceptionFallback();
            /*0x3329088*/ System.Text.EncoderFallbackBuffer CreateFallbackBuffer();
            /*0x33290e4*/ int get_MaxCharCount();
            /*0x33290ec*/ bool Equals(object value);
            /*0x3329148*/ int GetHashCode();
        }

        class EncoderExceptionFallbackBuffer : System.Text.EncoderFallbackBuffer
        {
            /*0x33290dc*/ EncoderExceptionFallbackBuffer();
            /*0x3329150*/ bool Fallback(char charUnknown, int index);
            /*0x3329224*/ bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
            /*0x33295d4*/ char GetNextChar();
            /*0x33295dc*/ bool MovePrevious();
            /*0x33295e4*/ int get_Remaining();
        }

        class EncoderFallbackException : System.ArgumentException
        {
            /*0x98*/ char _charUnknown;
            /*0x9a*/ char _charUnknownHigh;
            /*0x9c*/ char _charUnknownLow;
            /*0xa0*/ int _index;

            /*0x33295ec*/ EncoderFallbackException();
            /*0x33291f4*/ EncoderFallbackException(string message, char charUnknown, int index);
            /*0x3329438*/ EncoderFallbackException(string message, char charUnknownHigh, char charUnknownLow, int index);
            /*0x3329648*/ EncoderFallbackException(System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);
        }

        class EncoderFallback
        {
            static /*0x0*/ System.Text.EncoderFallback s_replacementFallback;
            static /*0x8*/ System.Text.EncoderFallback s_exceptionFallback;

            static /*0x33235dc*/ System.Text.EncoderFallback get_ReplacementFallback();
            static /*0x3329698*/ System.Text.EncoderFallback get_ExceptionFallback();
            /*0x3328a30*/ EncoderFallback();
            /*0x1f30214*/ System.Text.EncoderFallbackBuffer CreateFallbackBuffer();
            /*0x1f2ffc8*/ int get_MaxCharCount();
        }

        class EncoderFallbackBuffer
        {
            /*0x10*/ char* charStart;
            /*0x18*/ char* charEnd;
            /*0x20*/ System.Text.EncoderNLS encoder;
            /*0x28*/ bool setEncoder;
            /*0x29*/ bool bUsedEncoder;
            /*0x2a*/ bool bFallingBack;
            /*0x2c*/ int iRecursionCount;

            /*0x3328d54*/ EncoderFallbackBuffer();
            bool Fallback(char charUnknown, int index);
            bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
            char GetNextChar();
            /*0x1f2fe14*/ bool MovePrevious();
            /*0x1f2ffc8*/ int get_Remaining();
            /*0x3329730*/ void Reset();
            /*0x3329758*/ void InternalReset();
            /*0x3324a7c*/ void InternalInitialize(char* charStart, char* charEnd, System.Text.EncoderNLS encoder, bool setEncoder);
            /*0x3324ab8*/ char InternalGetNextChar();
            /*0x3329770*/ bool InternalFallback(char ch, ref char* chars);
            /*0x3329900*/ void ThrowLastCharRecursive(int charRecursive);
        }

        class EncoderNLS : System.Text.Encoder
        {
            /*0x20*/ char _charLeftOver;
            /*0x28*/ System.Text.Encoding _encoding;
            /*0x30*/ bool _mustFlush;
            /*0x31*/ bool _throwOnOverflow;
            /*0x34*/ int _charsUsed;

            /*0x33256a4*/ EncoderNLS(System.Text.Encoding encoding);
            /*0x332998c*/ void Reset();
            /*0x33299ac*/ int GetByteCount(char[] chars, int index, int count, bool flush);
            /*0x3329b78*/ int GetByteCount(char* chars, int count, bool flush);
            /*0x3329c68*/ int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, bool flush);
            /*0x3329ee8*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, bool flush);
            /*0x332a000*/ void Convert(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, int byteCount, bool flush, ref int charsUsed, ref int bytesUsed, ref bool completed);
            /*0x332a2b8*/ void Convert(char* chars, int charCount, byte* bytes, int byteCount, bool flush, ref int charsUsed, ref int bytesUsed, ref bool completed);
            /*0x332a458*/ System.Text.Encoding get_Encoding();
            /*0x332a460*/ bool get_MustFlush();
            /*0x332a468*/ bool get_HasState();
            /*0x332a478*/ void ClearMustFlush();
        }

        class EncoderReplacementFallback : System.Text.EncoderFallback, System.Runtime.Serialization.ISerializable
        {
            /*0x10*/ string _strDefault;

            /*0x3329650*/ EncoderReplacementFallback();
            /*0x332a60c*/ EncoderReplacementFallback(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x332a480*/ EncoderReplacementFallback(string replacement);
            /*0x332a730*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x332a78c*/ string get_DefaultString();
            /*0x332a794*/ System.Text.EncoderFallbackBuffer CreateFallbackBuffer();
            /*0x332a7f0*/ int get_MaxCharCount();
            /*0x332a808*/ bool Equals(object value);
            /*0x332a87c*/ int GetHashCode();
        }

        class EncoderReplacementFallbackBuffer : System.Text.EncoderFallbackBuffer
        {
            /*0x30*/ string _strDefault;
            /*0x38*/ int _fallbackCount;
            /*0x3c*/ int _fallbackIndex;

            /*0x311acd0*/ EncoderReplacementFallbackBuffer(System.Text.EncoderReplacementFallback fallback);
            /*0x311ad20*/ bool Fallback(char charUnknown, int index);
            /*0x311ae50*/ bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
            /*0x311b02c*/ char GetNextChar();
            /*0x311b080*/ bool MovePrevious();
            /*0x311b0b0*/ int get_Remaining();
            /*0x311b0bc*/ void Reset();
        }

        class EncodingInfo
        {
            /*0x10*/ int iCodePage;
            /*0x18*/ string strEncodingName;
            /*0x20*/ string strDisplayName;

            /*0x311b0d0*/ EncodingInfo(int codePage, string name, string displayName);
            /*0x311b1a4*/ EncodingInfo();
            /*0x311b124*/ int get_CodePage();
            /*0x311b12c*/ bool Equals(object value);
            /*0x311b19c*/ int GetHashCode();
        }

        class EncodingNLS : System.Text.Encoding
        {
            /*0x311b1dc*/ EncodingNLS(int codePage);
            /*0x311b1e4*/ int GetByteCount(char[] chars, int index, int count);
            /*0x311b36c*/ int GetByteCount(string s);
            /*0x311b3f8*/ int GetByteCount(char* chars, int count);
            /*0x311b4c8*/ int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
            /*0x311b710*/ int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
            /*0x311b984*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
            /*0x311ba7c*/ int GetCharCount(byte[] bytes, int index, int count);
            /*0x311bc04*/ int GetCharCount(byte* bytes, int count);
            /*0x311bcd4*/ int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
            /*0x311bf4c*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
            /*0x311c044*/ string GetString(byte[] bytes, int index, int count);
            /*0x311c1d8*/ System.Text.Decoder GetDecoder();
            /*0x311c234*/ System.Text.Encoder GetEncoder();
        }

        class EncodingProvider
        {
            static /*0x0*/ object s_InternalSyncObject;
            static /*0x8*/ System.Text.EncodingProvider[] s_providers;

            static /*0x311c650*/ EncodingProvider();
            static /*0x311c38c*/ System.Text.Encoding GetEncodingFromProvider(int codepage);
            static /*0x311c470*/ System.Text.Encoding GetEncodingFromProvider(string encodingName);
            static /*0x311c554*/ System.Text.Encoding GetEncodingFromProvider(int codepage, System.Text.EncoderFallback enc, System.Text.DecoderFallback dec);
            /*0x1f302cc*/ System.Text.Encoding GetEncoding(string name);
            /*0x1f30240*/ System.Text.Encoding GetEncoding(int codepage);
            /*0x311c290*/ System.Text.Encoding GetEncoding(int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);
        }

        class Latin1Encoding : System.Text.EncodingNLS, System.Runtime.Serialization.ISerializable
        {
            static /*0x0*/ System.Text.Latin1Encoding s_default;
            static /*0x8*/ char[] arrayCharBestFit;

            static /*0x311d040*/ Latin1Encoding();
            /*0x311c6cc*/ Latin1Encoding();
            /*0x311c6d8*/ Latin1Encoding(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x311c724*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x311c80c*/ int GetByteCount(char* chars, int charCount, System.Text.EncoderNLS encoder);
            /*0x311ca08*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, System.Text.EncoderNLS encoder);
            /*0x311cd64*/ int GetCharCount(byte* bytes, int count, System.Text.DecoderNLS decoder);
            /*0x311cd6c*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount, System.Text.DecoderNLS decoder);
            /*0x311cdf0*/ int GetMaxByteCount(int charCount);
            /*0x311ceec*/ int GetMaxCharCount(int byteCount);
            /*0x311cfe8*/ char[] GetBestFitUnicodeToBytesData();
        }

        enum NormalizationForm
        {
            FormC = 1,
            FormD = 2,
            FormKC = 5,
            FormKD = 6,
        }

        class StringBuilder : System.Runtime.Serialization.ISerializable
        {
            /*0x10*/ char[] m_ChunkChars;
            /*0x18*/ System.Text.StringBuilder m_ChunkPrevious;
            /*0x20*/ int m_ChunkLength;
            /*0x24*/ int m_ChunkOffset;
            /*0x28*/ int m_MaxCapacity;

            static /*0x3120728*/ void FormatError();
            static /*0x311d5dc*/ void ThreadSafeCopy(char* sourcePtr, char[] destination, int destinationIndex, int count);
            static /*0x311f07c*/ void ThreadSafeCopy(char[] source, int sourceIndex, System.Span<char> destination, int destinationIndex, int count);
            /*0x311d10c*/ StringBuilder();
            /*0x311d178*/ StringBuilder(int capacity);
            /*0x311d350*/ StringBuilder(string value);
            /*0x311d36c*/ StringBuilder(string value, int capacity);
            /*0x311d388*/ StringBuilder(string value, int startIndex, int length, int capacity);
            /*0x311d180*/ StringBuilder(int capacity, int maxCapacity);
            /*0x311d6a4*/ StringBuilder(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x31211b4*/ StringBuilder(System.Text.StringBuilder from);
            /*0x3121210*/ StringBuilder(int size, int maxCapacity, System.Text.StringBuilder previousBlock);
            /*0x311d9a0*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x311dae4*/ int get_Capacity();
            /*0x311db04*/ void set_Capacity(int value);
            /*0x311dc98*/ int get_MaxCapacity();
            /*0x311dca0*/ int EnsureCapacity(int capacity);
            /*0x311dd54*/ string ToString();
            /*0x311de68*/ string ToString(int startIndex, int length);
            /*0x311e250*/ System.Text.StringBuilder Clear();
            /*0x311dc8c*/ int get_Length();
            /*0x311e26c*/ void set_Length(int value);
            /*0x311e62c*/ char get_Chars(int index);
            /*0x311e6b4*/ void set_Chars(int index, char value);
            /*0x311e4d0*/ System.Text.StringBuilder Append(char value, int repeatCount);
            /*0x311e91c*/ System.Text.StringBuilder Append(char[] value, int startIndex, int charCount);
            /*0x311eba8*/ System.Text.StringBuilder Append(string value);
            /*0x311ecac*/ void AppendHelper(string value);
            /*0x311ece4*/ System.Text.StringBuilder Append(string value, int startIndex, int count);
            /*0x311ee20*/ System.Text.StringBuilder Append(System.Text.StringBuilder value);
            /*0x311ee44*/ System.Text.StringBuilder AppendCore(System.Text.StringBuilder value, int startIndex, int count);
            /*0x311f038*/ System.Text.StringBuilder AppendLine();
            /*0x311f058*/ System.Text.StringBuilder AppendLine(string value);
            /*0x311e088*/ void CopyTo(int sourceIndex, System.Span<char> destination, int count);
            /*0x311f1e0*/ System.Text.StringBuilder Remove(int startIndex, int length);
            /*0x311f4a0*/ System.Text.StringBuilder Append(bool value);
            /*0x311f4ec*/ System.Text.StringBuilder Append(char value);
            /*0x311f53c*/ System.Text.StringBuilder Append(byte value);
            /*0x311f59c*/ System.Text.StringBuilder Append(int value);
            /*0x311f5fc*/ System.Text.StringBuilder Append(long value);
            /*0x311f65c*/ System.Text.StringBuilder Append(float value);
            /*0x311f6bc*/ System.Text.StringBuilder Append(double value);
            /*0x311f71c*/ System.Text.StringBuilder Append(uint value);
            /*0x1ffc854*/ System.Text.StringBuilder AppendSpanFormattable<T>(T value);
            /*0x311f77c*/ System.Text.StringBuilder Append(object value);
            /*0x311f7b4*/ System.Text.StringBuilder Append(char[] value);
            /*0x311f7dc*/ System.Text.StringBuilder Append(System.ReadOnlySpan<char> value);
            /*0x311f864*/ System.Text.StringBuilder Insert(int index, string value);
            /*0x311f9e4*/ System.Text.StringBuilder Insert(int index, char value);
            /*0x311fa10*/ System.Text.StringBuilder AppendFormat(string format, object arg0);
            /*0x31204f8*/ System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1);
            /*0x3120554*/ System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2);
            /*0x31205b4*/ System.Text.StringBuilder AppendFormat(string format, object[] args);
            /*0x3120668*/ System.Text.StringBuilder AppendFormat(System.IFormatProvider provider, string format, object arg0);
            /*0x31206c4*/ System.Text.StringBuilder AppendFormat(System.IFormatProvider provider, string format, object arg0, object arg1, object arg2);
            /*0x311fa68*/ System.Text.StringBuilder AppendFormatHelper(System.IFormatProvider provider, string format, System.ParamsArray args);
            /*0x3120774*/ System.Text.StringBuilder Replace(string oldValue, string newValue);
            /*0x3120784*/ System.Text.StringBuilder Replace(string oldValue, string newValue, int startIndex, int count);
            /*0x311ea58*/ System.Text.StringBuilder Append(char* value, int valueCount);
            /*0x311f914*/ void Insert(int index, char* value, int valueCount);
            /*0x3120b60*/ void ReplaceAllInChunk(int[] replacements, int replacementsCount, System.Text.StringBuilder sourceChunk, int removeCount, string value);
            /*0x3120a80*/ bool StartsWith(System.Text.StringBuilder chunk, int indexInChunk, int count, string value);
            /*0x3120fec*/ void ReplaceInPlaceAtChunk(ref System.Text.StringBuilder chunk, ref int indexInChunk, char* value, int count);
            /*0x311e604*/ System.Text.StringBuilder FindChunkForIndex(int index);
            /*0x3121140*/ System.Span<char> get_RemainingCurrentChunk();
            /*0x3121100*/ System.Text.StringBuilder Next(System.Text.StringBuilder chunk);
            /*0x311e76c*/ void ExpandByABlock(int minBlockCharCount);
            /*0x3120d0c*/ void MakeRoom(int index, int count, ref System.Text.StringBuilder chunk, ref int indexInChunk, bool doNotMoveFollowingChars);
            /*0x311f310*/ void Remove(int startIndex, int count, ref System.Text.StringBuilder chunk, ref int indexInChunk);
        }

        class StringBuilderCache
        {
            [ThreadStatic] static System.Text.StringBuilder t_cachedInstance;

            static /*0x31212b8*/ System.Text.StringBuilder Acquire(int capacity);
            static /*0x312138c*/ void Release(System.Text.StringBuilder sb);
            static /*0x3121414*/ string GetStringAndRelease(System.Text.StringBuilder sb);
        }

        class UTF32Encoding : System.Text.Encoding
        {
            static /*0x0*/ System.Text.UTF32Encoding s_default;
            static /*0x8*/ System.Text.UTF32Encoding s_bigEndianDefault;
            static /*0x10*/ byte[] s_bigEndianPreamble;
            static /*0x18*/ byte[] s_littleEndianPreamble;
            /*0x38*/ bool _emitUTF32ByteOrderMark;
            /*0x39*/ bool _isThrowException;
            /*0x3a*/ bool _bigEndian;

            static /*0x3123a4c*/ UTF32Encoding();
            /*0x3121450*/ UTF32Encoding();
            /*0x31214e4*/ UTF32Encoding(bool bigEndian, bool byteOrderMark);
            /*0x3121478*/ UTF32Encoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);
            /*0x3121524*/ void SetDefaultFallbacks();
            /*0x3121610*/ int GetByteCount(char[] chars, int index, int count);
            /*0x3121798*/ int GetByteCount(string s);
            /*0x3121824*/ int GetByteCount(char* chars, int count);
            /*0x31218f4*/ int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
            /*0x3121b3c*/ int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
            /*0x3121db0*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
            /*0x3121ea8*/ int GetCharCount(byte[] bytes, int index, int count);
            /*0x3122030*/ int GetCharCount(byte* bytes, int count);
            /*0x3122100*/ int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
            /*0x3122378*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
            /*0x3122470*/ string GetString(byte[] bytes, int index, int count);
            /*0x3122604*/ int GetByteCount(char* chars, int count, System.Text.EncoderNLS encoder);
            /*0x31228b4*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, System.Text.EncoderNLS encoder);
            /*0x3122c78*/ int GetCharCount(byte* bytes, int count, System.Text.DecoderNLS baseDecoder);
            /*0x3122fbc*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount, System.Text.DecoderNLS baseDecoder);
            /*0x3122c5c*/ uint GetSurrogate(char cHigh, char cLow);
            /*0x31233c0*/ char GetHighSurrogate(uint iChar);
            /*0x31233d4*/ char GetLowSurrogate(uint iChar);
            /*0x31233e0*/ System.Text.Decoder GetDecoder();
            /*0x3123444*/ System.Text.Encoder GetEncoder();
            /*0x31234a0*/ int GetMaxByteCount(int charCount);
            /*0x312359c*/ int GetMaxCharCount(int byteCount);
            /*0x3123664*/ byte[] GetPreamble();
            /*0x3123788*/ System.ReadOnlySpan<byte> get_Preamble();
            /*0x3123914*/ bool Equals(object value);
            /*0x31239d0*/ int GetHashCode();

            class UTF32Decoder : System.Text.DecoderNLS
            {
                /*0x30*/ int iChar;
                /*0x34*/ int readByteCount;

                /*0x312343c*/ UTF32Decoder(System.Text.UTF32Encoding encoding);
                /*0x3123ba8*/ void Reset();
                /*0x3123bc8*/ bool get_HasState();
            }
        }

        class UTF7Encoding : System.Text.Encoding
        {
            static /*0x0*/ System.Text.UTF7Encoding s_default;
            /*0x38*/ byte[] _base64Bytes;
            /*0x40*/ sbyte[] _base64Values;
            /*0x48*/ bool[] _directEncode;
            /*0x50*/ bool _allowOptionals;

            static /*0x31258f8*/ UTF7Encoding();
            /*0x3123bd8*/ UTF7Encoding();
            /*0x3123bfc*/ UTF7Encoding(bool allowOptionals);
            /*0x3123c2c*/ void MakeTables();
            /*0x3123ec0*/ void SetDefaultFallbacks();
            /*0x3123f80*/ bool Equals(object value);
            /*0x3124048*/ int GetHashCode();
            /*0x31240b4*/ int GetByteCount(char[] chars, int index, int count);
            /*0x312423c*/ int GetByteCount(string s);
            /*0x31242c8*/ int GetByteCount(char* chars, int count);
            /*0x3124398*/ int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
            /*0x31245e0*/ int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
            /*0x3124854*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
            /*0x312494c*/ int GetCharCount(byte[] bytes, int index, int count);
            /*0x3124ad4*/ int GetCharCount(byte* bytes, int count);
            /*0x3124ba4*/ int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
            /*0x3124e1c*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
            /*0x3124f14*/ string GetString(byte[] bytes, int index, int count);
            /*0x31250a8*/ int GetByteCount(char* chars, int count, System.Text.EncoderNLS baseEncoder);
            /*0x31250c4*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, System.Text.EncoderNLS baseEncoder);
            /*0x3125434*/ int GetCharCount(byte* bytes, int count, System.Text.DecoderNLS baseDecoder);
            /*0x3125450*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount, System.Text.DecoderNLS baseDecoder);
            /*0x3125700*/ System.Text.Decoder GetDecoder();
            /*0x3125764*/ System.Text.Encoder GetEncoder();
            /*0x31257c8*/ int GetMaxByteCount(int charCount);
            /*0x3125884*/ int GetMaxCharCount(int byteCount);

            class Decoder : System.Text.DecoderNLS
            {
                /*0x30*/ int bits;
                /*0x34*/ int bitCount;
                /*0x38*/ bool firstByte;

                /*0x312575c*/ Decoder(System.Text.UTF7Encoding encoding);
                /*0x3125970*/ void Reset();
                /*0x3125998*/ bool get_HasState();
            }

            class Encoder : System.Text.EncoderNLS
            {
                /*0x38*/ int bits;
                /*0x3c*/ int bitCount;

                /*0x31257c0*/ Encoder(System.Text.UTF7Encoding encoding);
                /*0x31259a8*/ void Reset();
                /*0x31259cc*/ bool get_HasState();
            }

            class DecoderUTF7Fallback : System.Text.DecoderFallback
            {
                /*0x3123f78*/ DecoderUTF7Fallback();
                /*0x31259ec*/ System.Text.DecoderFallbackBuffer CreateFallbackBuffer();
                /*0x3125a58*/ int get_MaxCharCount();
                /*0x3125a60*/ bool Equals(object value);
                /*0x3125abc*/ int GetHashCode();
            }

            class DecoderUTF7FallbackBuffer : System.Text.DecoderFallbackBuffer
            {
                /*0x20*/ char cFallback;
                /*0x24*/ int iCount;
                /*0x28*/ int iSize;

                /*0x3125a48*/ DecoderUTF7FallbackBuffer(System.Text.UTF7Encoding.DecoderUTF7Fallback fallback);
                /*0x3125ac4*/ bool Fallback(byte[] bytesUnknown, int index);
                /*0x3125b00*/ char GetNextChar();
                /*0x3125b20*/ int get_Remaining();
                /*0x3125b2c*/ void Reset();
                /*0x3125b3c*/ int InternalFallback(byte[] bytes, byte* pBytes);
            }
        }

        class UTF8Encoding : System.Text.Encoding
        {
            static /*0x0*/ System.Text.UTF8Encoding.UTF8EncodingSealed s_default;
            static /*0x8*/ byte[] s_preamble;
            /*0x38*/ bool _emitUTF8Identifier;
            /*0x39*/ bool _isThrowException;

            static /*0x3128dc0*/ UTF8Encoding();
            static /*0x31272f0*/ int PtrDiff(char* a, char* b);
            static /*0x31272fc*/ int PtrDiff(byte* a, byte* b);
            static /*0x31272dc*/ bool InRange(int ch, int start, int end);
            /*0x3125bb0*/ UTF8Encoding();
            /*0x3125bd0*/ UTF8Encoding(bool encoderShouldEmitUTF8Identifier);
            /*0x3125c00*/ UTF8Encoding(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);
            /*0x3125c50*/ void SetDefaultFallbacks();
            /*0x3125d3c*/ int GetByteCount(char[] chars, int index, int count);
            /*0x3125ec4*/ int GetByteCount(string chars);
            /*0x3125f50*/ int GetByteCount(char* chars, int count);
            /*0x3126020*/ int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
            /*0x3126268*/ int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
            /*0x31264dc*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
            /*0x31265d4*/ int GetCharCount(byte[] bytes, int index, int count);
            /*0x312675c*/ int GetCharCount(byte* bytes, int count);
            /*0x312682c*/ int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
            /*0x3126aa4*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
            /*0x3126b9c*/ string GetString(byte[] bytes, int index, int count);
            /*0x3126d30*/ int GetByteCount(char* chars, int count, System.Text.EncoderNLS baseEncoder);
            /*0x3127304*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, System.Text.EncoderNLS baseEncoder);
            /*0x31279e8*/ int GetCharCount(byte* bytes, int count, System.Text.DecoderNLS baseDecoder);
            /*0x3127ecc*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount, System.Text.DecoderNLS baseDecoder);
            /*0x3128520*/ bool FallbackInvalidByteSequence(ref byte* pSrc, int ch, System.Text.DecoderFallbackBuffer fallback, ref char* pTarget);
            /*0x3127e8c*/ int FallbackInvalidByteSequence(byte* pSrc, int ch, System.Text.DecoderFallbackBuffer fallback);
            /*0x312858c*/ byte[] GetBytesUnknown(ref byte* pSrc, int ch);
            /*0x3128780*/ System.Text.Decoder GetDecoder();
            /*0x31287e4*/ System.Text.Encoder GetEncoder();
            /*0x3128848*/ int GetMaxByteCount(int charCount);
            /*0x3128944*/ int GetMaxCharCount(int byteCount);
            /*0x3128a40*/ byte[] GetPreamble();
            /*0x3128b2c*/ System.ReadOnlySpan<byte> get_Preamble();
            /*0x3128c98*/ bool Equals(object value);
            /*0x3128d60*/ int GetHashCode();

            class UTF8EncodingSealed : System.Text.UTF8Encoding
            {
                /*0x3128e9c*/ UTF8EncodingSealed(bool encoderShouldEmitUTF8Identifier);
                /*0x3128f14*/ System.ReadOnlySpan<byte> get_Preamble();
            }

            class UTF8Encoder : System.Text.EncoderNLS
            {
                /*0x38*/ int surrogateChar;

                /*0x3128840*/ UTF8Encoder(System.Text.UTF8Encoding encoding);
                /*0x3129000*/ void Reset();
                /*0x3129020*/ bool get_HasState();
            }

            class UTF8Decoder : System.Text.DecoderNLS
            {
                /*0x30*/ int bits;

                /*0x31287dc*/ UTF8Decoder(System.Text.UTF8Encoding encoding);
                /*0x3129030*/ void Reset();
                /*0x3129050*/ bool get_HasState();
            }
        }

        class UnicodeEncoding : System.Text.Encoding
        {
            static /*0x0*/ System.Text.UnicodeEncoding s_bigEndianDefault;
            static /*0x8*/ System.Text.UnicodeEncoding s_littleEndianDefault;
            static /*0x10*/ byte[] s_bigEndianPreamble;
            static /*0x18*/ byte[] s_littleEndianPreamble;
            static /*0x20*/ ulong highLowPatternMask;
            /*0x38*/ bool isThrowException;
            /*0x39*/ bool bigEndian;
            /*0x3a*/ bool byteOrderMark;

            static /*0x312c2f4*/ UnicodeEncoding();
            /*0x3129060*/ UnicodeEncoding();
            /*0x3129094*/ UnicodeEncoding(bool bigEndian, bool byteOrderMark);
            /*0x31290dc*/ UnicodeEncoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);
            /*0x3129150*/ void SetDefaultFallbacks();
            /*0x312923c*/ int GetByteCount(char[] chars, int index, int count);
            /*0x31293c4*/ int GetByteCount(string s);
            /*0x3129450*/ int GetByteCount(char* chars, int count);
            /*0x3129520*/ int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
            /*0x3129768*/ int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
            /*0x31299dc*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
            /*0x3129ad4*/ int GetCharCount(byte[] bytes, int index, int count);
            /*0x3129c5c*/ int GetCharCount(byte* bytes, int count);
            /*0x3129d2c*/ int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
            /*0x3129fa4*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
            /*0x312a09c*/ string GetString(byte[] bytes, int index, int count);
            /*0x312a230*/ int GetByteCount(char* chars, int count, System.Text.EncoderNLS encoder);
            /*0x312a74c*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, System.Text.EncoderNLS encoder);
            /*0x312adec*/ int GetCharCount(byte* bytes, int count, System.Text.DecoderNLS baseDecoder);
            /*0x312b430*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount, System.Text.DecoderNLS baseDecoder);
            /*0x312bc10*/ System.Text.Encoder GetEncoder();
            /*0x312bc6c*/ System.Text.Decoder GetDecoder();
            /*0x312bcc8*/ byte[] GetPreamble();
            /*0x312bde4*/ System.ReadOnlySpan<byte> get_Preamble();
            /*0x312bf70*/ int GetMaxByteCount(int charCount);
            /*0x312c06c*/ int GetMaxCharCount(int byteCount);
            /*0x312c16c*/ bool Equals(object value);
            /*0x312c278*/ int GetHashCode();

            class Decoder : System.Text.DecoderNLS
            {
                /*0x30*/ int lastByte;
                /*0x34*/ char lastChar;

                /*0x312c478*/ Decoder(System.Text.UnicodeEncoding encoding);
                /*0x312c488*/ void Reset();
                /*0x312c4b0*/ bool get_HasState();
            }
        }

        struct ValueStringBuilder
        {
            /*0x10*/ char[] _arrayToReturnToPool;
            /*0x18*/ System.Span<char> _chars;
            /*0x28*/ int _pos;

            /*0x312c4d4*/ ValueStringBuilder(System.Span<char> initialBuffer);
            /*0x312c4e4*/ int get_Length();
            /*0x312c4ec*/ ref char get_Item(int index);
            /*0x312c50c*/ string ToString();
            /*0x312c60c*/ bool TryCopyTo(System.Span<char> destination, ref int charsWritten);
            /*0x312c734*/ void Append(char c);
            /*0x312c830*/ void Append(string s);
            /*0x312c8dc*/ void AppendSlow(string s);
            /*0x312cca4*/ void Append(char c, int count);
            /*0x312cecc*/ void Append(char* value, int length);
            /*0x312cfe4*/ System.Span<char> AppendSpan(int length);
            /*0x312c7b0*/ void GrowAndAppend(char c);
            /*0x312ca40*/ void Grow(int requiredAdditionalCapacity);
            /*0x312d0d4*/ void Dispose();
        }

        struct ValueUtf8Converter
        {
            /*0x10*/ byte[] _arrayToReturnToPool;
            /*0x18*/ System.Span<byte> _bytes;

            /*0x312d1dc*/ ValueUtf8Converter(System.Span<byte> initialBuffer);
            /*0x312d1e8*/ System.Span<byte> ConvertAndTerminateString(System.ReadOnlySpan<char> value);
            /*0x312d4d0*/ void Dispose();
        }

        class Encoding : System.ICloneable
        {
            static /*0x0*/ System.Text.Encoding defaultEncoding;
            static /*0x8*/ System.Text.Encoding unicodeEncoding;
            static /*0x10*/ System.Text.Encoding bigEndianUnicode;
            static /*0x18*/ System.Text.Encoding utf7Encoding;
            static /*0x20*/ System.Text.Encoding utf8Encoding;
            static /*0x28*/ System.Text.Encoding utf32Encoding;
            static /*0x30*/ System.Text.Encoding asciiEncoding;
            static /*0x38*/ System.Text.Encoding latin1Encoding;
            static /*0x40*/ System.Collections.Generic.Dictionary<int, System.Text.Encoding> encodings;
            static /*0x48*/ object s_InternalSyncObject;
            /*0x10*/ int m_codePage;
            /*0x18*/ System.Globalization.CodePageDataItem dataItem;
            /*0x20*/ bool m_deserializedFromEverett;
            /*0x21*/ bool m_isReadOnly;
            /*0x28*/ System.Text.EncoderFallback encoderFallback;
            /*0x30*/ System.Text.DecoderFallback decoderFallback;

            static /*0x312dd78*/ object get_InternalSyncObject();
            static /*0x312de10*/ System.Text.Encoding GetEncoding(int codepage);
            static /*0x312f18c*/ System.Text.Encoding GetEncoding(int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);
            static /*0x312f408*/ System.Text.Encoding GetEncoding(string name);
            static /*0x312e988*/ System.Text.Encoding get_ASCII();
            static /*0x312ea2c*/ System.Text.Encoding get_Latin1();
            static /*0x31305b8*/ System.Text.Encoding CreateDefaultEncoding();
            static /*0x312e654*/ System.Text.Encoding get_Default();
            static /*0x312e6e0*/ System.Text.Encoding get_Unicode();
            static /*0x312e78c*/ System.Text.Encoding get_BigEndianUnicode();
            static /*0x312e838*/ System.Text.Encoding get_UTF7();
            static /*0x312d428*/ System.Text.Encoding get_UTF8();
            static /*0x312e8dc*/ System.Text.Encoding get_UTF32();
            /*0x312d5d4*/ Encoding();
            /*0x312d604*/ Encoding(int codePage);
            /*0x312d68c*/ void SetDefaultFallbacks();
            /*0x312d734*/ void OnDeserializing();
            /*0x312d768*/ void OnDeserialized();
            /*0x312d7ac*/ void OnDeserializing(System.Runtime.Serialization.StreamingContext ctx);
            /*0x312d7e0*/ void OnDeserialized(System.Runtime.Serialization.StreamingContext ctx);
            /*0x312d7e4*/ void OnSerializing(System.Runtime.Serialization.StreamingContext ctx);
            /*0x312d7f0*/ void DeserializeEncoding(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x312dbd0*/ void SerializeEncoding(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x312f4a4*/ byte[] GetPreamble();
            /*0x312f4fc*/ System.ReadOnlySpan<byte> get_Preamble();
            /*0x312f550*/ void GetDataItem();
            /*0x312f68c*/ string get_EncodingName();
            /*0x312f698*/ string get_WebName();
            /*0x312f6c8*/ System.Text.EncoderFallback get_EncoderFallback();
            /*0x312f290*/ void set_EncoderFallback(System.Text.EncoderFallback value);
            /*0x312f6d0*/ System.Text.DecoderFallback get_DecoderFallback();
            /*0x312f34c*/ void set_DecoderFallback(System.Text.DecoderFallback value);
            /*0x312f6d8*/ object Clone();
            /*0x312f760*/ bool get_IsReadOnly();
            /*0x312f768*/ int GetByteCount(string s);
            int GetByteCount(char[] chars, int index, int count);
            /*0x312f7f0*/ int GetByteCount(char* chars, int count);
            /*0x312f954*/ int GetByteCount(char* chars, int count, System.Text.EncoderNLS encoder);
            /*0x312f964*/ byte[] GetBytes(char[] chars);
            /*0x312f9ec*/ byte[] GetBytes(char[] chars, int index, int count);
            int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
            /*0x312faa4*/ byte[] GetBytes(string s);
            /*0x312fba4*/ int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
            /*0x312fc50*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, System.Text.EncoderNLS encoder);
            /*0x312fc60*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
            int GetCharCount(byte[] bytes, int index, int count);
            /*0x312fe70*/ int GetCharCount(byte* bytes, int count);
            /*0x312ffe0*/ int GetCharCount(byte* bytes, int count, System.Text.DecoderNLS decoder);
            /*0x312fff0*/ char[] GetChars(byte[] bytes, int index, int count);
            int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
            /*0x31300ac*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
            /*0x31302c0*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount, System.Text.DecoderNLS decoder);
            /*0x31302d0*/ string GetString(byte* bytes, int byteCount);
            /*0x31303b4*/ int GetChars(System.ReadOnlySpan<byte> bytes, System.Span<char> chars);
            /*0x3130488*/ string GetString(System.ReadOnlySpan<byte> bytes);
            /*0x3130504*/ int get_CodePage();
            /*0x313050c*/ System.Text.Decoder GetDecoder();
            /*0x31307f0*/ void setReadOnly(bool value);
            /*0x31307f8*/ System.Text.Encoder GetEncoder();
            int GetMaxByteCount(int charCount);
            int GetMaxCharCount(int byteCount);
            /*0x31308a4*/ string GetString(byte[] bytes);
            /*0x313092c*/ string GetString(byte[] bytes, int index, int count);
            /*0x3130954*/ bool Equals(object value);
            /*0x3130a1c*/ int GetHashCode();
            /*0x3130a74*/ char[] GetBestFitUnicodeToBytesData();
            /*0x3130acc*/ char[] GetBestFitBytesToUnicodeData();
            /*0x3130b24*/ void ThrowBytesOverflow();
            /*0x3130c20*/ void ThrowBytesOverflow(System.Text.EncoderNLS encoder, bool nothingEncoded);
            /*0x3130c8c*/ void ThrowCharsOverflow();
            /*0x3130d88*/ void ThrowCharsOverflow(System.Text.DecoderNLS decoder, bool nothingDecoded);
            /*0x3130df4*/ int GetByteCount(System.ReadOnlySpan<char> chars);
            /*0x3130e7c*/ int GetBytes(System.ReadOnlySpan<char> chars, System.Span<byte> bytes);

            class DefaultEncoder : System.Text.Encoder, System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IObjectReference
            {
                /*0x20*/ System.Text.Encoding m_encoding;
                /*0x28*/ bool m_hasInitializedEncoding;
                /*0x2a*/ char charLeftOver;

                /*0x3130868*/ DefaultEncoder(System.Text.Encoding encoding);
                /*0x3130f50*/ DefaultEncoder(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x31312a8*/ object GetRealObject(System.Runtime.Serialization.StreamingContext context);
                /*0x3131370*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x3131410*/ int GetByteCount(char[] chars, int index, int count, bool flush);
                /*0x313142c*/ int GetByteCount(char* chars, int count, bool flush);
                /*0x313144c*/ int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, bool flush);
                /*0x313146c*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, bool flush);
            }

            class DefaultDecoder : System.Text.Decoder, System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IObjectReference
            {
                /*0x20*/ System.Text.Encoding m_encoding;
                /*0x28*/ bool m_hasInitializedEncoding;

                /*0x313057c*/ DefaultDecoder(System.Text.Encoding encoding);
                /*0x313148c*/ DefaultDecoder(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x3131784*/ object GetRealObject(System.Runtime.Serialization.StreamingContext context);
                /*0x31317d8*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x3131878*/ int GetCharCount(byte[] bytes, int index, int count);
                /*0x3131888*/ int GetCharCount(byte[] bytes, int index, int count, bool flush);
                /*0x31318a8*/ int GetCharCount(byte* bytes, int count, bool flush);
                /*0x31318c8*/ int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
                /*0x31318d8*/ int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, bool flush);
                /*0x31318f8*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount, bool flush);
            }

            class EncodingCharBuffer
            {
                /*0x10*/ char* chars;
                /*0x18*/ char* charStart;
                /*0x20*/ char* charEnd;
                /*0x28*/ int charCountResult;
                /*0x30*/ System.Text.Encoding enc;
                /*0x38*/ System.Text.DecoderNLS decoder;
                /*0x40*/ byte* byteStart;
                /*0x48*/ byte* byteEnd;
                /*0x50*/ byte* bytes;
                /*0x58*/ System.Text.DecoderFallbackBuffer fallbackBuffer;

                /*0x3131918*/ EncodingCharBuffer(System.Text.Encoding enc, System.Text.DecoderNLS decoder, char* charStart, int charCount, byte* byteStart, int byteCount);
                /*0x31319f8*/ bool AddChar(char ch, int numBytes);
                /*0x3131a64*/ bool AddChar(char ch);
                /*0x3131a6c*/ void AdjustBytes(int count);
                /*0x3131a7c*/ bool get_MoreData();
                /*0x3131a8c*/ byte GetNextByte();
                /*0x3131ab0*/ int get_BytesUsed();
                /*0x3131ac0*/ bool Fallback(byte fallbackByte);
                /*0x3131b38*/ bool Fallback(byte[] byteBuffer);
                /*0x3131c18*/ int get_Count();
            }

            class EncodingByteBuffer
            {
                /*0x10*/ byte* bytes;
                /*0x18*/ byte* byteStart;
                /*0x20*/ byte* byteEnd;
                /*0x28*/ char* chars;
                /*0x30*/ char* charStart;
                /*0x38*/ char* charEnd;
                /*0x40*/ int byteCountResult;
                /*0x48*/ System.Text.Encoding enc;
                /*0x50*/ System.Text.EncoderNLS encoder;
                /*0x58*/ System.Text.EncoderFallbackBuffer fallbackBuffer;

                /*0x3131c20*/ EncodingByteBuffer(System.Text.Encoding inEncoding, System.Text.EncoderNLS inEncoder, byte* inByteStart, int inByteCount, char* inCharStart, int inCharCount);
                /*0x3131e5c*/ bool AddByte(byte b, int moreBytesExpected);
                /*0x3131f28*/ bool AddByte(byte b1);
                /*0x3131f30*/ bool AddByte(byte b1, byte b2);
                /*0x3131f38*/ bool AddByte(byte b1, byte b2, int moreBytesExpected);
                /*0x3131eac*/ void MovePrevious(bool bThrow);
                /*0x3131f80*/ bool get_MoreData();
                /*0x3131fc8*/ char GetNextChar();
                /*0x3132014*/ int get_CharsUsed();
                /*0x313202c*/ int get_Count();
            }
        }

        enum NormalizationCheck
        {
            Yes = 0,
            No = 1,
            Maybe = 2,
        }

        class Normalization
        {
            static /*0x0*/ byte* props;
            static /*0x8*/ int* mappedChars;
            static /*0x10*/ short* charMapIndex;
            static /*0x18*/ short* helperIndex;
            static /*0x20*/ ushort* mapIdxToComposite;
            static /*0x28*/ byte* combiningClass;
            static /*0x30*/ object forLock;
            static /*0x38*/ bool isReady;

            static /*0x3133700*/ Normalization();
            static /*0x3132034*/ uint PropValue(int cp);
            static /*0x31320c8*/ int CharMapIdx(int cp);
            static /*0x313215c*/ byte GetCombiningClass(int c);
            static /*0x3132204*/ int GetPrimaryCompositeFromMapIndex(int src);
            static /*0x31322ac*/ int GetPrimaryCompositeHelperIndex(int cp);
            static /*0x3132354*/ string Compose(string source, int checkType);
            static /*0x3132568*/ System.Text.StringBuilder Combine(string source, int start, int checkType);
            static /*0x31326a4*/ void Combine(System.Text.StringBuilder sb, int i, int checkType);
            static /*0x31328e0*/ int CombineHangul(System.Text.StringBuilder sb, string s, int current);
            static /*0x3132cdc*/ int Fetch(System.Text.StringBuilder sb, string s, int i);
            static /*0x3132aa8*/ int TryComposeWithPreviousStarter(System.Text.StringBuilder sb, string s, int current);
            static /*0x3132d18*/ int TryCompose(int i, int starter, int candidate);
            static /*0x3132e30*/ string Decompose(string source, int checkType);
            static /*0x3132434*/ void Decompose(string source, ref System.Text.StringBuilder sb, int checkType);
            static /*0x31330b4*/ void ReorderCanonical(string src, ref System.Text.StringBuilder sb, int start);
            static /*0x3132ebc*/ void DecomposeChar(ref System.Text.StringBuilder sb, ref int[] buf, string s, int i, int checkType, ref int start);
            static /*0x31327b4*/ System.Text.NormalizationCheck QuickCheck(char c, int type);
            static /*0x31334e8*/ int GetCanonicalHangul(int s, int[] buf, int bufIdx);
            static /*0x3133330*/ int GetCanonical(int c, int[] buf, int bufIdx, int checkType);
            static /*0x31335cc*/ string Normalize(string source, System.Text.NormalizationForm normalizationForm);
            static /*0x3133670*/ string Normalize(string source, int type);
            static /*0x31336fc*/ void load_normalization_resource(ref nint props, ref nint mappedChars, ref nint charMapIndex, ref nint helperIndex, ref nint mapIdxToComposite, ref nint combiningClass);
        }

        class EncodingHelper
        {
            static /*0x0*/ System.Text.Encoding utf8EncodingWithoutMarkers;
            static /*0x8*/ object lockobj;
            static /*0x10*/ System.Reflection.Assembly i18nAssembly;
            static /*0x18*/ bool i18nDisabled;

            static /*0x3133b14*/ EncodingHelper();
            static /*0x3133918*/ System.Text.Encoding get_UTF8Unmarked();
            static /*0x3133b10*/ string InternalCodePage(ref int code_page);
            static /*0x3130618*/ System.Text.Encoding GetDefaultEncoding();
            static /*0x312ead0*/ object InvokeI18N(string name, object[] args);
        }
    }

    namespace Security
    {
        interface IPermission : System.Security.ISecurityEncodable
        {
            /*0x1f309e4*/ void Demand();
            /*0x1f2fec8*/ bool IsSubsetOf(System.Security.IPermission target);
        }

        interface ISecurityEncodable
        {
            /*0x1f30214*/ System.Security.SecurityElement ToXml();
        }

        class XmlSyntaxException : System.SystemException
        {
            /*0x3133b88*/ XmlSyntaxException();
            /*0x3133b90*/ XmlSyntaxException(int lineNumber);
            /*0x3133b98*/ XmlSyntaxException(int lineNumber, string message);
            /*0x3133ba0*/ XmlSyntaxException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class SecurityDocument
        {
            /*0x10*/ byte[] m_data;

            static /*0x3133ea8*/ int EncodedStringSize(string str);
            /*0x3133ba8*/ SecurityDocument(int numData);
            /*0x3133c18*/ void GuaranteeSize(int size);
            /*0x3133cd0*/ void AddString(string str, ref int position);
            /*0x3133e1c*/ void AppendString(string str, ref int position);
            /*0x3133ec4*/ string GetString(ref int position, bool bCreate);
            /*0x3134418*/ void AddToken(byte b, ref int position);
            /*0x3134474*/ System.Security.SecurityElement GetRootElement();
            /*0x3134490*/ System.Security.SecurityElement GetElement(int position, bool bCreate);
            /*0x31344a8*/ System.Security.SecurityElement InternalGetElement(ref int position, bool bCreate);
        }

        class CodeAccessPermission : System.Security.IPermission, System.Security.ISecurityEncodable
        {
            static /*0x3134b88*/ System.Security.Permissions.PermissionState CheckPermissionState(System.Security.Permissions.PermissionState state, bool allowUnrestricted);
            /*0x3134928*/ CodeAccessPermission();
            /*0x3134930*/ void Demand();
            /*0x3134a40*/ bool Equals(object obj);
            /*0x3134b58*/ int GetHashCode();
            /*0x1f2fec8*/ bool IsSubsetOf(System.Security.IPermission target);
            /*0x3134b60*/ string ToString();
            /*0x1f30214*/ System.Security.SecurityElement ToXml();
            /*0x3134c34*/ void System.Security.IPermission.Demand();
        }

        class NamedPermissionSet : System.Security.PermissionSet
        {
            /*0x30*/ string name;
            /*0x38*/ string description;

            /*0x3134c38*/ NamedPermissionSet();
            /*0x3134cf8*/ NamedPermissionSet(string name, System.Security.Permissions.PermissionState state);
            /*0x3134e48*/ NamedPermissionSet(string name);
            /*0x3134e50*/ string get_Name();
            /*0x3134da8*/ void set_Name(string value);
            /*0x3134e58*/ System.Security.SecurityElement ToXml();
            /*0x3135314*/ bool Equals(object obj);
            /*0x313552c*/ int GetHashCode();
        }

        class PermissionSet : System.Security.ISecurityEncodable, System.Collections.ICollection, System.Collections.IEnumerable, System.Runtime.Serialization.IDeserializationCallback
        {
            static /*0x0*/ object[] psUnrestricted;
            static /*0x8*/ object[] action;
            /*0x10*/ System.Security.Permissions.PermissionState state;
            /*0x18*/ System.Collections.ArrayList list;
            /*0x20*/ bool _declsec;
            /*0x28*/ bool[] _ignored;

            static /*0x3135d50*/ PermissionSet();
            /*0x3134c8c*/ PermissionSet();
            /*0x3134d78*/ PermissionSet(System.Security.Permissions.PermissionState state);
            /*0x3134964*/ PermissionSet(System.Security.IPermission perm);
            /*0x31355a8*/ void CopyTo(System.Array array, int index);
            /*0x3135710*/ void Demand();
            /*0x31349b0*/ void CasOnlyDemand(int skip);
            /*0x3135cbc*/ System.Collections.IEnumerator GetEnumerator();
            /*0x3135948*/ bool IsEmpty();
            /*0x3135cac*/ bool IsUnrestricted();
            /*0x3135cdc*/ string ToString();
            /*0x3134ef0*/ System.Security.SecurityElement ToXml();
            /*0x3135d08*/ int get_Count();
            /*0x3135d28*/ bool get_IsSynchronized();
            /*0x3135d48*/ object get_SyncRoot();
            /*0x3135d4c*/ void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
            /*0x3135398*/ bool Equals(object obj);
            /*0x3135564*/ int GetHashCode();
        }

        class SecureString : System.IDisposable
        {
            /*0x10*/ int length;
            /*0x14*/ bool disposed;
            /*0x18*/ byte[] data;

            /*0x3135ed0*/ SecureString();
            /*0x3136090*/ SecureString(char* value, int length);
            /*0x31361cc*/ int get_Length();
            /*0x3136228*/ void Dispose();
            /*0x31361c8*/ void Encrypt();
            /*0x3136278*/ void Decrypt();
            /*0x3135ef4*/ void Alloc(int length, bool realloc);
            /*0x313627c*/ byte[] GetBuffer();
        }

        enum SecurityElementType
        {
            Regular = 0,
            Format = 1,
            Comment = 2,
        }

        class SecurityElement
        {
            static /*0x0*/ char[] invalid_tag_chars;
            static /*0x8*/ char[] invalid_text_chars;
            static /*0x10*/ char[] invalid_attr_name_chars;
            static /*0x18*/ char[] invalid_attr_value_chars;
            static /*0x20*/ char[] invalid_chars;
            /*0x10*/ string text;
            /*0x18*/ string tag;
            /*0x20*/ System.Collections.ArrayList attributes;
            /*0x28*/ System.Collections.ArrayList children;

            static /*0x31379b4*/ SecurityElement();
            static /*0x3136c8c*/ string Escape(string str);
            static /*0x3136680*/ string Unescape(string str);
            static /*0x3136e94*/ bool IsValidAttributeName(string name);
            static /*0x3136f10*/ bool IsValidAttributeValue(string value);
            static /*0x313647c*/ bool IsValidTag(string tag);
            static /*0x3136604*/ bool IsValidText(string text);
            /*0x31346a4*/ SecurityElement(string tag);
            /*0x313632c*/ SecurityElement(string tag, string text);
            /*0x31365f4*/ System.Collections.ArrayList get_Children();
            /*0x31365fc*/ string get_Tag();
            /*0x31364f8*/ void set_Text(string value);
            /*0x31346ac*/ void AddAttribute(string name, string value);
            /*0x3134850*/ void AddChild(System.Security.SecurityElement child);
            /*0x3136f8c*/ System.Security.SecurityElement SearchForChildByTag(string tag);
            /*0x31370b0*/ string ToString();
            /*0x3137138*/ void ToXml(ref System.Text.StringBuilder s, int level);
            /*0x3136850*/ System.Security.SecurityElement.SecurityAttribute GetAttribute(string name);
            /*0x313776c*/ void set_m_strText(string value);
            /*0x3137774*/ string SearchForTextOfLocalName(string strLocalName);

            class SecurityAttribute
            {
                /*0x10*/ string _name;
                /*0x18*/ string _value;

                /*0x3136b1c*/ SecurityAttribute(string name, string value);
                /*0x3137b60*/ string get_Name();
                /*0x3137b68*/ string get_Value();
            }
        }

        class SecurityException : System.SystemException
        {
            /*0x90*/ string permissionState;

            /*0x3137b70*/ SecurityException();
            /*0x3137bd8*/ SecurityException(string message);
            /*0x3137bfc*/ SecurityException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x3137d1c*/ SecurityException(string message, System.Exception inner);
            /*0x3137d40*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x3137e40*/ string ToString();
        }

        class SecurityManager
        {
            static /*0x313495c*/ bool get_SecurityEnabled();
            static /*0x3137e48*/ void EnsureElevatedPermissions();
        }

        namespace Util
        {
            class Parser
            {
                /*0x10*/ System.Security.SecurityDocument _doc;
                /*0x18*/ System.Security.Util.Tokenizer _t;

                /*0x3139464*/ Parser(System.Security.Util.Tokenizer t);
                /*0x3139528*/ Parser(string input);
                /*0x3137e4c*/ System.Security.SecurityElement GetTopElement();
                /*0x3137e74*/ void GetRequiredSizes(System.Security.Util.TokenizerStream stream, ref int index);
                /*0x31383a0*/ int DetermineFormat(System.Security.Util.TokenizerStream stream);
                /*0x3138ffc*/ void ParseContents();
            }

            class Tokenizer
            {
                /*0x10*/ int LineNo;
                /*0x14*/ int _inProcessingTag;
                /*0x18*/ byte[] _inBytes;
                /*0x20*/ char[] _inChars;
                /*0x28*/ string _inString;
                /*0x30*/ int _inIndex;
                /*0x34*/ int _inSize;
                /*0x38*/ int _inSavedCharacter;
                /*0x3c*/ System.Security.Util.Tokenizer.TokenSource _inTokenSource;
                /*0x40*/ System.Security.Util.Tokenizer.ITokenReader _inTokenReader;
                /*0x48*/ System.Security.Util.Tokenizer.StringMaker _maker;
                /*0x50*/ string[] _searchStrings;
                /*0x58*/ string[] _replaceStrings;
                /*0x60*/ int _inNestedIndex;
                /*0x64*/ int _inNestedSize;
                /*0x68*/ string _inNestedString;

                /*0x3139590*/ Tokenizer(string input);
                /*0x31395e4*/ void BasicInitialization();
                /*0x3139664*/ void Recycle();
                /*0x3138dc8*/ void ChangeFormat(System.Text.Encoding encoding);
                /*0x313852c*/ void GetTokens(System.Security.Util.TokenizerStream stream, int maxNum, bool endAfterKet);
                /*0x31397f4*/ string GetStringToken();

                enum TokenSource
                {
                    UnicodeByteArray = 0,
                    UTF8ByteArray = 1,
                    ASCIIByteArray = 2,
                    CharArray = 3,
                    String = 4,
                    NestedStrings = 5,
                    Other = 6,
                }

                class StringMaker
                {
                    /*0x10*/ string[] aStrings;
                    /*0x18*/ uint cStringsMax;
                    /*0x1c*/ uint cStringsUsed;
                    /*0x20*/ System.Text.StringBuilder _outStringBuilder;
                    /*0x28*/ char[] _outChars;
                    /*0x30*/ int _outIndex;

                    static /*0x31398f0*/ uint HashString(string str);
                    static /*0x313995c*/ uint HashCharArray(char[] a, int l);
                    /*0x31399b0*/ StringMaker();
                    /*0x3139a58*/ bool CompareStringAndChars(string str, char[] a, int l);
                    /*0x31341cc*/ string MakeString();
                }

                interface ITokenReader
                {
                    /*0x1f2ffc8*/ int Read();
                }

                class StreamTokenReader : System.Security.Util.Tokenizer.ITokenReader
                {
                    /*0x10*/ System.IO.StreamReader _in;
                    /*0x18*/ int _numCharRead;

                    /*0x31396bc*/ StreamTokenReader(System.IO.StreamReader input);
                    /*0x3139af8*/ int Read();
                    /*0x3139b34*/ int get_NumCharEncountered();
                }
            }

            class TokenizerShortBlock
            {
                /*0x10*/ short[] m_block;
                /*0x18*/ System.Security.Util.TokenizerShortBlock m_next;

                /*0x3139b3c*/ TokenizerShortBlock();
            }

            class TokenizerStringBlock
            {
                /*0x10*/ string[] m_block;
                /*0x18*/ System.Security.Util.TokenizerStringBlock m_next;

                /*0x3139ba0*/ TokenizerStringBlock();
            }

            class TokenizerStream
            {
                /*0x10*/ int m_countTokens;
                /*0x18*/ System.Security.Util.TokenizerShortBlock m_headTokens;
                /*0x20*/ System.Security.Util.TokenizerShortBlock m_lastTokens;
                /*0x28*/ System.Security.Util.TokenizerShortBlock m_currentTokens;
                /*0x30*/ int m_indexTokens;
                /*0x38*/ System.Security.Util.TokenizerStringBlock m_headStrings;
                /*0x40*/ System.Security.Util.TokenizerStringBlock m_currentStrings;
                /*0x48*/ int m_indexStrings;

                /*0x31392d0*/ TokenizerStream();
                /*0x31396f4*/ void AddToken(short token);
                /*0x3139808*/ void AddString(string str);
                /*0x3139380*/ void Reset();
                /*0x31393c4*/ short GetNextFullToken();
                /*0x313829c*/ short GetNextToken();
                /*0x3138328*/ string GetNextString();
                /*0x31382b0*/ void ThrowAwayNextString();
                /*0x31382b4*/ void TagLastToken(short tag);
                /*0x3139c04*/ int GetTokenCount();
                /*0x3138d7c*/ void GoToPosition(int position);
            }
        }

        namespace Policy
        {
            class Evidence : System.Collections.ICollection, System.Collections.IEnumerable
            {
                /*0x10*/ bool _locked;
                /*0x18*/ System.Collections.ArrayList hostEvidenceList;
                /*0x20*/ System.Collections.ArrayList assemblyEvidenceList;

                /*0x3139c0c*/ Evidence();
                /*0x3139c14*/ int get_Count();
                /*0x3139c70*/ bool get_IsSynchronized();
                /*0x3139c78*/ object get_SyncRoot();
                /*0x3139c7c*/ void CopyTo(System.Array array, int index);
                /*0x3139d40*/ System.Collections.IEnumerator GetEnumerator();

                class EvidenceEnumerator : System.Collections.IEnumerator
                {
                    /*0x10*/ System.Collections.IEnumerator currentEnum;
                    /*0x18*/ System.Collections.IEnumerator hostEnum;
                    /*0x20*/ System.Collections.IEnumerator assemblyEnum;

                    /*0x3139de4*/ EvidenceEnumerator(System.Collections.IEnumerator hostenum, System.Collections.IEnumerator assemblyenum);
                    /*0x3139e44*/ bool MoveNext();
                    /*0x3139f90*/ void Reset();
                    /*0x313a0b8*/ object get_Current();
                }
            }
        }

        namespace Permissions
        {
            enum PermissionState
            {
                None = 0,
                Unrestricted = 1,
            }

            enum SecurityAction
            {
                Demand = 2,
                Assert = 3,
                Deny = 4,
                PermitOnly = 5,
                LinkDemand = 6,
                InheritanceDemand = 7,
                RequestMinimum = 8,
                RequestOptional = 9,
                RequestRefuse = 10,
            }
        }

        namespace Cryptography
        {
            class CryptoStream : System.IO.Stream, System.IDisposable
            {
                /*0x28*/ System.IO.Stream _stream;
                /*0x30*/ System.Security.Cryptography.ICryptoTransform _transform;
                /*0x38*/ System.Security.Cryptography.CryptoStreamMode _transformMode;
                /*0x40*/ byte[] _inputBuffer;
                /*0x48*/ int _inputBufferIndex;
                /*0x4c*/ int _inputBlockSize;
                /*0x50*/ byte[] _outputBuffer;
                /*0x58*/ int _outputBufferIndex;
                /*0x5c*/ int _outputBlockSize;
                /*0x60*/ bool _canRead;
                /*0x61*/ bool _canWrite;
                /*0x62*/ bool _finalBlockTransformed;
                /*0x68*/ System.Threading.SemaphoreSlim _lazyAsyncActiveSemaphore;
                /*0x70*/ bool _leaveOpen;

                /*0x313a15c*/ CryptoStream(System.IO.Stream stream, System.Security.Cryptography.ICryptoTransform transform, System.Security.Cryptography.CryptoStreamMode mode);
                /*0x313a164*/ CryptoStream(System.IO.Stream stream, System.Security.Cryptography.ICryptoTransform transform, System.Security.Cryptography.CryptoStreamMode mode, bool leaveOpen);
                /*0x313a4c4*/ bool get_CanRead();
                /*0x313a4cc*/ bool get_CanSeek();
                /*0x313a4d4*/ bool get_CanWrite();
                /*0x313a4dc*/ long get_Length();
                /*0x313a528*/ long get_Position();
                /*0x313a574*/ void set_Position(long value);
                /*0x313a5c0*/ bool get_HasFlushedFinalBlock();
                /*0x313a5c8*/ void FlushFinalBlock();
                /*0x313a7f0*/ void Flush();
                /*0x313a7f4*/ System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken cancellationToken);
                /*0x313a970*/ long Seek(long offset, System.IO.SeekOrigin origin);
                /*0x313a9bc*/ void SetLength(long value);
                /*0x313aa08*/ System.Threading.Tasks.Task<int> ReadAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
                /*0x313acec*/ System.IAsyncResult BeginRead(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state);
                /*0x313ada0*/ int EndRead(System.IAsyncResult asyncResult);
                /*0x313ab88*/ System.Threading.Tasks.Task<int> ReadAsyncInternal(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
                /*0x313adfc*/ int ReadByte();
                /*0x313ae78*/ void WriteByte(byte value);
                /*0x313aecc*/ int Read(byte[] buffer, int offset, int count);
                /*0x313aa50*/ void CheckReadArguments(byte[] buffer, int offset, int count);
                /*0x313af98*/ System.Threading.Tasks.Task<int> ReadAsyncCore(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken, bool useAsync);
                /*0x313b10c*/ System.Threading.Tasks.Task WriteAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
                /*0x313b3b8*/ System.IAsyncResult BeginWrite(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state);
                /*0x313b46c*/ void EndWrite(System.IAsyncResult asyncResult);
                /*0x313b28c*/ System.Threading.Tasks.Task WriteAsyncInternal(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
                /*0x313b478*/ void Write(byte[] buffer, int offset, int count);
                /*0x313b154*/ void CheckWriteArguments(byte[] buffer, int offset, int count);
                /*0x313b4e8*/ System.Threading.Tasks.Task WriteAsyncCore(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken, bool useAsync);
                /*0x313b624*/ void Clear();
                /*0x313b634*/ void Dispose(bool disposing);
                /*0x313a350*/ void InitializeBuffer();
                /*0x313b6d8*/ System.Threading.SemaphoreSlim get_AsyncActiveSemaphore();

                struct <ReadAsyncInternal>d__37 : System.Runtime.CompilerServices.IAsyncStateMachine
                {
                    /*0x10*/ int <>1__state;
                    /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder<int> <>t__builder;
                    /*0x30*/ System.Security.Cryptography.CryptoStream <>4__this;
                    /*0x38*/ byte[] buffer;
                    /*0x40*/ int offset;
                    /*0x44*/ int count;
                    /*0x48*/ System.Threading.CancellationToken cancellationToken;
                    /*0x50*/ System.Threading.SemaphoreSlim <semaphore>5__2;
                    /*0x58*/ System.Threading.Tasks.ForceAsyncAwaiter <>u__1;
                    /*0x60*/ System.Runtime.CompilerServices.TaskAwaiter<int> <>u__2;

                    /*0x313b7d0*/ void MoveNext();
                    /*0x313bcac*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
                }

                struct <ReadAsyncCore>d__42 : System.Runtime.CompilerServices.IAsyncStateMachine
                {
                    /*0x10*/ int <>1__state;
                    /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder<int> <>t__builder;
                    /*0x30*/ int count;
                    /*0x34*/ int offset;
                    /*0x38*/ System.Security.Cryptography.CryptoStream <>4__this;
                    /*0x40*/ byte[] buffer;
                    /*0x48*/ bool useAsync;
                    /*0x50*/ System.Threading.CancellationToken cancellationToken;
                    /*0x58*/ int <bytesToDeliver>5__2;
                    /*0x5c*/ int <currentOutputIndex>5__3;
                    /*0x60*/ int <numWholeBlocksInBytes>5__4;
                    /*0x68*/ byte[] <tempInputBuffer>5__5;
                    /*0x70*/ byte[] <tempOutputBuffer>5__6;
                    /*0x78*/ System.Runtime.CompilerServices.ValueTaskAwaiter<int> <>u__1;

                    /*0x313bd28*/ void MoveNext();
                    /*0x313cd50*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
                }

                struct <WriteAsyncInternal>d__46 : System.Runtime.CompilerServices.IAsyncStateMachine
                {
                    /*0x10*/ int <>1__state;
                    /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder <>t__builder;
                    /*0x30*/ System.Security.Cryptography.CryptoStream <>4__this;
                    /*0x38*/ byte[] buffer;
                    /*0x40*/ int offset;
                    /*0x44*/ int count;
                    /*0x48*/ System.Threading.CancellationToken cancellationToken;
                    /*0x50*/ System.Threading.SemaphoreSlim <semaphore>5__2;
                    /*0x58*/ System.Threading.Tasks.ForceAsyncAwaiter <>u__1;
                    /*0x60*/ System.Runtime.CompilerServices.TaskAwaiter <>u__2;

                    /*0x313cdcc*/ void MoveNext();
                    /*0x313d210*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
                }

                struct <WriteAsyncCore>d__49 : System.Runtime.CompilerServices.IAsyncStateMachine
                {
                    /*0x10*/ int <>1__state;
                    /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder <>t__builder;
                    /*0x30*/ int count;
                    /*0x34*/ int offset;
                    /*0x38*/ System.Security.Cryptography.CryptoStream <>4__this;
                    /*0x40*/ byte[] buffer;
                    /*0x48*/ bool useAsync;
                    /*0x50*/ System.Threading.CancellationToken cancellationToken;
                    /*0x58*/ int <bytesToWrite>5__2;
                    /*0x5c*/ int <currentInputIndex>5__3;
                    /*0x60*/ int <numOutputBytes>5__4;
                    /*0x68*/ System.Runtime.CompilerServices.ValueTaskAwaiter <>u__1;
                    /*0x78*/ int <numWholeBlocksInBytes>5__5;
                    /*0x80*/ byte[] <tempOutputBuffer>5__6;

                    /*0x313d278*/ void MoveNext();
                    /*0x313e0b8*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
                }

                class <>c
                {
                    static /*0x0*/ System.Security.Cryptography.CryptoStream.<> <>9;
                    static /*0x8*/ System.Func<System.Threading.SemaphoreSlim> <>9__54_0;

                    static /*0x313e120*/ <>c();
                    /*0x313e188*/ <>c();
                    /*0x313e190*/ System.Threading.SemaphoreSlim <get_AsyncActiveSemaphore>b__54_0();
                }
            }

            enum CryptoStreamMode
            {
                Read = 0,
                Write = 1,
            }

            class CryptographicOperations
            {
                static /*0x313cce8*/ void ZeroMemory(System.Span<byte> buffer);
            }

            class HashAlgorithm : System.IDisposable, System.Security.Cryptography.ICryptoTransform
            {
                /*0x10*/ bool _disposed;
                /*0x14*/ int HashSizeValue;
                /*0x18*/ byte[] HashValue;
                /*0x20*/ int State;

                static /*0x313e1f4*/ System.Security.Cryptography.HashAlgorithm Create(string hashName);
                /*0x313e1ec*/ HashAlgorithm();
                /*0x313e274*/ int get_HashSize();
                /*0x313e27c*/ byte[] get_Hash();
                /*0x313e3b0*/ byte[] ComputeHash(byte[] buffer);
                /*0x313e510*/ byte[] ComputeHash(byte[] buffer, int offset, int count);
                /*0x313e454*/ byte[] CaptureHashCodeAndReinitialize();
                /*0x313e670*/ void Dispose();
                /*0x313e6dc*/ void Clear();
                /*0x313e770*/ void Dispose(bool disposing);
                /*0x313e780*/ int get_InputBlockSize();
                /*0x313e788*/ int get_OutputBlockSize();
                /*0x313e790*/ bool get_CanTransformMultipleBlocks();
                /*0x313e798*/ int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);
                /*0x313e978*/ byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount);
                /*0x313e834*/ void ValidateTransformBlock(byte[] inputBuffer, int inputOffset, int inputCount);
                void HashCore(byte[] array, int ibStart, int cbSize);
                /*0x1f30214*/ byte[] HashFinal();
                /*0x1f309e4*/ void Initialize();
            }

            class Aes : System.Security.Cryptography.SymmetricAlgorithm
            {
                static /*0x0*/ System.Security.Cryptography.KeySizes[] s_legalBlockSizes;
                static /*0x8*/ System.Security.Cryptography.KeySizes[] s_legalKeySizes;

                static /*0x313eb64*/ Aes();
                /*0x313eac0*/ Aes();
            }

            class AsymmetricAlgorithm : System.IDisposable
            {
                /*0x10*/ int KeySizeValue;
                /*0x18*/ System.Security.Cryptography.KeySizes[] LegalKeySizesValue;

                /*0x313ece8*/ AsymmetricAlgorithm();
                /*0x313ecf0*/ void Dispose();
                /*0x313ecf4*/ void Clear();
                /*0x313ed60*/ void Dispose(bool disposing);
                /*0x313ed64*/ int get_KeySize();
                /*0x313ed6c*/ void set_KeySize(int value);
                /*0x313ee7c*/ void FromXmlString(string xmlString);
                /*0x313eeb4*/ string ToXmlString(bool includePrivateParameters);
            }

            class AsymmetricSignatureDeformatter
            {
                /*0x313eeec*/ AsymmetricSignatureDeformatter();
                /*0x1f30ebc*/ void SetKey(System.Security.Cryptography.AsymmetricAlgorithm key);
                /*0x1f30ebc*/ void SetHashAlgorithm(string strName);
                /*0x1f2ff00*/ bool VerifySignature(byte[] rgbHash, byte[] rgbSignature);
            }

            class AsymmetricSignatureFormatter
            {
                /*0x313eef4*/ AsymmetricSignatureFormatter();
            }

            enum CipherMode
            {
                CBC = 1,
                ECB = 2,
                OFB = 3,
                CFB = 4,
                CTS = 5,
            }

            enum PaddingMode
            {
                None = 1,
                PKCS7 = 2,
                Zeros = 3,
                ANSIX923 = 4,
                ISO10126 = 5,
            }

            class KeySizes
            {
                /*0x10*/ int m_minSize;
                /*0x14*/ int m_maxSize;
                /*0x18*/ int m_skipSize;

                static /*0x313ef58*/ bool IsLegalKeySize(System.Security.Cryptography.KeySizes[] legalKeys, int size);
                /*0x313ecac*/ KeySizes(int minSize, int maxSize, int skipSize);
                /*0x313eefc*/ int get_MinSize();
                /*0x313ef04*/ int get_MaxSize();
                /*0x313ef0c*/ int get_SkipSize();
                /*0x313ef14*/ bool IsLegal(int keySize);
            }

            class CryptographicException : System.SystemException
            {
                /*0x313efec*/ CryptographicException();
                /*0x313ee54*/ CryptographicException(string message);
                /*0x313f058*/ CryptographicException(string format, string insert);
                /*0x313f0f0*/ CryptographicException(string message, System.Exception inner);
                /*0x313f118*/ CryptographicException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            }

            class CryptographicUnexpectedOperationException : System.Security.Cryptography.CryptographicException
            {
                /*0x313f120*/ CryptographicUnexpectedOperationException();
                /*0x313e368*/ CryptographicUnexpectedOperationException(string message);
                /*0x313f144*/ CryptographicUnexpectedOperationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            }

            enum CspProviderFlags
            {
                NoFlags = 0,
                UseMachineKeyStore = 1,
                UseDefaultKeyContainer = 2,
                UseNonExportableKey = 4,
                UseExistingKey = 8,
                UseArchivableKey = 16,
                UseUserProtectedKey = 32,
                NoPrompt = 64,
                CreateEphemeralKey = 128,
            }

            class CspParameters
            {
                /*0x10*/ int ProviderType;
                /*0x18*/ string ProviderName;
                /*0x20*/ string KeyContainerName;
                /*0x28*/ int KeyNumber;
                /*0x2c*/ int m_flags;

                /*0x313f230*/ CspParameters();
                /*0x313f24c*/ CspParameters(int dwTypeIn);
                /*0x313f244*/ CspParameters(int dwTypeIn, string strProviderNameIn, string strContainerNameIn);
                /*0x313f25c*/ CspParameters(int providerType, string providerName, string keyContainerName, System.Security.Cryptography.CspProviderFlags flags);
                /*0x313f14c*/ System.Security.Cryptography.CspProviderFlags get_Flags();
                /*0x313f154*/ void set_Flags(System.Security.Cryptography.CspProviderFlags value);
            }

            class DES : System.Security.Cryptography.SymmetricAlgorithm
            {
                static /*0x0*/ System.Security.Cryptography.KeySizes[] s_legalBlockSizes;
                static /*0x8*/ System.Security.Cryptography.KeySizes[] s_legalKeySizes;

                static /*0x313fb70*/ DES();
                static /*0x313f9a8*/ System.Security.Cryptography.DES Create();
                static /*0x313f448*/ bool IsWeakKey(byte[] rgbKey);
                static /*0x313f578*/ bool IsSemiWeakKey(byte[] rgbKey);
                static /*0x313fab8*/ bool IsLegalKeySize(byte[] rgbKey);
                static /*0x313fad8*/ ulong QuadWordFromBigEndian(byte[] block);
                /*0x313f2c8*/ DES();
                /*0x313f360*/ byte[] get_Key();
                /*0x313f784*/ void set_Key(byte[] value);
            }

            class DESCryptoServiceProvider : System.Security.Cryptography.DES
            {
                /*0x313f9f8*/ DESCryptoServiceProvider();
                /*0x313fcb0*/ System.Security.Cryptography.ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV);
                /*0x313fde0*/ System.Security.Cryptography.ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV);
                /*0x313ff10*/ void GenerateKey();
                /*0x313fff4*/ void GenerateIV();
            }

            struct DSAParameters
            {
                /*0x10*/ byte[] P;
                /*0x18*/ byte[] Q;
                /*0x20*/ byte[] G;
                /*0x28*/ byte[] Y;
                /*0x30*/ byte[] J;
                /*0x38*/ byte[] X;
                /*0x40*/ byte[] Seed;
                /*0x48*/ int Counter;
            }

            class DSA : System.Security.Cryptography.AsymmetricAlgorithm
            {
                static /*0x3140074*/ System.Security.Cryptography.DSA Create();
                /*0x314006c*/ DSA();
                /*0x1f2ff00*/ bool VerifySignature(byte[] rgbHash, byte[] rgbSignature);
                /*0x31400c8*/ void FromXmlString(string xmlString);
                /*0x3140750*/ string ToXmlString(bool includePrivateParameters);
                System.Security.Cryptography.DSAParameters ExportParameters(bool includePrivateParameters);
                void ImportParameters(System.Security.Cryptography.DSAParameters parameters);
            }

            class DSASignatureDeformatter : System.Security.Cryptography.AsymmetricSignatureDeformatter
            {
                /*0x10*/ System.Security.Cryptography.DSA _dsaKey;
                /*0x18*/ string _oid;

                /*0x3141000*/ DSASignatureDeformatter();
                /*0x3141088*/ DSASignatureDeformatter(System.Security.Cryptography.AsymmetricAlgorithm key);
                /*0x3141184*/ void SetKey(System.Security.Cryptography.AsymmetricAlgorithm key);
                /*0x3141278*/ void SetHashAlgorithm(string strName);
                /*0x3141340*/ bool VerifySignature(byte[] rgbHash, byte[] rgbSignature);
            }

            class DSASignatureFormatter : System.Security.Cryptography.AsymmetricSignatureFormatter
            {
                /*0x10*/ string _oid;

                /*0x3141424*/ DSASignatureFormatter();
            }

            class HMAC : System.Security.Cryptography.KeyedHashAlgorithm
            {
                /*0x30*/ int blockSizeValue;
                /*0x38*/ string m_hashName;
                /*0x40*/ System.Security.Cryptography.HashAlgorithm m_hash1;
                /*0x48*/ System.Security.Cryptography.HashAlgorithm m_hash2;
                /*0x50*/ byte[] m_inner;
                /*0x58*/ byte[] m_outer;
                /*0x60*/ bool m_hashing;

                static /*0x3141844*/ System.Security.Cryptography.HMAC Create();
                /*0x3141c88*/ HMAC();
                /*0x31414ac*/ int get_BlockSizeValue();
                /*0x31414b4*/ void set_BlockSizeValue(int value);
                /*0x31414bc*/ void UpdateIOPadBuffers();
                /*0x3141648*/ void InitializeKey(byte[] key);
                /*0x3141768*/ byte[] get_Key();
                /*0x31417e0*/ void set_Key(byte[] value);
                /*0x31418d4*/ void Initialize();
                /*0x314191c*/ void HashCore(byte[] rgb, int ib, int cb);
                /*0x31419a4*/ byte[] HashFinal();
                /*0x3141ae8*/ void Dispose(bool disposing);
            }

            class HMACMD5 : System.Security.Cryptography.HMAC
            {
                /*0x3141ca0*/ HMACMD5();
                /*0x3141cc4*/ HMACMD5(byte[] key);
            }

            class HMACRIPEMD160 : System.Security.Cryptography.HMAC
            {
                /*0x3141da0*/ HMACRIPEMD160();
                /*0x3141dc4*/ HMACRIPEMD160(byte[] key);
            }

            class HMACSHA1 : System.Security.Cryptography.HMAC
            {
                /*0x31418ac*/ HMACSHA1();
                /*0x3141fd8*/ HMACSHA1(byte[] key);
                /*0x3141fe0*/ HMACSHA1(byte[] key, bool useManagedSha1);
            }

            class HMACSHA256 : System.Security.Cryptography.HMAC
            {
                /*0x31421f4*/ HMACSHA256();
                /*0x3142218*/ HMACSHA256(byte[] key);
            }

            class HMACSHA384 : System.Security.Cryptography.HMAC
            {
                /*0x61*/ bool m_useLegacyBlockSize;

                /*0x314242c*/ HMACSHA384();
                /*0x3142450*/ HMACSHA384(byte[] key);
                /*0x3142688*/ int get_BlockSize();
            }

            class HMACSHA512 : System.Security.Cryptography.HMAC
            {
                /*0x61*/ bool m_useLegacyBlockSize;

                /*0x31426a0*/ HMACSHA512();
                /*0x31426c4*/ HMACSHA512(byte[] key);
                /*0x31427c4*/ int get_BlockSize();
            }

            interface ICryptoTransform : System.IDisposable
            {
                /*0x1f2ffc8*/ int get_InputBlockSize();
                /*0x1f2ffc8*/ int get_OutputBlockSize();
                /*0x1f2fe14*/ bool get_CanTransformMultipleBlocks();
                int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);
                /*0x1f30348*/ byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount);
            }

            class KeyedHashAlgorithm : System.Security.Cryptography.HashAlgorithm
            {
                /*0x28*/ byte[] KeyValue;

                /*0x3141c98*/ KeyedHashAlgorithm();
                /*0x3141c30*/ void Dispose(bool disposing);
                /*0x31427dc*/ byte[] get_Key();
                /*0x3142854*/ void set_Key(byte[] value);
            }

            class MACTripleDES : System.Security.Cryptography.KeyedHashAlgorithm
            {
                /*0x30*/ System.Security.Cryptography.ICryptoTransform m_encryptor;
                /*0x38*/ System.Security.Cryptography.CryptoStream _cs;
                /*0x40*/ System.Security.Cryptography.TailStream _ts;
                /*0x48*/ int m_bytesPerBlock;
                /*0x50*/ System.Security.Cryptography.TripleDES des;

                /*0x314295c*/ MACTripleDES();
                /*0x3142ac0*/ void Initialize();
                /*0x3142acc*/ void HashCore(byte[] rgbData, int ibStart, int cbSize);
                /*0x3142ce8*/ byte[] HashFinal();
                /*0x3142ec4*/ void Dispose(bool disposing);
            }

            class TailStream : System.IO.Stream
            {
                /*0x28*/ byte[] _Buffer;
                /*0x30*/ int _BufferSize;
                /*0x34*/ int _BufferIndex;
                /*0x38*/ bool _BufferFull;

                /*0x3142c4c*/ TailStream(int bufferSize);
                /*0x3142fac*/ void Clear();
                /*0x3142fbc*/ void Dispose(bool disposing);
                /*0x3142e4c*/ byte[] get_Buffer();
                /*0x3143080*/ bool get_CanRead();
                /*0x3143088*/ bool get_CanSeek();
                /*0x3143090*/ bool get_CanWrite();
                /*0x31430a0*/ long get_Length();
                /*0x31430f8*/ long get_Position();
                /*0x3143150*/ void set_Position(long value);
                /*0x31431a8*/ void Flush();
                /*0x31431ac*/ long Seek(long offset, System.IO.SeekOrigin origin);
                /*0x3143204*/ void SetLength(long value);
                /*0x314325c*/ int Read(byte[] buffer, int offset, int count);
                /*0x31432b4*/ void Write(byte[] buffer, int offset, int count);
            }

            class MD5 : System.Security.Cryptography.HashAlgorithm
            {
                static /*0x3143444*/ System.Security.Cryptography.MD5 Create();
                /*0x3143424*/ MD5();
            }

            class RandomNumberGenerator : System.IDisposable
            {
                static /*0x31434a0*/ System.Security.Cryptography.RandomNumberGenerator Create();
                /*0x3143498*/ RandomNumberGenerator();
                /*0x31434f4*/ void Dispose();
                /*0x3143560*/ void Dispose(bool disposing);
                /*0x1f30ebc*/ void GetBytes(byte[] data);
                /*0x3143564*/ void GetBytes(byte[] data, int offset, int count);
                /*0x3143744*/ void GetBytes(System.Span<byte> data);
            }

            class RC2 : System.Security.Cryptography.SymmetricAlgorithm
            {
                static /*0x0*/ System.Security.Cryptography.KeySizes[] s_legalBlockSizes;
                static /*0x8*/ System.Security.Cryptography.KeySizes[] s_legalKeySizes;
                /*0x44*/ int EffectiveKeySizeValue;

                static /*0x3143aac*/ RC2();
                /*0x3143984*/ RC2();
                /*0x3143a1c*/ int get_EffectiveKeySize();
                /*0x3143a38*/ int get_KeySize();
                /*0x3143a40*/ void set_KeySize(int value);
            }

            class RC2CryptoServiceProvider : System.Security.Cryptography.RC2
            {
                static /*0x0*/ System.Security.Cryptography.KeySizes[] s_legalKeySizes;
                /*0x48*/ bool m_use40bitSalt;

                static /*0x3143ff0*/ RC2CryptoServiceProvider();
                /*0x3143bec*/ RC2CryptoServiceProvider();
                /*0x3143d58*/ int get_EffectiveKeySize();
                /*0x3143d60*/ System.Security.Cryptography.ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV);
                /*0x3143e28*/ System.Security.Cryptography.ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV);
                /*0x3143ef0*/ void GenerateKey();
                /*0x3143f78*/ void GenerateIV();
            }

            class Rijndael : System.Security.Cryptography.SymmetricAlgorithm
            {
                static /*0x0*/ System.Security.Cryptography.KeySizes[] s_legalBlockSizes;
                static /*0x8*/ System.Security.Cryptography.KeySizes[] s_legalKeySizes;

                static /*0x314415c*/ Rijndael();
                /*0x31440c4*/ Rijndael();
            }

            class RijndaelManaged : System.Security.Cryptography.Rijndael
            {
                /*0x314429c*/ RijndaelManaged();
                /*0x3144374*/ System.Security.Cryptography.ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV);
                /*0x314447c*/ System.Security.Cryptography.ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV);
                /*0x3144490*/ void GenerateKey();
                /*0x31444c8*/ void GenerateIV();
                /*0x3144388*/ System.Security.Cryptography.ICryptoTransform NewEncryptor(byte[] rgbKey, System.Security.Cryptography.CipherMode mode, byte[] rgbIV, int feedbackSize, System.Security.Cryptography.RijndaelManagedTransformMode encryptMode);
            }

            enum RijndaelManagedTransformMode
            {
                Encrypt = 0,
                Decrypt = 1,
            }

            class RijndaelManagedTransform : System.Security.Cryptography.ICryptoTransform, System.IDisposable
            {
                static /*0x0*/ byte[] s_Sbox;
                static /*0x8*/ int[] s_Rcon;
                static /*0x10*/ int[] s_T;
                static /*0x18*/ int[] s_TF;
                static /*0x20*/ int[] s_iT;
                static /*0x28*/ int[] s_iTF;
                /*0x10*/ System.Security.Cryptography.CipherMode m_cipherMode;
                /*0x14*/ System.Security.Cryptography.PaddingMode m_paddingValue;
                /*0x18*/ System.Security.Cryptography.RijndaelManagedTransformMode m_transformMode;
                /*0x1c*/ int m_blockSizeBits;
                /*0x20*/ int m_blockSizeBytes;
                /*0x24*/ int m_inputBlockSize;
                /*0x28*/ int m_outputBlockSize;
                /*0x30*/ int[] m_encryptKeyExpansion;
                /*0x38*/ int[] m_decryptKeyExpansion;
                /*0x40*/ int m_Nr;
                /*0x44*/ int m_Nb;
                /*0x48*/ int m_Nk;
                /*0x50*/ int[] m_encryptindex;
                /*0x58*/ int[] m_decryptindex;
                /*0x60*/ int[] m_IV;
                /*0x68*/ int[] m_lastBlockBuffer;
                /*0x70*/ byte[] m_depadBuffer;
                /*0x78*/ byte[] m_shiftRegister;

                static /*0x314744c*/ RijndaelManagedTransform();
                static /*0x3147444*/ int rot1(int val);
                static /*0x314743c*/ int rot2(int val);
                static /*0x314734c*/ int rot3(int val);
                static /*0x3147354*/ int SubWord(int a);
                static /*0x3147418*/ int MulX(int x);
                /*0x3144500*/ RijndaelManagedTransform(byte[] rgbKey, System.Security.Cryptography.CipherMode mode, byte[] rgbIV, int blockSize, int feedbackSize, System.Security.Cryptography.PaddingMode PaddingValue, System.Security.Cryptography.RijndaelManagedTransformMode transformMode);
                /*0x31450e8*/ void Dispose();
                /*0x31450f0*/ void Dispose(bool disposing);
                /*0x3145218*/ int get_InputBlockSize();
                /*0x3145220*/ int get_OutputBlockSize();
                /*0x3145228*/ bool get_CanTransformMultipleBlocks();
                /*0x3145230*/ int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);
                /*0x3146c54*/ byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount);
                /*0x3146f20*/ void Reset();
                /*0x3145500*/ int EncryptData(byte[] inputBuffer, int inputOffset, int inputCount, ref byte[] outputBuffer, int outputOffset, System.Security.Cryptography.PaddingMode paddingMode, bool fLast);
                /*0x3146138*/ int DecryptData(byte[] inputBuffer, int inputOffset, int inputCount, ref byte[] outputBuffer, int outputOffset, System.Security.Cryptography.PaddingMode paddingMode, bool fLast);
                /*0x3146fa4*/ void Enc(int* encryptindex, int* encryptKeyExpansion, int* T, int* TF, int* work, int* temp);
                /*0x3147174*/ void Dec(int* decryptindex, int* decryptKeyExpansion, int* iT, int* iTF, int* work, int* temp);
                /*0x3144b64*/ void GenerateKeyExpansion(byte[] rgbKey);
            }

            class RIPEMD160 : System.Security.Cryptography.HashAlgorithm
            {
                static /*0x314768c*/ System.Security.Cryptography.RIPEMD160 Create();
                /*0x314766c*/ RIPEMD160();
            }

            class RIPEMD160Managed : System.Security.Cryptography.RIPEMD160
            {
                /*0x28*/ byte[] _buffer;
                /*0x30*/ long _count;
                /*0x38*/ uint[] _stateMD160;
                /*0x40*/ uint[] _blockDWords;

                static /*0x3147abc*/ void MDTransform(uint* blockDWords, uint* state, byte* block);
                static /*0x314913c*/ uint F(uint x, uint y, uint z);
                static /*0x3149148*/ uint G(uint x, uint y, uint z);
                static /*0x3149158*/ uint H(uint x, uint y, uint z);
                static /*0x3149164*/ uint I(uint x, uint y, uint z);
                static /*0x3149174*/ uint J(uint x, uint y, uint z);
                /*0x3141e98*/ RIPEMD160Managed();
                /*0x3147760*/ void Initialize();
                /*0x31477a4*/ void HashCore(byte[] rgb, int ibStart, int cbSize);
                /*0x3147928*/ byte[] HashFinal();
                /*0x31476dc*/ void InitializeState();
                /*0x31477a8*/ void _HashData(byte[] partIn, int ibStart, int cbSize);
                /*0x314792c*/ byte[] _EndHash();
            }

            struct RSAParameters
            {
                /*0x10*/ byte[] Exponent;
                /*0x18*/ byte[] Modulus;
                /*0x20*/ byte[] P;
                /*0x28*/ byte[] Q;
                /*0x30*/ byte[] DP;
                /*0x38*/ byte[] DQ;
                /*0x40*/ byte[] InverseQ;
                /*0x48*/ byte[] D;
            }

            class RSA : System.Security.Cryptography.AsymmetricAlgorithm
            {
                static /*0x3149188*/ System.Security.Cryptography.RSA Create();
                /*0x3149180*/ RSA();
                /*0x3149220*/ byte[] EncryptValue(byte[] rgb);
                /*0x3149278*/ void FromXmlString(string xmlString);
                /*0x3149810*/ string ToXmlString(bool includePrivateParameters);
                System.Security.Cryptography.RSAParameters ExportParameters(bool includePrivateParameters);
                void ImportParameters(System.Security.Cryptography.RSAParameters parameters);
            }

            class RSACryptoServiceProvider : System.Security.Cryptography.RSA
            {
                static /*0x0*/ System.Security.Cryptography.CspProviderFlags s_UseMachineKeyStore;
                /*0x20*/ Mono.Security.Cryptography.KeyPairPersistence store;
                /*0x28*/ bool persistKey;
                /*0x29*/ bool persisted;
                /*0x2a*/ bool privateKeyExportable;
                /*0x2b*/ bool m_disposed;
                /*0x30*/ Mono.Security.Cryptography.RSAManaged rsa;

                static /*0x3149c38*/ bool get_UseMachineKeyStore();
                /*0x31491f4*/ RSACryptoServiceProvider();
                /*0x3149cc4*/ RSACryptoServiceProvider(System.Security.Cryptography.CspParameters parameters);
                /*0x3149c8c*/ RSACryptoServiceProvider(int dwKeySize);
                /*0x3149cd0*/ RSACryptoServiceProvider(int dwKeySize, System.Security.Cryptography.CspParameters parameters);
                /*0x3149d2c*/ void Common(int dwKeySize, bool parameters);
                /*0x3149f74*/ void Common(System.Security.Cryptography.CspParameters p);
                /*0x314a0a0*/ void Finalize();
                /*0x314a130*/ int get_KeySize();
                /*0x314a150*/ bool get_PublicOnly();
                /*0x314a168*/ byte[] EncryptValue(byte[] rgb);
                /*0x314a184*/ System.Security.Cryptography.RSAParameters ExportParameters(bool includePrivateParameters);
                /*0x314a2bc*/ void ImportParameters(System.Security.Cryptography.RSAParameters parameters);
                /*0x314a300*/ string GetHashNameFromOID(string oid);
                /*0x314a4c4*/ bool VerifyHash(byte[] rgbHash, string str, byte[] rgbSignature);
                /*0x314a5e4*/ void Dispose(bool disposing);
                /*0x314a638*/ void OnKeyGenerated(object sender, System.EventArgs e);
            }

            class SHA1 : System.Security.Cryptography.HashAlgorithm
            {
                static /*0x314a6dc*/ System.Security.Cryptography.SHA1 Create();
                /*0x314a6bc*/ SHA1();
            }

            class SHA1Managed : System.Security.Cryptography.SHA1
            {
                /*0x28*/ byte[] _buffer;
                /*0x30*/ long _count;
                /*0x38*/ uint[] _stateSHA1;
                /*0x40*/ uint[] _expandedBuffer;

                static /*0x314ab10*/ void SHATransform(uint* expandedBuffer, uint* state, byte* block);
                static /*0x314aef0*/ void SHAExpand(uint* x);
                /*0x31420b4*/ SHA1Managed();
                /*0x314a7b4*/ void Initialize();
                /*0x314a7f8*/ void HashCore(byte[] rgb, int ibStart, int cbSize);
                /*0x314a97c*/ byte[] HashFinal();
                /*0x314a730*/ void InitializeState();
                /*0x314a7fc*/ void _HashData(byte[] partIn, int ibStart, int cbSize);
                /*0x314a980*/ byte[] _EndHash();
            }

            class SHA256 : System.Security.Cryptography.HashAlgorithm
            {
                static /*0x314af4c*/ System.Security.Cryptography.SHA256 Create();
                /*0x314af2c*/ SHA256();
            }

            class SHA256Managed : System.Security.Cryptography.SHA256
            {
                static /*0x0*/ uint[] _K;
                /*0x28*/ byte[] _buffer;
                /*0x30*/ long _count;
                /*0x38*/ uint[] _stateSHA256;
                /*0x40*/ uint[] _W;

                static /*0x314bbd8*/ SHA256Managed();
                static /*0x314b400*/ void SHATransform(uint* expandedBuffer, uint* state, byte* block);
                static /*0x314bb18*/ uint RotateRight(uint x, int n);
                static /*0x314ba98*/ uint Ch(uint x, uint y, uint z);
                static /*0x314bb04*/ uint Maj(uint x, uint y, uint z);
                static /*0x314bb20*/ uint sigma_0(uint x);
                static /*0x314bb7c*/ uint sigma_1(uint x);
                static /*0x314baa8*/ uint Sigma_0(uint x);
                static /*0x314ba3c*/ uint Sigma_1(uint x);
                static /*0x314b994*/ void SHA256Expand(uint* x);
                /*0x31422ec*/ SHA256Managed();
                /*0x314b05c*/ void Initialize();
                /*0x314b0a0*/ void HashCore(byte[] rgb, int ibStart, int cbSize);
                /*0x314b26c*/ byte[] HashFinal();
                /*0x314af9c*/ void InitializeState();
                /*0x314b0a4*/ void _HashData(byte[] partIn, int ibStart, int cbSize);
                /*0x314b270*/ byte[] _EndHash();
            }

            class SHA384 : System.Security.Cryptography.HashAlgorithm
            {
                static /*0x314bc98*/ System.Security.Cryptography.SHA384 Create();
                /*0x314bc78*/ SHA384();
            }

            class SHA384Managed : System.Security.Cryptography.SHA384
            {
                static /*0x0*/ ulong[] _K;
                /*0x28*/ byte[] _buffer;
                /*0x30*/ ulong _count;
                /*0x38*/ ulong[] _stateSHA384;
                /*0x40*/ ulong[] _W;

                static /*0x314c948*/ SHA384Managed();
                static /*0x314c188*/ void SHATransform(ulong* expandedBuffer, ulong* state, byte* block);
                static /*0x314c888*/ ulong RotateRight(ulong x, int n);
                static /*0x314c808*/ ulong Ch(ulong x, ulong y, ulong z);
                static /*0x314c874*/ ulong Maj(ulong x, ulong y, ulong z);
                static /*0x314c818*/ ulong Sigma_0(ulong x);
                static /*0x314c7ac*/ ulong Sigma_1(ulong x);
                static /*0x314c890*/ ulong sigma_0(ulong x);
                static /*0x314c8ec*/ ulong sigma_1(ulong x);
                static /*0x314c704*/ void SHA384Expand(ulong* x);
                /*0x3142548*/ SHA384Managed();
                /*0x314bde8*/ void Initialize();
                /*0x314be2c*/ void HashCore(byte[] rgb, int ibStart, int cbSize);
                /*0x314bff4*/ byte[] HashFinal();
                /*0x314bce8*/ void InitializeState();
                /*0x314be30*/ void _HashData(byte[] partIn, int ibStart, int cbSize);
                /*0x314bff8*/ byte[] _EndHash();
            }

            class SHA512 : System.Security.Cryptography.HashAlgorithm
            {
                static /*0x314ca08*/ System.Security.Cryptography.SHA512 Create();
                /*0x314c9e8*/ SHA512();
            }

            class SHA512Managed : System.Security.Cryptography.SHA512
            {
                static /*0x0*/ ulong[] _K;
                /*0x28*/ byte[] _buffer;
                /*0x30*/ ulong _count;
                /*0x38*/ ulong[] _stateSHA512;
                /*0x40*/ ulong[] _W;

                static /*0x314d9dc*/ SHA512Managed();
                static /*0x314cfe8*/ void SHATransform(ulong* expandedBuffer, ulong* state, byte* block);
                static /*0x314d91c*/ ulong RotateRight(ulong x, int n);
                static /*0x314d89c*/ ulong Ch(ulong x, ulong y, ulong z);
                static /*0x314d908*/ ulong Maj(ulong x, ulong y, ulong z);
                static /*0x314d8ac*/ ulong Sigma_0(ulong x);
                static /*0x314d840*/ ulong Sigma_1(ulong x);
                static /*0x314d924*/ ulong sigma_0(ulong x);
                static /*0x314d980*/ ulong sigma_1(ulong x);
                static /*0x314d798*/ void SHA512Expand(ulong* x);
                /*0x314ca58*/ SHA512Managed();
                /*0x314cc4c*/ void Initialize();
                /*0x314cc90*/ void HashCore(byte[] rgb, int ibStart, int cbSize);
                /*0x314ce58*/ byte[] HashFinal();
                /*0x314cb4c*/ void InitializeState();
                /*0x314cc94*/ void _HashData(byte[] partIn, int ibStart, int cbSize);
                /*0x314ce5c*/ byte[] _EndHash();
            }

            class SignatureDescription
            {
                /*0x10*/ string _strKey;
                /*0x18*/ string _strDigest;
                /*0x20*/ string _strFormatter;
                /*0x28*/ string _strDeformatter;

                /*0x314da7c*/ SignatureDescription();
                /*0x314da84*/ void set_KeyAlgorithm(string value);
                /*0x314da8c*/ void set_DigestAlgorithm(string value);
                /*0x314da94*/ void set_FormatterAlgorithm(string value);
                /*0x314da9c*/ void set_DeformatterAlgorithm(string value);
            }

            class RSAPKCS1SignatureDescription : System.Security.Cryptography.SignatureDescription
            {
                /*0x30*/ string _hashAlgorithm;

                /*0x314daa4*/ RSAPKCS1SignatureDescription(string hashAlgorithm, string digestAlgorithm);
            }

            class RSAPKCS1SHA1SignatureDescription : System.Security.Cryptography.RSAPKCS1SignatureDescription
            {
                /*0x314db7c*/ RSAPKCS1SHA1SignatureDescription();
            }

            class RSAPKCS1SHA256SignatureDescription : System.Security.Cryptography.RSAPKCS1SignatureDescription
            {
                /*0x314dbe4*/ RSAPKCS1SHA256SignatureDescription();
            }

            class RSAPKCS1SHA384SignatureDescription : System.Security.Cryptography.RSAPKCS1SignatureDescription
            {
                /*0x314dc4c*/ RSAPKCS1SHA384SignatureDescription();
            }

            class RSAPKCS1SHA512SignatureDescription : System.Security.Cryptography.RSAPKCS1SignatureDescription
            {
                /*0x314dcb4*/ RSAPKCS1SHA512SignatureDescription();
            }

            class DSASignatureDescription : System.Security.Cryptography.SignatureDescription
            {
                /*0x314dd1c*/ DSASignatureDescription();
            }

            class SymmetricAlgorithm : System.IDisposable
            {
                /*0x10*/ int BlockSizeValue;
                /*0x14*/ int FeedbackSizeValue;
                /*0x18*/ byte[] IVValue;
                /*0x20*/ byte[] KeyValue;
                /*0x28*/ System.Security.Cryptography.KeySizes[] LegalBlockSizesValue;
                /*0x30*/ System.Security.Cryptography.KeySizes[] LegalKeySizesValue;
                /*0x38*/ int KeySizeValue;
                /*0x3c*/ System.Security.Cryptography.CipherMode ModeValue;
                /*0x40*/ System.Security.Cryptography.PaddingMode PaddingValue;

                static /*0x314e72c*/ System.Security.Cryptography.SymmetricAlgorithm Create(string algName);
                /*0x314ddf0*/ SymmetricAlgorithm();
                /*0x314de14*/ void Dispose();
                /*0x314de80*/ void Clear();
                /*0x314df14*/ void Dispose(bool disposing);
                /*0x314df8c*/ int get_BlockSize();
                /*0x314df94*/ void set_BlockSize(int value);
                /*0x314e094*/ int get_FeedbackSize();
                /*0x314e09c*/ byte[] get_IV();
                /*0x314e130*/ void set_IV(byte[] value);
                /*0x314e290*/ byte[] get_Key();
                /*0x314e324*/ void set_Key(byte[] value);
                /*0x314e540*/ System.Security.Cryptography.KeySizes[] get_LegalKeySizes();
                /*0x314e5b8*/ int get_KeySize();
                /*0x314e5c0*/ void set_KeySize(int value);
                /*0x314e644*/ System.Security.Cryptography.CipherMode get_Mode();
                /*0x314e64c*/ void set_Mode(System.Security.Cryptography.CipherMode value);
                /*0x314e6b8*/ System.Security.Cryptography.PaddingMode get_Padding();
                /*0x314e6c0*/ void set_Padding(System.Security.Cryptography.PaddingMode value);
                /*0x314e4a0*/ bool ValidKeySize(int bitLength);
                /*0x314e824*/ System.Security.Cryptography.ICryptoTransform CreateEncryptor();
                /*0x1f30394*/ System.Security.Cryptography.ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV);
                /*0x314e874*/ System.Security.Cryptography.ICryptoTransform CreateDecryptor();
                /*0x1f30394*/ System.Security.Cryptography.ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV);
                /*0x1f309e4*/ void GenerateKey();
                /*0x1f309e4*/ void GenerateIV();
            }

            class TripleDES : System.Security.Cryptography.SymmetricAlgorithm
            {
                static /*0x0*/ System.Security.Cryptography.KeySizes[] s_legalBlockSizes;
                static /*0x8*/ System.Security.Cryptography.KeySizes[] s_legalKeySizes;

                static /*0x314f090*/ TripleDES();
                static /*0x314ed64*/ System.Security.Cryptography.TripleDES Create();
                static /*0x314ea30*/ bool IsWeakKey(byte[] rgbKey);
                static /*0x314eefc*/ bool EqualBytes(byte[] rgbKey, int start1, int start2, int count);
                static /*0x314ee14*/ bool IsLegalKeySize(byte[] rgbKey);
                /*0x314e8c4*/ TripleDES();
                /*0x314e968*/ byte[] get_Key();
                /*0x314eb68*/ void set_Key(byte[] value);
            }

            class TripleDESCryptoServiceProvider : System.Security.Cryptography.TripleDES
            {
                /*0x314edb4*/ TripleDESCryptoServiceProvider();
                /*0x314f1d8*/ System.Security.Cryptography.ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV);
                /*0x314f614*/ System.Security.Cryptography.ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV);
                /*0x314f71c*/ void GenerateKey();
                /*0x314f890*/ void GenerateIV();
            }

            class Utils
            {
                static /*0x0*/ System.Security.Cryptography.RNGCryptoServiceProvider _rng;

                static /*0x314f7e8*/ System.Security.Cryptography.RNGCryptoServiceProvider get_StaticRandomNumberGenerator();
                static /*0x314f978*/ byte[] GenerateRandom(int keySize);
                static /*0x314f1d0*/ bool HasAlgorithm(int dwCalg, int dwKeySize);
                static /*0x314f9e8*/ string DiscardWhiteSpaces(string inputBuffer);
                static /*0x314fa00*/ string DiscardWhiteSpaces(string inputBuffer, int inputOffset, int inputCount);
                static /*0x314fb7c*/ int ConvertByteArrayToInt(byte[] input);
                static /*0x314fbd4*/ byte[] ConvertIntToByteArray(int dwInput);
                static /*0x314ee30*/ byte[] FixupKeyParity(byte[] key);
                static /*0x314fcec*/ void DWORDFromLittleEndian(uint* x, int digits, byte* block);
                static /*0x314fd38*/ void DWORDToLittleEndian(byte[] block, uint[] x, int digits);
                static /*0x314fe28*/ void DWORDFromBigEndian(uint* x, int digits, byte* block);
                static /*0x314fe78*/ void DWORDToBigEndian(byte[] block, uint[] x, int digits);
                static /*0x314d718*/ void QuadWordFromBigEndian(ulong* x, int digits, byte* block);
                static /*0x314d560*/ void QuadWordToBigEndian(byte[] block, ulong[] x, int digits);
                static /*0x314ff68*/ bool _ProduceLegacyHmacValues();
            }

            class CryptoConfig
            {
                static /*0x0*/ object lockObject;
                static /*0x8*/ System.Collections.Generic.Dictionary<string, System.Type> algorithms;

                static /*0x3152cec*/ CryptoConfig();
                static /*0x314e7cc*/ object CreateFromName(string name);
                static /*0x314ff70*/ object CreateFromName(string name, object[] args);
                static /*0x3151fbc*/ string MapNameToOID(string name);
                static /*0x3152790*/ byte[] EncodeOID(string str);
                static /*0x3152b90*/ byte[] EncodeLongNumber(long x);
                static /*0x314cb44*/ bool get_AllowOnlyFipsAlgorithms();
            }

            class DESTransform : Mono.Security.Cryptography.SymmetricTransform
            {
                static /*0x0*/ int KEY_BIT_SIZE;
                static /*0x4*/ int KEY_BYTE_SIZE;
                static /*0x8*/ int BLOCK_BIT_SIZE;
                static /*0xc*/ int BLOCK_BYTE_SIZE;
                static /*0x10*/ uint[] spBoxes;
                static /*0x18*/ byte[] PC1;
                static /*0x20*/ byte[] leftRotTotal;
                static /*0x28*/ byte[] PC2;
                static /*0x30*/ uint[] ipTab;
                static /*0x38*/ uint[] fpTab;
                /*0x58*/ byte[] keySchedule;
                /*0x60*/ byte[] byteBuff;
                /*0x68*/ uint[] dwordBuff;

                static /*0x3153d8c*/ DESTransform();
                static /*0x3153630*/ void Permutation(byte[] input, byte[] output, uint[] permTab, bool preSwap);
                static /*0x31538ec*/ void BSwap(byte[] byteBuff);
                static /*0x3152fac*/ byte[] GetStrongKey();
                /*0x3152d68*/ DESTransform(System.Security.Cryptography.SymmetricAlgorithm symmAlgo, bool encryption, byte[] key, byte[] iv);
                /*0x3153404*/ uint CipherFunct(uint r, int n);
                /*0x315307c*/ void SetKey(byte[] key);
                /*0x315394c*/ void ProcessBlock(byte[] input, byte[] output);
                /*0x3153ce8*/ void ECB(byte[] input, byte[] output);
            }

            class DSACryptoServiceProvider : System.Security.Cryptography.DSA
            {
                static /*0x0*/ bool useMachineKeyStore;
                /*0x20*/ Mono.Security.Cryptography.KeyPairPersistence store;
                /*0x28*/ bool persistKey;
                /*0x29*/ bool persisted;
                /*0x2a*/ bool privateKeyExportable;
                /*0x2b*/ bool m_disposed;
                /*0x30*/ Mono.Security.Cryptography.DSAManaged dsa;

                /*0x3151e4c*/ DSACryptoServiceProvider();
                /*0x3153fb8*/ DSACryptoServiceProvider(int dwKeySize);
                /*0x3153ff0*/ void Common(int dwKeySize, bool parameters);
                /*0x3154240*/ void Finalize();
                /*0x31542d0*/ int get_KeySize();
                /*0x31542ec*/ bool get_PublicOnly();
                /*0x3154304*/ System.Security.Cryptography.DSAParameters ExportParameters(bool includePrivateParameters);
                /*0x31543b0*/ void ImportParameters(System.Security.Cryptography.DSAParameters parameters);
                /*0x31543f4*/ bool VerifySignature(byte[] rgbHash, byte[] rgbSignature);
                /*0x3154410*/ void Dispose(bool disposing);
                /*0x3154464*/ void OnKeyGenerated(object sender, System.EventArgs e);
            }

            class MD5CryptoServiceProvider : System.Security.Cryptography.MD5
            {
                static /*0x0*/ uint[] K;
                /*0x28*/ uint[] _H;
                /*0x30*/ uint[] buff;
                /*0x38*/ ulong count;
                /*0x40*/ byte[] _ProcessingBuffer;
                /*0x48*/ int _ProcessingBufferCount;

                static /*0x315574c*/ MD5CryptoServiceProvider();
                /*0x3151e78*/ MD5CryptoServiceProvider();
                /*0x31544e8*/ void Finalize();
                /*0x3154578*/ void Dispose(bool disposing);
                /*0x31545e8*/ void HashCore(byte[] rgb, int ibStart, int cbSize);
                /*0x3155358*/ byte[] HashFinal();
                /*0x31555e8*/ void Initialize();
                /*0x31546e8*/ void ProcessBlock(byte[] inputBuffer, int inputOffset);
                /*0x3155430*/ void ProcessFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount);
                /*0x315565c*/ void AddLength(ulong length, byte[] buffer, int position);
            }

            class RC2Transform : Mono.Security.Cryptography.SymmetricTransform
            {
                static /*0x0*/ byte[] pitable;
                /*0x58*/ ushort R0;
                /*0x5a*/ ushort R1;
                /*0x5c*/ ushort R2;
                /*0x5e*/ ushort R3;
                /*0x60*/ ushort[] K;
                /*0x68*/ int j;

                static /*0x315664c*/ RC2Transform();
                /*0x31557ec*/ RC2Transform(System.Security.Cryptography.RC2 rc2Algo, bool encryption, byte[] key, byte[] iv);
                /*0x3155d24*/ void ECB(byte[] input, byte[] output);
            }

            class RNGCryptoServiceProvider : System.Security.Cryptography.RandomNumberGenerator
            {
                static /*0x0*/ object _lock;
                /*0x10*/ nint _handle;

                static /*0x31566ec*/ RNGCryptoServiceProvider();
                static /*0x315677c*/ bool RngOpen();
                static /*0x3156780*/ nint RngInitialize(byte* seed, nint seed_length);
                static /*0x31567e8*/ nint RngGetBytes(nint handle, byte* data, nint data_length);
                static /*0x31567ec*/ void RngClose(nint handle);
                /*0x314f904*/ RNGCryptoServiceProvider();
                /*0x3156784*/ void Check();
                /*0x31567f0*/ void GetBytes(byte[] data);
                /*0x3156a10*/ void Finalize();
                /*0x3156ae8*/ void Dispose(bool disposing);
            }

            class RSAPKCS1SignatureDeformatter : System.Security.Cryptography.AsymmetricSignatureDeformatter
            {
                /*0x10*/ System.Security.Cryptography.RSA rsa;
                /*0x18*/ string hashName;

                /*0x3151f44*/ RSAPKCS1SignatureDeformatter();
                /*0x3156af0*/ RSAPKCS1SignatureDeformatter(System.Security.Cryptography.AsymmetricAlgorithm key);
                /*0x3156b24*/ void SetHashAlgorithm(string strName);
                /*0x3156b7c*/ void SetKey(System.Security.Cryptography.AsymmetricAlgorithm key);
                /*0x3156c70*/ bool VerifySignature(byte[] rgbHash, byte[] rgbSignature);
            }

            class RSAPKCS1SignatureFormatter : System.Security.Cryptography.AsymmetricSignatureFormatter
            {
                /*0x3151f4c*/ RSAPKCS1SignatureFormatter();
            }

            class SHA1Internal
            {
                /*0x10*/ uint[] _H;
                /*0x18*/ ulong count;
                /*0x20*/ byte[] _ProcessingBuffer;
                /*0x28*/ int _ProcessingBufferCount;
                /*0x30*/ uint[] buff;

                static /*0x31577a8*/ void InitialiseBuff(uint[] buff, byte[] input, uint inputOffset);
                static /*0x3157e48*/ void FillBuff(uint[] buff);
                /*0x3156dc0*/ SHA1Internal();
                /*0x3156f08*/ void HashCore(byte[] rgb, int ibStart, int cbSize);
                /*0x3157504*/ byte[] HashFinal();
                /*0x3156e80*/ void Initialize();
                /*0x3157008*/ void ProcessBlock(byte[] inputBuffer, uint inputOffset);
                /*0x31575e0*/ void ProcessFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount);
                /*0x3157fcc*/ void AddLength(ulong length, byte[] buffer, int position);
            }

            class SHA1CryptoServiceProvider : System.Security.Cryptography.SHA1
            {
                /*0x28*/ System.Security.Cryptography.SHA1Internal sha;

                /*0x3151f54*/ SHA1CryptoServiceProvider();
                /*0x31580bc*/ void Finalize();
                /*0x315814c*/ void Dispose(bool disposing);
                /*0x3158154*/ void HashCore(byte[] rgb, int ibStart, int cbSize);
                /*0x3158174*/ byte[] HashFinal();
                /*0x3158190*/ void Initialize();
            }

            class TripleDESTransform : Mono.Security.Cryptography.SymmetricTransform
            {
                /*0x58*/ System.Security.Cryptography.DESTransform E1;
                /*0x60*/ System.Security.Cryptography.DESTransform D2;
                /*0x68*/ System.Security.Cryptography.DESTransform E3;
                /*0x70*/ System.Security.Cryptography.DESTransform D1;
                /*0x78*/ System.Security.Cryptography.DESTransform E2;
                /*0x80*/ System.Security.Cryptography.DESTransform D3;

                static /*0x31581a4*/ byte[] GetStrongKey();
                /*0x314f2e0*/ TripleDESTransform(System.Security.Cryptography.TripleDES algo, bool encryption, byte[] key, byte[] iv);
                /*0x3158248*/ void ECB(byte[] input, byte[] output);
            }

            class CryptoConfigForwarder
            {
                static /*0x3158368*/ object CreateFromName(string name);
            }

            namespace X509Certificates
            {
                enum X509ContentType
                {
                    Unknown = 0,
                    Cert = 1,
                    SerializedCert = 2,
                    Pfx = 3,
                    Pkcs12 = 3,
                    SerializedStore = 4,
                    Pkcs7 = 5,
                    Authenticode = 6,
                }

                enum X509KeyStorageFlags
                {
                    DefaultKeySet = 0,
                    UserKeySet = 1,
                    MachineKeySet = 2,
                    Exportable = 4,
                    UserProtected = 8,
                    PersistKeySet = 16,
                    EphemeralKeySet = 32,
                }

                class X509Certificate : System.IDisposable, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable
                {
                    /*0x10*/ System.Security.Cryptography.X509Certificates.X509CertificateImpl impl;
                    /*0x18*/ byte[] lazyCertHash;
                    /*0x20*/ byte[] lazySerialNumber;
                    /*0x28*/ string lazyIssuer;
                    /*0x30*/ string lazySubject;
                    /*0x38*/ string lazyKeyAlgorithm;
                    /*0x40*/ byte[] lazyKeyAlgorithmParameters;
                    /*0x48*/ byte[] lazyPublicKey;
                    /*0x50*/ System.DateTime lazyNotBefore;
                    /*0x58*/ System.DateTime lazyNotAfter;

                    static /*0x31593bc*/ string FormatDate(System.DateTime date);
                    /*0x3158544*/ X509Certificate();
                    /*0x31585b8*/ X509Certificate(byte[] data);
                    /*0x3158718*/ X509Certificate(System.Security.Cryptography.X509Certificates.X509CertificateImpl impl);
                    /*0x31587d8*/ X509Certificate(System.Security.Cryptography.X509Certificates.X509Certificate cert);
                    /*0x315896c*/ X509Certificate(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                    /*0x31583bc*/ void Reset();
                    /*0x31589a8*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                    /*0x31589e0*/ void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
                    /*0x3158a18*/ string get_Issuer();
                    /*0x3158a84*/ string get_Subject();
                    /*0x3158ae8*/ void Dispose();
                    /*0x3158af8*/ void Dispose(bool disposing);
                    /*0x3158b0c*/ bool Equals(object obj);
                    /*0x3158ba0*/ bool Equals(System.Security.Cryptography.X509Certificates.X509Certificate other);
                    /*0x3158cd4*/ byte[] GetCertHash();
                    /*0x3158d54*/ string GetCertHashString();
                    /*0x3158cf8*/ byte[] GetRawCertHash();
                    /*0x3158d78*/ byte[] GetRawCertData();
                    /*0x3158dac*/ int GetHashCode();
                    /*0x3158e0c*/ string GetKeyAlgorithm();
                    /*0x3158e74*/ byte[] GetKeyAlgorithmParameters();
                    /*0x3158ee0*/ byte[] GetPublicKey();
                    /*0x3158f4c*/ byte[] GetSerialNumber();
                    /*0x3158fb4*/ string GetSerialNumberString();
                    /*0x3158c74*/ byte[] GetRawSerialNumber();
                    /*0x3158fd8*/ string ToString();
                    /*0x3158fec*/ string ToString(bool fVerbose);
                    /*0x3159504*/ System.DateTime GetNotAfter();
                    /*0x3159320*/ System.DateTime GetNotBefore();
                    /*0x31595a0*/ void ImportHandle(System.Security.Cryptography.X509Certificates.X509CertificateImpl impl);
                    /*0x31595d8*/ System.Security.Cryptography.X509Certificates.X509CertificateImpl get_Impl();
                    /*0x31595e0*/ bool get_IsValid();
                    /*0x3158a7c*/ void ThrowIfInvalid();
                }

                class X509CertificateImpl : System.IDisposable
                {
                    /*0x3159964*/ X509CertificateImpl();
                    /*0x1f2fe14*/ bool get_IsValid();
                    /*0x3159638*/ void ThrowIfContextInvalid();
                    /*0x1f30214*/ System.Security.Cryptography.X509Certificates.X509CertificateImpl Clone();
                    /*0x1f30214*/ string get_Issuer();
                    /*0x1f30214*/ string get_Subject();
                    /*0x1f30214*/ byte[] get_RawData();
                    System.DateTime get_NotAfter();
                    System.DateTime get_NotBefore();
                    /*0x1f30214*/ byte[] get_Thumbprint();
                    /*0x31596f4*/ int GetHashCode();
                    /*0x1f30214*/ string get_KeyAlgorithm();
                    /*0x1f30214*/ byte[] get_KeyAlgorithmParameters();
                    /*0x1f30214*/ byte[] get_PublicKeyValue();
                    /*0x1f30214*/ byte[] get_SerialNumber();
                    /*0x1f2fe14*/ bool get_HasPrivateKey();
                    /*0x1f30214*/ System.Security.Cryptography.RSA GetRSAPrivateKey();
                    /*0x1f30214*/ System.Security.Cryptography.DSA GetDSAPrivateKey();
                    /*0x315976c*/ bool Equals(object obj);
                    /*0x31584d4*/ void Dispose();
                    /*0x31598cc*/ void Dispose(bool disposing);
                    /*0x31598d0*/ void Finalize();
                }

                class X509Helper
                {
                    static /*0x315996c*/ Mono.ISystemCertificateProvider get_CertificateProvider();
                    static /*0x31588bc*/ System.Security.Cryptography.X509Certificates.X509CertificateImpl InitFromCertificate(System.Security.Cryptography.X509Certificates.X509Certificate cert);
                    static /*0x31587c4*/ System.Security.Cryptography.X509Certificates.X509CertificateImpl InitFromCertificate(System.Security.Cryptography.X509Certificates.X509CertificateImpl impl);
                    static /*0x315930c*/ bool IsValid(System.Security.Cryptography.X509Certificates.X509CertificateImpl impl);
                    static /*0x31595f8*/ void ThrowIfContextInvalid(System.Security.Cryptography.X509Certificates.X509CertificateImpl impl);
                    static /*0x3159674*/ System.Exception GetInvalidContextException();
                    static /*0x315866c*/ System.Security.Cryptography.X509Certificates.X509CertificateImpl Import(byte[] rawData);
                    static /*0x3159a34*/ System.Security.Cryptography.X509Certificates.X509CertificateImpl Import(byte[] rawData, Microsoft.Win32.SafeHandles.SafePasswordHandle password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);
                }
            }
        }

        namespace Principal
        {
            interface IIdentity
            {
                /*0x1f30214*/ string get_Name();
                /*0x1f30214*/ string get_AuthenticationType();
            }

            interface IPrincipal
            {
            }

            enum TokenImpersonationLevel
            {
                None = 0,
                Anonymous = 1,
                Identification = 2,
                Impersonation = 3,
                Delegation = 4,
            }

            enum WindowsAccountType
            {
                Normal = 0,
                Guest = 1,
                System = 2,
                Anonymous = 3,
            }

            class WindowsIdentity : System.Security.Claims.ClaimsIdentity, System.Security.Principal.IIdentity, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable, System.IDisposable
            {
                static /*0x0*/ nint invalidWindows;
                /*0x78*/ nint _token;
                /*0x80*/ string _type;
                /*0x88*/ System.Security.Principal.WindowsAccountType _account;
                /*0x8c*/ bool _authenticated;
                /*0x90*/ string _name;
                /*0x98*/ System.Runtime.Serialization.SerializationInfo _info;

                static /*0x315a310*/ WindowsIdentity();
                static /*0x3159ce4*/ System.Security.Principal.WindowsIdentity GetCurrent();
                static /*0x3159d60*/ nint GetCurrentToken();
                static /*0x3159ecc*/ string GetTokenName(nint token);
                /*0x3159afc*/ WindowsIdentity(nint userToken, string type, System.Security.Principal.WindowsAccountType acctType, bool isAuthenticated);
                /*0x3159cac*/ WindowsIdentity(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x3159cdc*/ void Dispose();
                /*0x3159d64*/ System.Security.Principal.WindowsImpersonationContext Impersonate();
                /*0x3159e48*/ string get_AuthenticationType();
                /*0x3159e50*/ string get_Name();
                /*0x3159ed0*/ void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
                /*0x315a1b4*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x3159b64*/ void SetToken(nint token);
            }

            class WindowsImpersonationContext : System.IDisposable
            {
                /*0x10*/ nint _token;
                /*0x18*/ bool undo;

                static /*0x315a434*/ bool CloseToken(nint token);
                static /*0x315a358*/ nint DuplicateToken(nint token);
                static /*0x315a35c*/ bool SetCurrentToken(nint token);
                static /*0x315a430*/ bool RevertToSelf();
                /*0x3159dc0*/ WindowsImpersonationContext(nint token);
                /*0x315a360*/ void Dispose();
                /*0x315a370*/ void Undo();
            }
        }

        namespace Claims
        {
            class Claim
            {
                /*0x10*/ string m_issuer;
                /*0x18*/ string m_originalIssuer;
                /*0x20*/ string m_type;
                /*0x28*/ string m_value;
                /*0x30*/ string m_valueType;
                /*0x38*/ byte[] m_userSerializationData;
                /*0x40*/ System.Collections.Generic.Dictionary<string, string> m_properties;
                /*0x48*/ object m_propertyLock;
                /*0x50*/ System.Security.Claims.ClaimsIdentity m_subject;

                /*0x315a438*/ Claim(string type, string value, string valueType, string issuer, string originalIssuer, System.Security.Claims.ClaimsIdentity subject);
                /*0x315a458*/ Claim(string type, string value, string valueType, string issuer, string originalIssuer, System.Security.Claims.ClaimsIdentity subject, string propertyKey, string propertyValue);
                /*0x315a840*/ Claim(System.Security.Claims.Claim other, System.Security.Claims.ClaimsIdentity subject);
                /*0x315ac2c*/ void OnDeserializedMethod(System.Runtime.Serialization.StreamingContext context);
                /*0x315a708*/ System.Collections.Generic.IDictionary<string, string> get_Properties();
                /*0x315ac8c*/ System.Security.Claims.ClaimsIdentity get_Subject();
                /*0x315ac94*/ void set_Subject(System.Security.Claims.ClaimsIdentity value);
                /*0x315ac9c*/ string get_Type();
                /*0x315aca4*/ string get_Value();
                /*0x315acac*/ System.Security.Claims.Claim Clone(System.Security.Claims.ClaimsIdentity identity);
                /*0x315ad14*/ string ToString();
            }

            class ClaimsIdentity : System.Security.Principal.IIdentity
            {
                /*0x10*/ byte[] m_userSerializationData;
                /*0x18*/ System.Collections.Generic.List<System.Security.Claims.Claim> m_instanceClaims;
                /*0x20*/ System.Collections.ObjectModel.Collection<System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>> m_externalClaims;
                /*0x28*/ string m_nameType;
                /*0x30*/ string m_roleType;
                /*0x38*/ string m_version;
                /*0x40*/ System.Security.Claims.ClaimsIdentity m_actor;
                /*0x48*/ string m_authenticationType;
                /*0x50*/ object m_bootstrapContext;
                /*0x58*/ string m_label;
                /*0x60*/ string m_serializedNameType;
                /*0x68*/ string m_serializedRoleType;
                /*0x70*/ string m_serializedClaims;

                /*0x315ad8c*/ ClaimsIdentity();
                /*0x315ada8*/ ClaimsIdentity(System.Collections.Generic.IEnumerable<System.Security.Claims.Claim> claims);
                /*0x315adc4*/ ClaimsIdentity(System.Security.Principal.IIdentity identity, System.Collections.Generic.IEnumerable<System.Security.Claims.Claim> claims, string authenticationType, string nameType, string roleType);
                /*0x315adcc*/ ClaimsIdentity(System.Security.Principal.IIdentity identity, System.Collections.Generic.IEnumerable<System.Security.Claims.Claim> claims, string authenticationType, string nameType, string roleType, bool checkAuthType);
                /*0x315b8e4*/ ClaimsIdentity(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x315c244*/ string get_AuthenticationType();
                /*0x315c24c*/ System.Security.Claims.ClaimsIdentity get_Actor();
                /*0x315c254*/ void set_Actor(System.Security.Claims.ClaimsIdentity value);
                /*0x315c2dc*/ System.Collections.Generic.IEnumerable<System.Security.Claims.Claim> get_Claims();
                /*0x315c390*/ string get_Name();
                /*0x315c3b4*/ System.Security.Claims.ClaimsIdentity Clone();
                /*0x315b52c*/ void SafeAddClaims(System.Collections.Generic.IEnumerable<System.Security.Claims.Claim> claims);
                /*0x315b848*/ void SafeAddClaim(System.Security.Claims.Claim claim);
                /*0x315c534*/ System.Security.Claims.Claim FindFirst(string type);
                /*0x315c860*/ void OnSerializingMethod(System.Runtime.Serialization.StreamingContext context);
                /*0x315cb10*/ void OnDeserializedMethod(System.Runtime.Serialization.StreamingContext context);
                /*0x315cf40*/ void OnDeserializingMethod(System.Runtime.Serialization.StreamingContext context);
                /*0x315d030*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x315cc10*/ void DeserializeClaims(string serializedClaims);
                /*0x315c8f0*/ string SerializeClaims();
                /*0x315b4ec*/ bool IsCircular(System.Security.Claims.ClaimsIdentity subject);
                /*0x315baac*/ void Deserialize(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context, bool useContext);

                class <get_Claims>d__51 : System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>, System.Collections.IEnumerable, System.Collections.Generic.IEnumerator<System.Security.Claims.Claim>, System.IDisposable, System.Collections.IEnumerator
                {
                    /*0x10*/ int <>1__state;
                    /*0x18*/ System.Security.Claims.Claim <>2__current;
                    /*0x20*/ int <>l__initialThreadId;
                    /*0x28*/ System.Security.Claims.ClaimsIdentity <>4__this;
                    /*0x30*/ int <i>5__2;
                    /*0x38*/ System.Collections.Generic.IEnumerator<System.Security.Claims.Claim> <>7__wrap2;

                    /*0x315c35c*/ <get_Claims>d__51(int <>1__state);
                    /*0x315d59c*/ void System.IDisposable.Dispose();
                    /*0x315d5b8*/ bool MoveNext();
                    /*0x315d9c8*/ void <>m__Finally1();
                    /*0x315da78*/ System.Security.Claims.Claim System.Collections.Generic.IEnumerator<System.Security.Claims.Claim>.get_Current();
                    /*0x315da80*/ void System.Collections.IEnumerator.Reset();
                    /*0x315dab8*/ object System.Collections.IEnumerator.get_Current();
                    /*0x315dac0*/ System.Collections.Generic.IEnumerator<System.Security.Claims.Claim> System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>.GetEnumerator();
                    /*0x315db64*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                }
            }
        }
    }

    namespace Runtime
    {
        class AmbiguousImplementationException : System.Exception
        {
            /*0x315db68*/ AmbiguousImplementationException();
            /*0x315dbe8*/ AmbiguousImplementationException(string message);
            /*0x315dc60*/ AmbiguousImplementationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class RuntimeImports
        {
            static /*0x315dce0*/ void RhZeroMemory(ref byte b, ulong byteLength);
            static /*0x315dce4*/ void ZeroMemory(void* p, uint byteLength);
            static /*0x315dce8*/ void Memmove(byte* dest, byte* src, uint len);
            static /*0x315dcec*/ void Memmove_wbarrier(byte* dest, byte* src, uint len, nint type_handle);
        }

        namespace Remoting
        {
            class ChannelInfo : System.Runtime.Remoting.IChannelInfo
            {
                /*0x10*/ object[] channelData;

                /*0x315dcf0*/ ChannelInfo();
                /*0x315e1e4*/ ChannelInfo(object remoteChannelData);
                /*0x315e2a0*/ object[] get_ChannelData();
            }

            class ActivatedClientTypeEntry : System.Runtime.Remoting.TypeEntry
            {
                /*0x20*/ string applicationUrl;
                /*0x28*/ System.Type obj_type;

                /*0x315e2a8*/ ActivatedClientTypeEntry(string typeName, string assemblyName, string appUrl);
                /*0x315e3f0*/ string get_ApplicationUrl();
                /*0x315e3f8*/ System.Runtime.Remoting.Contexts.IContextAttribute[] get_ContextAttributes();
                /*0x315e400*/ System.Type get_ObjectType();
                /*0x315e408*/ string ToString();
            }

            class ActivatedServiceTypeEntry : System.Runtime.Remoting.TypeEntry
            {
                /*0x20*/ System.Type obj_type;

                /*0x315e41c*/ ActivatedServiceTypeEntry(string typeName, string assemblyName);
                /*0x315e538*/ System.Type get_ObjectType();
                /*0x315e540*/ string ToString();
            }

            enum CustomErrorsModes
            {
                On = 0,
                Off = 1,
                RemoteOnly = 2,
            }

            class EnvoyInfo : System.Runtime.Remoting.IEnvoyInfo
            {
                /*0x10*/ System.Runtime.Remoting.Messaging.IMessageSink envoySinks;

                /*0x315e550*/ EnvoyInfo(System.Runtime.Remoting.Messaging.IMessageSink sinks);
                /*0x315e580*/ System.Runtime.Remoting.Messaging.IMessageSink get_EnvoySinks();
            }

            interface IChannelInfo
            {
                /*0x1f30214*/ object[] get_ChannelData();
            }

            interface IEnvoyInfo
            {
                /*0x1f30214*/ System.Runtime.Remoting.Messaging.IMessageSink get_EnvoySinks();
            }

            interface IRemotingTypeInfo
            {
                /*0x1f30214*/ string get_TypeName();
                /*0x1f2ff00*/ bool CanCastTo(System.Type fromType, object o);
            }

            class Identity
            {
                /*0x10*/ string _objectUri;
                /*0x18*/ System.Runtime.Remoting.Messaging.IMessageSink _channelSink;
                /*0x20*/ System.Runtime.Remoting.Messaging.IMessageSink _envoySink;
                /*0x28*/ System.Runtime.Remoting.Contexts.DynamicPropertyCollection _clientDynamicProperties;
                /*0x30*/ System.Runtime.Remoting.Contexts.DynamicPropertyCollection _serverDynamicProperties;
                /*0x38*/ System.Runtime.Remoting.ObjRef _objRef;
                /*0x40*/ bool _disposed;

                /*0x315e588*/ Identity(string objectUri);
                /*0x1f302cc*/ System.Runtime.Remoting.ObjRef CreateObjRef(System.Type requestedType);
                /*0x315e5b8*/ System.Runtime.Remoting.Messaging.IMessageSink get_ChannelSink();
                /*0x315e5c0*/ void set_ChannelSink(System.Runtime.Remoting.Messaging.IMessageSink value);
                /*0x315e5c8*/ System.Runtime.Remoting.Messaging.IMessageSink get_EnvoySink();
                /*0x315e5d0*/ string get_ObjectUri();
                /*0x315e5d8*/ void set_ObjectUri(string value);
                /*0x315e5e0*/ bool get_IsConnected();
                /*0x315e5f0*/ bool get_Disposed();
                /*0x315e5f8*/ void set_Disposed(bool value);
                /*0x315e600*/ System.Runtime.Remoting.Contexts.DynamicPropertyCollection get_ClientDynamicProperties();
                /*0x315e6d8*/ bool get_HasServerDynamicSinks();
                /*0x315e748*/ void NotifyClientDynamicSinks(bool start, System.Runtime.Remoting.Messaging.IMessage req_msg, bool client_site, bool async);
                /*0x315eda8*/ void NotifyServerDynamicSinks(bool start, System.Runtime.Remoting.Messaging.IMessage req_msg, bool client_site, bool async);
            }

            class ClientIdentity : System.Runtime.Remoting.Identity
            {
                /*0x48*/ System.WeakReference _proxyReference;

                /*0x315ee2c*/ ClientIdentity(string objectUri, System.Runtime.Remoting.ObjRef objRef);
                /*0x315ef5c*/ System.MarshalByRefObject get_ClientProxy();
                /*0x315efe4*/ void set_ClientProxy(System.MarshalByRefObject value);
                /*0x315f054*/ System.Runtime.Remoting.ObjRef CreateObjRef(System.Type requestedType);
                /*0x315f05c*/ string get_TargetUri();
            }

            class InternalRemotingServices
            {
                static /*0x0*/ System.Collections.Hashtable _soapAttributes;

                static /*0x315f580*/ InternalRemotingServices();
                static /*0x315f078*/ System.Runtime.Remoting.Metadata.SoapAttribute GetCachedSoapAttribute(object reflectionObject);
            }

            class ObjRef : System.Runtime.Serialization.IObjectReference, System.Runtime.Serialization.ISerializable
            {
                static /*0x0*/ int MarshalledObjectRef;
                static /*0x4*/ int WellKnowObjectRef;
                /*0x10*/ System.Runtime.Remoting.IChannelInfo channel_info;
                /*0x18*/ string uri;
                /*0x20*/ System.Runtime.Remoting.IRemotingTypeInfo typeInfo;
                /*0x28*/ System.Runtime.Remoting.IEnvoyInfo envoyInfo;
                /*0x30*/ int flags;
                /*0x38*/ System.Type _serverType;

                static /*0x3160a04*/ ObjRef();
                /*0x315f5fc*/ ObjRef();
                /*0x315f674*/ ObjRef(string uri, System.Runtime.Remoting.IChannelInfo cinfo);
                /*0x315faa4*/ ObjRef(System.Type type, string url, object remoteChannelData);
                /*0x315ffd8*/ ObjRef(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x315f6b8*/ System.Runtime.Remoting.ObjRef DeserializeInTheCurrentDomain(int domainId, byte[] tInfo);
                /*0x315f938*/ byte[] SerializeType();
                /*0x3160558*/ bool get_IsReferenceToWellKnow();
                /*0x31605c0*/ System.Runtime.Remoting.IChannelInfo get_ChannelInfo();
                /*0x31605c8*/ System.Runtime.Remoting.IEnvoyInfo get_EnvoyInfo();
                /*0x31605d0*/ void set_EnvoyInfo(System.Runtime.Remoting.IEnvoyInfo value);
                /*0x31605d8*/ System.Runtime.Remoting.IRemotingTypeInfo get_TypeInfo();
                /*0x31605e0*/ void set_TypeInfo(System.Runtime.Remoting.IRemotingTypeInfo value);
                /*0x31605e8*/ string get_URI();
                /*0x31605f0*/ void set_URI(string value);
                /*0x31605f8*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x31607c4*/ object GetRealObject(System.Runtime.Serialization.StreamingContext context);
                /*0x315f618*/ void UpdateChannelInfo();
                /*0x31608c0*/ System.Type get_ServerType();
            }

            class RemotingConfiguration
            {
                static /*0x0*/ string applicationID;
                static /*0x8*/ string applicationName;
                static /*0x10*/ string processGuid;
                static /*0x18*/ bool defaultConfigRead;
                static /*0x19*/ bool defaultDelayedConfigRead;
                static /*0x1c*/ System.Runtime.Remoting.CustomErrorsModes _errorMode;
                static /*0x20*/ System.Collections.Hashtable wellKnownClientEntries;
                static /*0x28*/ System.Collections.Hashtable activatedClientEntries;
                static /*0x30*/ System.Collections.Hashtable wellKnownServiceEntries;
                static /*0x38*/ System.Collections.Hashtable activatedServiceEntries;
                static /*0x40*/ System.Collections.Hashtable channelTemplates;
                static /*0x48*/ System.Collections.Hashtable clientProviderTemplates;
                static /*0x50*/ System.Collections.Hashtable serverProviderTemplates;

                static /*0x3164e6c*/ RemotingConfiguration();
                static /*0x3160a54*/ string get_ApplicationName();
                static /*0x3160aac*/ void set_ApplicationName(string value);
                static /*0x3160b0c*/ string get_ProcessId();
                static /*0x3160bb8*/ void LoadDefaultDelayedChannels();
                static /*0x3160f84*/ bool IsActivationAllowed(System.Type svrType);
                static /*0x31610cc*/ System.Runtime.Remoting.ActivatedClientTypeEntry IsRemotelyActivatedClientType(System.Type svrType);
                static /*0x3161264*/ System.Runtime.Remoting.WellKnownClientTypeEntry IsWellKnownClientType(System.Type svrType);
                static /*0x31613fc*/ void RegisterActivatedClientType(System.Runtime.Remoting.ActivatedClientTypeEntry entry);
                static /*0x3161680*/ void RegisterActivatedServiceType(System.Runtime.Remoting.ActivatedServiceTypeEntry entry);
                static /*0x31617c8*/ void RegisterWellKnownClientType(System.Runtime.Remoting.WellKnownClientTypeEntry entry);
                static /*0x3161a48*/ void RegisterWellKnownServiceType(System.Runtime.Remoting.WellKnownServiceTypeEntry entry);
                static /*0x3161cc8*/ void RegisterChannelTemplate(System.Runtime.Remoting.ChannelData channel);
                static /*0x3161d44*/ void RegisterClientProviderTemplate(System.Runtime.Remoting.ProviderData prov);
                static /*0x3161dc0*/ void RegisterServerProviderTemplate(System.Runtime.Remoting.ProviderData prov);
                static /*0x3161e3c*/ void RegisterChannels(System.Collections.ArrayList channels, bool onlyDelayed);
                static /*0x31646b4*/ void RegisterTypes(System.Collections.ArrayList types);
                static /*0x3164ba0*/ bool CustomErrorsEnabled(bool isLocalRequest);
                static /*0x3164c38*/ void SetCustomErrorsMode(string mode);
            }

            class ConfigHandler : Mono.Xml.SmallXmlParser.IContentHandler
            {
                /*0x10*/ System.Collections.ArrayList typeEntries;
                /*0x18*/ System.Collections.ArrayList channelInstances;
                /*0x20*/ System.Runtime.Remoting.ChannelData currentChannel;
                /*0x28*/ System.Collections.Stack currentProviderData;
                /*0x30*/ string currentClientUrl;
                /*0x38*/ string appName;
                /*0x40*/ string currentXmlPath;
                /*0x48*/ bool onlyDelayedChannels;

                /*0x3160eb8*/ ConfigHandler(bool onlyDelayedChannels);
                /*0x3165028*/ void ValidatePath(string element, string[] paths);
                /*0x3165104*/ bool CheckPath(string path);
                /*0x31651ec*/ void OnStartParsing(Mono.Xml.SmallXmlParser parser);
                /*0x31651f0*/ void OnProcessingInstruction(string name, string text);
                /*0x31651f4*/ void OnIgnorableWhitespace(string s);
                /*0x31651f8*/ void OnStartElement(string name, Mono.Xml.SmallXmlParser.IAttrList attrs);
                /*0x31653b8*/ void ParseElement(string name, Mono.Xml.SmallXmlParser.IAttrList attrs);
                /*0x3167c18*/ void OnEndElement(string name);
                /*0x31662ac*/ void ReadCustomProviderData(string name, Mono.Xml.SmallXmlParser.IAttrList attrs);
                /*0x3166608*/ void ReadLifetine(Mono.Xml.SmallXmlParser.IAttrList attrs);
                /*0x3167d70*/ System.TimeSpan ParseTime(string s);
                /*0x3166b58*/ void ReadChannel(Mono.Xml.SmallXmlParser.IAttrList attrs, bool isTemplate);
                /*0x3166f1c*/ System.Runtime.Remoting.ProviderData ReadProvider(string name, Mono.Xml.SmallXmlParser.IAttrList attrs, bool isTemplate);
                /*0x31675f8*/ void ReadClientActivated(Mono.Xml.SmallXmlParser.IAttrList attrs);
                /*0x316773c*/ void ReadServiceActivated(Mono.Xml.SmallXmlParser.IAttrList attrs);
                /*0x3167320*/ void ReadClientWellKnown(Mono.Xml.SmallXmlParser.IAttrList attrs);
                /*0x3167414*/ void ReadServiceWellKnown(Mono.Xml.SmallXmlParser.IAttrList attrs);
                /*0x3167808*/ void ReadInteropXml(Mono.Xml.SmallXmlParser.IAttrList attrs, bool isElement);
                /*0x31679ac*/ void ReadPreload(Mono.Xml.SmallXmlParser.IAttrList attrs);
                /*0x3168368*/ string GetNotNull(Mono.Xml.SmallXmlParser.IAttrList attrs, string name);
                /*0x3168498*/ string ExtractAssembly(ref string type);
                /*0x31690a8*/ void OnChars(string ch);
                /*0x31690ac*/ void OnEndParsing(Mono.Xml.SmallXmlParser parser);
            }

            class ChannelData
            {
                /*0x10*/ string Ref;
                /*0x18*/ string Type;
                /*0x20*/ string Id;
                /*0x28*/ string DelayLoadAsClientChannel;
                /*0x30*/ System.Collections.ArrayList _serverProviders;
                /*0x38*/ System.Collections.ArrayList _clientProviders;
                /*0x40*/ System.Collections.Hashtable _customProperties;

                /*0x31681b8*/ ChannelData();
                /*0x316329c*/ System.Collections.ArrayList get_ServerProviders();
                /*0x31639bc*/ System.Collections.ArrayList get_ClientProviders();
                /*0x3168288*/ System.Collections.Hashtable get_CustomProperties();
                /*0x31629f4*/ void CopyFrom(System.Runtime.Remoting.ChannelData other);
            }

            class ProviderData
            {
                /*0x10*/ string Ref;
                /*0x18*/ string Type;
                /*0x20*/ string Id;
                /*0x28*/ System.Collections.Hashtable CustomProperties;
                /*0x30*/ System.Collections.IList CustomData;

                /*0x31682fc*/ ProviderData();
                /*0x316330c*/ void CopyFrom(System.Runtime.Remoting.ProviderData other);
            }

            class FormatterData : System.Runtime.Remoting.ProviderData
            {
                /*0x31682f8*/ FormatterData();
            }

            class RemotingException : System.SystemException
            {
                /*0x31691a8*/ RemotingException();
                /*0x315e3e8*/ RemotingException(string message);
                /*0x31691b0*/ RemotingException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x31662a4*/ RemotingException(string message, System.Exception InnerException);
            }

            class RemotingServices
            {
                static /*0x0*/ System.Collections.Hashtable uri_hash;
                static /*0x8*/ System.Runtime.Serialization.Formatters.Binary.BinaryFormatter _serializationFormatter;
                static /*0x10*/ System.Runtime.Serialization.Formatters.Binary.BinaryFormatter _deserializationFormatter;
                static /*0x18*/ string app_id;
                static /*0x20*/ object app_id_lock;
                static /*0x28*/ int next_id;
                static /*0x30*/ System.Reflection.MethodInfo FieldSetterMethod;
                static /*0x38*/ System.Reflection.MethodInfo FieldGetterMethod;

                static /*0x31691b8*/ RemotingServices();
                static /*0x31694d4*/ object InternalExecute(System.Reflection.MethodBase method, object obj, object[] parameters, ref object[] out_args);
                static /*0x31694d8*/ System.Reflection.MethodBase GetVirtualMethod(System.Type type, System.Reflection.MethodBase method);
                static /*0x31694dc*/ bool IsTransparentProxy(object proxy);
                static /*0x3169514*/ System.Runtime.Remoting.Messaging.IMethodReturnMessage InternalExecuteMessage(System.MarshalByRefObject target, System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg);
                static /*0x3169f2c*/ object Connect(System.Type classToProxy, string url);
                static /*0x316a034*/ object Connect(System.Type classToProxy, string url, object data);
                static /*0x316a0d4*/ System.Type GetServerTypeForUri(string URI);
                static /*0x3160868*/ object Unmarshal(System.Runtime.Remoting.ObjRef objectRef);
                static /*0x316a3d4*/ object Unmarshal(System.Runtime.Remoting.ObjRef objectRef, bool fRefine);
                static /*0x316aa2c*/ System.Runtime.Remoting.ObjRef Marshal(System.MarshalByRefObject Obj);
                static /*0x316aa70*/ System.Runtime.Remoting.ObjRef Marshal(System.MarshalByRefObject Obj, string ObjURI, System.Type RequestedType);
                static /*0x316abc4*/ string NewUri();
                static /*0x316aadc*/ System.Runtime.Remoting.Proxies.RealProxy GetRealProxy(object proxy);
                static /*0x316b678*/ System.Reflection.MethodBase GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage msg);
                static /*0x316b954*/ System.Reflection.MethodBase GetMethodBaseFromName(System.Type type, string methodName, System.Type[] signature);
                static /*0x316bb28*/ System.Reflection.MethodBase FindInterfaceMethod(System.Type type, string methodName, System.Type[] signature);
                static /*0x316bc6c*/ void GetObjectData(object obj, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                static /*0x316bd4c*/ bool IsOneWay(System.Reflection.MethodBase method);
                static /*0x316bdd0*/ object CreateClientProxy(System.Runtime.Remoting.ActivatedClientTypeEntry entry, object[] activationAttributes);
                static /*0x316becc*/ object CreateClientProxy(System.Type objectType, string url, object[] activationAttributes);
                static /*0x316c12c*/ object CreateClientProxy(System.Runtime.Remoting.WellKnownClientTypeEntry entry);
                static /*0x316c194*/ object CreateClientProxyForContextBound(System.Type type, object[] activationAttributes);
                static /*0x316a17c*/ System.Runtime.Remoting.Identity GetIdentityForUri(string uri);
                static /*0x316c37c*/ string RemoveAppNameFromUri(string uri);
                static /*0x316c470*/ System.Runtime.Remoting.ClientIdentity GetOrCreateClientIdentity(System.Runtime.Remoting.ObjRef objRef, System.Type proxyType, ref object clientProxy);
                static /*0x316bffc*/ System.Runtime.Remoting.Messaging.IMessageSink GetClientChannelSinkChain(string url, object channelData, ref string objectUri);
                static /*0x316d38c*/ System.Runtime.Remoting.ClientActivatedIdentity CreateContextBoundObjectIdentity(System.Type objectType);
                static /*0x316b5bc*/ System.Runtime.Remoting.ClientActivatedIdentity CreateClientActivatedServerIdentity(System.MarshalByRefObject realObject, System.Type objectType, string objectUri);
                static /*0x3161bd4*/ System.Runtime.Remoting.ServerIdentity CreateWellKnownServerIdentity(System.Type objectType, string objectUri, System.Runtime.Remoting.WellKnownObjectMode mode);
                static /*0x316aef8*/ void RegisterServerIdentity(System.Runtime.Remoting.ServerIdentity identity);
                static /*0x316a938*/ object GetProxyForRemoteObject(System.Runtime.Remoting.ObjRef objref, System.Type classToProxy);
                static /*0x3169fc0*/ object GetRemoteObject(System.Runtime.Remoting.ObjRef objRef, System.Type proxyType);
                static /*0x316d4f8*/ byte[] SerializeCallData(object obj);
                static /*0x316d71c*/ object DeserializeCallData(byte[] array);
                static /*0x316d968*/ byte[] SerializeExceptionData(System.Exception ex);
                static /*0x3169488*/ void RegisterInternalChannels();
                static /*0x316c970*/ void DisposeIdentity(System.Runtime.Remoting.Identity ident);
                static /*0x316dc18*/ System.Runtime.Remoting.Identity GetMessageTargetIdentity(System.Runtime.Remoting.Messaging.IMessage msg);
                static /*0x316df64*/ void SetMessageTargetIdentity(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Identity ident);
                static /*0x316e078*/ bool UpdateOutArgObject(System.Reflection.ParameterInfo pi, object local, object remote);
                static /*0x316c304*/ string GetNormalizedUri(string uri);

                class CACD
                {
                    /*0x10*/ object d;
                    /*0x18*/ object c;

                    /*0x316d714*/ CACD();
                }
            }

            class ServerIdentity : System.Runtime.Remoting.Identity
            {
                /*0x48*/ System.Type _objectType;
                /*0x50*/ System.MarshalByRefObject _serverObject;
                /*0x58*/ System.Runtime.Remoting.Messaging.IMessageSink _serverSink;
                /*0x60*/ System.Runtime.Remoting.Contexts.Context _context;
                /*0x68*/ System.Runtime.Remoting.Lifetime.Lease _lease;

                /*0x316e1b0*/ ServerIdentity(string objectUri, System.Runtime.Remoting.Contexts.Context context, System.Type objectType);
                /*0x316e210*/ System.Type get_ObjectType();
                /*0x316b100*/ void StartTrackingLifetime(System.Runtime.Remoting.Lifetime.ILease lease);
                /*0x316e3d8*/ void OnLifetimeExpired();
                /*0x316e484*/ System.Runtime.Remoting.ObjRef CreateObjRef(System.Type requestedType);
                /*0x316d47c*/ void AttachServerObject(System.MarshalByRefObject serverObject, System.Runtime.Remoting.Contexts.Context context);
                /*0x316e8bc*/ System.Runtime.Remoting.Lifetime.Lease get_Lease();
                /*0x316e8c4*/ System.Runtime.Remoting.Contexts.Context get_Context();
                /*0x316e8cc*/ void set_Context(System.Runtime.Remoting.Contexts.Context value);
                /*0x1f302cc*/ System.Runtime.Remoting.Messaging.IMessage SyncObjectProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                /*0x1f30394*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncObjectProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                /*0x316e3dc*/ void DisposeServerObject();
            }

            class ClientActivatedIdentity : System.Runtime.Remoting.ServerIdentity
            {
                /*0x70*/ System.MarshalByRefObject _targetThis;

                /*0x316d468*/ ClientActivatedIdentity(string objectUri, System.Type objectType);
                /*0x316ebd8*/ System.MarshalByRefObject GetServerObject();
                /*0x316ebe0*/ void SetClientProxy(System.MarshalByRefObject obj);
                /*0x316ebe8*/ void OnLifetimeExpired();
                /*0x316ec44*/ System.Runtime.Remoting.Messaging.IMessage SyncObjectProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                /*0x316ef04*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncObjectProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
            }

            class SingletonIdentity : System.Runtime.Remoting.ServerIdentity
            {
                /*0x316d4f4*/ SingletonIdentity(string objectUri, System.Runtime.Remoting.Contexts.Context context, System.Type objectType);
                /*0x316f004*/ System.MarshalByRefObject GetServerObject();
                /*0x316f19c*/ System.Runtime.Remoting.Messaging.IMessage SyncObjectProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                /*0x316f284*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncObjectProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
            }

            class SingleCallIdentity : System.Runtime.Remoting.ServerIdentity
            {
                /*0x316d4f0*/ SingleCallIdentity(string objectUri, System.Runtime.Remoting.Contexts.Context context, System.Type objectType);
                /*0x316f378*/ System.Runtime.Remoting.Messaging.IMessage SyncObjectProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                /*0x316f598*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncObjectProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
            }

            class DisposerReplySink : System.Runtime.Remoting.Messaging.IMessageSink
            {
                /*0x10*/ System.Runtime.Remoting.Messaging.IMessageSink _next;
                /*0x18*/ System.IDisposable _disposable;

                /*0x316f750*/ DisposerReplySink(System.Runtime.Remoting.Messaging.IMessageSink next, System.IDisposable disposable);
                /*0x316f794*/ System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                /*0x316f8b0*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
            }

            class SoapServices
            {
                static /*0x0*/ System.Collections.Hashtable _xmlTypes;
                static /*0x8*/ System.Collections.Hashtable _xmlElements;
                static /*0x10*/ System.Collections.Hashtable _soapActions;
                static /*0x18*/ System.Collections.Hashtable _soapActionsMethods;
                static /*0x20*/ System.Collections.Hashtable _typeInfos;

                static /*0x3170088*/ SoapServices();
                static /*0x316f8e8*/ string get_XmlNsForClrTypeWithAssembly();
                static /*0x316f928*/ string get_XmlNsForClrTypeWithNs();
                static /*0x316f968*/ string get_XmlNsForClrTypeWithNsAndAssembly();
                static /*0x316f9a8*/ string CodeXmlNamespaceForClrTypeNamespace(string typeNamespace, string assemblyName);
                static /*0x316fc18*/ string GetNameKey(string name, string namspace);
                static /*0x316fc80*/ string GetAssemblyName(System.Reflection.MethodBase mb);
                static /*0x316fd70*/ bool GetXmlElementForInteropType(System.Type type, ref string xmlElement, ref string xmlNamespace);
                static /*0x316fe6c*/ string GetXmlNamespaceForMethodCall(System.Reflection.MethodBase mb);
                static /*0x316ff00*/ string GetXmlNamespaceForMethodResponse(System.Reflection.MethodBase mb);
                static /*0x316ff94*/ bool GetXmlTypeForInteropType(System.Type type, ref string xmlType, ref string xmlTypeNamespace);
                static /*0x3168fec*/ void PreLoad(System.Reflection.Assembly assembly);
                static /*0x3168b10*/ void PreLoad(System.Type type);
                static /*0x31687e8*/ void RegisterInteropXmlElement(string xmlElement, string xmlNamespace, System.Type type);
                static /*0x316897c*/ void RegisterInteropXmlType(string xmlType, string xmlTypeNamespace, System.Type type);
                static /*0x316fb34*/ string EncodeNs(string ns);

                class TypeInfo
                {
                    /*0x10*/ System.Collections.Hashtable Attributes;
                    /*0x18*/ System.Collections.Hashtable Elements;

                    /*0x3170080*/ TypeInfo();
                }
            }

            class TypeEntry
            {
                /*0x10*/ string assembly_name;
                /*0x18*/ string type_name;

                /*0x315e3e0*/ TypeEntry();
                /*0x31701a4*/ string get_AssemblyName();
                /*0x31701ac*/ void set_AssemblyName(string value);
                /*0x31701b4*/ string get_TypeName();
                /*0x31701bc*/ void set_TypeName(string value);
            }

            class TypeInfo : System.Runtime.Remoting.IRemotingTypeInfo
            {
                /*0x10*/ string serverType;
                /*0x18*/ string[] serverHierarchy;
                /*0x20*/ string[] interfacesImplemented;

                /*0x315fbb8*/ TypeInfo(System.Type type);
                /*0x31701c4*/ string get_TypeName();
                /*0x31701cc*/ bool CanCastTo(System.Type fromType, object o);
            }

            class WellKnownClientTypeEntry : System.Runtime.Remoting.TypeEntry
            {
                /*0x20*/ System.Type obj_type;
                /*0x28*/ string obj_url;
                /*0x30*/ string app_url;

                /*0x3168564*/ WellKnownClientTypeEntry(string typeName, string assemblyName, string objectUrl);
                /*0x3170420*/ string get_ApplicationUrl();
                /*0x3170428*/ System.Type get_ObjectType();
                /*0x3170430*/ string get_ObjectUrl();
                /*0x3170438*/ string ToString();
            }

            enum WellKnownObjectMode
            {
                Singleton = 1,
                SingleCall = 2,
            }

            class WellKnownServiceTypeEntry : System.Runtime.Remoting.TypeEntry
            {
                /*0x20*/ System.Type obj_type;
                /*0x28*/ string obj_uri;
                /*0x30*/ System.Runtime.Remoting.WellKnownObjectMode obj_mode;

                /*0x316869c*/ WellKnownServiceTypeEntry(string typeName, string assemblyName, string objectUri, System.Runtime.Remoting.WellKnownObjectMode mode);
                /*0x317045c*/ System.Runtime.Remoting.WellKnownObjectMode get_Mode();
                /*0x3170464*/ System.Type get_ObjectType();
                /*0x317046c*/ string get_ObjectUri();
                /*0x3170474*/ string ToString();
            }

            namespace Services
            {
                interface ITrackingHandler
                {
                    /*0x1f30ebc*/ void DisconnectedObject(object obj);
                    /*0x1f30ff0*/ void MarshaledObject(object obj, System.Runtime.Remoting.ObjRef or);
                    /*0x1f30ff0*/ void UnmarshaledObject(object obj, System.Runtime.Remoting.ObjRef or);
                }

                class TrackingServices
                {
                    static /*0x0*/ System.Collections.ArrayList _handlers;

                    static /*0x3170598*/ TrackingServices();
                    static /*0x316b2a4*/ void NotifyMarshaledObject(object obj, System.Runtime.Remoting.ObjRef or);
                    static /*0x316a620*/ void NotifyUnmarshaledObject(object obj, System.Runtime.Remoting.ObjRef or);
                    static /*0x316e8d4*/ void NotifyDisconnectedObject(object obj);
                }
            }

            namespace Proxies
            {
                class ProxyAttribute : System.Attribute, System.Runtime.Remoting.Contexts.IContextAttribute
                {
                    /*0x3170614*/ System.MarshalByRefObject CreateInstance(System.Type serverType);
                    /*0x3170708*/ System.Runtime.Remoting.Proxies.RealProxy CreateProxy(System.Runtime.Remoting.ObjRef objRef, System.Type serverType, object serverObject, System.Runtime.Remoting.Contexts.Context serverContext);
                    /*0x3170764*/ void GetPropertiesForNewContext(System.Runtime.Remoting.Activation.IConstructionCallMessage msg);
                    /*0x3170768*/ bool IsContextOK(System.Runtime.Remoting.Contexts.Context ctx, System.Runtime.Remoting.Activation.IConstructionCallMessage msg);
                }

                class TransparentProxy
                {
                    /*0x10*/ System.Runtime.Remoting.Proxies.RealProxy _rp;
                    /*0x18*/ Mono.RuntimeRemoteClassHandle _class;
                    /*0x20*/ bool _custom_type_info;

                    /*0x317175c*/ TransparentProxy();
                    /*0x3170770*/ System.RuntimeType GetProxyType();
                    /*0x3170830*/ bool get_IsContextBoundObject();
                    /*0x317084c*/ System.Runtime.Remoting.Contexts.Context get_TargetContext();
                    /*0x3170864*/ bool InCurrentContext();
                    /*0x31708a4*/ object LoadRemoteFieldNew(nint classPtr, nint fieldPtr);
                    /*0x3171480*/ void StoreRemoteField(nint classPtr, nint fieldPtr, object arg);
                }

                class RealProxy
                {
                    /*0x10*/ System.Type class_to_proxy;
                    /*0x18*/ System.Runtime.Remoting.Contexts.Context _targetContext;
                    /*0x20*/ System.MarshalByRefObject _server;
                    /*0x28*/ int _targetDomainId;
                    /*0x30*/ string _targetUri;
                    /*0x38*/ System.Runtime.Remoting.Identity _objectIdentity;
                    /*0x40*/ object _objTP;
                    /*0x48*/ object _stubData;

                    static /*0x3171894*/ System.Type InternalGetProxyType(object transparentProxy);
                    static /*0x3170b70*/ object PrivateInvoke(System.Runtime.Remoting.Proxies.RealProxy rp, System.Runtime.Remoting.Messaging.IMessage msg, ref System.Exception exc, ref object[] out_args);
                    static /*0x31719e8*/ object[] ProcessResponse(System.Runtime.Remoting.Messaging.IMethodReturnMessage mrm, System.Runtime.Remoting.Messaging.MonoMethodMessage call);
                    /*0x3171764*/ RealProxy();
                    /*0x3171774*/ RealProxy(System.Type classToProxy);
                    /*0x3171864*/ RealProxy(System.Type classToProxy, System.Runtime.Remoting.ClientIdentity identity);
                    /*0x317177c*/ RealProxy(System.Type classToProxy, nint stub, object stubData);
                    /*0x316ab24*/ System.Type GetProxiedType();
                    /*0x3171898*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                    /*0x31718fc*/ System.Runtime.Remoting.Identity get_ObjectIdentity();
                    /*0x3171904*/ void set_ObjectIdentity(System.Runtime.Remoting.Identity value);
                    /*0x1f302cc*/ System.Runtime.Remoting.Messaging.IMessage Invoke(System.Runtime.Remoting.Messaging.IMessage msg);
                    /*0x31720e0*/ object InternalGetTransparentProxy(string className);
                    /*0x31720e4*/ object GetTransparentProxy();
                    /*0x3172258*/ void AttachServer(System.MarshalByRefObject s);
                    /*0x3172260*/ void SetTargetDomain(int domainId);
                    /*0x3172268*/ object GetAppDomainTarget();
                }

                class RemotingProxy : System.Runtime.Remoting.Proxies.RealProxy, System.Runtime.Remoting.IRemotingTypeInfo
                {
                    static /*0x0*/ System.Reflection.MethodInfo _cache_GetTypeMethod;
                    static /*0x8*/ System.Reflection.MethodInfo _cache_GetHashCodeMethod;
                    /*0x50*/ System.Runtime.Remoting.Messaging.IMessageSink _sink;
                    /*0x58*/ bool _hasEnvoySink;
                    /*0x60*/ System.Runtime.Remoting.Messaging.ConstructionCall _ctorCall;

                    static /*0x3173ef8*/ RemotingProxy();
                    /*0x316cb78*/ RemotingProxy(System.Type type, System.Runtime.Remoting.ClientIdentity identity);
                    /*0x316c0d8*/ RemotingProxy(System.Type type, string activationUrl, object[] activationAttributes);
                    /*0x3172cd8*/ System.Runtime.Remoting.Messaging.IMessage Invoke(System.Runtime.Remoting.Messaging.IMessage request);
                    /*0x31735e4*/ void AttachIdentity(System.Runtime.Remoting.Identity identity);
                    /*0x317190c*/ System.Runtime.Remoting.Messaging.IMessage ActivateRemoteObject(System.Runtime.Remoting.Messaging.IMethodMessage request);
                    /*0x3173aa4*/ string get_TypeName();
                    /*0x3173bdc*/ bool CanCastTo(System.Type fromType, object o);
                    /*0x3173de8*/ void Finalize();
                }
            }

            namespace Lifetime
            {
                interface ILease
                {
                    /*0x1f30870*/ System.TimeSpan get_CurrentLeaseTime();
                    /*0x1f2ffc8*/ System.Runtime.Remoting.Lifetime.LeaseState get_CurrentState();
                    /*0x1f30870*/ System.TimeSpan get_RenewOnCallTime();
                    System.TimeSpan Renew(System.TimeSpan renewalTime);
                }

                interface ISponsor
                {
                    System.TimeSpan Renewal(System.Runtime.Remoting.Lifetime.ILease lease);
                }

                class Lease : System.MarshalByRefObject, System.Runtime.Remoting.Lifetime.ILease
                {
                    /*0x18*/ System.DateTime _leaseExpireTime;
                    /*0x20*/ System.Runtime.Remoting.Lifetime.LeaseState _currentState;
                    /*0x28*/ System.TimeSpan _initialLeaseTime;
                    /*0x30*/ System.TimeSpan _renewOnCallTime;
                    /*0x38*/ System.TimeSpan _sponsorshipTimeout;
                    /*0x40*/ System.Collections.ArrayList _sponsors;
                    /*0x48*/ System.Collections.Queue _renewingSponsors;
                    /*0x50*/ System.Runtime.Remoting.Lifetime.Lease.RenewalDelegate _renewalDelegate;

                    /*0x316e218*/ Lease();
                    /*0x3173fe8*/ System.TimeSpan get_CurrentLeaseTime();
                    /*0x3174050*/ System.Runtime.Remoting.Lifetime.LeaseState get_CurrentState();
                    /*0x3174058*/ void Activate();
                    /*0x3174064*/ System.TimeSpan get_RenewOnCallTime();
                    /*0x317406c*/ System.TimeSpan Renew(System.TimeSpan renewalTime);
                    /*0x31740f8*/ void Unregister(System.Runtime.Remoting.Lifetime.ISponsor obj);
                    /*0x3174240*/ void UpdateState();
                    /*0x31743e8*/ void CheckNextSponsor();
                    /*0x317477c*/ void ProcessSponsorResponse(object state, bool timedOut);

                    class RenewalDelegate : System.MulticastDelegate
                    {
                        /*0x3174654*/ RenewalDelegate(object object, nint method);
                        /*0x3174998*/ System.TimeSpan Invoke(System.Runtime.Remoting.Lifetime.ILease lease);
                        /*0x317475c*/ System.IAsyncResult BeginInvoke(System.Runtime.Remoting.Lifetime.ILease lease, System.AsyncCallback callback, object object);
                        /*0x3174970*/ System.TimeSpan EndInvoke(System.IAsyncResult result);
                    }
                }

                class LeaseManager
                {
                    /*0x10*/ System.Collections.ArrayList _objects;
                    /*0x18*/ System.Threading.Timer _timer;

                    /*0x3174fb0*/ LeaseManager();
                    /*0x31749ac*/ void SetPollTime(System.TimeSpan timeSpan);
                    /*0x3174a9c*/ void TrackLifetime(System.Runtime.Remoting.ServerIdentity identity);
                    /*0x3174bd0*/ void StartManager();
                    /*0x3174d2c*/ void StopManager();
                    /*0x3174d5c*/ void ManageLeases(object state);
                }

                class LeaseSink : System.Runtime.Remoting.Messaging.IMessageSink
                {
                    /*0x10*/ System.Runtime.Remoting.Messaging.IMessageSink _nextSink;

                    /*0x317501c*/ LeaseSink(System.Runtime.Remoting.Messaging.IMessageSink nextSink);
                    /*0x317504c*/ System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                    /*0x3175388*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                    /*0x31750fc*/ void RenewLease(System.Runtime.Remoting.Messaging.IMessage msg);
                }

                enum LeaseState
                {
                    Null = 0,
                    Initial = 1,
                    Active = 2,
                    Renewing = 3,
                    Expired = 4,
                }

                class LifetimeServices
                {
                    static /*0x0*/ System.TimeSpan _leaseManagerPollTime;
                    static /*0x8*/ System.TimeSpan _leaseTime;
                    static /*0x10*/ System.TimeSpan _renewOnCallTime;
                    static /*0x18*/ System.TimeSpan _sponsorshipTimeout;
                    static /*0x20*/ System.Runtime.Remoting.Lifetime.LeaseManager _leaseManager;

                    static /*0x317544c*/ LifetimeServices();
                    static /*0x317554c*/ System.TimeSpan get_LeaseManagerPollTime();
                    static /*0x3168144*/ void set_LeaseManagerPollTime(System.TimeSpan value);
                    static /*0x31755a4*/ System.TimeSpan get_LeaseTime();
                    static /*0x31755fc*/ void set_LeaseTime(System.TimeSpan value);
                    static /*0x3175658*/ System.TimeSpan get_RenewOnCallTime();
                    static /*0x31756b0*/ void set_RenewOnCallTime(System.TimeSpan value);
                    static /*0x317570c*/ System.TimeSpan get_SponsorshipTimeout();
                    static /*0x3175764*/ void set_SponsorshipTimeout(System.TimeSpan value);
                    static /*0x316e370*/ void TrackLifetime(System.Runtime.Remoting.ServerIdentity identity);
                }
            }

            namespace Contexts
            {
                class Context
                {
                    static /*0x0*/ object[] local_slots;
                    static /*0x8*/ System.Runtime.Remoting.Messaging.IMessageSink default_server_context_sink;
                    static /*0x10*/ int global_count;
                    static /*0x18*/ System.LocalDataStoreMgr _localDataStoreMgr;
                    static /*0x20*/ System.Runtime.Remoting.Contexts.DynamicPropertyCollection global_dynamic_properties;
                    /*0x10*/ int domain_id;
                    /*0x14*/ int context_id;
                    /*0x18*/ nuint static_data;
                    /*0x20*/ nuint data;
                    /*0x28*/ System.Runtime.Remoting.Messaging.IMessageSink server_context_sink_chain;
                    /*0x30*/ System.Runtime.Remoting.Messaging.IMessageSink client_context_sink_chain;
                    /*0x38*/ System.Collections.Generic.List<System.Runtime.Remoting.Contexts.IContextProperty> context_properties;
                    /*0x40*/ System.LocalDataStoreHolder _localDataStore;
                    /*0x48*/ System.Runtime.Remoting.Contexts.DynamicPropertyCollection context_dynamic_properties;
                    /*0x50*/ System.Runtime.Remoting.Contexts.ContextCallbackObject callback_object;

                    static /*0x3177918*/ Context();
                    static /*0x31757c0*/ void RegisterContext(System.Runtime.Remoting.Contexts.Context ctx);
                    static /*0x31757c4*/ void ReleaseContext(System.Runtime.Remoting.Contexts.Context ctx);
                    static /*0x316d474*/ System.Runtime.Remoting.Contexts.Context get_DefaultContext();
                    static /*0x3175a90*/ bool RegisterDynamicProperty(System.Runtime.Remoting.Contexts.IDynamicProperty prop, System.ContextBoundObject obj, System.Runtime.Remoting.Contexts.Context ctx);
                    static /*0x3175fac*/ bool UnregisterDynamicProperty(string name, System.ContextBoundObject obj, System.Runtime.Remoting.Contexts.Context ctx);
                    static /*0x3175b08*/ System.Runtime.Remoting.Contexts.DynamicPropertyCollection GetDynamicPropertyCollection(System.ContextBoundObject obj, System.Runtime.Remoting.Contexts.Context ctx);
                    static /*0x3176194*/ void NotifyGlobalDynamicSinks(bool start, System.Runtime.Remoting.Messaging.IMessage req_msg, bool client_site, bool async);
                    static /*0x3176294*/ bool get_HasGlobalDynamicSinks();
                    static /*0x3176c28*/ System.Runtime.Remoting.Contexts.Context SwitchToContext(System.Runtime.Remoting.Contexts.Context newContext);
                    static /*0x3176c30*/ System.Runtime.Remoting.Contexts.Context CreateNewContext(System.Runtime.Remoting.Activation.IConstructionCallMessage msg);
                    static /*0x3177700*/ System.LocalDataStoreSlot AllocateDataSlot();
                    static /*0x3177764*/ System.LocalDataStoreSlot AllocateNamedDataSlot(string name);
                    static /*0x31777d0*/ void FreeNamedDataSlot(string name);
                    static /*0x317783c*/ System.LocalDataStoreSlot GetNamedDataSlot(string name);
                    static /*0x31778a8*/ object GetData(System.LocalDataStoreSlot slot);
                    static /*0x31778d8*/ void SetData(System.LocalDataStoreSlot slot, object data);
                    /*0x31757c8*/ Context();
                    /*0x3175854*/ void Finalize();
                    /*0x3175924*/ int get_ContextID();
                    /*0x317592c*/ System.Runtime.Remoting.Contexts.IContextProperty[] get_ContextProperties();
                    /*0x31759a0*/ bool get_IsDefaultContext();
                    /*0x31759b0*/ bool get_NeedsContextSink();
                    /*0x3176338*/ void NotifyDynamicSinks(bool start, System.Runtime.Remoting.Messaging.IMessage req_msg, bool client_site, bool async);
                    /*0x31763bc*/ bool get_HasDynamicSinks();
                    /*0x3173294*/ bool get_HasExitSinks();
                    /*0x31763fc*/ System.Runtime.Remoting.Contexts.IContextProperty GetProperty(string name);
                    /*0x317664c*/ void SetProperty(System.Runtime.Remoting.Contexts.IContextProperty prop);
                    /*0x31767ac*/ void Freeze();
                    /*0x31769d8*/ string ToString();
                    /*0x3176a34*/ System.Runtime.Remoting.Messaging.IMessageSink GetServerContextSinkChain();
                    /*0x317334c*/ System.Runtime.Remoting.Messaging.IMessageSink GetClientContextSinkChain();
                    /*0x316ed38*/ System.Runtime.Remoting.Messaging.IMessageSink CreateServerObjectSinkChain(System.MarshalByRefObject obj, bool forceInternalExecute);
                    /*0x316e640*/ System.Runtime.Remoting.Messaging.IMessageSink CreateEnvoySink(System.MarshalByRefObject serverObject);
                    /*0x31773f0*/ void DoCallBack(System.Runtime.Remoting.Contexts.CrossContextDelegate deleg);
                    /*0x3177584*/ System.LocalDataStore get_MyLocalStore();
                }

                class DynamicPropertyCollection
                {
                    /*0x10*/ System.Collections.ArrayList _properties;

                    /*0x315e66c*/ DynamicPropertyCollection();
                    /*0x315e718*/ bool get_HasProperties();
                    /*0x3175c98*/ bool RegisterDynamicProperty(System.Runtime.Remoting.Contexts.IDynamicProperty prop);
                    /*0x3176024*/ bool UnregisterDynamicProperty(string name);
                    /*0x315e7cc*/ void NotifyMessage(bool start, System.Runtime.Remoting.Messaging.IMessage msg, bool client_site, bool async);
                    /*0x317798c*/ int FindProperty(string name);

                    class DynamicPropertyReg
                    {
                        /*0x10*/ System.Runtime.Remoting.Contexts.IDynamicProperty Property;
                        /*0x18*/ System.Runtime.Remoting.Contexts.IDynamicMessageSink Sink;

                        /*0x3177af0*/ DynamicPropertyReg();
                    }
                }

                class ContextCallbackObject : System.ContextBoundObject
                {
                    /*0x3177578*/ ContextCallbackObject();
                    /*0x3177580*/ void DoCallBack(System.Runtime.Remoting.Contexts.CrossContextDelegate deleg);
                }

                class CrossContextChannel : System.Runtime.Remoting.Messaging.IMessageSink
                {
                    /*0x31782e0*/ CrossContextChannel();
                    /*0x3177af8*/ System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                    /*0x3177eb4*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);

                    class ContextRestoreSink : System.Runtime.Remoting.Messaging.IMessageSink
                    {
                        /*0x10*/ System.Runtime.Remoting.Messaging.IMessageSink _next;
                        /*0x18*/ System.Runtime.Remoting.Contexts.Context _context;
                        /*0x20*/ System.Runtime.Remoting.Messaging.IMessage _call;

                        /*0x3178280*/ ContextRestoreSink(System.Runtime.Remoting.Messaging.IMessageSink next, System.Runtime.Remoting.Contexts.Context context, System.Runtime.Remoting.Messaging.IMessage call);
                        /*0x31782e8*/ System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                        /*0x3178588*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                    }
                }

                class CrossContextDelegate : System.MulticastDelegate
                {
                    /*0x31785c0*/ CrossContextDelegate(object object, nint method);
                    /*0x317865c*/ void Invoke();
                }

                interface IContextAttribute
                {
                    /*0x1f30ebc*/ void GetPropertiesForNewContext(System.Runtime.Remoting.Activation.IConstructionCallMessage msg);
                    /*0x1f2ff00*/ bool IsContextOK(System.Runtime.Remoting.Contexts.Context ctx, System.Runtime.Remoting.Activation.IConstructionCallMessage msg);
                }

                interface IContextProperty
                {
                    /*0x1f30214*/ string get_Name();
                    /*0x1f30ebc*/ void Freeze(System.Runtime.Remoting.Contexts.Context newContext);
                    /*0x1f2fec8*/ bool IsNewContextOK(System.Runtime.Remoting.Contexts.Context newCtx);
                }

                interface IContributeClientContextSink
                {
                    /*0x1f302cc*/ System.Runtime.Remoting.Messaging.IMessageSink GetClientContextSink(System.Runtime.Remoting.Messaging.IMessageSink nextSink);
                }

                interface IContributeDynamicSink
                {
                    /*0x1f30214*/ System.Runtime.Remoting.Contexts.IDynamicMessageSink GetDynamicSink();
                }

                interface IContributeEnvoySink
                {
                    /*0x1f30394*/ System.Runtime.Remoting.Messaging.IMessageSink GetEnvoySink(System.MarshalByRefObject obj, System.Runtime.Remoting.Messaging.IMessageSink nextSink);
                }

                interface IContributeObjectSink
                {
                    /*0x1f30394*/ System.Runtime.Remoting.Messaging.IMessageSink GetObjectSink(System.MarshalByRefObject obj, System.Runtime.Remoting.Messaging.IMessageSink nextSink);
                }

                interface IContributeServerContextSink
                {
                    /*0x1f302cc*/ System.Runtime.Remoting.Messaging.IMessageSink GetServerContextSink(System.Runtime.Remoting.Messaging.IMessageSink nextSink);
                }

                interface IDynamicMessageSink
                {
                    void ProcessMessageFinish(System.Runtime.Remoting.Messaging.IMessage replyMsg, bool bCliSide, bool bAsync);
                    void ProcessMessageStart(System.Runtime.Remoting.Messaging.IMessage reqMsg, bool bCliSide, bool bAsync);
                }

                interface IDynamicProperty
                {
                    /*0x1f30214*/ string get_Name();
                }
            }

            namespace Channels
            {
                class ChannelServices
                {
                    static /*0x0*/ System.Collections.ArrayList registeredChannels;
                    static /*0x8*/ System.Collections.ArrayList delayedClientChannels;
                    static /*0x10*/ System.Runtime.Remoting.Contexts.CrossContextChannel _crossContextSink;
                    static /*0x18*/ string CrossContextUrl;
                    static /*0x20*/ System.Collections.IList oldStartModeTypes;

                    static /*0x317996c*/ ChannelServices();
                    static /*0x3178670*/ System.Runtime.Remoting.Contexts.CrossContextChannel get_CrossContextChannel();
                    static /*0x316cbec*/ System.Runtime.Remoting.Messaging.IMessageSink CreateClientChannelSinkChain(string url, object remoteChannelData, ref string objectUri);
                    static /*0x31786c8*/ System.Runtime.Remoting.Messaging.IMessageSink CreateClientChannelSinkChain(System.Runtime.Remoting.Channels.IChannelSender sender, string url, object[] channelDataArray, ref string objectUri);
                    static /*0x31788f0*/ void RegisterChannel(System.Runtime.Remoting.Channels.IChannel chnl);
                    static /*0x3178948*/ void RegisterChannel(System.Runtime.Remoting.Channels.IChannel chnl, bool ensureSecurity);
                    static /*0x3163a2c*/ void RegisterChannelConfig(System.Runtime.Remoting.ChannelData channel);
                    static /*0x3179158*/ object CreateProvider(System.Runtime.Remoting.ProviderData prov);
                    static /*0x317945c*/ System.Runtime.Remoting.Messaging.IMessage SyncDispatchMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                    static /*0x3179504*/ System.Runtime.Remoting.Messaging.ReturnMessage CheckIncomingMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                    static /*0x31797a0*/ System.Runtime.Remoting.Messaging.IMessage CheckReturnMessage(System.Runtime.Remoting.Messaging.IMessage callMsg, System.Runtime.Remoting.Messaging.IMessage retMsg);
                    static /*0x3179964*/ bool IsLocalCall(System.Runtime.Remoting.Messaging.IMessage callMsg);
                    static /*0x315dd5c*/ object[] GetCurrentChannelInfo();
                }

                class CrossAppDomainData
                {
                    /*0x10*/ object _ContextID;
                    /*0x18*/ int _DomainID;
                    /*0x20*/ string _processGuid;

                    /*0x315f7f0*/ CrossAppDomainData(int domainId);
                    /*0x3179b28*/ int get_DomainID();
                    /*0x3179b30*/ string get_ProcessID();
                }

                class CrossAppDomainChannel : System.Runtime.Remoting.Channels.IChannel, System.Runtime.Remoting.Channels.IChannelSender, System.Runtime.Remoting.Channels.IChannelReceiver
                {
                    static /*0x0*/ object s_lock;

                    static /*0x317a000*/ CrossAppDomainChannel();
                    static /*0x316dadc*/ void RegisterCrossAppDomainChannel();
                    /*0x3179b38*/ CrossAppDomainChannel();
                    /*0x3179b40*/ string get_ChannelName();
                    /*0x3179b80*/ int get_ChannelPriority();
                    /*0x3179b88*/ object get_ChannelData();
                    /*0x3179bec*/ void StartListening(object data);
                    /*0x3179bf0*/ System.Runtime.Remoting.Messaging.IMessageSink CreateMessageSink(string url, object data, ref string uri);
                }

                class CrossAppDomainSink : System.Runtime.Remoting.Messaging.IMessageSink
                {
                    static /*0x0*/ System.Collections.Hashtable s_sinks;
                    static /*0x8*/ System.Reflection.MethodInfo processMessageMethod;
                    /*0x10*/ int _domainID;

                    static /*0x317a9e0*/ CrossAppDomainSink();
                    static /*0x3179d74*/ System.Runtime.Remoting.Channels.CrossAppDomainSink GetSink(int domainID);
                    static /*0x317a0ac*/ System.Runtime.Remoting.Channels.CrossAppDomainSink.ProcessMessageRes ProcessMessageInDomain(byte[] arrRequest, System.Runtime.Remoting.Messaging.CADMethodCallMessage cadMsg);
                    /*0x317a07c*/ CrossAppDomainSink(int domainID);
                    /*0x317a0a4*/ int get_TargetDomainId();
                    /*0x317a308*/ System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msgRequest);
                    /*0x317a7c8*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage reqMsg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                    /*0x317a8d4*/ void SendAsyncMessage(object data);
                    /*0x317aae4*/ void <AsyncProcessMessage>b__10_0(object data);

                    struct ProcessMessageRes
                    {
                        /*0x10*/ byte[] arrResponse;
                        /*0x18*/ System.Runtime.Remoting.Messaging.CADMethodReturnMessage cadMrm;
                    }
                }

                class CADSerializer
                {
                    static /*0x317a790*/ System.Runtime.Remoting.Messaging.IMessage DeserializeMessage(System.IO.MemoryStream mem, System.Runtime.Remoting.Messaging.IMethodCallMessage msg);
                    static /*0x317a210*/ System.IO.MemoryStream SerializeMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                    static /*0x315f89c*/ object DeserializeObjectSafe(byte[] mem);
                    static /*0x315f9ac*/ System.IO.MemoryStream SerializeObject(object obj);
                    static /*0x317ab64*/ object DeserializeObject(System.IO.MemoryStream mem);
                }

                class AsyncRequest
                {
                    /*0x10*/ System.Runtime.Remoting.Messaging.IMessageSink ReplySink;
                    /*0x18*/ System.Runtime.Remoting.Messaging.IMessage MsgRequest;

                    /*0x317a890*/ AsyncRequest(System.Runtime.Remoting.Messaging.IMessage msgRequest, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                }

                interface IChannel
                {
                    /*0x1f30214*/ string get_ChannelName();
                    /*0x1f2ffc8*/ int get_ChannelPriority();
                }

                interface IChannelDataStore
                {
                }

                interface IChannelReceiver : System.Runtime.Remoting.Channels.IChannel
                {
                    /*0x1f30214*/ object get_ChannelData();
                    /*0x1f30ebc*/ void StartListening(object data);
                }

                interface IChannelSender : System.Runtime.Remoting.Channels.IChannel
                {
                    /*0x1f303d0*/ System.Runtime.Remoting.Messaging.IMessageSink CreateMessageSink(string url, object remoteChannelData, ref string objectURI);
                }

                interface IClientChannelSinkProvider
                {
                    /*0x1f30ebc*/ void set_Next(System.Runtime.Remoting.Channels.IClientChannelSinkProvider value);
                }

                interface ISecurableChannel
                {
                    /*0x1f30a84*/ void set_IsSecured(bool value);
                }

                interface IServerChannelSinkProvider
                {
                    /*0x1f30ebc*/ void set_Next(System.Runtime.Remoting.Channels.IServerChannelSinkProvider value);
                }

                class SinkProviderData
                {
                    /*0x10*/ string sinkName;
                    /*0x18*/ System.Collections.ArrayList children;
                    /*0x20*/ System.Collections.Hashtable properties;

                    /*0x3167cb0*/ SinkProviderData(string name);
                    /*0x317abf8*/ System.Collections.IList get_Children();
                    /*0x317ac00*/ System.Collections.IDictionary get_Properties();
                }
            }

            namespace Activation
            {
                class ActivationServices
                {
                    static /*0x0*/ System.Runtime.Remoting.Activation.IActivator _constructionActivator;

                    static /*0x317ac08*/ System.Runtime.Remoting.Activation.IActivator get_ConstructionActivator();
                    static /*0x3173874*/ System.Runtime.Remoting.Messaging.IMessage Activate(System.Runtime.Remoting.Proxies.RemotingProxy proxy, System.Runtime.Remoting.Messaging.ConstructionCall ctorCall);
                    static /*0x317acac*/ System.Runtime.Remoting.Messaging.IMessage RemoteActivate(System.Runtime.Remoting.Activation.IConstructionCallMessage ctorCall);
                    static /*0x3172394*/ System.Runtime.Remoting.Messaging.ConstructionCall CreateConstructionCall(System.Type type, string activationUrl, object[] activationAttributes);
                    static /*0x317aef0*/ System.Runtime.Remoting.Messaging.IMessage CreateInstanceFromMessage(System.Runtime.Remoting.Activation.IConstructionCallMessage ctorCall);
                    static /*0x317b0a0*/ object CreateProxyForType(System.Type type);
                    static /*0x317b09c*/ object AllocateUninitializedClassInstance(System.Type type);
                    static /*0x316167c*/ void EnableProxyActivation(System.Type type, bool enable);
                }

                class AppDomainLevelActivator : System.Runtime.Remoting.Activation.IActivator
                {
                    /*0x10*/ string _activationUrl;
                    /*0x18*/ System.Runtime.Remoting.Activation.IActivator _next;

                    /*0x317ae7c*/ AppDomainLevelActivator(string activationUrl, System.Runtime.Remoting.Activation.IActivator next);
                    /*0x317b1cc*/ System.Runtime.Remoting.Activation.IActivator get_NextActivator();
                    /*0x317b1d4*/ System.Runtime.Remoting.Activation.IConstructionReturnMessage Activate(System.Runtime.Remoting.Activation.IConstructionCallMessage ctorCall);
                }

                class ConstructionLevelActivator : System.Runtime.Remoting.Activation.IActivator
                {
                    /*0x317aca4*/ ConstructionLevelActivator();
                    /*0x317b684*/ System.Runtime.Remoting.Activation.IActivator get_NextActivator();
                    /*0x317b68c*/ System.Runtime.Remoting.Activation.IConstructionReturnMessage Activate(System.Runtime.Remoting.Activation.IConstructionCallMessage msg);
                }

                class ContextLevelActivator : System.Runtime.Remoting.Activation.IActivator
                {
                    /*0x10*/ System.Runtime.Remoting.Activation.IActivator m_NextActivator;

                    /*0x317aec0*/ ContextLevelActivator(System.Runtime.Remoting.Activation.IActivator next);
                    /*0x317b77c*/ System.Runtime.Remoting.Activation.IActivator get_NextActivator();
                    /*0x317b784*/ System.Runtime.Remoting.Activation.IConstructionReturnMessage Activate(System.Runtime.Remoting.Activation.IConstructionCallMessage ctorCall);
                }

                interface IActivator
                {
                    /*0x1f30214*/ System.Runtime.Remoting.Activation.IActivator get_NextActivator();
                    /*0x1f302cc*/ System.Runtime.Remoting.Activation.IConstructionReturnMessage Activate(System.Runtime.Remoting.Activation.IConstructionCallMessage msg);
                }

                interface IConstructionCallMessage : System.Runtime.Remoting.Messaging.IMessage, System.Runtime.Remoting.Messaging.IMethodCallMessage, System.Runtime.Remoting.Messaging.IMethodMessage
                {
                    /*0x1f30214*/ System.Type get_ActivationType();
                    /*0x1f30214*/ string get_ActivationTypeName();
                    /*0x1f30214*/ System.Runtime.Remoting.Activation.IActivator get_Activator();
                    /*0x1f30ebc*/ void set_Activator(System.Runtime.Remoting.Activation.IActivator value);
                    /*0x1f30214*/ object[] get_CallSiteActivationAttributes();
                    /*0x1f30214*/ System.Collections.IList get_ContextProperties();
                }

                interface IConstructionReturnMessage : System.Runtime.Remoting.Messaging.IMethodReturnMessage, System.Runtime.Remoting.Messaging.IMethodMessage, System.Runtime.Remoting.Messaging.IMessage
                {
                }

                class RemoteActivationAttribute : System.Attribute, System.Runtime.Remoting.Contexts.IContextAttribute
                {
                    /*0x10*/ System.Collections.IList _contextProperties;

                    /*0x317baa8*/ RemoteActivationAttribute(System.Collections.IList contextProperties);
                    /*0x317bad8*/ bool IsContextOK(System.Runtime.Remoting.Contexts.Context ctx, System.Runtime.Remoting.Activation.IConstructionCallMessage ctor);
                    /*0x317bae0*/ void GetPropertiesForNewContext(System.Runtime.Remoting.Activation.IConstructionCallMessage ctor);
                }

                class RemoteActivator : System.MarshalByRefObject, System.Runtime.Remoting.Activation.IActivator
                {
                    /*0x317be90*/ System.Runtime.Remoting.Activation.IConstructionReturnMessage Activate(System.Runtime.Remoting.Activation.IConstructionCallMessage msg);
                    /*0x317c328*/ System.Runtime.Remoting.Activation.IActivator get_NextActivator();
                }
            }

            namespace Metadata
            {
                class SoapAttribute : System.Attribute
                {
                    /*0x10*/ bool _useAttribute;
                    /*0x18*/ string ProtXmlNamespace;
                    /*0x20*/ object ReflectInfo;

                    /*0x317c360*/ SoapAttribute();
                    /*0x317c368*/ bool get_UseAttribute();
                    /*0x317c370*/ string get_XmlNamespace();
                    /*0x317c378*/ void SetReflectionObject(object reflectionObject);
                }

                class SoapFieldAttribute : System.Runtime.Remoting.Metadata.SoapAttribute
                {
                    /*0x28*/ string _elementName;
                    /*0x30*/ bool _isElement;

                    /*0x317c380*/ SoapFieldAttribute();
                    /*0x317c388*/ string get_XmlElementName();
                    /*0x317c390*/ bool IsInteropXmlElement();
                    /*0x317c398*/ void SetReflectionObject(object reflectionObject);
                }

                class SoapMethodAttribute : System.Runtime.Remoting.Metadata.SoapAttribute
                {
                    /*0x28*/ string _responseElement;
                    /*0x30*/ string _responseNamespace;
                    /*0x38*/ string _returnElement;
                    /*0x40*/ string _soapAction;
                    /*0x48*/ bool _useAttribute;
                    /*0x50*/ string _namespace;

                    /*0x317c44c*/ SoapMethodAttribute();
                    /*0x317c454*/ bool get_UseAttribute();
                    /*0x317c45c*/ string get_XmlNamespace();
                    /*0x317c464*/ void SetReflectionObject(object reflectionObject);
                }

                class SoapParameterAttribute : System.Runtime.Remoting.Metadata.SoapAttribute
                {
                    /*0x317c680*/ SoapParameterAttribute();
                }

                class SoapTypeAttribute : System.Runtime.Remoting.Metadata.SoapAttribute
                {
                    /*0x28*/ bool _useAttribute;
                    /*0x30*/ string _xmlElementName;
                    /*0x38*/ string _xmlNamespace;
                    /*0x40*/ string _xmlTypeName;
                    /*0x48*/ string _xmlTypeNamespace;
                    /*0x50*/ bool _isType;
                    /*0x51*/ bool _isElement;

                    /*0x317c688*/ SoapTypeAttribute();
                    /*0x317c690*/ bool get_UseAttribute();
                    /*0x317c698*/ string get_XmlElementName();
                    /*0x317c6a0*/ string get_XmlNamespace();
                    /*0x317c6a8*/ string get_XmlTypeName();
                    /*0x317c6b0*/ string get_XmlTypeNamespace();
                    /*0x317c6b8*/ bool get_IsInteropXmlElement();
                    /*0x317c6c0*/ bool get_IsInteropXmlType();
                    /*0x317c6c8*/ void SetReflectionObject(object reflectionObject);
                }
            }

            namespace Messaging
            {
                class CallContext
                {
                    static /*0x317c918*/ object SetCurrentCallContext(System.Runtime.Remoting.Messaging.LogicalCallContext ctx);
                    static /*0x317c920*/ System.Runtime.Remoting.Messaging.LogicalCallContext SetLogicalCallContext(System.Runtime.Remoting.Messaging.LogicalCallContext callCtx);
                    /*0x317c910*/ CallContext();
                }

                class IllogicalCallContext
                {
                    /*0x10*/ System.Collections.Hashtable m_Datastore;
                    /*0x18*/ object m_HostContext;

                    /*0x317cc74*/ IllogicalCallContext();
                    /*0x317c978*/ System.Collections.Hashtable get_Datastore();
                    /*0x317c9e8*/ object get_HostContext();
                    /*0x317c9f0*/ void set_HostContext(object value);
                    /*0x317c9f8*/ bool get_HasUserData();
                    /*0x317ca24*/ System.Runtime.Remoting.Messaging.IllogicalCallContext CreateCopy();
                }

                class LogicalCallContext : System.Runtime.Serialization.ISerializable, System.ICloneable
                {
                    static /*0x0*/ System.Type s_callContextType;
                    /*0x10*/ System.Collections.Hashtable m_Datastore;
                    /*0x18*/ System.Runtime.Remoting.Messaging.CallContextRemotingData m_RemotingData;
                    /*0x20*/ System.Runtime.Remoting.Messaging.CallContextSecurityData m_SecurityData;
                    /*0x28*/ object m_HostContext;
                    /*0x30*/ bool m_IsCorrelationMgr;

                    static /*0x317e158*/ LogicalCallContext();
                    /*0x317cc7c*/ LogicalCallContext();
                    /*0x317cc84*/ LogicalCallContext(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                    /*0x317d1d0*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                    /*0x317d778*/ object Clone();
                    /*0x317deb4*/ void Merge(System.Runtime.Remoting.Messaging.LogicalCallContext lc);
                    /*0x317e0d8*/ bool get_HasInfo();
                    /*0x317d74c*/ bool get_HasUserData();
                    /*0x317d12c*/ System.Collections.Hashtable get_Datastore();

                    struct Reader
                    {
                        /*0x10*/ System.Runtime.Remoting.Messaging.LogicalCallContext m_ctx;

                        /*0x317e1e8*/ Reader(System.Runtime.Remoting.Messaging.LogicalCallContext ctx);
                        /*0x317e1f0*/ bool get_IsNull();
                        /*0x317e200*/ bool get_HasInfo();
                        /*0x317e210*/ System.Runtime.Remoting.Messaging.LogicalCallContext Clone();
                    }
                }

                class CallContextSecurityData : System.ICloneable
                {
                    /*0x10*/ System.Security.Principal.IPrincipal _principal;

                    /*0x317e278*/ CallContextSecurityData();
                    /*0x317e148*/ bool get_HasInfo();
                    /*0x317de44*/ object Clone();
                }

                class CallContextRemotingData : System.ICloneable
                {
                    /*0x10*/ string _logicalCallID;

                    /*0x317e290*/ CallContextRemotingData();
                    /*0x317e280*/ string get_LogicalCallID();
                    /*0x317e288*/ void set_LogicalCallID(string value);
                    /*0x317e138*/ bool get_HasInfo();
                    /*0x317ddd4*/ object Clone();
                }

                enum ArgInfoType
                {
                    In = 0,
                    Out = 1,
                }

                class ArgInfo
                {
                    /*0x10*/ int[] _paramMap;
                    /*0x18*/ int _inoutArgCount;
                    /*0x20*/ System.Reflection.MethodBase _method;

                    /*0x317e298*/ ArgInfo(System.Reflection.MethodBase method, System.Runtime.Remoting.Messaging.ArgInfoType type);
                    /*0x317e46c*/ object[] GetInOutArgs(object[] args);
                }

                class AsyncResult : System.IAsyncResult, System.Runtime.Remoting.Messaging.IMessageSink, System.Threading.IThreadPoolWorkItem
                {
                    /*0x10*/ object async_state;
                    /*0x18*/ System.Threading.WaitHandle handle;
                    /*0x20*/ object async_delegate;
                    /*0x28*/ nint data;
                    /*0x30*/ object object_data;
                    /*0x38*/ bool sync_completed;
                    /*0x39*/ bool completed;
                    /*0x3a*/ bool endinvoke_called;
                    /*0x40*/ object async_callback;
                    /*0x48*/ System.Threading.ExecutionContext current;
                    /*0x50*/ System.Threading.ExecutionContext original;
                    /*0x58*/ long add_time;
                    /*0x60*/ System.Runtime.Remoting.Messaging.MonoMethodMessage call_message;
                    /*0x68*/ System.Runtime.Remoting.Messaging.IMessageCtrl message_ctrl;
                    /*0x70*/ System.Runtime.Remoting.Messaging.IMessage reply_message;
                    /*0x78*/ System.Threading.WaitCallback orig_cb;

                    /*0x317e584*/ AsyncResult();
                    /*0x317e58c*/ object get_AsyncState();
                    /*0x317e594*/ System.Threading.WaitHandle get_AsyncWaitHandle();
                    /*0x317e6c0*/ bool get_CompletedSynchronously();
                    /*0x317e6c8*/ bool get_IsCompleted();
                    /*0x317e6d0*/ bool get_EndInvokeCalled();
                    /*0x317e6d8*/ void set_EndInvokeCalled(bool value);
                    /*0x317e6e0*/ object get_AsyncDelegate();
                    /*0x317e6e8*/ System.Runtime.Remoting.Messaging.IMessageSink get_NextSink();
                    /*0x317e6f0*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                    /*0x317e728*/ System.Runtime.Remoting.Messaging.IMessage GetReplyMessage();
                    /*0x317e730*/ void SetMessageCtrl(System.Runtime.Remoting.Messaging.IMessageCtrl mc);
                    /*0x317e738*/ void SetCompletedSynchronously(bool completed);
                    /*0x317e740*/ System.Runtime.Remoting.Messaging.IMessage EndInvoke();
                    /*0x317e85c*/ System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                    /*0x317ea04*/ System.Runtime.Remoting.Messaging.MonoMethodMessage get_CallMessage();
                    /*0x317ea0c*/ void set_CallMessage(System.Runtime.Remoting.Messaging.MonoMethodMessage value);
                    /*0x317ea14*/ void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
                    /*0x317ea1c*/ void System.Threading.IThreadPoolWorkItem.MarkAborted(System.Threading.ThreadAbortException tae);
                    /*0x317ea18*/ object Invoke();
                }

                class CADArgHolder
                {
                    /*0x10*/ int index;

                    /*0x317ea20*/ CADArgHolder(int i);
                }

                class CADObjRef
                {
                    /*0x10*/ System.Runtime.Remoting.ObjRef objref;
                    /*0x18*/ int SourceDomain;
                    /*0x20*/ byte[] TypeInfo;

                    /*0x317ea48*/ CADObjRef(System.Runtime.Remoting.ObjRef o, int sourceDomain);
                }

                class CADMethodRef
                {
                    /*0x10*/ bool ctor;
                    /*0x18*/ string typeName;
                    /*0x20*/ string methodName;
                    /*0x28*/ string[] param_names;
                    /*0x30*/ string[] generic_arg_names;

                    /*0x317f054*/ CADMethodRef(System.Runtime.Remoting.Messaging.IMethodMessage msg);
                    /*0x317eaa8*/ System.Type[] GetTypes(string[] typeArray);
                    /*0x317ebf4*/ System.Reflection.MethodBase Resolve();
                }

                class CADMessageBase
                {
                    /*0x10*/ object[] _args;
                    /*0x18*/ byte[] _serializedArgs;
                    /*0x20*/ int _propertyCount;
                    /*0x28*/ System.Runtime.Remoting.Messaging.CADArgHolder _callContext;
                    /*0x30*/ byte[] serializedMethod;

                    static /*0x317f440*/ System.Type[] GetSignature(System.Reflection.MethodBase methodBase, bool load);
                    static /*0x317f610*/ int MarshalProperties(System.Collections.IDictionary dict, ref System.Collections.ArrayList args);
                    static /*0x317fe6c*/ void UnmarshalProperties(System.Collections.IDictionary dict, int count, System.Collections.ArrayList args);
                    static /*0x317ffa8*/ bool IsPossibleToIgnoreMarshal(object obj);
                    /*0x317f320*/ CADMessageBase(System.Runtime.Remoting.Messaging.IMethodMessage msg);
                    /*0x317f3bc*/ System.Reflection.MethodBase GetMethod();
                    /*0x3180118*/ object MarshalArgument(object arg, ref System.Collections.ArrayList args);
                    /*0x31802e0*/ object UnmarshalArgument(object arg, System.Collections.ArrayList args);
                    /*0x31809b4*/ object[] MarshalArguments(object[] arguments, ref System.Collections.ArrayList args);
                    /*0x3180ab0*/ object[] UnmarshalArguments(object[] arguments, System.Collections.ArrayList args);
                    /*0x3180bac*/ void SaveLogicalCallContext(System.Runtime.Remoting.Messaging.IMethodMessage msg, ref System.Collections.ArrayList serializeList);
                    /*0x3180dfc*/ System.Runtime.Remoting.Messaging.LogicalCallContext GetLogicalCallContext(System.Collections.ArrayList args);
                }

                class CADMethodCallMessage : System.Runtime.Remoting.Messaging.CADMessageBase
                {
                    /*0x38*/ string _uri;

                    static /*0x3180e8c*/ System.Runtime.Remoting.Messaging.CADMethodCallMessage Create(System.Runtime.Remoting.Messaging.IMessage callMsg);
                    /*0x3180f14*/ CADMethodCallMessage(System.Runtime.Remoting.Messaging.IMethodCallMessage callMsg);
                    /*0x3180e84*/ string get_Uri();
                    /*0x318112c*/ System.Collections.ArrayList GetArguments();
                    /*0x3181274*/ object[] GetArgs(System.Collections.ArrayList args);
                    /*0x3181284*/ int get_PropertiesCount();
                }

                class CADMethodReturnMessage : System.Runtime.Remoting.Messaging.CADMessageBase
                {
                    /*0x38*/ object _returnValue;
                    /*0x40*/ System.Runtime.Remoting.Messaging.CADArgHolder _exception;
                    /*0x48*/ System.Type[] _sig;

                    static /*0x318128c*/ System.Runtime.Remoting.Messaging.CADMethodReturnMessage Create(System.Runtime.Remoting.Messaging.IMessage callMsg);
                    /*0x3181314*/ CADMethodReturnMessage(System.Runtime.Remoting.Messaging.IMethodReturnMessage retMsg);
                    /*0x31816d8*/ System.Collections.ArrayList GetArguments();
                    /*0x3181820*/ object[] GetArgs(System.Collections.ArrayList args);
                    /*0x3181830*/ object GetReturnValue(System.Collections.ArrayList args);
                    /*0x3181840*/ System.Exception GetException(System.Collections.ArrayList args);
                    /*0x31818e4*/ int get_PropertiesCount();
                }

                class ClientContextTerminatorSink : System.Runtime.Remoting.Messaging.IMessageSink
                {
                    /*0x10*/ System.Runtime.Remoting.Contexts.Context _context;

                    /*0x31818ec*/ ClientContextTerminatorSink(System.Runtime.Remoting.Contexts.Context ctx);
                    /*0x318191c*/ System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                    /*0x3181b08*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                }

                class ClientContextReplySink : System.Runtime.Remoting.Messaging.IMessageSink
                {
                    /*0x10*/ System.Runtime.Remoting.Messaging.IMessageSink _replySink;
                    /*0x18*/ System.Runtime.Remoting.Contexts.Context _context;

                    /*0x3181d4c*/ ClientContextReplySink(System.Runtime.Remoting.Contexts.Context ctx, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                    /*0x3181d90*/ System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                    /*0x3181e9c*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                }

                class ConstructionCall : System.Runtime.Remoting.Messaging.MethodCall, System.Runtime.Remoting.Activation.IConstructionCallMessage, System.Runtime.Remoting.Messaging.IMessage, System.Runtime.Remoting.Messaging.IMethodCallMessage, System.Runtime.Remoting.Messaging.IMethodMessage
                {
                    /*0x68*/ System.Runtime.Remoting.Activation.IActivator _activator;
                    /*0x70*/ object[] _activationAttributes;
                    /*0x78*/ System.Collections.IList _contextProperties;
                    /*0x80*/ System.Type _activationType;
                    /*0x88*/ string _activationTypeName;
                    /*0x90*/ bool _isContextOk;
                    /*0x98*/ System.Runtime.Remoting.Proxies.RemotingProxy _sourceProxy;

                    /*0x3181ed4*/ ConstructionCall(System.Type type);
                    /*0x3181f44*/ ConstructionCall(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                    /*0x3181ff0*/ void InitDictionary();
                    /*0x3182148*/ bool get_IsContextOk();
                    /*0x3182150*/ void set_IsContextOk(bool value);
                    /*0x3182158*/ System.Type get_ActivationType();
                    /*0x3182220*/ string get_ActivationTypeName();
                    /*0x3182228*/ System.Runtime.Remoting.Activation.IActivator get_Activator();
                    /*0x3182230*/ void set_Activator(System.Runtime.Remoting.Activation.IActivator value);
                    /*0x3182238*/ object[] get_CallSiteActivationAttributes();
                    /*0x3182240*/ void SetActivationAttributes(object[] attributes);
                    /*0x3182248*/ System.Collections.IList get_ContextProperties();
                    /*0x31822b8*/ void InitMethodProperty(string key, object value);
                    /*0x31829ac*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                    /*0x3182f64*/ System.Collections.IDictionary get_Properties();
                    /*0x3182fc4*/ System.Runtime.Remoting.Proxies.RemotingProxy get_SourceProxy();
                    /*0x3182fcc*/ void set_SourceProxy(System.Runtime.Remoting.Proxies.RemotingProxy value);
                }

                class ConstructionCallDictionary : System.Runtime.Remoting.Messaging.MessageDictionary
                {
                    static /*0x0*/ string[] InternalKeys;

                    static /*0x3183e7c*/ ConstructionCallDictionary();
                    /*0x3182070*/ ConstructionCallDictionary(System.Runtime.Remoting.Activation.IConstructionCallMessage message);
                    /*0x3183004*/ object GetMethodProperty(string key);
                    /*0x3183940*/ void SetMethodProperty(string key, object value);
                }

                class ConstructionResponse : System.Runtime.Remoting.Messaging.MethodResponse, System.Runtime.Remoting.Activation.IConstructionReturnMessage, System.Runtime.Remoting.Messaging.IMethodReturnMessage, System.Runtime.Remoting.Messaging.IMethodMessage, System.Runtime.Remoting.Messaging.IMessage
                {
                    /*0x317c31c*/ ConstructionResponse(object resultObject, System.Runtime.Remoting.Messaging.LogicalCallContext callCtx, System.Runtime.Remoting.Messaging.IMethodCallMessage msg);
                    /*0x3184244*/ ConstructionResponse(System.Exception e, System.Runtime.Remoting.Messaging.IMethodCallMessage msg);
                    /*0x3184388*/ ConstructionResponse(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                    /*0x3184414*/ System.Collections.IDictionary get_Properties();
                }

                class EnvoyTerminatorSink : System.Runtime.Remoting.Messaging.IMessageSink
                {
                    static /*0x0*/ System.Runtime.Remoting.Messaging.EnvoyTerminatorSink Instance;

                    static /*0x3184630*/ EnvoyTerminatorSink();
                    /*0x3184628*/ EnvoyTerminatorSink();
                    /*0x31844ac*/ System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                    /*0x3184564*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                }

                class ErrorMessage : System.Runtime.Remoting.Messaging.IMethodCallMessage, System.Runtime.Remoting.Messaging.IMethodMessage, System.Runtime.Remoting.Messaging.IMessage
                {
                    /*0x10*/ string _uri;

                    /*0x3184698*/ ErrorMessage();
                    /*0x31846f0*/ int get_ArgCount();
                    /*0x31846f8*/ object[] get_Args();
                    /*0x3184700*/ System.Reflection.MethodBase get_MethodBase();
                    /*0x3184708*/ string get_MethodName();
                    /*0x3184748*/ object get_MethodSignature();
                    /*0x3184750*/ System.Collections.IDictionary get_Properties();
                    /*0x3184758*/ string get_TypeName();
                    /*0x3184798*/ string get_Uri();
                    /*0x31847a0*/ object GetArg(int arg_num);
                    /*0x31847a8*/ System.Runtime.Remoting.Messaging.LogicalCallContext get_LogicalCallContext();
                }

                class Header
                {
                }

                class HeaderHandler : System.MulticastDelegate
                {
                    /*0x31847b0*/ HeaderHandler(object object, nint method);
                    /*0x31848b8*/ object Invoke(System.Runtime.Remoting.Messaging.Header[] headers);
                }

                interface IInternalMessage
                {
                    /*0x1f30214*/ System.Runtime.Remoting.Identity get_TargetIdentity();
                    /*0x1f30ebc*/ void set_TargetIdentity(System.Runtime.Remoting.Identity value);
                    /*0x1f30214*/ string get_Uri();
                    /*0x1f30ebc*/ void set_Uri(string value);
                }

                interface IMessage
                {
                    /*0x1f30214*/ System.Collections.IDictionary get_Properties();
                }

                interface IMessageCtrl
                {
                }

                interface IMessageSink
                {
                    /*0x1f302cc*/ System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                    /*0x1f30394*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                }

                interface IMethodCallMessage : System.Runtime.Remoting.Messaging.IMethodMessage, System.Runtime.Remoting.Messaging.IMessage
                {
                }

                interface IMethodMessage : System.Runtime.Remoting.Messaging.IMessage
                {
                    /*0x1f2ffc8*/ int get_ArgCount();
                    /*0x1f30214*/ object[] get_Args();
                    /*0x1f30214*/ System.Runtime.Remoting.Messaging.LogicalCallContext get_LogicalCallContext();
                    /*0x1f30214*/ System.Reflection.MethodBase get_MethodBase();
                    /*0x1f30214*/ string get_MethodName();
                    /*0x1f30214*/ object get_MethodSignature();
                    /*0x1f30214*/ string get_TypeName();
                    /*0x1f30214*/ string get_Uri();
                    /*0x1f30240*/ object GetArg(int argNum);
                }

                interface IMethodReturnMessage : System.Runtime.Remoting.Messaging.IMethodMessage, System.Runtime.Remoting.Messaging.IMessage
                {
                    /*0x1f30214*/ System.Exception get_Exception();
                    /*0x1f30214*/ object[] get_OutArgs();
                    /*0x1f30214*/ object get_ReturnValue();
                }

                class MethodCall : System.Runtime.Remoting.Messaging.IMethodCallMessage, System.Runtime.Remoting.Messaging.IMethodMessage, System.Runtime.Remoting.Messaging.IMessage, System.Runtime.Serialization.ISerializable, System.Runtime.Remoting.Messaging.IInternalMessage
                {
                    /*0x10*/ string _uri;
                    /*0x18*/ string _typeName;
                    /*0x20*/ string _methodName;
                    /*0x28*/ object[] _args;
                    /*0x30*/ System.Type[] _methodSignature;
                    /*0x38*/ System.Reflection.MethodBase _methodBase;
                    /*0x40*/ System.Runtime.Remoting.Messaging.LogicalCallContext _callContext;
                    /*0x48*/ System.Runtime.Remoting.Identity _targetIdentity;
                    /*0x50*/ System.Type[] _genericArguments;
                    /*0x58*/ System.Collections.IDictionary ExternalProperties;
                    /*0x60*/ System.Collections.IDictionary InternalProperties;

                    static /*0x31859e4*/ string GetTypeNameFromAssemblyQualifiedName(string aqname);
                    /*0x3181f48*/ MethodCall(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                    /*0x3184994*/ MethodCall(System.Runtime.Remoting.Messaging.CADMethodCallMessage msg);
                    /*0x3181f3c*/ MethodCall();
                    /*0x3184ae8*/ void CopyFrom(System.Runtime.Remoting.Messaging.IMethodMessage call);
                    /*0x318256c*/ void InitMethodProperty(string key, object value);
                    /*0x3182b30*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                    /*0x3184eb4*/ int get_ArgCount();
                    /*0x3184ecc*/ object[] get_Args();
                    /*0x3184ed4*/ System.Runtime.Remoting.Messaging.LogicalCallContext get_LogicalCallContext();
                    /*0x3184f44*/ System.Reflection.MethodBase get_MethodBase();
                    /*0x31854e0*/ string get_MethodName();
                    /*0x3185528*/ object get_MethodSignature();
                    /*0x3182f94*/ System.Collections.IDictionary get_Properties();
                    /*0x3185670*/ void InitDictionary();
                    /*0x318577c*/ string get_TypeName();
                    /*0x31857d8*/ string get_Uri();
                    /*0x31857e0*/ void set_Uri(string value);
                    /*0x31857e8*/ string System.Runtime.Remoting.Messaging.IInternalMessage.get_Uri();
                    /*0x31857f0*/ void System.Runtime.Remoting.Messaging.IInternalMessage.set_Uri(string value);
                    /*0x31857f8*/ object GetArg(int argNum);
                    /*0x3185828*/ void Init();
                    /*0x3184f74*/ void ResolveMethod();
                    /*0x318582c*/ System.Type CastTo(string clientType, System.Type serverType);
                    /*0x3185a8c*/ System.Runtime.Remoting.Identity System.Runtime.Remoting.Messaging.IInternalMessage.get_TargetIdentity();
                    /*0x3185a94*/ void System.Runtime.Remoting.Messaging.IInternalMessage.set_TargetIdentity(System.Runtime.Remoting.Identity value);
                    /*0x3185990*/ System.Type[] get_GenericArguments();
                }

                class MCMDictionary : System.Runtime.Remoting.Messaging.MessageDictionary
                {
                    static /*0x0*/ string[] InternalKeys;

                    static /*0x3185a9c*/ MCMDictionary();
                    /*0x31856f0*/ MCMDictionary(System.Runtime.Remoting.Messaging.IMethodMessage message);
                }

                class MessageDictionary : System.Collections.IDictionary, System.Collections.ICollection, System.Collections.IEnumerable
                {
                    /*0x10*/ System.Collections.IDictionary _internalProperties;
                    /*0x18*/ System.Runtime.Remoting.Messaging.IMethodMessage _message;
                    /*0x20*/ string[] _methodKeys;
                    /*0x28*/ bool _ownProperties;

                    /*0x3182fd4*/ MessageDictionary(System.Runtime.Remoting.Messaging.IMethodMessage message);
                    /*0x317fcf8*/ bool HasUserData();
                    /*0x317fdec*/ System.Collections.IDictionary get_InternalDictionary();
                    /*0x3185c50*/ void set_MethodKeys(string[] value);
                    /*0x3185c58*/ System.Collections.IDictionary AllocInternalProperties();
                    /*0x31820fc*/ System.Collections.IDictionary GetInternalProperties();
                    /*0x3185cb8*/ bool IsOverridenKey(string key);
                    /*0x3185d40*/ bool get_IsFixedSize();
                    /*0x3185d48*/ bool get_IsReadOnly();
                    /*0x3185d50*/ object get_Item(object key);
                    /*0x3185e84*/ void set_Item(object key, object value);
                    /*0x31833c8*/ object GetMethodProperty(string key);
                    /*0x3183ba8*/ void SetMethodProperty(string key, object value);
                    /*0x3185ffc*/ System.Collections.ICollection get_Keys();
                    /*0x3186404*/ System.Collections.ICollection get_Values();
                    /*0x3185e88*/ void Add(object key, object value);
                    /*0x31867ec*/ void Clear();
                    /*0x3186898*/ bool Contains(object key);
                    /*0x31869c8*/ void Remove(object key);
                    /*0x3186b40*/ int get_Count();
                    /*0x3186c08*/ bool get_IsSynchronized();
                    /*0x3186c10*/ object get_SyncRoot();
                    /*0x3186c14*/ void CopyTo(System.Array array, int index);
                    /*0x3186cd4*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                    /*0x3186e28*/ System.Collections.IDictionaryEnumerator GetEnumerator();

                    class DictionaryEnumerator : System.Collections.IDictionaryEnumerator, System.Collections.IEnumerator
                    {
                        /*0x10*/ System.Runtime.Remoting.Messaging.MessageDictionary _methodDictionary;
                        /*0x18*/ System.Collections.IDictionaryEnumerator _hashtableEnum;
                        /*0x20*/ int _posMethod;

                        /*0x3186d2c*/ DictionaryEnumerator(System.Runtime.Remoting.Messaging.MessageDictionary methodDictionary);
                        /*0x3186e80*/ object get_Current();
                        /*0x318704c*/ bool MoveNext();
                        /*0x318720c*/ void Reset();
                        /*0x3186ee4*/ System.Collections.DictionaryEntry get_Entry();
                        /*0x31872b8*/ object get_Key();
                        /*0x31872bc*/ object get_Value();
                    }
                }

                class MethodResponse : System.Runtime.Remoting.Messaging.IMethodReturnMessage, System.Runtime.Remoting.Messaging.IMethodMessage, System.Runtime.Remoting.Messaging.IMessage, System.Runtime.Serialization.ISerializable, System.Runtime.Remoting.Messaging.IInternalMessage
                {
                    /*0x10*/ string _methodName;
                    /*0x18*/ string _uri;
                    /*0x20*/ string _typeName;
                    /*0x28*/ System.Reflection.MethodBase _methodBase;
                    /*0x30*/ object _returnValue;
                    /*0x38*/ System.Exception _exception;
                    /*0x40*/ System.Type[] _methodSignature;
                    /*0x48*/ System.Runtime.Remoting.Messaging.ArgInfo _inArgInfo;
                    /*0x50*/ object[] _args;
                    /*0x58*/ object[] _outArgs;
                    /*0x60*/ System.Runtime.Remoting.Messaging.IMethodCallMessage _callMsg;
                    /*0x68*/ System.Runtime.Remoting.Messaging.LogicalCallContext _callContext;
                    /*0x70*/ System.Runtime.Remoting.Identity _targetIdentity;
                    /*0x78*/ System.Collections.IDictionary ExternalProperties;
                    /*0x80*/ System.Collections.IDictionary InternalProperties;

                    /*0x3184248*/ MethodResponse(System.Exception e, System.Runtime.Remoting.Messaging.IMethodCallMessage msg);
                    /*0x3184134*/ MethodResponse(object returnValue, object[] outArgs, System.Runtime.Remoting.Messaging.LogicalCallContext callCtx, System.Runtime.Remoting.Messaging.IMethodCallMessage msg);
                    /*0x31872d0*/ MethodResponse(System.Runtime.Remoting.Messaging.IMethodCallMessage msg, System.Runtime.Remoting.Messaging.CADMethodReturnMessage retmsg);
                    /*0x318438c*/ MethodResponse(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                    /*0x3187584*/ void InitMethodProperty(string key, object value);
                    /*0x3187a48*/ int get_ArgCount();
                    /*0x3187a60*/ object[] get_Args();
                    /*0x3187a68*/ System.Exception get_Exception();
                    /*0x3187a70*/ System.Runtime.Remoting.Messaging.LogicalCallContext get_LogicalCallContext();
                    /*0x3187ae0*/ System.Reflection.MethodBase get_MethodBase();
                    /*0x3187bfc*/ string get_MethodName();
                    /*0x3187d94*/ object get_MethodSignature();
                    /*0x3187ebc*/ object[] get_OutArgs();
                    /*0x3184418*/ System.Collections.IDictionary get_Properties();
                    /*0x31880a4*/ object get_ReturnValue();
                    /*0x3187cc8*/ string get_TypeName();
                    /*0x31880ac*/ string get_Uri();
                    /*0x3188178*/ void set_Uri(string value);
                    /*0x3188180*/ string System.Runtime.Remoting.Messaging.IInternalMessage.get_Uri();
                    /*0x3188184*/ void System.Runtime.Remoting.Messaging.IInternalMessage.set_Uri(string value);
                    /*0x318818c*/ object GetArg(int argNum);
                    /*0x31881bc*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                    /*0x318860c*/ System.Runtime.Remoting.Identity System.Runtime.Remoting.Messaging.IInternalMessage.get_TargetIdentity();
                    /*0x3188614*/ void System.Runtime.Remoting.Messaging.IInternalMessage.set_TargetIdentity(System.Runtime.Remoting.Identity value);
                }

                class MethodReturnDictionary : System.Runtime.Remoting.Messaging.MessageDictionary
                {
                    static /*0x0*/ string[] InternalReturnKeys;
                    static /*0x8*/ string[] InternalExceptionKeys;

                    static /*0x318861c*/ MethodReturnDictionary();
                    /*0x3187f8c*/ MethodReturnDictionary(System.Runtime.Remoting.Messaging.IMethodReturnMessage message);
                }

                class MonoMethodMessage : System.Runtime.Remoting.Messaging.IMethodCallMessage, System.Runtime.Remoting.Messaging.IMethodMessage, System.Runtime.Remoting.Messaging.IMessage, System.Runtime.Remoting.Messaging.IMethodReturnMessage, System.Runtime.Remoting.Messaging.IInternalMessage
                {
                    /*0x10*/ System.Reflection.RuntimeMethodInfo method;
                    /*0x18*/ object[] args;
                    /*0x20*/ string[] names;
                    /*0x28*/ byte[] arg_types;
                    /*0x30*/ System.Runtime.Remoting.Messaging.LogicalCallContext ctx;
                    /*0x38*/ object rval;
                    /*0x40*/ System.Exception exc;
                    /*0x48*/ System.Runtime.Remoting.Messaging.AsyncResult asyncResult;
                    /*0x50*/ System.Runtime.Remoting.Messaging.CallType call_type;
                    /*0x58*/ string uri;
                    /*0x60*/ System.Runtime.Remoting.Messaging.MCMDictionary properties;
                    /*0x68*/ System.Runtime.Remoting.Identity identity;
                    /*0x70*/ System.Type[] methodSignature;

                    static /*0x3188d08*/ System.Reflection.MethodInfo GetMethodInfo(System.Type type, string methodName);
                    /*0x3188afc*/ MonoMethodMessage(System.Reflection.MethodBase method, object[] out_args);
                    /*0x3188bcc*/ MonoMethodMessage(System.Reflection.MethodInfo minfo, object[] in_args, object[] out_args);
                    /*0x3188db8*/ MonoMethodMessage(System.Type type, string methodName, object[] in_args);
                    /*0x318884c*/ void InitMessage(System.Reflection.RuntimeMethodInfo method, object[] out_args);
                    /*0x3188df0*/ System.Collections.IDictionary get_Properties();
                    /*0x3188e64*/ int get_ArgCount();
                    /*0x3188f18*/ object[] get_Args();
                    /*0x3188f20*/ System.Runtime.Remoting.Messaging.LogicalCallContext get_LogicalCallContext();
                    /*0x3188f28*/ void set_LogicalCallContext(System.Runtime.Remoting.Messaging.LogicalCallContext value);
                    /*0x3188f30*/ System.Reflection.MethodBase get_MethodBase();
                    /*0x3188f38*/ string get_MethodName();
                    /*0x3188f8c*/ object get_MethodSignature();
                    /*0x31890c0*/ string get_TypeName();
                    /*0x3189128*/ string get_Uri();
                    /*0x3189130*/ void set_Uri(string value);
                    /*0x3189138*/ object GetArg(int arg_num);
                    /*0x3189168*/ System.Exception get_Exception();
                    /*0x3189170*/ int get_OutArgCount();
                    /*0x31891d4*/ object[] get_OutArgs();
                    /*0x3189314*/ object get_ReturnValue();
                    /*0x318931c*/ System.Runtime.Remoting.Identity System.Runtime.Remoting.Messaging.IInternalMessage.get_TargetIdentity();
                    /*0x3189324*/ void System.Runtime.Remoting.Messaging.IInternalMessage.set_TargetIdentity(System.Runtime.Remoting.Identity value);
                    /*0x318932c*/ System.Runtime.Remoting.Messaging.AsyncResult get_AsyncResult();
                    /*0x3188e9c*/ System.Runtime.Remoting.Messaging.CallType get_CallType();
                    /*0x3189334*/ bool NeedsOutProcessing(ref int outCount);
                }

                enum CallType
                {
                    Sync = 0,
                    BeginInvoke = 1,
                    EndInvoke = 2,
                    OneWay = 3,
                }

                class OneWayAttribute : System.Attribute
                {
                }

                class RemotingSurrogate : System.Runtime.Serialization.ISerializationSurrogate
                {
                    /*0x318950c*/ RemotingSurrogate();
                    /*0x31893bc*/ void GetObjectData(object obj, System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext sc);
                    /*0x31894d4*/ object SetObjectData(object obj, System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext sc, System.Runtime.Serialization.ISurrogateSelector selector);
                }

                class ObjRefSurrogate : System.Runtime.Serialization.ISerializationSurrogate
                {
                    /*0x31896d8*/ ObjRefSurrogate();
                    /*0x3189514*/ void GetObjectData(object obj, System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext sc);
                    /*0x318968c*/ object SetObjectData(object obj, System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext sc, System.Runtime.Serialization.ISurrogateSelector selector);
                }

                class RemotingSurrogateSelector : System.Runtime.Serialization.ISurrogateSelector
                {
                    static /*0x0*/ System.Type s_cachedTypeObjRef;
                    static /*0x8*/ System.Runtime.Remoting.Messaging.ObjRefSurrogate _objRefSurrogate;
                    static /*0x10*/ System.Runtime.Remoting.Messaging.RemotingSurrogate _objRemotingSurrogate;
                    /*0x10*/ System.Runtime.Serialization.ISurrogateSelector _next;

                    static /*0x31898a8*/ RemotingSurrogateSelector();
                    /*0x31896e0*/ RemotingSurrogateSelector();
                    /*0x31896e8*/ System.Runtime.Serialization.ISerializationSurrogate GetSurrogate(System.Type type, System.Runtime.Serialization.StreamingContext context, ref System.Runtime.Serialization.ISurrogateSelector ssout);
                }

                class ReturnMessage : System.Runtime.Remoting.Messaging.IMethodReturnMessage, System.Runtime.Remoting.Messaging.IMethodMessage, System.Runtime.Remoting.Messaging.IMessage, System.Runtime.Remoting.Messaging.IInternalMessage
                {
                    /*0x10*/ object[] _outArgs;
                    /*0x18*/ object[] _args;
                    /*0x20*/ System.Runtime.Remoting.Messaging.LogicalCallContext _callCtx;
                    /*0x28*/ object _returnValue;
                    /*0x30*/ string _uri;
                    /*0x38*/ System.Exception _exception;
                    /*0x40*/ System.Reflection.MethodBase _methodBase;
                    /*0x48*/ string _methodName;
                    /*0x50*/ System.Type[] _methodSignature;
                    /*0x58*/ string _typeName;
                    /*0x60*/ System.Runtime.Remoting.Messaging.MethodReturnDictionary _properties;
                    /*0x68*/ System.Runtime.Remoting.Identity _targetIdentity;
                    /*0x70*/ System.Runtime.Remoting.Messaging.ArgInfo _inArgInfo;

                    /*0x31899b8*/ ReturnMessage(object ret, object[] outArgs, int outArgsCount, System.Runtime.Remoting.Messaging.LogicalCallContext callCtx, System.Runtime.Remoting.Messaging.IMethodCallMessage mcm);
                    /*0x3189b80*/ ReturnMessage(System.Exception e, System.Runtime.Remoting.Messaging.IMethodCallMessage mcm);
                    /*0x3189cf4*/ int get_ArgCount();
                    /*0x3189d0c*/ object[] get_Args();
                    /*0x3189d14*/ System.Runtime.Remoting.Messaging.LogicalCallContext get_LogicalCallContext();
                    /*0x3189d84*/ System.Reflection.MethodBase get_MethodBase();
                    /*0x3189d8c*/ string get_MethodName();
                    /*0x3189df0*/ object get_MethodSignature();
                    /*0x3189f38*/ System.Collections.IDictionary get_Properties();
                    /*0x3189fac*/ string get_TypeName();
                    /*0x318a024*/ string get_Uri();
                    /*0x318a02c*/ void set_Uri(string value);
                    /*0x318a034*/ string System.Runtime.Remoting.Messaging.IInternalMessage.get_Uri();
                    /*0x318a03c*/ void System.Runtime.Remoting.Messaging.IInternalMessage.set_Uri(string value);
                    /*0x318a044*/ object GetArg(int argNum);
                    /*0x318a074*/ System.Exception get_Exception();
                    /*0x318a07c*/ object[] get_OutArgs();
                    /*0x318a140*/ object get_ReturnValue();
                    /*0x318a148*/ System.Runtime.Remoting.Identity System.Runtime.Remoting.Messaging.IInternalMessage.get_TargetIdentity();
                    /*0x318a150*/ void System.Runtime.Remoting.Messaging.IInternalMessage.set_TargetIdentity(System.Runtime.Remoting.Identity value);
                }

                class ServerContextTerminatorSink : System.Runtime.Remoting.Messaging.IMessageSink
                {
                    /*0x318a324*/ ServerContextTerminatorSink();
                    /*0x318a158*/ System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                    /*0x318a264*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                }

                class ServerObjectTerminatorSink : System.Runtime.Remoting.Messaging.IMessageSink
                {
                    /*0x10*/ System.Runtime.Remoting.Messaging.IMessageSink _nextSink;

                    /*0x318a32c*/ ServerObjectTerminatorSink(System.Runtime.Remoting.Messaging.IMessageSink nextSink);
                    /*0x318a35c*/ System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                    /*0x318a4d0*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                }

                class ServerObjectReplySink : System.Runtime.Remoting.Messaging.IMessageSink
                {
                    /*0x10*/ System.Runtime.Remoting.Messaging.IMessageSink _replySink;
                    /*0x18*/ System.Runtime.Remoting.ServerIdentity _identity;

                    /*0x318a698*/ ServerObjectReplySink(System.Runtime.Remoting.ServerIdentity identity, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                    /*0x318a6dc*/ System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                    /*0x318a7a4*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                }

                class StackBuilderSink : System.Runtime.Remoting.Messaging.IMessageSink
                {
                    /*0x10*/ System.MarshalByRefObject _target;
                    /*0x18*/ System.Runtime.Remoting.Proxies.RealProxy _rp;

                    /*0x318a7dc*/ StackBuilderSink(System.MarshalByRefObject obj, bool forceInternalExecute);
                    /*0x318a8a4*/ System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                    /*0x318acf8*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                    /*0x318ae2c*/ void ExecuteAsyncMessage(object ob);
                    /*0x318a970*/ void CheckParameters(System.Runtime.Remoting.Messaging.IMessage msg);
                    /*0x318b030*/ void <AsyncProcessMessage>b__4_0(object data);
                }
            }
        }

        namespace Versioning
        {
            class NonVersionableAttribute : System.Attribute
            {
                /*0x318b0b0*/ NonVersionableAttribute();
            }

            class TargetFrameworkAttribute : System.Attribute
            {
                /*0x10*/ string _frameworkName;
                /*0x18*/ string _frameworkDisplayName;

                /*0x318b0b8*/ TargetFrameworkAttribute(string frameworkName);
                /*0x318b134*/ void set_FrameworkDisplayName(string value);
            }

            class BinaryCompatibility
            {
                static /*0x0*/ bool TargetsAtLeast_Desktop_V4_5;
                static /*0x1*/ bool TargetsAtLeast_Desktop_V4_5_1;

                static /*0x318b13c*/ BinaryCompatibility();
            }
        }

        namespace Serialization
        {
            interface IDeserializationCallback
            {
                /*0x1f30ebc*/ void OnDeserialization(object sender);
            }

            interface IFormatterConverter
            {
                /*0x1f30394*/ object Convert(object value, System.Type type);
                /*0x1f2fec8*/ bool ToBoolean(object value);
                /*0x1f2fec8*/ byte ToByte(object value);
                /*0x1f3008c*/ int ToInt32(object value);
                long ToInt64(object value);
                float ToSingle(object value);
                /*0x1f302cc*/ string ToString(object value);
            }

            interface IObjectReference
            {
                object GetRealObject(System.Runtime.Serialization.StreamingContext context);
            }

            interface ISerializable
            {
                void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            }

            class SerializationException : System.SystemException
            {
                static /*0x0*/ string s_nullMessage;

                static /*0x318b24c*/ SerializationException();
                /*0x318b188*/ SerializationException();
                /*0x318b1fc*/ SerializationException(string message);
                /*0x318b220*/ SerializationException(string message, System.Exception innerException);
                /*0x318b244*/ SerializationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            }

            struct SerializationEntry
            {
                /*0x10*/ string _name;
                /*0x18*/ object _value;
                /*0x20*/ System.Type _type;

                /*0x318b2b4*/ SerializationEntry(string entryName, object entryValue, System.Type entryType);
                /*0x318b2f8*/ object get_Value();
                /*0x318b300*/ string get_Name();
            }

            class SerializationInfoEnumerator : System.Collections.IEnumerator
            {
                /*0x10*/ string[] _members;
                /*0x18*/ object[] _data;
                /*0x20*/ System.Type[] _types;
                /*0x28*/ int _numItems;
                /*0x2c*/ int _currItem;
                /*0x30*/ bool _current;

                /*0x318b308*/ SerializationInfoEnumerator(string[] members, object[] info, System.Type[] types, int numItems);
                /*0x317d19c*/ bool MoveNext();
                /*0x318b380*/ object System.Collections.IEnumerator.get_Current();
                /*0x31848cc*/ System.Runtime.Serialization.SerializationEntry get_Current();
                /*0x318b3f0*/ void Reset();
                /*0x317d024*/ string get_Name();
                /*0x317d0a8*/ object get_Value();
                /*0x318b400*/ System.Type get_ObjectType();
            }

            class DeserializationEventHandler : System.MulticastDelegate
            {
                /*0x318b484*/ DeserializationEventHandler(object object, nint method);
                /*0x318b58c*/ void Invoke(object sender);
            }

            class SerializationEventHandler : System.MulticastDelegate
            {
                /*0x318b5a0*/ SerializationEventHandler(object object, nint method);
                /*0x318b640*/ void Invoke(System.Runtime.Serialization.StreamingContext context);
            }

            class FormatterConverter : System.Runtime.Serialization.IFormatterConverter
            {
                static /*0x318b6f4*/ void ThrowValueNullException();
                /*0x318bad0*/ FormatterConverter();
                /*0x318b654*/ object Convert(object value, System.Type type);
                /*0x318b740*/ bool ToBoolean(object value);
                /*0x318b7d8*/ byte ToByte(object value);
                /*0x318b870*/ int ToInt32(object value);
                /*0x318b908*/ long ToInt64(object value);
                /*0x318b9a0*/ float ToSingle(object value);
                /*0x318ba38*/ string ToString(object value);
            }

            interface ISerializationSurrogate
            {
                void GetObjectData(object obj, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                object SetObjectData(object obj, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context, System.Runtime.Serialization.ISurrogateSelector selector);
            }

            interface ISurrogateSelector
            {
                System.Runtime.Serialization.ISerializationSurrogate GetSurrogate(System.Type type, System.Runtime.Serialization.StreamingContext context, ref System.Runtime.Serialization.ISurrogateSelector selector);
            }

            class MemberHolder
            {
                /*0x10*/ System.Type _memberType;
                /*0x18*/ System.Runtime.Serialization.StreamingContext _context;

                /*0x318bad8*/ MemberHolder(System.Type type, System.Runtime.Serialization.StreamingContext ctx);
                /*0x318bb2c*/ int GetHashCode();
                /*0x318bb48*/ bool Equals(object obj);
            }

            class SerializationBinder
            {
                /*0x318bbf4*/ SerializationBinder();
                /*0x318bbc8*/ void BindToName(System.Type serializedType, ref string assemblyName, ref string typeName);
                /*0x1f30394*/ System.Type BindToType(string assemblyName, string typeName);
            }

            class SerializationEvents
            {
                /*0x10*/ System.Collections.Generic.List<System.Reflection.MethodInfo> _onSerializingMethods;
                /*0x18*/ System.Collections.Generic.List<System.Reflection.MethodInfo> _onSerializedMethods;
                /*0x20*/ System.Collections.Generic.List<System.Reflection.MethodInfo> _onDeserializingMethods;
                /*0x28*/ System.Collections.Generic.List<System.Reflection.MethodInfo> _onDeserializedMethods;

                static /*0x318bfa0*/ void InvokeOnDelegate(object obj, System.Runtime.Serialization.StreamingContext context, System.Collections.Generic.List<System.Reflection.MethodInfo> methods);
                static /*0x318c0ac*/ System.Runtime.Serialization.SerializationEventHandler AddOnDelegate(object obj, System.Runtime.Serialization.SerializationEventHandler handler, System.Collections.Generic.List<System.Reflection.MethodInfo> methods);
                /*0x318bbfc*/ SerializationEvents(System.Type t);
                /*0x318bd50*/ System.Collections.Generic.List<System.Reflection.MethodInfo> GetMethodsWithAttribute(System.Type attribute, System.Type t);
                /*0x318bf2c*/ bool get_HasOnSerializingEvents();
                /*0x318bf4c*/ void InvokeOnSerializing(object obj, System.Runtime.Serialization.StreamingContext context);
                /*0x318bff0*/ void InvokeOnDeserializing(object obj, System.Runtime.Serialization.StreamingContext context);
                /*0x318c044*/ void InvokeOnDeserialized(object obj, System.Runtime.Serialization.StreamingContext context);
                /*0x318c098*/ System.Runtime.Serialization.SerializationEventHandler AddOnSerialized(object obj, System.Runtime.Serialization.SerializationEventHandler handler);
                /*0x318c35c*/ System.Runtime.Serialization.SerializationEventHandler AddOnDeserialized(object obj, System.Runtime.Serialization.SerializationEventHandler handler);
            }

            class SerializationEventsCache
            {
                static /*0x0*/ System.Collections.Concurrent.ConcurrentDictionary<System.Type, System.Runtime.Serialization.SerializationEvents> s_cache;

                static /*0x318c4bc*/ SerializationEventsCache();
                static /*0x318c370*/ System.Runtime.Serialization.SerializationEvents GetSerializationEventsForType(System.Type t);

                class <>c
                {
                    static /*0x0*/ System.Runtime.Serialization.SerializationEventsCache.<> <>9;
                    static /*0x8*/ System.Func<System.Type, System.Runtime.Serialization.SerializationEvents> <>9__1_0;

                    static /*0x318c554*/ <>c();
                    /*0x318c5bc*/ <>c();
                    /*0x318c5c4*/ System.Runtime.Serialization.SerializationEvents <GetSerializationEventsForType>b__1_0(System.Type type);
                }
            }

            class SerializationObjectManager
            {
                /*0x10*/ System.Collections.Generic.Dictionary<object, object> _objectSeenTable;
                /*0x18*/ System.Runtime.Serialization.StreamingContext _context;
                /*0x28*/ System.Runtime.Serialization.SerializationEventHandler _onSerializedHandler;

                /*0x318c61c*/ SerializationObjectManager(System.Runtime.Serialization.StreamingContext context);
                /*0x318c6c8*/ void RegisterObject(object obj);
                /*0x318c864*/ void RaiseOnSerializedEvent();
                /*0x318c7cc*/ void AddOnSerialized(object obj);
            }

            class ValueTypeFixupInfo
            {
                /*0x10*/ long _containerID;
                /*0x18*/ System.Reflection.FieldInfo _parentField;
                /*0x20*/ int[] _parentIndex;

                /*0x318c888*/ ValueTypeFixupInfo(long containerID, System.Reflection.FieldInfo member, int[] parentIndex);
                /*0x318ca00*/ long get_ContainerID();
                /*0x318ca08*/ System.Reflection.FieldInfo get_ParentField();
                /*0x318ca10*/ int[] get_ParentIndex();
            }

            class FormatterServices
            {
                static /*0x0*/ System.Collections.Concurrent.ConcurrentDictionary<System.Runtime.Serialization.MemberHolder, System.Reflection.MemberInfo[]> m_MemberInfoTable;
                static /*0x8*/ bool unsafeTypeForwardersIsEnabled;
                static /*0x9*/ bool unsafeTypeForwardersIsEnabledInitialized;
                static /*0x10*/ System.Type[] advancedTypes;
                static /*0x18*/ System.Reflection.Binder s_binder;

                static /*0x318ca18*/ FormatterServices();
                static /*0x318cbb8*/ System.Reflection.MemberInfo[] GetSerializableMembers(System.RuntimeType type);
                static /*0x318cd5c*/ bool CheckSerializable(System.RuntimeType type);
                static /*0x318cd78*/ System.Reflection.MemberInfo[] InternalGetSerializableMembers(System.RuntimeType type);
                static /*0x318d3d0*/ bool GetParentTypes(System.RuntimeType parentType, ref System.RuntimeType[] parentTypes, ref int parentTypeCount);
                static /*0x318d86c*/ System.Reflection.MemberInfo[] GetSerializableMembers(System.Type type, System.Runtime.Serialization.StreamingContext context);
                static /*0x318db20*/ object GetUninitializedObject(System.Type type);
                static /*0x318dce0*/ object nativeGetUninitializedObject(System.RuntimeType type);
                static /*0x318dce8*/ bool GetEnableUnsafeTypeForwarders();
                static /*0x318dcf0*/ bool UnsafeTypeForwardersIsEnabled();
                static /*0x318dd98*/ void SerializationSetValue(System.Reflection.MemberInfo fi, object target, object value);
                static /*0x318e048*/ object PopulateObjectMembers(object obj, System.Reflection.MemberInfo[] members, object[] data);
                static /*0x318e33c*/ object[] GetObjectData(object obj, System.Reflection.MemberInfo[] members);
                static /*0x318e72c*/ System.Type GetTypeFromAssembly(System.Reflection.Assembly assem, string name);
                static /*0x318e7c4*/ System.Reflection.Assembly LoadAssemblyFromString(string assemblyName);
                static /*0x318e7cc*/ System.Reflection.Assembly LoadAssemblyFromStringNoThrow(string assemblyName);
                static /*0x318e8a0*/ string GetClrAssemblyName(System.Type type, ref bool hasTypeForwardedFrom);
                static /*0x318e9fc*/ string GetClrTypeFullName(System.Type type);
                static /*0x318ea84*/ string GetClrTypeFullNameForArray(System.Type type);
                static /*0x318ecac*/ string GetClrTypeFullNameForNonArrayTypes(System.Type type);

                class <>c__DisplayClass9_0
                {
                    /*0x10*/ System.Type type;

                    /*0x318db18*/ <>c__DisplayClass9_0();
                    /*0x318ef1c*/ System.Reflection.MemberInfo[] <GetSerializableMembers>b__0(System.Runtime.Serialization.MemberHolder _);
                }
            }

            class SurrogateForCyclicalReference : System.Runtime.Serialization.ISerializationSurrogate
            {
                /*0x10*/ System.Runtime.Serialization.ISerializationSurrogate innerSurrogate;

                /*0x318efc8*/ void GetObjectData(object obj, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x318f098*/ object SetObjectData(object obj, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context, System.Runtime.Serialization.ISurrogateSelector selector);
            }

            class ObjectIDGenerator
            {
                static /*0x0*/ int[] sizes;
                /*0x10*/ int m_currentCount;
                /*0x14*/ int m_currentSize;
                /*0x18*/ long[] m_ids;
                /*0x20*/ object[] m_objs;

                static /*0x318f868*/ ObjectIDGenerator();
                /*0x318f174*/ ObjectIDGenerator();
                /*0x318f260*/ int FindElement(object obj, ref bool found);
                /*0x318f32c*/ long GetId(object obj, ref bool firstTime);
                /*0x318f798*/ long HasId(object obj, ref bool firstTime);
                /*0x318f4ac*/ void Rehash();
            }

            class ObjectManager
            {
                /*0x10*/ System.Runtime.Serialization.DeserializationEventHandler m_onDeserializationHandler;
                /*0x18*/ System.Runtime.Serialization.SerializationEventHandler m_onDeserializedHandler;
                /*0x20*/ System.Runtime.Serialization.ObjectHolder[] m_objects;
                /*0x28*/ object m_topObject;
                /*0x30*/ System.Runtime.Serialization.ObjectHolderList m_specialFixupObjects;
                /*0x38*/ long m_fixupCount;
                /*0x40*/ System.Runtime.Serialization.ISurrogateSelector m_selector;
                /*0x48*/ System.Runtime.Serialization.StreamingContext m_context;

                static /*0x31924c4*/ System.Reflection.RuntimeConstructorInfo GetConstructor(System.RuntimeType t);
                /*0x318f908*/ ObjectManager(System.Runtime.Serialization.ISurrogateSelector selector, System.Runtime.Serialization.StreamingContext context, bool checkSecurity, bool isCrossAppDomain);
                /*0x318f9ac*/ bool CanCallGetType(object obj);
                /*0x318f9b4*/ void set_TopObject(object value);
                /*0x318f9bc*/ object get_TopObject();
                /*0x318f9c4*/ System.Runtime.Serialization.ObjectHolderList get_SpecialFixupObjects();
                /*0x318fa3c*/ System.Runtime.Serialization.ObjectHolder FindObjectHolder(long objectID);
                /*0x318fa9c*/ System.Runtime.Serialization.ObjectHolder FindOrCreateObjectHolder(long objectID);
                /*0x318fb6c*/ void AddObjectHolder(System.Runtime.Serialization.ObjectHolder holder);
                /*0x318fca0*/ bool GetCompletionInfo(System.Runtime.Serialization.FixupHolder fixup, ref System.Runtime.Serialization.ObjectHolder holder, ref object member, bool bThrowIfMissing);
                /*0x318ff7c*/ void FixupSpecialObject(System.Runtime.Serialization.ObjectHolder holder);
                /*0x3190d3c*/ bool ResolveObjectReference(System.Runtime.Serialization.ObjectHolder holder);
                /*0x3190728*/ bool DoValueTypeFixup(System.Reflection.FieldInfo memberToFix, System.Runtime.Serialization.ObjectHolder holder, object value);
                /*0x3190fc8*/ void CompleteObject(System.Runtime.Serialization.ObjectHolder holder, bool bObjectFullyComplete);
                /*0x3190c64*/ void DoNewlyRegisteredObjectFixups(System.Runtime.Serialization.ObjectHolder holder);
                /*0x319183c*/ object GetObject(long objectID);
                /*0x31918ec*/ void RegisterString(string obj, long objectID, System.Runtime.Serialization.SerializationInfo info, long idOfContainingObj, System.Reflection.MemberInfo member);
                /*0x3191b0c*/ void RegisterObject(object obj, long objectID, System.Runtime.Serialization.SerializationInfo info, long idOfContainingObj, System.Reflection.MemberInfo member, int[] arrayIndex);
                /*0x3190448*/ void CompleteISerializableObject(object obj, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x31925f4*/ void DoFixups();
                /*0x3192a48*/ void RegisterFixup(System.Runtime.Serialization.FixupHolder fixup, long objectToBeFixed, long objectRequired);
                /*0x3192c6c*/ void RecordFixup(long objectToBeFixed, System.Reflection.MemberInfo member, long objectRequired);
                /*0x3192f4c*/ void RecordDelayedFixup(long objectToBeFixed, string memberName, long objectRequired);
                /*0x31930b0*/ void RecordArrayElementFixup(long arrayToBeFixed, int[] indices, long objectRequired);
                /*0x3193214*/ void RaiseDeserializationEvent();
                /*0x3193260*/ void AddOnDeserialization(System.Runtime.Serialization.DeserializationEventHandler handler);
                /*0x31932f0*/ void AddOnDeserialized(object obj);
                /*0x3193388*/ void RaiseOnDeserializedEvent(object obj);
                /*0x319340c*/ void RaiseOnDeserializingEvent(object obj);
            }

            class ObjectHolder
            {
                /*0x10*/ object m_object;
                /*0x18*/ long m_id;
                /*0x20*/ int m_missingElementsRemaining;
                /*0x24*/ int m_missingDecendents;
                /*0x28*/ System.Runtime.Serialization.SerializationInfo m_serInfo;
                /*0x30*/ System.Runtime.Serialization.ISerializationSurrogate m_surrogate;
                /*0x38*/ System.Runtime.Serialization.FixupHolderList m_missingElements;
                /*0x40*/ System.Runtime.Serialization.LongList m_dependentObjects;
                /*0x48*/ System.Runtime.Serialization.ObjectHolder m_next;
                /*0x50*/ int m_flags;
                /*0x54*/ bool m_markForFixupWhenAvailable;
                /*0x58*/ System.Runtime.Serialization.ValueTypeFixupInfo m_valueFixup;
                /*0x60*/ System.Runtime.Serialization.TypeLoadExceptionHolder m_typeLoad;
                /*0x68*/ bool m_reachable;

                /*0x318fb38*/ ObjectHolder(long objID);
                /*0x31920c0*/ ObjectHolder(object obj, long objID, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.ISerializationSurrogate surrogate, long idOfContainingObj, System.Reflection.FieldInfo field, int[] arrayIndex);
                /*0x31919e4*/ ObjectHolder(string obj, long objID, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.ISerializationSurrogate surrogate, long idOfContainingObj, System.Reflection.FieldInfo field, int[] arrayIndex);
                /*0x3193490*/ void IncrementDescendentFixups(int amount);
                /*0x3191714*/ void DecrementFixupsRemaining(System.Runtime.Serialization.ObjectManager manager);
                /*0x3191738*/ void RemoveDependency(long id);
                /*0x3192b20*/ void AddFixup(System.Runtime.Serialization.FixupHolder fixup, System.Runtime.Serialization.ObjectManager manager);
                /*0x31934a0*/ void UpdateDescendentDependencyChain(int amount, System.Runtime.Serialization.ObjectManager manager);
                /*0x3192bec*/ void AddDependency(long dependentObject);
                /*0x319230c*/ void UpdateData(object obj, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.ISerializationSurrogate surrogate, long idOfContainer, System.Reflection.FieldInfo field, int[] arrayIndex, System.Runtime.Serialization.ObjectManager manager);
                /*0x31917b0*/ void MarkForCompletionWhenAvailable();
                /*0x3190390*/ void SetFlags();
                /*0x318ff70*/ bool get_IsIncompleteObjectReference();
                /*0x3190fb8*/ void set_IsIncompleteObjectReference(bool value);
                /*0x31922fc*/ bool get_RequiresDelayedFixup();
                /*0x31906e4*/ bool get_RequiresValueTypeFixup();
                /*0x31906f0*/ bool get_ValueTypeFixupPerformed();
                /*0x319175c*/ void set_ValueTypeFixupPerformed(bool value);
                /*0x3191618*/ bool get_HasISerializable();
                /*0x31901d4*/ bool get_HasSurrogate();
                /*0x31901e0*/ bool get_CanSurrogatedObjectValueChange();
                /*0x318ff50*/ bool get_CanObjectValueChange();
                /*0x3193638*/ int get_DirectlyDependentObjects();
                /*0x31924b8*/ int get_TotalDependentObjects();
                /*0x3193640*/ bool get_Reachable();
                /*0x3193648*/ void set_Reachable(bool value);
                /*0x319174c*/ bool get_TypeLoadExceptionReachable();
                /*0x3193650*/ System.Runtime.Serialization.TypeLoadExceptionHolder get_TypeLoadException();
                /*0x3193658*/ void set_TypeLoadException(System.Runtime.Serialization.TypeLoadExceptionHolder value);
                /*0x3193660*/ object get_ObjectValue();
                /*0x319027c*/ void SetObjectValue(object obj, System.Runtime.Serialization.ObjectManager manager);
                /*0x3193668*/ System.Runtime.Serialization.SerializationInfo get_SerializationInfo();
                /*0x3193670*/ void set_SerializationInfo(System.Runtime.Serialization.SerializationInfo value);
                /*0x3193678*/ System.Runtime.Serialization.ISerializationSurrogate get_Surrogate();
                /*0x3193680*/ System.Runtime.Serialization.LongList get_DependentObjects();
                /*0x3193688*/ void set_DependentObjects(System.Runtime.Serialization.LongList value);
                /*0x3192980*/ bool get_RequiresSerInfoFixup();
                /*0x31906c4*/ void set_RequiresSerInfoFixup(bool value);
                /*0x3193690*/ System.Runtime.Serialization.ValueTypeFixupInfo get_ValueFixup();
                /*0x318ff30*/ bool get_CompletelyFixed();
                /*0x3193598*/ long get_ContainerID();
            }

            class FixupHolder
            {
                /*0x10*/ long m_id;
                /*0x18*/ object m_fixupInfo;
                /*0x20*/ int m_fixupType;

                /*0x3192f00*/ FixupHolder(long id, object fixupInfo, int fixupType);
            }

            class FixupHolderList
            {
                /*0x10*/ System.Runtime.Serialization.FixupHolder[] m_values;
                /*0x18*/ int m_count;

                /*0x3193590*/ FixupHolderList();
                /*0x3193698*/ FixupHolderList(int startingSize);
                /*0x319370c*/ void Add(System.Runtime.Serialization.FixupHolder fixup);
                /*0x31937b8*/ void EnlargeArray();
            }

            class LongList
            {
                /*0x10*/ long[] m_values;
                /*0x18*/ int m_count;
                /*0x1c*/ int m_totalItems;
                /*0x20*/ int m_currentItem;

                /*0x31935b0*/ LongList();
                /*0x319384c*/ LongList(int startingSize);
                /*0x31935b8*/ void Add(long value);
                /*0x3193954*/ int get_Count();
                /*0x3191770*/ void StartEnumeration();
                /*0x31917bc*/ bool MoveNext();
                /*0x319177c*/ long get_Current();
                /*0x3193500*/ bool RemoveElement(long value);
                /*0x31938c0*/ void EnlargeArray();
            }

            class ObjectHolderList
            {
                /*0x10*/ System.Runtime.Serialization.ObjectHolder[] m_values;
                /*0x18*/ int m_count;

                /*0x318fa34*/ ObjectHolderList();
                /*0x319395c*/ ObjectHolderList(int startingSize);
                /*0x31939d0*/ void Add(System.Runtime.Serialization.ObjectHolder value);
                /*0x31928e8*/ System.Runtime.Serialization.ObjectHolderListEnumerator GetFixupEnumerator();
                /*0x3193a48*/ void EnlargeArray();
                /*0x3193b40*/ int get_Version();
                /*0x3193b48*/ int get_Count();
            }

            class ObjectHolderListEnumerator
            {
                /*0x10*/ bool m_isFixupEnumerator;
                /*0x18*/ System.Runtime.Serialization.ObjectHolderList m_list;
                /*0x20*/ int m_startingVersion;
                /*0x24*/ int m_currPos;

                /*0x3193adc*/ ObjectHolderListEnumerator(System.Runtime.Serialization.ObjectHolderList list, bool isFixupEnumerator);
                /*0x3192998*/ bool MoveNext();
                /*0x3192944*/ System.Runtime.Serialization.ObjectHolder get_Current();
            }

            class TypeLoadExceptionHolder
            {
                /*0x10*/ string m_typeName;

                /*0x3193b50*/ TypeLoadExceptionHolder(string typeName);
                /*0x3193b80*/ string get_TypeName();
            }

            class SafeSerializationEventArgs : System.EventArgs
            {
                /*0x10*/ System.Runtime.Serialization.StreamingContext m_streamingContext;
                /*0x20*/ System.Collections.Generic.List<object> m_serializedStates;

                /*0x3193b88*/ SafeSerializationEventArgs(System.Runtime.Serialization.StreamingContext streamingContext);
                /*0x3193c58*/ System.Collections.Generic.IList<object> get_SerializedStates();
            }

            interface ISafeSerializationData
            {
                /*0x1f30ebc*/ void CompleteDeserialization(object deserialized);
            }

            class SafeSerializationManager : System.Runtime.Serialization.IObjectReference, System.Runtime.Serialization.ISerializable
            {
                /*0x10*/ System.Collections.Generic.IList<object> m_serializedStates;
                /*0x18*/ System.Runtime.Serialization.SerializationInfo m_savedSerializationInfo;
                /*0x20*/ object m_realObject;
                /*0x28*/ System.RuntimeType m_realType;
                /*0x30*/ System.EventHandler<System.Runtime.Serialization.SafeSerializationEventArgs> SerializeObjectState;

                /*0x3193c60*/ SafeSerializationManager();
                /*0x3193c68*/ SafeSerializationManager(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x3194198*/ bool get_IsActive();
                /*0x31941a8*/ void CompleteSerialization(object serializedObject, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x31943a0*/ void CompleteDeserialization(object deserializedObject);
                /*0x31946f4*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x3194798*/ object System.Runtime.Serialization.IObjectReference.GetRealObject(System.Runtime.Serialization.StreamingContext context);
                /*0x3194a64*/ void OnDeserialized(System.Runtime.Serialization.StreamingContext context);
            }

            class OptionalFieldAttribute : System.Attribute
            {
                /*0x10*/ int versionAdded;

                /*0x3194b18*/ OptionalFieldAttribute();
                /*0x3194b28*/ void set_VersionAdded(int value);
            }

            class OnSerializingAttribute : System.Attribute
            {
                /*0x3194b90*/ OnSerializingAttribute();
            }

            class OnSerializedAttribute : System.Attribute
            {
                /*0x3194b98*/ OnSerializedAttribute();
            }

            class OnDeserializingAttribute : System.Attribute
            {
                /*0x3194ba0*/ OnDeserializingAttribute();
            }

            class OnDeserializedAttribute : System.Attribute
            {
                /*0x3194ba8*/ OnDeserializedAttribute();
            }

            class SerializationFieldInfo : System.Reflection.FieldInfo
            {
                /*0x10*/ System.Reflection.RuntimeFieldInfo m_field;
                /*0x18*/ string m_serializationName;

                /*0x318d7c4*/ SerializationFieldInfo(System.Reflection.RuntimeFieldInfo field, string namePrefix);
                /*0x3194bb0*/ System.Reflection.Module get_Module();
                /*0x3194bcc*/ int get_MetadataToken();
                /*0x3194bec*/ string get_Name();
                /*0x3194bf4*/ System.Type get_DeclaringType();
                /*0x3194c10*/ System.Type get_ReflectedType();
                /*0x3194c2c*/ object[] GetCustomAttributes(bool inherit);
                /*0x3194c50*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
                /*0x3194c74*/ bool IsDefined(System.Type attributeType, bool inherit);
                /*0x3194c94*/ System.Type get_FieldType();
                /*0x3194cb4*/ object GetValue(object obj);
                /*0x318e6ac*/ object InternalGetValue(object obj);
                /*0x3194cd4*/ void SetValue(object obj, object value, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Globalization.CultureInfo culture);
                /*0x318df98*/ void InternalSetValue(object obj, object value, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Globalization.CultureInfo culture);
                /*0x3194cf4*/ System.Reflection.RuntimeFieldInfo get_FieldInfo();
                /*0x3194cfc*/ System.RuntimeFieldHandle get_FieldHandle();
                /*0x3194d1c*/ System.Reflection.FieldAttributes get_Attributes();
            }

            class SerializationInfo
            {
                /*0x10*/ string[] m_members;
                /*0x18*/ object[] m_data;
                /*0x20*/ System.Type[] m_types;
                /*0x28*/ System.Collections.Generic.Dictionary<string, int> m_nameToIndex;
                /*0x30*/ int m_currMember;
                /*0x38*/ System.Runtime.Serialization.IFormatterConverter m_converter;
                /*0x40*/ string m_fullTypeName;
                /*0x48*/ string m_assemName;
                /*0x50*/ System.Type objectType;
                /*0x58*/ bool isFullTypeNameSetExplicit;
                /*0x59*/ bool isAssemblyNameSetExplicit;
                /*0x5a*/ bool requireSameTokenInPartialTrust;

                static /*0x3194f94*/ bool Compare(byte[] a, byte[] b);
                static /*0x3194f90*/ void DemandForUnsafeAssemblyNameAssignments(string originalAssemblyName, string newAssemblyName);
                static /*0x3195000*/ bool IsAssemblyNameAssignmentSafe(string originalAssemblyName, string newAssemblyName);
                /*0x3194d3c*/ SerializationInfo(System.Type type, System.Runtime.Serialization.IFormatterConverter converter);
                /*0x3194d44*/ SerializationInfo(System.Type type, System.Runtime.Serialization.IFormatterConverter converter, bool requireSameTokenInPartialTrust);
                /*0x3194f80*/ string get_FullTypeName();
                /*0x3194f88*/ string get_AssemblyName();
                /*0x317d500*/ void SetType(System.Type type);
                /*0x3195134*/ int get_MemberCount();
                /*0x319513c*/ System.Type get_ObjectType();
                /*0x3195144*/ bool get_IsFullTypeNameSetExplicit();
                /*0x319514c*/ bool get_IsAssemblyNameSetExplicit();
                /*0x317cfac*/ System.Runtime.Serialization.SerializationInfoEnumerator GetEnumerator();
                /*0x3195154*/ void ExpandArrays();
                /*0x3194324*/ void AddValue(string name, object value, System.Type type);
                /*0x317d658*/ void AddValue(string name, object value);
                /*0x317d6d4*/ void AddValue(string name, bool value);
                /*0x3195478*/ void AddValue(string name, byte value);
                /*0x31954f0*/ void AddValue(string name, short value);
                /*0x3189614*/ void AddValue(string name, int value);
                /*0x3195568*/ void AddValue(string name, long value);
                /*0x31955e0*/ void AddValue(string name, ulong value);
                /*0x3195658*/ void AddValue(string name, float value);
                /*0x31956d0*/ void AddValue(string name, System.DateTime value);
                /*0x319529c*/ void AddValueInternal(string name, object value, System.Type type);
                /*0x3191624*/ void UpdateValue(string name, object value, System.Type type);
                /*0x3195790*/ int FindElement(string name);
                /*0x3195854*/ object GetElement(string name, ref System.Type foundType);
                /*0x3195964*/ object GetElementNoThrow(string name, ref System.Type foundType);
                /*0x3193f90*/ object GetValue(string name, System.Type type);
                /*0x3193e88*/ object GetValueNoThrow(string name, System.Type type);
                /*0x3195a00*/ bool GetBoolean(string name);
                /*0x3195b4c*/ byte GetByte(string name);
                /*0x3195c8c*/ int GetInt32(string name);
                /*0x3195dcc*/ long GetInt64(string name);
                /*0x3195f0c*/ float GetSingle(string name);
                /*0x319604c*/ string GetString(string name);
            }

            struct StreamingContext
            {
                /*0x10*/ object m_additionalContext;
                /*0x18*/ System.Runtime.Serialization.StreamingContextStates m_state;

                /*0x3196184*/ StreamingContext(System.Runtime.Serialization.StreamingContextStates state);
                /*0x3196198*/ StreamingContext(System.Runtime.Serialization.StreamingContextStates state, object additional);
                /*0x31961a8*/ object get_Context();
                /*0x31961b0*/ bool Equals(object obj);
                /*0x3196260*/ int GetHashCode();
                /*0x3196268*/ System.Runtime.Serialization.StreamingContextStates get_State();
            }

            enum StreamingContextStates
            {
                CrossProcess = 1,
                CrossMachine = 2,
                File = 4,
                Persistence = 8,
                Remoting = 16,
                Other = 32,
                Clone = 64,
                CrossAppDomain = 128,
                All = 255,
            }

            namespace Formatters
            {
                enum FormatterTypeStyle
                {
                    TypesWhenNeeded = 0,
                    TypesAlways = 1,
                    XsdString = 2,
                }

                enum FormatterAssemblyStyle
                {
                    Simple = 0,
                    Full = 1,
                }

                enum TypeFilterLevel
                {
                    Low = 2,
                    Full = 3,
                }

                namespace Binary
                {
                    enum BinaryHeaderEnum
                    {
                        SerializedStreamHeader = 0,
                        Object = 1,
                        ObjectWithMap = 2,
                        ObjectWithMapAssemId = 3,
                        ObjectWithMapTyped = 4,
                        ObjectWithMapTypedAssemId = 5,
                        ObjectString = 6,
                        Array = 7,
                        MemberPrimitiveTyped = 8,
                        MemberReference = 9,
                        ObjectNull = 10,
                        MessageEnd = 11,
                        Assembly = 12,
                        ObjectNullMultiple256 = 13,
                        ObjectNullMultiple = 14,
                        ArraySinglePrimitive = 15,
                        ArraySingleObject = 16,
                        ArraySingleString = 17,
                        CrossAppDomainMap = 18,
                        CrossAppDomainString = 19,
                        CrossAppDomainAssembly = 20,
                        MethodCall = 21,
                        MethodReturn = 22,
                    }

                    enum BinaryTypeEnum
                    {
                        Primitive = 0,
                        String = 1,
                        Object = 2,
                        ObjectUrt = 3,
                        ObjectUser = 4,
                        ObjectArray = 5,
                        StringArray = 6,
                        PrimitiveArray = 7,
                    }

                    enum BinaryArrayTypeEnum
                    {
                        Single = 0,
                        Jagged = 1,
                        Rectangular = 2,
                        SingleOffset = 3,
                        JaggedOffset = 4,
                        RectangularOffset = 5,
                    }

                    enum InternalSerializerTypeE
                    {
                        Soap = 1,
                        Binary = 2,
                    }

                    enum InternalParseTypeE
                    {
                        Empty = 0,
                        SerializedStreamHeader = 1,
                        Object = 2,
                        Member = 3,
                        ObjectEnd = 4,
                        MemberEnd = 5,
                        Headers = 6,
                        HeadersEnd = 7,
                        SerializedStreamHeaderEnd = 8,
                        Envelope = 9,
                        EnvelopeEnd = 10,
                        Body = 11,
                        BodyEnd = 12,
                    }

                    enum InternalObjectTypeE
                    {
                        Empty = 0,
                        Object = 1,
                        Array = 2,
                    }

                    enum InternalObjectPositionE
                    {
                        Empty = 0,
                        Top = 1,
                        Child = 2,
                        Headers = 3,
                    }

                    enum InternalArrayTypeE
                    {
                        Empty = 0,
                        Single = 1,
                        Jagged = 2,
                        Rectangular = 3,
                        Base64 = 4,
                    }

                    enum InternalMemberTypeE
                    {
                        Empty = 0,
                        Header = 1,
                        Field = 2,
                        Item = 3,
                    }

                    enum InternalMemberValueE
                    {
                        Empty = 0,
                        InlineValue = 1,
                        Nested = 2,
                        Reference = 3,
                        Null = 4,
                    }

                    enum InternalPrimitiveTypeE
                    {
                        Invalid = 0,
                        Boolean = 1,
                        Byte = 2,
                        Char = 3,
                        Currency = 4,
                        Decimal = 5,
                        Double = 6,
                        Int16 = 7,
                        Int32 = 8,
                        Int64 = 9,
                        SByte = 10,
                        Single = 11,
                        TimeSpan = 12,
                        DateTime = 13,
                        UInt16 = 14,
                        UInt32 = 15,
                        UInt64 = 16,
                        Null = 17,
                        String = 18,
                    }

                    enum ValueFixupEnum
                    {
                        Empty = 0,
                        Array = 1,
                        Header = 2,
                        Member = 3,
                    }

                    class BinaryConverter
                    {
                        static /*0x3196270*/ System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum GetBinaryTypeInfo(System.Type type, System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo, string typeName, System.Runtime.Serialization.Formatters.Binary.ObjectWriter objectWriter, ref object typeInformation, ref int assemId);
                        static /*0x3196934*/ System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum GetParserBinaryTypeInfo(System.Type type, ref object typeInformation);
                        static /*0x3196c44*/ void WriteTypeInfo(System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum binaryTypeEnum, object typeInformation, int assemId, System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        static /*0x3196edc*/ object ReadTypeInfo(System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum binaryTypeEnum, System.Runtime.Serialization.Formatters.Binary.__BinaryParser input, ref int assemId);
                        static /*0x3197124*/ void TypeFromInfo(System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum binaryTypeEnum, object typeInformation, System.Runtime.Serialization.Formatters.Binary.ObjectReader objectReader, System.Runtime.Serialization.Formatters.Binary.BinaryAssemblyInfo assemblyInfo, ref System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE primitiveTypeEnum, ref string typeString, ref System.Type type, ref bool isVariant);
                    }

                    class IOUtil
                    {
                        static /*0x31978d8*/ bool FlagTest(System.Runtime.Serialization.Formatters.Binary.MessageEnum flag, System.Runtime.Serialization.Formatters.Binary.MessageEnum target);
                        static /*0x31978e4*/ void WriteStringWithCode(string value, System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        static /*0x3197960*/ void WriteWithCode(System.Type type, object value, System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                    }

                    class BinaryAssemblyInfo
                    {
                        /*0x10*/ string assemblyString;
                        /*0x18*/ System.Reflection.Assembly assembly;

                        /*0x31981e0*/ BinaryAssemblyInfo(string assemblyString);
                        /*0x3198210*/ BinaryAssemblyInfo(string assemblyString, System.Reflection.Assembly assembly);
                        /*0x3198254*/ System.Reflection.Assembly GetAssembly();
                    }

                    class SerializationHeaderRecord
                    {
                        /*0x10*/ int binaryFormatterMajorVersion;
                        /*0x14*/ int binaryFormatterMinorVersion;
                        /*0x18*/ System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum binaryHeaderEnum;
                        /*0x1c*/ int topId;
                        /*0x20*/ int headerId;
                        /*0x24*/ int majorVersion;
                        /*0x28*/ int minorVersion;

                        static /*0x319849c*/ int GetInt32(byte[] buffer, int index);
                        /*0x3198384*/ SerializationHeaderRecord();
                        /*0x3198394*/ SerializationHeaderRecord(System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum binaryHeaderEnum, int topId, int headerId, int majorVersion, int minorVersion);
                        /*0x31983ec*/ void Write(System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        /*0x319850c*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                        /*0x3198684*/ void Dump();
                    }

                    class BinaryAssembly
                    {
                        /*0x10*/ int assemId;
                        /*0x18*/ string assemblyString;

                        /*0x3198688*/ BinaryAssembly();
                        /*0x3198690*/ void Set(int assemId, string assemblyString);
                        /*0x31986a4*/ void Write(System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        /*0x3198714*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                        /*0x319877c*/ void Dump();
                    }

                    class BinaryCrossAppDomainAssembly
                    {
                        /*0x10*/ int assemId;
                        /*0x14*/ int assemblyIndex;

                        /*0x3198780*/ BinaryCrossAppDomainAssembly();
                        /*0x3198788*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                        /*0x31987e8*/ void Dump();
                    }

                    class BinaryObject
                    {
                        /*0x10*/ int objectId;
                        /*0x14*/ int mapId;

                        /*0x31987ec*/ BinaryObject();
                        /*0x31987f4*/ void Set(int objectId, int mapId);
                        /*0x31987fc*/ void Write(System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        /*0x319886c*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                        /*0x31988cc*/ void Dump();
                    }

                    class BinaryMethodCall
                    {
                        /*0x10*/ string methodName;
                        /*0x18*/ string typeName;
                        /*0x20*/ object[] args;
                        /*0x28*/ object callContext;
                        /*0x30*/ System.Type[] argTypes;
                        /*0x38*/ bool bArgsPrimitive;
                        /*0x3c*/ System.Runtime.Serialization.Formatters.Binary.MessageEnum messageEnum;

                        /*0x31989fc*/ BinaryMethodCall();
                        /*0x31988d0*/ void Write(System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        /*0x31989f8*/ void Dump();
                    }

                    class BinaryMethodReturn
                    {
                        static /*0x0*/ object instanceOfVoid;
                        /*0x10*/ object returnValue;
                        /*0x18*/ object[] args;
                        /*0x20*/ object callContext;
                        /*0x28*/ System.Type[] argTypes;
                        /*0x30*/ bool bArgsPrimitive;
                        /*0x34*/ System.Runtime.Serialization.Formatters.Binary.MessageEnum messageEnum;
                        /*0x38*/ System.Type returnType;

                        static /*0x3198a0c*/ BinaryMethodReturn();
                        /*0x3198ac4*/ BinaryMethodReturn();
                        /*0x3198ad4*/ void Write(System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        /*0x3198bfc*/ void Dump();
                    }

                    class BinaryObjectString
                    {
                        /*0x10*/ int objectId;
                        /*0x18*/ string value;

                        /*0x3198c00*/ BinaryObjectString();
                        /*0x3198c08*/ void Set(int objectId, string value);
                        /*0x3198c1c*/ void Write(System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        /*0x3198c8c*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                        /*0x3198cf4*/ void Dump();
                    }

                    class BinaryCrossAppDomainString
                    {
                        /*0x10*/ int objectId;
                        /*0x14*/ int value;

                        /*0x3198cf8*/ BinaryCrossAppDomainString();
                        /*0x3198d00*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                        /*0x3198d60*/ void Dump();
                    }

                    class BinaryCrossAppDomainMap
                    {
                        /*0x10*/ int crossAppDomainArrayIndex;

                        /*0x3198d64*/ BinaryCrossAppDomainMap();
                        /*0x3198d6c*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                        /*0x3198da0*/ void Dump();
                    }

                    class MemberPrimitiveTyped
                    {
                        /*0x10*/ System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE primitiveTypeEnum;
                        /*0x18*/ object value;

                        /*0x3198da4*/ MemberPrimitiveTyped();
                        /*0x3198dac*/ void Set(System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE primitiveTypeEnum, object value);
                        /*0x3198dc0*/ void Write(System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        /*0x3198e20*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                        /*0x3199248*/ void Dump();
                    }

                    class BinaryObjectWithMap
                    {
                        /*0x10*/ System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum binaryHeaderEnum;
                        /*0x14*/ int objectId;
                        /*0x18*/ string name;
                        /*0x20*/ int numMembers;
                        /*0x28*/ string[] memberNames;
                        /*0x30*/ int assemId;

                        /*0x319924c*/ BinaryObjectWithMap();
                        /*0x3199254*/ BinaryObjectWithMap(System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum binaryHeaderEnum);
                        /*0x319927c*/ void Set(int objectId, string name, int numMembers, string[] memberNames, int assemId);
                        /*0x31992e0*/ void Write(System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        /*0x31993f4*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                        /*0x3199564*/ void Dump();
                    }

                    class BinaryObjectWithMapTyped
                    {
                        /*0x10*/ System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum binaryHeaderEnum;
                        /*0x14*/ int objectId;
                        /*0x18*/ string name;
                        /*0x20*/ int numMembers;
                        /*0x28*/ string[] memberNames;
                        /*0x30*/ System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum[] binaryTypeEnumA;
                        /*0x38*/ object[] typeInformationA;
                        /*0x40*/ int[] memberAssemIds;
                        /*0x48*/ int assemId;

                        /*0x3199568*/ BinaryObjectWithMapTyped();
                        /*0x3199570*/ BinaryObjectWithMapTyped(System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum binaryHeaderEnum);
                        /*0x3199598*/ void Set(int objectId, string name, int numMembers, string[] memberNames, System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum[] binaryTypeEnumA, object[] typeInformationA, int[] memberAssemIds, int assemId);
                        /*0x3199648*/ void Write(System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        /*0x3199820*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                    }

                    class BinaryArray
                    {
                        /*0x10*/ int objectId;
                        /*0x14*/ int rank;
                        /*0x18*/ int[] lengthA;
                        /*0x20*/ int[] lowerBoundA;
                        /*0x28*/ System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum binaryTypeEnum;
                        /*0x30*/ object typeInformation;
                        /*0x38*/ int assemId;
                        /*0x3c*/ System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum binaryHeaderEnum;
                        /*0x40*/ System.Runtime.Serialization.Formatters.Binary.BinaryArrayTypeEnum binaryArrayTypeEnum;

                        /*0x3199b6c*/ BinaryArray();
                        /*0x3199b74*/ BinaryArray(System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum binaryHeaderEnum);
                        /*0x3199b9c*/ void Set(int objectId, int rank, int[] lengthA, int[] lowerBoundA, System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum binaryTypeEnum, object typeInformation, System.Runtime.Serialization.Formatters.Binary.BinaryArrayTypeEnum binaryArrayTypeEnum, int assemId);
                        /*0x3199c38*/ void Write(System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        /*0x3199f10*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                    }

                    class MemberPrimitiveUnTyped
                    {
                        /*0x10*/ System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE typeInformation;
                        /*0x18*/ object value;

                        /*0x319a384*/ MemberPrimitiveUnTyped();
                        /*0x319a38c*/ void Set(System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE typeInformation, object value);
                        /*0x319a3a0*/ void Set(System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE typeInformation);
                        /*0x319a3a8*/ void Write(System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        /*0x319a3c8*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                        /*0x319a3fc*/ void Dump();
                    }

                    class MemberReference
                    {
                        /*0x10*/ int idRef;

                        /*0x319a400*/ MemberReference();
                        /*0x319a408*/ void Set(int idRef);
                        /*0x319a410*/ void Write(System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        /*0x319a464*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                        /*0x319a498*/ void Dump();
                    }

                    class ObjectNull
                    {
                        /*0x10*/ int nullCount;

                        /*0x319a49c*/ ObjectNull();
                        /*0x319a4a4*/ void SetNullCount(int nullCount);
                        /*0x319a4ac*/ void Write(System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        /*0x319a560*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input, System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum binaryHeaderEnum);
                        /*0x319a5d4*/ void Dump();
                    }

                    class MessageEnd
                    {
                        /*0x319a5d8*/ MessageEnd();
                        /*0x319a5e0*/ void Write(System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        /*0x319a608*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                        /*0x319a60c*/ void Dump();
                        /*0x319a610*/ void Dump(System.IO.Stream sout);
                    }

                    class ObjectMap
                    {
                        /*0x10*/ string objectName;
                        /*0x18*/ System.Type objectType;
                        /*0x20*/ System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum[] binaryTypeEnumA;
                        /*0x28*/ object[] typeInformationA;
                        /*0x30*/ System.Type[] memberTypes;
                        /*0x38*/ string[] memberNames;
                        /*0x40*/ System.Runtime.Serialization.Formatters.Binary.ReadObjectInfo objectInfo;
                        /*0x48*/ bool isInitObjectInfo;
                        /*0x50*/ System.Runtime.Serialization.Formatters.Binary.ObjectReader objectReader;
                        /*0x58*/ int objectId;
                        /*0x60*/ System.Runtime.Serialization.Formatters.Binary.BinaryAssemblyInfo assemblyInfo;

                        static /*0x319b248*/ System.Runtime.Serialization.Formatters.Binary.ObjectMap Create(string name, System.Type objectType, string[] memberNames, System.Runtime.Serialization.Formatters.Binary.ObjectReader objectReader, int objectId, System.Runtime.Serialization.Formatters.Binary.BinaryAssemblyInfo assemblyInfo);
                        static /*0x319b2e0*/ System.Runtime.Serialization.Formatters.Binary.ObjectMap Create(string name, string[] memberNames, System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum[] binaryTypeEnumA, object[] typeInformationA, int[] memberAssemIds, System.Runtime.Serialization.Formatters.Binary.ObjectReader objectReader, int objectId, System.Runtime.Serialization.Formatters.Binary.BinaryAssemblyInfo assemblyInfo, System.Runtime.Serialization.Formatters.Binary.SizedArray assemIdToAssemblyTable);
                        /*0x319a614*/ ObjectMap(string objectName, System.Type objectType, string[] memberNames, System.Runtime.Serialization.Formatters.Binary.ObjectReader objectReader, int objectId, System.Runtime.Serialization.Formatters.Binary.BinaryAssemblyInfo assemblyInfo);
                        /*0x319ad78*/ ObjectMap(string objectName, string[] memberNames, System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum[] binaryTypeEnumA, object[] typeInformationA, int[] memberAssemIds, System.Runtime.Serialization.Formatters.Binary.ObjectReader objectReader, int objectId, System.Runtime.Serialization.Formatters.Binary.BinaryAssemblyInfo assemblyInfo, System.Runtime.Serialization.Formatters.Binary.SizedArray assemIdToAssemblyTable);
                        /*0x319b114*/ System.Runtime.Serialization.Formatters.Binary.ReadObjectInfo CreateObjectInfo(ref System.Runtime.Serialization.SerializationInfo si, ref object[] memberData);
                    }

                    class ObjectProgress
                    {
                        static /*0x0*/ int opRecordIdCount;
                        /*0x10*/ bool isInitial;
                        /*0x14*/ int count;
                        /*0x18*/ System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum expectedType;
                        /*0x20*/ object expectedTypeInformation;
                        /*0x28*/ string name;
                        /*0x30*/ System.Runtime.Serialization.Formatters.Binary.InternalObjectTypeE objectTypeEnum;
                        /*0x34*/ System.Runtime.Serialization.Formatters.Binary.InternalMemberTypeE memberTypeEnum;
                        /*0x38*/ System.Runtime.Serialization.Formatters.Binary.InternalMemberValueE memberValueEnum;
                        /*0x40*/ System.Type dtType;
                        /*0x48*/ int numItems;
                        /*0x4c*/ System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum binaryTypeEnum;
                        /*0x50*/ object typeInformation;
                        /*0x58*/ int nullCount;
                        /*0x5c*/ int memberLength;
                        /*0x60*/ System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum[] binaryTypeEnumA;
                        /*0x68*/ object[] typeInformationA;
                        /*0x70*/ string[] memberNames;
                        /*0x78*/ System.Type[] memberTypes;
                        /*0x80*/ System.Runtime.Serialization.Formatters.Binary.ParseRecord pr;

                        static /*0x319b640*/ ObjectProgress();
                        /*0x319b39c*/ ObjectProgress();
                        /*0x319b410*/ void Init();
                        /*0x319b4d0*/ void ArrayCountIncrement(int value);
                        /*0x319b4e0*/ bool GetNext(ref System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum outBinaryTypeEnum, ref object outTypeInformation);
                    }

                    class Converter
                    {
                        static /*0x0*/ int primitiveTypeEnumLength;
                        static /*0x8*/ System.Type[] typeA;
                        static /*0x10*/ System.Type[] arrayTypeA;
                        static /*0x18*/ string[] valueA;
                        static /*0x20*/ System.TypeCode[] typeCodeA;
                        static /*0x28*/ System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE[] codeA;
                        static /*0x30*/ System.Type typeofISerializable;
                        static /*0x38*/ System.Type typeofString;
                        static /*0x40*/ System.Type typeofConverter;
                        static /*0x48*/ System.Type typeofBoolean;
                        static /*0x50*/ System.Type typeofByte;
                        static /*0x58*/ System.Type typeofChar;
                        static /*0x60*/ System.Type typeofDecimal;
                        static /*0x68*/ System.Type typeofDouble;
                        static /*0x70*/ System.Type typeofInt16;
                        static /*0x78*/ System.Type typeofInt32;
                        static /*0x80*/ System.Type typeofInt64;
                        static /*0x88*/ System.Type typeofSByte;
                        static /*0x90*/ System.Type typeofSingle;
                        static /*0x98*/ System.Type typeofTimeSpan;
                        static /*0xa0*/ System.Type typeofDateTime;
                        static /*0xa8*/ System.Type typeofUInt16;
                        static /*0xb0*/ System.Type typeofUInt32;
                        static /*0xb8*/ System.Type typeofUInt64;
                        static /*0xc0*/ System.Type typeofObject;
                        static /*0xc8*/ System.Type typeofSystemVoid;
                        static /*0xd0*/ System.Reflection.Assembly urtAssembly;
                        static /*0xd8*/ string urtAssemblyString;
                        static /*0xe0*/ System.Type typeofTypeArray;
                        static /*0xe8*/ System.Type typeofObjectArray;
                        static /*0xf0*/ System.Type typeofStringArray;
                        static /*0xf8*/ System.Type typeofBooleanArray;
                        static /*0x100*/ System.Type typeofByteArray;
                        static /*0x108*/ System.Type typeofCharArray;
                        static /*0x110*/ System.Type typeofDecimalArray;
                        static /*0x118*/ System.Type typeofDoubleArray;
                        static /*0x120*/ System.Type typeofInt16Array;
                        static /*0x128*/ System.Type typeofInt32Array;
                        static /*0x130*/ System.Type typeofInt64Array;
                        static /*0x138*/ System.Type typeofSByteArray;
                        static /*0x140*/ System.Type typeofSingleArray;
                        static /*0x148*/ System.Type typeofTimeSpanArray;
                        static /*0x150*/ System.Type typeofDateTimeArray;
                        static /*0x158*/ System.Type typeofUInt16Array;
                        static /*0x160*/ System.Type typeofUInt32Array;
                        static /*0x168*/ System.Type typeofUInt64Array;
                        static /*0x170*/ System.Type typeofMarshalByRefObject;

                        static /*0x319ca40*/ Converter();
                        static /*0x3196b2c*/ System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE ToCode(System.Type type);
                        static /*0x319b744*/ bool IsWriteAsByteArray(System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE code);
                        static /*0x319b760*/ int TypeLength(System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE code);
                        static /*0x319765c*/ System.Type ToArrayType(System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE code);
                        static /*0x319bc00*/ void InitTypeA();
                        static /*0x319b784*/ void InitArrayTypeA();
                        static /*0x31975a4*/ System.Type ToType(System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE code);
                        static /*0x319c07c*/ System.Array CreatePrimitiveArray(System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE code, int length);
                        static /*0x3196578*/ bool IsPrimitiveArray(System.Type type, ref object typeInformation);
                        static /*0x319c19c*/ void InitValueA();
                        static /*0x31974ec*/ string ToComType(System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE code);
                        static /*0x319c558*/ void InitTypeCodeA();
                        static /*0x319c6f0*/ System.TypeCode ToTypeCode(System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE code);
                        static /*0x319c7a8*/ void InitCodeA();
                        static /*0x319b68c*/ System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE ToPrimitiveTypeEnum(System.TypeCode typeCode);
                        static /*0x319c954*/ object FromString(string value, System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE code);
                    }

                    class BinaryFormatter
                    {
                        static /*0x0*/ System.Collections.Generic.Dictionary<System.Type, System.Runtime.Serialization.Formatters.Binary.TypeInformation> typeNameCache;
                        /*0x10*/ System.Runtime.Serialization.ISurrogateSelector m_surrogates;
                        /*0x18*/ System.Runtime.Serialization.StreamingContext m_context;
                        /*0x28*/ System.Runtime.Serialization.SerializationBinder m_binder;
                        /*0x30*/ System.Runtime.Serialization.Formatters.FormatterTypeStyle m_typeFormat;
                        /*0x34*/ System.Runtime.Serialization.Formatters.FormatterAssemblyStyle m_assemblyFormat;
                        /*0x38*/ System.Runtime.Serialization.Formatters.TypeFilterLevel m_securityLevel;
                        /*0x40*/ object[] m_crossAppDomainArray;

                        static /*0x319e6d8*/ BinaryFormatter();
                        static /*0x319e428*/ System.Runtime.Serialization.Formatters.Binary.TypeInformation GetTypeInformation(System.Type type);
                        /*0x319d2d0*/ BinaryFormatter();
                        /*0x319d33c*/ BinaryFormatter(System.Runtime.Serialization.ISurrogateSelector selector, System.Runtime.Serialization.StreamingContext context);
                        /*0x319d2c0*/ void set_AssemblyFormat(System.Runtime.Serialization.Formatters.FormatterAssemblyStyle value);
                        /*0x319d2c8*/ void set_SurrogateSelector(System.Runtime.Serialization.ISurrogateSelector value);
                        /*0x319d3a0*/ object Deserialize(System.IO.Stream serializationStream);
                        /*0x319d3b4*/ object Deserialize(System.IO.Stream serializationStream, System.Runtime.Remoting.Messaging.HeaderHandler handler, bool fCheck);
                        /*0x319d3ac*/ object Deserialize(System.IO.Stream serializationStream, System.Runtime.Remoting.Messaging.HeaderHandler handler);
                        /*0x319dc0c*/ void Serialize(System.IO.Stream serializationStream, object graph);
                        /*0x319dc18*/ void Serialize(System.IO.Stream serializationStream, object graph, System.Runtime.Remoting.Messaging.Header[] headers);
                        /*0x319dc20*/ void Serialize(System.IO.Stream serializationStream, object graph, System.Runtime.Remoting.Messaging.Header[] headers, bool fCheck);
                    }

                    class __BinaryWriter
                    {
                        /*0x10*/ System.IO.Stream sout;
                        /*0x18*/ System.Runtime.Serialization.Formatters.FormatterTypeStyle formatterTypeStyle;
                        /*0x20*/ System.Collections.Hashtable objectMapTable;
                        /*0x28*/ System.Runtime.Serialization.Formatters.Binary.ObjectWriter objectWriter;
                        /*0x30*/ System.IO.BinaryWriter dataWriter;
                        /*0x38*/ int m_nestedObjectCount;
                        /*0x3c*/ int nullCount;
                        /*0x40*/ System.Runtime.Serialization.Formatters.Binary.BinaryMethodCall binaryMethodCall;
                        /*0x48*/ System.Runtime.Serialization.Formatters.Binary.BinaryMethodReturn binaryMethodReturn;
                        /*0x50*/ System.Runtime.Serialization.Formatters.Binary.BinaryObject binaryObject;
                        /*0x58*/ System.Runtime.Serialization.Formatters.Binary.BinaryObjectWithMap binaryObjectWithMap;
                        /*0x60*/ System.Runtime.Serialization.Formatters.Binary.BinaryObjectWithMapTyped binaryObjectWithMapTyped;
                        /*0x68*/ System.Runtime.Serialization.Formatters.Binary.BinaryObjectString binaryObjectString;
                        /*0x70*/ System.Runtime.Serialization.Formatters.Binary.BinaryArray binaryArray;
                        /*0x78*/ byte[] byteBuffer;
                        /*0x80*/ int chunkSize;
                        /*0x88*/ System.Runtime.Serialization.Formatters.Binary.MemberPrimitiveUnTyped memberPrimitiveUnTyped;
                        /*0x90*/ System.Runtime.Serialization.Formatters.Binary.MemberPrimitiveTyped memberPrimitiveTyped;
                        /*0x98*/ System.Runtime.Serialization.Formatters.Binary.ObjectNull objectNull;
                        /*0xa0*/ System.Runtime.Serialization.Formatters.Binary.MemberReference memberReference;
                        /*0xa8*/ System.Runtime.Serialization.Formatters.Binary.BinaryAssembly binaryAssembly;

                        /*0x319df3c*/ __BinaryWriter(System.IO.Stream sout, System.Runtime.Serialization.Formatters.Binary.ObjectWriter objectWriter, System.Runtime.Serialization.Formatters.FormatterTypeStyle formatterTypeStyle);
                        /*0x319e770*/ void WriteBegin();
                        /*0x319e774*/ void WriteEnd();
                        /*0x319e790*/ void WriteBoolean(bool value);
                        /*0x3196e80*/ void WriteByte(byte value);
                        /*0x319e7b0*/ void WriteBytes(byte[] value);
                        /*0x319e7cc*/ void WriteBytes(byte[] byteA, int offset, int size);
                        /*0x319e7e8*/ void WriteChar(char value);
                        /*0x319e804*/ void WriteChars(char[] value);
                        /*0x319e820*/ void WriteDecimal(decimal value);
                        /*0x319e91c*/ void WriteSingle(float value);
                        /*0x319e93c*/ void WriteDouble(double value);
                        /*0x319e95c*/ void WriteInt16(short value);
                        /*0x3196ebc*/ void WriteInt32(int value);
                        /*0x319e97c*/ void WriteInt64(long value);
                        /*0x319e99c*/ void WriteSByte(sbyte value);
                        /*0x3196e9c*/ void WriteString(string value);
                        /*0x319e9b8*/ void WriteTimeSpan(System.TimeSpan value);
                        /*0x319ea30*/ void WriteDateTime(System.DateTime value);
                        /*0x319eaa8*/ void WriteUInt16(ushort value);
                        /*0x319eac8*/ void WriteUInt32(uint value);
                        /*0x319eae8*/ void WriteUInt64(ulong value);
                        /*0x319eb08*/ void WriteObjectEnd(System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo typeNameInfo);
                        /*0x319eb0c*/ void WriteSerializationHeaderEnd();
                        /*0x319eb6c*/ void WriteSerializationHeader(int topId, int headerId, int minorVersion, int majorVersion);
                        /*0x319ebfc*/ void WriteMethodCall();
                        /*0x319ec84*/ void WriteMethodReturn();
                        /*0x319ed0c*/ void WriteObject(System.Runtime.Serialization.Formatters.Binary.NameInfo nameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo typeNameInfo, int numMembers, string[] memberNames, System.Type[] memberTypes, System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo[] memberObjectInfos);
                        /*0x319f4d0*/ void WriteObjectString(int objectId, string value);
                        /*0x319f580*/ void WriteSingleArray(System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo arrayNameInfo, System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo arrayElemTypeNameInfo, int length, int lowerBound, System.Array array);
                        /*0x319f848*/ void WriteArrayAsBytes(System.Array array, int typeLength);
                        /*0x319f9a0*/ void WriteJaggedArray(System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo arrayNameInfo, System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo arrayElemTypeNameInfo, int length, int lowerBound);
                        /*0x319fb48*/ void WriteRectangleArray(System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo arrayNameInfo, System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo arrayElemTypeNameInfo, int rank, int[] lengthA, int[] lowerBoundA);
                        /*0x319fcc4*/ void WriteObjectByteArray(System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo arrayNameInfo, System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo arrayElemTypeNameInfo, int length, int lowerBound, byte[] byteA);
                        /*0x319fd24*/ void WriteMember(System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo typeNameInfo, object value);
                        /*0x319fe60*/ void WriteNullMember(System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo typeNameInfo);
                        /*0x319ff10*/ void WriteMemberObjectRef(System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, int idRef);
                        /*0x319ffb0*/ void WriteMemberNested(System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo);
                        /*0x319ffcc*/ void WriteMemberString(System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo typeNameInfo, string value);
                        /*0x31a0014*/ void WriteItem(System.Runtime.Serialization.Formatters.Binary.NameInfo itemNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo typeNameInfo, object value);
                        /*0x31a0054*/ void WriteNullItem(System.Runtime.Serialization.Formatters.Binary.NameInfo itemNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo typeNameInfo);
                        /*0x31a0064*/ void WriteDelayedNullItem();
                        /*0x31a0074*/ void WriteItemEnd();
                        /*0x319f2bc*/ void InternalWriteItemNull();
                        /*0x31a0078*/ void WriteItemObjectRef(System.Runtime.Serialization.Formatters.Binary.NameInfo nameInfo, int idRef);
                        /*0x31a00a8*/ void WriteAssembly(System.Type type, string assemblyString, int assemId, bool isNew);
                        /*0x3197a80*/ void WriteValue(System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE code, object value);
                    }

                    class ObjectMapInfo
                    {
                        /*0x10*/ int objectId;
                        /*0x14*/ int numMembers;
                        /*0x18*/ string[] memberNames;
                        /*0x20*/ System.Type[] memberTypes;

                        /*0x319f478*/ ObjectMapInfo(int objectId, int numMembers, string[] memberNames, System.Type[] memberTypes);
                        /*0x319f358*/ bool isCompatible(int numMembers, string[] memberNames, System.Type[] memberTypes);
                    }

                    class WriteObjectInfo
                    {
                        /*0x10*/ int objectInfoId;
                        /*0x18*/ object obj;
                        /*0x20*/ System.Type objectType;
                        /*0x28*/ bool isSi;
                        /*0x29*/ bool isNamed;
                        /*0x2a*/ bool isTyped;
                        /*0x2b*/ bool isArray;
                        /*0x30*/ System.Runtime.Serialization.SerializationInfo si;
                        /*0x38*/ System.Runtime.Serialization.Formatters.Binary.SerObjectInfoCache cache;
                        /*0x40*/ object[] memberData;
                        /*0x48*/ System.Runtime.Serialization.ISerializationSurrogate serializationSurrogate;
                        /*0x50*/ System.Runtime.Serialization.StreamingContext context;
                        /*0x60*/ System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit serObjectInfoInit;
                        /*0x68*/ long objectId;
                        /*0x70*/ long assemId;
                        /*0x78*/ string binderTypeName;
                        /*0x80*/ string binderAssemblyString;

                        static /*0x31a0240*/ System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo Serialize(object obj, System.Runtime.Serialization.ISurrogateSelector surrogateSelector, System.Runtime.Serialization.StreamingContext context, System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit serObjectInfoInit, System.Runtime.Serialization.IFormatterConverter converter, System.Runtime.Serialization.Formatters.Binary.ObjectWriter objectWriter, System.Runtime.Serialization.SerializationBinder binder);
                        static /*0x31a11fc*/ System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo Serialize(System.Type objectType, System.Runtime.Serialization.ISurrogateSelector surrogateSelector, System.Runtime.Serialization.StreamingContext context, System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit serObjectInfoInit, System.Runtime.Serialization.IFormatterConverter converter, System.Runtime.Serialization.SerializationBinder binder);
                        static /*0x31a0d7c*/ void CheckTypeForwardedFrom(System.Runtime.Serialization.Formatters.Binary.SerObjectInfoCache cache, System.Type objectType, string binderAssemblyString);
                        static /*0x31a02d0*/ System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo GetObjectInfo(System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit serObjectInfoInit);
                        static /*0x31a01a0*/ void PutObjectInfo(System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit serObjectInfoInit, System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo);
                        /*0x31a018c*/ WriteObjectInfo();
                        /*0x31a0194*/ void ObjectEnd();
                        /*0x31a01c0*/ void InternalInit();
                        /*0x31a039c*/ void InitSerialize(object obj, System.Runtime.Serialization.ISurrogateSelector surrogateSelector, System.Runtime.Serialization.StreamingContext context, System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit serObjectInfoInit, System.Runtime.Serialization.IFormatterConverter converter, System.Runtime.Serialization.Formatters.Binary.ObjectWriter objectWriter, System.Runtime.Serialization.SerializationBinder binder);
                        /*0x31a1284*/ void InitSerialize(System.Type objectType, System.Runtime.Serialization.ISurrogateSelector surrogateSelector, System.Runtime.Serialization.StreamingContext context, System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit serObjectInfoInit, System.Runtime.Serialization.IFormatterConverter converter, System.Runtime.Serialization.SerializationBinder binder);
                        /*0x31a0a44*/ void InitSiWrite();
                        /*0x31a0900*/ void InitNoMembers();
                        /*0x31a0ed4*/ void InitMemberInfo();
                        /*0x319690c*/ string GetTypeFullName();
                        /*0x31968e4*/ string GetAssemblyString();
                        /*0x31a0a1c*/ void InvokeSerializationBinder(System.Runtime.Serialization.SerializationBinder binder);
                        /*0x31a16d4*/ System.Type GetMemberType(System.Reflection.MemberInfo objMember);
                        /*0x31a1844*/ void GetMemberInfo(ref string[] outMemberNames, ref System.Type[] outMemberTypes, ref object[] outMemberData);
                    }

                    class ReadObjectInfo
                    {
                        static /*0x0*/ int readObjectInfoCounter;
                        /*0x10*/ int objectInfoId;
                        /*0x18*/ System.Type objectType;
                        /*0x20*/ System.Runtime.Serialization.ObjectManager objectManager;
                        /*0x28*/ int count;
                        /*0x2c*/ bool isSi;
                        /*0x2d*/ bool isNamed;
                        /*0x2e*/ bool isTyped;
                        /*0x2f*/ bool bSimpleAssembly;
                        /*0x30*/ System.Runtime.Serialization.Formatters.Binary.SerObjectInfoCache cache;
                        /*0x38*/ string[] wireMemberNames;
                        /*0x40*/ System.Type[] wireMemberTypes;
                        /*0x48*/ int lastPosition;
                        /*0x50*/ System.Runtime.Serialization.ISerializationSurrogate serializationSurrogate;
                        /*0x58*/ System.Runtime.Serialization.StreamingContext context;
                        /*0x68*/ System.Collections.Generic.List<System.Type> memberTypesList;
                        /*0x70*/ System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit serObjectInfoInit;
                        /*0x78*/ System.Runtime.Serialization.IFormatterConverter formatterConverter;

                        static /*0x31a1918*/ System.Runtime.Serialization.Formatters.Binary.ReadObjectInfo Create(System.Type objectType, System.Runtime.Serialization.ISurrogateSelector surrogateSelector, System.Runtime.Serialization.StreamingContext context, System.Runtime.Serialization.ObjectManager objectManager, System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit serObjectInfoInit, System.Runtime.Serialization.IFormatterConverter converter, bool bSimpleAssembly);
                        static /*0x31a1c80*/ System.Runtime.Serialization.Formatters.Binary.ReadObjectInfo Create(System.Type objectType, string[] memberNames, System.Type[] memberTypes, System.Runtime.Serialization.ISurrogateSelector surrogateSelector, System.Runtime.Serialization.StreamingContext context, System.Runtime.Serialization.ObjectManager objectManager, System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit serObjectInfoInit, System.Runtime.Serialization.IFormatterConverter converter, bool bSimpleAssembly);
                        static /*0x31a19a8*/ System.Runtime.Serialization.Formatters.Binary.ReadObjectInfo GetObjectInfo(System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit serObjectInfoInit);
                        /*0x31a190c*/ ReadObjectInfo();
                        /*0x31a1914*/ void ObjectEnd();
                        /*0x319b240*/ void PrepareForReuse();
                        /*0x31a1a1c*/ void Init(System.Type objectType, System.Runtime.Serialization.ISurrogateSelector surrogateSelector, System.Runtime.Serialization.StreamingContext context, System.Runtime.Serialization.ObjectManager objectManager, System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit serObjectInfoInit, System.Runtime.Serialization.IFormatterConverter converter, bool bSimpleAssembly);
                        /*0x31a1d1c*/ void Init(System.Type objectType, string[] memberNames, System.Type[] memberTypes, System.Runtime.Serialization.ISurrogateSelector surrogateSelector, System.Runtime.Serialization.StreamingContext context, System.Runtime.Serialization.ObjectManager objectManager, System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit serObjectInfoInit, System.Runtime.Serialization.IFormatterConverter converter, bool bSimpleAssembly);
                        /*0x31a1ad0*/ void InitReadConstructor(System.Type objectType, System.Runtime.Serialization.ISurrogateSelector surrogateSelector, System.Runtime.Serialization.StreamingContext context);
                        /*0x31a1e9c*/ void InitSiRead();
                        /*0x31a1e38*/ void InitNoMembers();
                        /*0x31a1f28*/ void InitMemberInfo();
                        /*0x31a22e4*/ System.Reflection.MemberInfo GetMemberInfo(string name);
                        /*0x31a25a8*/ System.Type GetType(string name);
                        /*0x31a2744*/ void AddValue(string name, object value, ref System.Runtime.Serialization.SerializationInfo si, ref object[] memberData);
                        /*0x319b154*/ void InitDataStore(ref System.Runtime.Serialization.SerializationInfo si, ref object[] memberData);
                        /*0x31a27ec*/ void RecordFixup(long objectId, string name, long idRef);
                        /*0x31a2890*/ void PopulateObjectMembers(object obj, object[] memberData);
                        /*0x31a2474*/ int Position(string name);
                        /*0x319a880*/ System.Type[] GetMemberTypes(string[] inMemberNames, System.Type objectType);
                        /*0x31a2174*/ System.Type GetMemberType(System.Reflection.MemberInfo objMember);
                    }

                    class SerObjectInfoInit
                    {
                        /*0x10*/ System.Collections.Hashtable seenBeforeTable;
                        /*0x18*/ int objectInfoIdCount;
                        /*0x20*/ System.Runtime.Serialization.Formatters.Binary.SerStack oiPool;

                        /*0x31a292c*/ SerObjectInfoInit();
                    }

                    class SerObjectInfoCache
                    {
                        /*0x10*/ string fullTypeName;
                        /*0x18*/ string assemblyString;
                        /*0x20*/ bool hasTypeForwardedFrom;
                        /*0x28*/ System.Reflection.MemberInfo[] memberInfos;
                        /*0x30*/ string[] memberNames;
                        /*0x38*/ System.Type[] memberTypes;

                        /*0x31a167c*/ SerObjectInfoCache(string typeName, string assemblyName, bool hasTypeForwardedFrom);
                        /*0x31a15d8*/ SerObjectInfoCache(System.Type type);
                    }

                    class TypeInformation
                    {
                        /*0x10*/ string fullTypeName;
                        /*0x18*/ string assemblyString;
                        /*0x20*/ bool hasTypeForwardedFrom;

                        /*0x319e680*/ TypeInformation(string fullTypeName, string assemblyString, bool hasTypeForwardedFrom);
                        /*0x31a29f8*/ string get_FullTypeName();
                        /*0x31a2a00*/ string get_AssemblyString();
                        /*0x31a2a08*/ bool get_HasTypeForwardedFrom();
                    }

                    class ObjectReader
                    {
                        /*0x10*/ System.IO.Stream m_stream;
                        /*0x18*/ System.Runtime.Serialization.ISurrogateSelector m_surrogates;
                        /*0x20*/ System.Runtime.Serialization.StreamingContext m_context;
                        /*0x30*/ System.Runtime.Serialization.ObjectManager m_objectManager;
                        /*0x38*/ System.Runtime.Serialization.Formatters.Binary.InternalFE formatterEnums;
                        /*0x40*/ System.Runtime.Serialization.SerializationBinder m_binder;
                        /*0x48*/ long topId;
                        /*0x50*/ bool bSimpleAssembly;
                        /*0x58*/ object handlerObject;
                        /*0x60*/ object m_topObject;
                        /*0x68*/ System.Runtime.Remoting.Messaging.Header[] headers;
                        /*0x70*/ System.Runtime.Remoting.Messaging.HeaderHandler handler;
                        /*0x78*/ System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit serObjectInfoInit;
                        /*0x80*/ System.Runtime.Serialization.IFormatterConverter m_formatterConverter;
                        /*0x88*/ System.Runtime.Serialization.Formatters.Binary.SerStack stack;
                        /*0x90*/ System.Runtime.Serialization.Formatters.Binary.SerStack valueFixupStack;
                        /*0x98*/ object[] crossAppDomainArray;
                        /*0xa0*/ bool bFullDeserialization;
                        /*0xa1*/ bool bOldFormatDetected;
                        /*0xa8*/ System.Runtime.Serialization.Formatters.Binary.IntSizedArray valTypeObjectIdTable;
                        /*0xb0*/ System.Runtime.Serialization.Formatters.Binary.NameCache typeCache;
                        /*0xb8*/ string previousAssemblyString;
                        /*0xc0*/ string previousName;
                        /*0xc8*/ System.Type previousType;

                        static /*0x31a5810*/ System.Reflection.Assembly ResolveSimpleAssemblyName(System.Reflection.AssemblyName assemblyName);
                        static /*0x31a5870*/ void GetSimplyNamedTypeFromAssembly(System.Reflection.Assembly assm, string typeName, ref System.Type type);
                        static /*0x31a5acc*/ void CheckTypeForwardedTo(System.Reflection.Assembly sourceAssembly, System.Reflection.Assembly destAssembly, System.Type resolvedType);
                        /*0x319d5e4*/ ObjectReader(System.IO.Stream stream, System.Runtime.Serialization.ISurrogateSelector selector, System.Runtime.Serialization.StreamingContext context, System.Runtime.Serialization.Formatters.Binary.InternalFE formatterEnums, System.Runtime.Serialization.SerializationBinder binder);
                        /*0x31a2a10*/ System.Runtime.Serialization.Formatters.Binary.SerStack get_ValueFixupStack();
                        /*0x31a2a98*/ object get_TopObject();
                        /*0x31a2aa0*/ void set_TopObject(object value);
                        /*0x319d878*/ object Deserialize(System.Runtime.Remoting.Messaging.HeaderHandler handler, System.Runtime.Serialization.Formatters.Binary.__BinaryParser serParser, bool fCheck);
                        /*0x31a3058*/ bool HasSurrogate(System.Type t);
                        /*0x31a312c*/ void CheckSerializable(System.Type t);
                        /*0x31a325c*/ void InitFullDeserialization();
                        /*0x31a3388*/ object CrossAppDomainArray(int index);
                        /*0x319a850*/ System.Runtime.Serialization.Formatters.Binary.ReadObjectInfo CreateReadObjectInfo(System.Type objectType);
                        /*0x319b0d4*/ System.Runtime.Serialization.Formatters.Binary.ReadObjectInfo CreateReadObjectInfo(System.Type objectType, string[] memberNames, System.Type[] memberTypes);
                        /*0x31a33b8*/ void Parse(System.Runtime.Serialization.Formatters.Binary.ParseRecord pr);
                        /*0x31a4098*/ void ParseError(System.Runtime.Serialization.Formatters.Binary.ParseRecord processing, System.Runtime.Serialization.Formatters.Binary.ParseRecord onStack);
                        /*0x31a3524*/ void ParseSerializedStreamHeader(System.Runtime.Serialization.Formatters.Binary.ParseRecord pr);
                        /*0x31a353c*/ void ParseSerializedStreamHeaderEnd(System.Runtime.Serialization.Formatters.Binary.ParseRecord pr);
                        /*0x31a3554*/ void ParseObject(System.Runtime.Serialization.Formatters.Binary.ParseRecord pr);
                        /*0x31a38a8*/ void ParseObjectEnd(System.Runtime.Serialization.Formatters.Binary.ParseRecord pr);
                        /*0x31a42e4*/ void ParseArray(System.Runtime.Serialization.Formatters.Binary.ParseRecord pr);
                        /*0x31a49f8*/ void NextRectangleMap(System.Runtime.Serialization.Formatters.Binary.ParseRecord pr);
                        /*0x31a4ac4*/ void ParseArrayMember(System.Runtime.Serialization.Formatters.Binary.ParseRecord pr);
                        /*0x31a5298*/ void ParseArrayMemberEnd(System.Runtime.Serialization.Formatters.Binary.ParseRecord pr);
                        /*0x31a3ad8*/ void ParseMember(System.Runtime.Serialization.Formatters.Binary.ParseRecord pr);
                        /*0x31a3fd0*/ void ParseMemberEnd(System.Runtime.Serialization.Formatters.Binary.ParseRecord pr);
                        /*0x31a5260*/ void ParseString(System.Runtime.Serialization.Formatters.Binary.ParseRecord pr, System.Runtime.Serialization.Formatters.Binary.ParseRecord parentPr);
                        /*0x31a49f0*/ void RegisterObject(object obj, System.Runtime.Serialization.Formatters.Binary.ParseRecord pr, System.Runtime.Serialization.Formatters.Binary.ParseRecord objectPr);
                        /*0x31a52b8*/ void RegisterObject(object obj, System.Runtime.Serialization.Formatters.Binary.ParseRecord pr, System.Runtime.Serialization.Formatters.Binary.ParseRecord objectPr, bool bIsString);
                        /*0x31a53c8*/ long GetId(long objectId);
                        /*0x31a54bc*/ System.Type Bind(string assemblyString, string typeString);
                        /*0x31a5514*/ System.Type FastBindToType(string assemblyName, string typeName);
                        /*0x3197714*/ System.Type GetType(System.Runtime.Serialization.Formatters.Binary.BinaryAssemblyInfo assemblyInfo, string name);

                        class TypeNAssembly
                        {
                            /*0x10*/ System.Type type;
                            /*0x18*/ string assemblyName;

                            /*0x31a5c0c*/ TypeNAssembly();
                        }

                        class TopLevelAssemblyTypeResolver
                        {
                            /*0x10*/ System.Reflection.Assembly m_topLevelAssembly;

                            /*0x31a5c14*/ TopLevelAssemblyTypeResolver(System.Reflection.Assembly topLevelAssembly);
                            /*0x31a5c44*/ System.Type ResolveType(System.Reflection.Assembly assembly, string simpleTypeName, bool ignoreCase);
                        }
                    }

                    class ObjectWriter
                    {
                        /*0x10*/ System.Collections.Queue m_objectQueue;
                        /*0x18*/ System.Runtime.Serialization.ObjectIDGenerator m_idGenerator;
                        /*0x20*/ int m_currentId;
                        /*0x28*/ System.Runtime.Serialization.ISurrogateSelector m_surrogates;
                        /*0x30*/ System.Runtime.Serialization.StreamingContext m_context;
                        /*0x40*/ System.Runtime.Serialization.Formatters.Binary.__BinaryWriter serWriter;
                        /*0x48*/ System.Runtime.Serialization.SerializationObjectManager m_objectManager;
                        /*0x50*/ long topId;
                        /*0x58*/ string topName;
                        /*0x60*/ System.Runtime.Remoting.Messaging.Header[] headers;
                        /*0x68*/ System.Runtime.Serialization.Formatters.Binary.InternalFE formatterEnums;
                        /*0x70*/ System.Runtime.Serialization.SerializationBinder m_binder;
                        /*0x78*/ System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit serObjectInfoInit;
                        /*0x80*/ System.Runtime.Serialization.IFormatterConverter m_formatterConverter;
                        /*0x88*/ object[] crossAppDomainArray;
                        /*0x90*/ object previousObj;
                        /*0x98*/ long previousId;
                        /*0xa0*/ System.Type previousType;
                        /*0xa8*/ System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE previousCode;
                        /*0xb0*/ System.Collections.Hashtable assemblyToIdTable;
                        /*0xb8*/ System.Runtime.Serialization.Formatters.Binary.SerStack niPool;

                        /*0x319ddf8*/ ObjectWriter(System.Runtime.Serialization.ISurrogateSelector selector, System.Runtime.Serialization.StreamingContext context, System.Runtime.Serialization.Formatters.Binary.InternalFE formatterEnums, System.Runtime.Serialization.SerializationBinder binder);
                        /*0x319e00c*/ void Serialize(object graph, System.Runtime.Remoting.Messaging.Header[] inHeaders, System.Runtime.Serialization.Formatters.Binary.__BinaryWriter serWriter, bool fCheck);
                        /*0x31a651c*/ System.Runtime.Serialization.SerializationObjectManager get_ObjectManager();
                        /*0x31a5ffc*/ void Write(System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo typeNameInfo);
                        /*0x31a6c5c*/ void Write(System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo typeNameInfo, string[] memberNames, System.Type[] memberTypes, object[] memberData, System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo[] memberObjectInfos);
                        /*0x31a6ee0*/ void WriteMemberSetup(System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo typeNameInfo, string memberName, System.Type memberType, object memberData, System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo memberObjectInfo);
                        /*0x31a7020*/ void WriteMembers(System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo memberTypeNameInfo, object memberData, System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo typeNameInfo, System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo memberObjectInfo);
                        /*0x31a6524*/ void WriteArray(System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo memberObjectInfo);
                        /*0x31a7628*/ void WriteArrayMember(System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo arrayElemTypeNameInfo, object data);
                        /*0x31a78c8*/ void WriteRectangle(System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo, int rank, int[] maxA, System.Array array, System.Runtime.Serialization.Formatters.Binary.NameInfo arrayElemNameTypeInfo, int[] lowerBoundA);
                        /*0x31a63ac*/ object GetNext(ref long objID);
                        /*0x31a5cc8*/ long InternalGetId(object obj, bool assignUniqueIdToValueType, System.Type type, ref bool isNew);
                        /*0x31a7b10*/ long Schedule(object obj, bool assignUniqueIdToValueType, System.Type type);
                        /*0x31a74a0*/ long Schedule(object obj, bool assignUniqueIdToValueType, System.Type type, System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo);
                        /*0x31a753c*/ bool WriteKnownValueClass(System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo typeNameInfo, object data);
                        /*0x31a7528*/ void WriteObjectRef(System.Runtime.Serialization.Formatters.Binary.NameInfo nameInfo, long objectId);
                        /*0x31a7b18*/ void WriteString(System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo typeNameInfo, object stringObject);
                        /*0x31a7358*/ bool CheckForNull(System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo typeNameInfo, object data);
                        /*0x31a5cac*/ void WriteSerializedStreamHeader(long topId, long headerId);
                        /*0x31a7be4*/ System.Runtime.Serialization.Formatters.Binary.NameInfo TypeToNameInfo(System.Type type, System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo, System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE code, System.Runtime.Serialization.Formatters.Binary.NameInfo nameInfo);
                        /*0x31a6fec*/ System.Runtime.Serialization.Formatters.Binary.NameInfo TypeToNameInfo(System.Type type);
                        /*0x31a5fb8*/ System.Runtime.Serialization.Formatters.Binary.NameInfo TypeToNameInfo(System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo);
                        /*0x31a7450*/ System.Runtime.Serialization.Formatters.Binary.NameInfo TypeToNameInfo(System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo nameInfo);
                        /*0x31a7418*/ void TypeToNameInfo(System.Type type, System.Runtime.Serialization.Formatters.Binary.NameInfo nameInfo);
                        /*0x31a6ea8*/ System.Runtime.Serialization.Formatters.Binary.NameInfo MemberToNameInfo(string name);
                        /*0x3196848*/ System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE ToCode(System.Type type);
                        /*0x31a5da8*/ long GetAssemblyId(System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo);
                        /*0x31a6c44*/ System.Type GetType(object obj);
                        /*0x31a7c8c*/ System.Runtime.Serialization.Formatters.Binary.NameInfo GetNameInfo();
                        /*0x31a6c38*/ bool CheckTypeFormat(System.Runtime.Serialization.Formatters.FormatterTypeStyle test, System.Runtime.Serialization.Formatters.FormatterTypeStyle want);
                        /*0x31a6394*/ void PutNameInfo(System.Runtime.Serialization.Formatters.Binary.NameInfo nameInfo);
                    }

                    class __BinaryParser
                    {
                        static /*0x0*/ System.Text.Encoding encoding;
                        static /*0x8*/ System.Runtime.Serialization.Formatters.Binary.MessageEnd messageEnd;
                        /*0x10*/ System.Runtime.Serialization.Formatters.Binary.ObjectReader objectReader;
                        /*0x18*/ System.IO.Stream input;
                        /*0x20*/ long topId;
                        /*0x28*/ long headerId;
                        /*0x30*/ System.Runtime.Serialization.Formatters.Binary.SizedArray objectMapIdTable;
                        /*0x38*/ System.Runtime.Serialization.Formatters.Binary.SizedArray assemIdToAssemblyTable;
                        /*0x40*/ System.Runtime.Serialization.Formatters.Binary.SerStack stack;
                        /*0x48*/ System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum expectedType;
                        /*0x50*/ object expectedTypeInformation;
                        /*0x58*/ System.Runtime.Serialization.Formatters.Binary.ParseRecord PRS;
                        /*0x60*/ System.Runtime.Serialization.Formatters.Binary.BinaryAssemblyInfo systemAssemblyInfo;
                        /*0x68*/ System.IO.BinaryReader dataReader;
                        /*0x70*/ System.Runtime.Serialization.Formatters.Binary.SerStack opPool;
                        /*0x78*/ System.Runtime.Serialization.Formatters.Binary.BinaryObject binaryObject;
                        /*0x80*/ System.Runtime.Serialization.Formatters.Binary.BinaryObjectWithMap bowm;
                        /*0x88*/ System.Runtime.Serialization.Formatters.Binary.BinaryObjectWithMapTyped bowmt;
                        /*0x90*/ System.Runtime.Serialization.Formatters.Binary.BinaryObjectString objectString;
                        /*0x98*/ System.Runtime.Serialization.Formatters.Binary.BinaryCrossAppDomainString crossAppDomainString;
                        /*0xa0*/ System.Runtime.Serialization.Formatters.Binary.MemberPrimitiveTyped memberPrimitiveTyped;
                        /*0xa8*/ byte[] byteBuffer;
                        /*0xb0*/ System.Runtime.Serialization.Formatters.Binary.MemberPrimitiveUnTyped memberPrimitiveUnTyped;
                        /*0xb8*/ System.Runtime.Serialization.Formatters.Binary.MemberReference memberReference;
                        /*0xc0*/ System.Runtime.Serialization.Formatters.Binary.ObjectNull objectNull;

                        static /*0x31aaec8*/ __BinaryParser();
                        /*0x319d73c*/ __BinaryParser(System.IO.Stream stream, System.Runtime.Serialization.Formatters.Binary.ObjectReader objectReader);
                        /*0x31a7d44*/ System.Runtime.Serialization.Formatters.Binary.BinaryAssemblyInfo get_SystemAssemblyInfo();
                        /*0x31a7df0*/ System.Runtime.Serialization.Formatters.Binary.SizedArray get_ObjectMapIdTable();
                        /*0x31a7e60*/ System.Runtime.Serialization.Formatters.Binary.SizedArray get_AssemIdToAssemblyTable();
                        /*0x31a7ed4*/ System.Runtime.Serialization.Formatters.Binary.ParseRecord get_prs();
                        /*0x31a2ae4*/ void Run();
                        /*0x31a7f44*/ void ReadBegin();
                        /*0x31a9c50*/ void ReadEnd();
                        /*0x31a9f70*/ bool ReadBoolean();
                        /*0x31970c8*/ byte ReadByte();
                        /*0x3198664*/ byte[] ReadBytes(int length);
                        /*0x31a9f8c*/ void ReadBytes(byte[] byteA, int offset, int size);
                        /*0x31aa008*/ char ReadChar();
                        /*0x31aa024*/ char[] ReadChars(int length);
                        /*0x31aa044*/ decimal ReadDecimal();
                        /*0x31aa0f8*/ float ReadSingle();
                        /*0x31aa118*/ double ReadDouble();
                        /*0x31aa138*/ short ReadInt16();
                        /*0x3197104*/ int ReadInt32();
                        /*0x31aa158*/ long ReadInt64();
                        /*0x31aa178*/ sbyte ReadSByte();
                        /*0x31970e4*/ string ReadString();
                        /*0x31aa194*/ System.TimeSpan ReadTimeSpan();
                        /*0x31aa1b4*/ System.DateTime ReadDateTime();
                        /*0x31aa230*/ ushort ReadUInt16();
                        /*0x31aa250*/ uint ReadUInt32();
                        /*0x31aa270*/ ulong ReadUInt64();
                        /*0x31a7f48*/ void ReadSerializationHeaderRecord();
                        /*0x31a8004*/ void ReadAssembly(System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum binaryHeaderEnum);
                        /*0x31a8274*/ void ReadObject();
                        /*0x31a863c*/ void ReadCrossAppDomainMap();
                        /*0x31a87d8*/ void ReadObjectWithMap(System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum binaryHeaderEnum);
                        /*0x31aa338*/ void ReadObjectWithMap(System.Runtime.Serialization.Formatters.Binary.BinaryObjectWithMap record);
                        /*0x31a8880*/ void ReadObjectWithMapTyped(System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum binaryHeaderEnum);
                        /*0x31aa7a8*/ void ReadObjectWithMapTyped(System.Runtime.Serialization.Formatters.Binary.BinaryObjectWithMapTyped record);
                        /*0x31a8924*/ void ReadObjectString(System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum binaryHeaderEnum);
                        /*0x31a942c*/ void ReadMemberPrimitiveTyped();
                        /*0x31a8e74*/ void ReadArray(System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum binaryHeaderEnum);
                        /*0x31aac44*/ void ReadArrayAsBytes(System.Runtime.Serialization.Formatters.Binary.ParseRecord pr);
                        /*0x31a9c54*/ void ReadMemberPrimitiveUnTyped();
                        /*0x31a9788*/ void ReadMemberReference();
                        /*0x31a9938*/ void ReadObjectNull(System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum binaryHeaderEnum);
                        /*0x31a9afc*/ void ReadMessageEnd();
                        /*0x3198e74*/ object ReadValue(System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE code);
                        /*0x31aa290*/ System.Runtime.Serialization.Formatters.Binary.ObjectProgress GetOp();
                        /*0x31a9ed4*/ void PutOp(System.Runtime.Serialization.Formatters.Binary.ObjectProgress op);
                    }

                    class ParseRecord
                    {
                        static /*0x0*/ int parseRecordIdCount;
                        /*0x10*/ System.Runtime.Serialization.Formatters.Binary.InternalParseTypeE PRparseTypeEnum;
                        /*0x14*/ System.Runtime.Serialization.Formatters.Binary.InternalObjectTypeE PRobjectTypeEnum;
                        /*0x18*/ System.Runtime.Serialization.Formatters.Binary.InternalArrayTypeE PRarrayTypeEnum;
                        /*0x1c*/ System.Runtime.Serialization.Formatters.Binary.InternalMemberTypeE PRmemberTypeEnum;
                        /*0x20*/ System.Runtime.Serialization.Formatters.Binary.InternalMemberValueE PRmemberValueEnum;
                        /*0x24*/ System.Runtime.Serialization.Formatters.Binary.InternalObjectPositionE PRobjectPositionEnum;
                        /*0x28*/ string PRname;
                        /*0x30*/ string PRvalue;
                        /*0x38*/ object PRvarValue;
                        /*0x40*/ string PRkeyDt;
                        /*0x48*/ System.Type PRdtType;
                        /*0x50*/ System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE PRdtTypeCode;
                        /*0x54*/ bool PRisEnum;
                        /*0x58*/ long PRobjectId;
                        /*0x60*/ long PRidRef;
                        /*0x68*/ string PRarrayElementTypeString;
                        /*0x70*/ System.Type PRarrayElementType;
                        /*0x78*/ bool PRisArrayVariant;
                        /*0x7c*/ System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE PRarrayElementTypeCode;
                        /*0x80*/ int PRrank;
                        /*0x88*/ int[] PRlengthA;
                        /*0x90*/ int[] PRpositionA;
                        /*0x98*/ int[] PRlowerBoundA;
                        /*0xa0*/ int[] PRupperBoundA;
                        /*0xa8*/ int[] PRindexMap;
                        /*0xb0*/ int PRmemberIndex;
                        /*0xb4*/ int PRlinearlength;
                        /*0xb8*/ int[] PRrectangularMap;
                        /*0xc0*/ bool PRisLowerBound;
                        /*0xc8*/ long PRtopId;
                        /*0xd0*/ long PRheaderId;
                        /*0xd8*/ System.Runtime.Serialization.Formatters.Binary.ReadObjectInfo PRobjectInfo;
                        /*0xe0*/ bool PRisValueTypeFixup;
                        /*0xe8*/ object PRnewObj;
                        /*0xf0*/ object[] PRobjectA;
                        /*0xf8*/ System.Runtime.Serialization.Formatters.Binary.PrimitiveArray PRprimitiveArray;
                        /*0x100*/ bool PRisRegistered;
                        /*0x108*/ object[] PRmemberData;
                        /*0x110*/ System.Runtime.Serialization.SerializationInfo PRsi;
                        /*0x118*/ int PRnullCount;

                        static /*0x31ab0b4*/ ParseRecord();
                        /*0x31aaf4c*/ ParseRecord();
                        /*0x31aaf54*/ void Init();
                    }

                    class SerStack
                    {
                        /*0x10*/ object[] objects;
                        /*0x18*/ string stackId;
                        /*0x20*/ int top;

                        /*0x31ab100*/ SerStack(string stackId);
                        /*0x31ab188*/ void Push(object obj);
                        /*0x31ab2c8*/ object Pop();
                        /*0x31ab238*/ void IncreaseCapacity();
                        /*0x31ab324*/ object Peek();
                        /*0x31ab364*/ object PeekPeek();
                        /*0x31ab3a8*/ bool IsEmpty();
                    }

                    class SizedArray : System.ICloneable
                    {
                        /*0x10*/ object[] objects;
                        /*0x18*/ object[] negObjects;

                        /*0x31ab3b8*/ SizedArray();
                        /*0x31ab438*/ SizedArray(int length);
                        /*0x31ab4c4*/ SizedArray(System.Runtime.Serialization.Formatters.Binary.SizedArray sizedArray);
                        /*0x31ab59c*/ object Clone();
                        /*0x31ab5f4*/ object get_Item(int index);
                        /*0x31ab668*/ void set_Item(int index, object value);
                        /*0x31ab778*/ void IncreaseCapacity(int index);
                    }

                    class IntSizedArray : System.ICloneable
                    {
                        /*0x10*/ int[] objects;
                        /*0x18*/ int[] negObjects;

                        /*0x31ab9b4*/ IntSizedArray();
                        /*0x31aba34*/ IntSizedArray(System.Runtime.Serialization.Formatters.Binary.IntSizedArray sizedArray);
                        /*0x31abb48*/ object Clone();
                        /*0x31abba0*/ int get_Item(int index);
                        /*0x31abc18*/ void set_Item(int index, int value);
                        /*0x31abcd0*/ void IncreaseCapacity(int index);
                    }

                    class NameCache
                    {
                        static /*0x0*/ System.Collections.Concurrent.ConcurrentDictionary<string, object> ht;
                        /*0x10*/ string name;

                        static /*0x31ac058*/ NameCache();
                        /*0x31ac050*/ NameCache();
                        /*0x31abf0c*/ object GetCachedValue(string name);
                        /*0x31abfc0*/ void SetCachedValue(object value);
                    }

                    class ValueFixup
                    {
                        static /*0x0*/ System.Reflection.MemberInfo valueInfo;
                        /*0x10*/ System.Runtime.Serialization.Formatters.Binary.ValueFixupEnum valueFixupEnum;
                        /*0x18*/ System.Array arrayObj;
                        /*0x20*/ int[] indexMap;
                        /*0x28*/ object header;
                        /*0x30*/ object memberObject;
                        /*0x38*/ System.Runtime.Serialization.Formatters.Binary.ReadObjectInfo objectInfo;
                        /*0x40*/ string memberName;

                        /*0x31ac0f0*/ ValueFixup(System.Array arrayObj, int[] indexMap);
                        /*0x31ac13c*/ ValueFixup(object memberObject, string memberName, System.Runtime.Serialization.Formatters.Binary.ReadObjectInfo objectInfo);
                        /*0x31ac1a4*/ void Fixup(System.Runtime.Serialization.Formatters.Binary.ParseRecord record, System.Runtime.Serialization.Formatters.Binary.ParseRecord parent);
                    }

                    class InternalFE
                    {
                        /*0x10*/ System.Runtime.Serialization.Formatters.FormatterTypeStyle FEtypeFormat;
                        /*0x14*/ System.Runtime.Serialization.Formatters.FormatterAssemblyStyle FEassemblyFormat;
                        /*0x18*/ System.Runtime.Serialization.Formatters.TypeFilterLevel FEsecurityLevel;
                        /*0x1c*/ System.Runtime.Serialization.Formatters.Binary.InternalSerializerTypeE FEserializerTypeEnum;

                        /*0x31ac7dc*/ InternalFE();
                    }

                    class NameInfo
                    {
                        /*0x10*/ string NIFullName;
                        /*0x18*/ long NIobjectId;
                        /*0x20*/ long NIassemId;
                        /*0x28*/ System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE NIprimitiveTypeEnum;
                        /*0x30*/ System.Type NItype;
                        /*0x38*/ bool NIisSealed;
                        /*0x39*/ bool NIisArray;
                        /*0x3a*/ bool NIisArrayItem;
                        /*0x3b*/ bool NItransmitTypeOnObject;
                        /*0x3c*/ bool NItransmitTypeOnMember;
                        /*0x3d*/ bool NIisParentTypeOnObject;
                        /*0x40*/ System.Runtime.Serialization.Formatters.Binary.InternalArrayTypeE NIarrayEnum;
                        /*0x44*/ bool NIsealedStatusChecked;

                        /*0x31ac7e4*/ NameInfo();
                        /*0x31ac7ec*/ void Init();
                        /*0x31ac830*/ bool get_IsSealed();
                        /*0x31ac880*/ string get_NIname();
                        /*0x31ac8cc*/ void set_NIname(string value);
                    }

                    class PrimitiveArray
                    {
                        /*0x10*/ System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE code;
                        /*0x18*/ bool[] booleanA;
                        /*0x20*/ char[] charA;
                        /*0x28*/ double[] doubleA;
                        /*0x30*/ short[] int16A;
                        /*0x38*/ int[] int32A;
                        /*0x40*/ long[] int64A;
                        /*0x48*/ sbyte[] sbyteA;
                        /*0x50*/ float[] singleA;
                        /*0x58*/ ushort[] uint16A;
                        /*0x60*/ uint[] uint32A;
                        /*0x68*/ ulong[] uint64A;

                        /*0x31ac8d4*/ PrimitiveArray(System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE code, System.Array array);
                        /*0x31ac908*/ void Init(System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE code, System.Array array);
                        /*0x31accd4*/ void SetValue(string value, int index);
                    }

                    enum MessageEnum
                    {
                        NoArgs = 1,
                        ArgsInline = 2,
                        ArgsIsArray = 4,
                        ArgsInArray = 8,
                        NoContext = 16,
                        ContextInline = 32,
                        ContextInArray = 64,
                        MethodSignatureInArray = 128,
                        PropertyInArray = 256,
                        NoReturnValue = 512,
                        ReturnValueVoid = 1024,
                        ReturnValueInline = 2048,
                        ReturnValueInArray = 4096,
                        ExceptionInArray = 8192,
                        GenericMethod = 32768,
                    }
                }
            }
        }

        namespace InteropServices
        {
            enum CharSet
            {
                None = 1,
                Ansi = 2,
                Unicode = 3,
                Auto = 4,
            }

            class ExternalException : System.SystemException
            {
                /*0x31ad104*/ ExternalException();
                /*0x31ad160*/ ExternalException(string message);
                /*0x31ad184*/ ExternalException(string message, System.Exception inner);
                /*0x31ad1a8*/ ExternalException(string message, int errorCode);
                /*0x31ad1d0*/ ExternalException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x31ad1d8*/ string ToString();
            }

            struct HandleRef
            {
                /*0x10*/ object _wrapper;
                /*0x18*/ nint _handle;

                /*0x31ad3c0*/ HandleRef(object wrapper, nint handle);
                /*0x31ad3e8*/ nint get_Handle();
            }

            class MarshalDirectiveException : System.SystemException
            {
                /*0x31ad3f0*/ MarshalDirectiveException();
                /*0x31ad44c*/ MarshalDirectiveException(string message);
                /*0x31ad470*/ MarshalDirectiveException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            }

            class MemoryMarshal
            {
                static /*0x1ffc854*/ System.Span<byte> AsBytes<T>(System.Span<T> span);
                static /*0x1ffc854*/ System.ReadOnlySpan<byte> AsBytes<T>(System.ReadOnlySpan<T> span);
                static /*0x1ffc854*/ System.Memory<T> AsMemory<T>(System.ReadOnlyMemory<T> memory);
                static /*0x1ffc854*/ ref T GetReference<T>(System.Span<T> span);
                static /*0x1ffc854*/ ref T GetReference<T>(System.ReadOnlySpan<T> span);
                static /*0x1ffc854*/ ref T GetNonNullPinnableReference<T>(System.Span<T> span);
                static /*0x1ffc854*/ ref T GetNonNullPinnableReference<T>(System.ReadOnlySpan<T> span);
                static /*0x1ffc854*/ System.Span<TTo> Cast<TFrom, TTo>(System.Span<TFrom> span);
                static /*0x1ffc854*/ System.ReadOnlySpan<TTo> Cast<TFrom, TTo>(System.ReadOnlySpan<TFrom> span);
                static /*0x1ffc854*/ System.ReadOnlySpan<T> CreateReadOnlySpan<T>(ref T reference, int length);
                static /*0x1ffc854*/ bool TryGetArray<T>(System.ReadOnlyMemory<T> memory, ref System.ArraySegment<T> segment);
                static /*0x1ffc854*/ System.Collections.Generic.IEnumerable<T> ToEnumerable<T>(System.ReadOnlyMemory<T> memory);
                static /*0x1ffc854*/ T Read<T>(System.ReadOnlySpan<byte> source);
                static /*0x1ffc854*/ void Write<T>(System.Span<byte> destination, ref T value);

                class <ToEnumerable>d__14<T> : System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.Collections.Generic.IEnumerator<T>, System.IDisposable, System.Collections.IEnumerator
                {
                    /*0x0*/ int <>1__state;
                    /*0x0*/ T <>2__current;
                    /*0x0*/ int <>l__initialThreadId;
                    /*0x0*/ System.ReadOnlyMemory<T> memory;
                    /*0x0*/ System.ReadOnlyMemory<T> <>3__memory;
                    /*0x0*/ int <i>5__2;

                    /*0x1f30b78*/ <ToEnumerable>d__14(int <>1__state);
                    /*0x1f309e4*/ void System.IDisposable.Dispose();
                    /*0x1f2fe14*/ bool MoveNext();
                    /*0x1ffc854*/ T System.Collections.Generic.IEnumerator<T>.get_Current();
                    /*0x1f309e4*/ void System.Collections.IEnumerator.Reset();
                    /*0x1f30214*/ object System.Collections.IEnumerator.get_Current();
                    /*0x1f30214*/ System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
                    /*0x1f30214*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                }
            }

            class SequenceMarshal
            {
                static /*0x31ad478*/ bool TryGetString(System.Buffers.ReadOnlySequence<char> sequence, ref string text, ref int start, ref int length);
            }

            enum GCHandleType
            {
                Weak = 0,
                WeakTrackResurrection = 1,
                Normal = 2,
                Pinned = 3,
            }

            class SafeBuffer : Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid
            {
                static /*0x0*/ nuint Uninitialized;
                /*0x20*/ nuint _numBytes;

                static /*0x31ad7b8*/ SafeBuffer();
                static /*0x31ad5e0*/ System.InvalidOperationException NotInitialized();
                /*0x31ad50c*/ void AcquirePointer(ref byte* pointer);
                /*0x31ad708*/ void ReleasePointer();
            }

            class COMException : System.Runtime.InteropServices.ExternalException
            {
                /*0x31ad824*/ COMException();
                /*0x31ad828*/ COMException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x31ad830*/ string ToString();
            }

            class ErrorWrapper
            {
                /*0x10*/ int m_ErrorCode;
            }

            interface ICustomMarshaler
            {
                object MarshalNativeToManaged(nint pNativeData);
                /*0x1ffc854*/ nint MarshalManagedToNative(object ManagedObj);
                void CleanUpNativeData(nint pNativeData);
                /*0x1f30ebc*/ void CleanUpManagedData(object ManagedObj);
                /*0x1f2ffc8*/ int GetNativeDataSize();
            }

            class UnmanagedFunctionPointerAttribute : System.Attribute
            {
                /*0x10*/ System.Runtime.InteropServices.CallingConvention m_callingConvention;

                /*0x31ada18*/ UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention callingConvention);
            }

            enum ComInterfaceType
            {
                InterfaceIsDual = 0,
                InterfaceIsIUnknown = 1,
                InterfaceIsIDispatch = 2,
                InterfaceIsIInspectable = 3,
            }

            class InterfaceTypeAttribute : System.Attribute
            {
                /*0x10*/ System.Runtime.InteropServices.ComInterfaceType _val;

                /*0x31ada40*/ InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType interfaceType);
            }

            class ComDefaultInterfaceAttribute : System.Attribute
            {
                /*0x10*/ System.Type _val;

                /*0x31ada68*/ ComDefaultInterfaceAttribute(System.Type defaultInterface);
            }

            enum ClassInterfaceType
            {
                None = 0,
                AutoDispatch = 1,
                AutoDual = 2,
            }

            class ClassInterfaceAttribute : System.Attribute
            {
                /*0x10*/ System.Runtime.InteropServices.ClassInterfaceType _val;

                /*0x31ada98*/ ClassInterfaceAttribute(System.Runtime.InteropServices.ClassInterfaceType classInterfaceType);
            }

            class ComVisibleAttribute : System.Attribute
            {
                /*0x10*/ bool _val;

                /*0x31adac0*/ ComVisibleAttribute(bool visibility);
            }

            enum VarEnum
            {
                VT_EMPTY = 0,
                VT_NULL = 1,
                VT_I2 = 2,
                VT_I4 = 3,
                VT_R4 = 4,
                VT_R8 = 5,
                VT_CY = 6,
                VT_DATE = 7,
                VT_BSTR = 8,
                VT_DISPATCH = 9,
                VT_ERROR = 10,
                VT_BOOL = 11,
                VT_VARIANT = 12,
                VT_UNKNOWN = 13,
                VT_DECIMAL = 14,
                VT_I1 = 16,
                VT_UI1 = 17,
                VT_UI2 = 18,
                VT_UI4 = 19,
                VT_I8 = 20,
                VT_UI8 = 21,
                VT_INT = 22,
                VT_UINT = 23,
                VT_VOID = 24,
                VT_HRESULT = 25,
                VT_PTR = 26,
                VT_SAFEARRAY = 27,
                VT_CARRAY = 28,
                VT_USERDEFINED = 29,
                VT_LPSTR = 30,
                VT_LPWSTR = 31,
                VT_RECORD = 36,
                VT_FILETIME = 64,
                VT_BLOB = 65,
                VT_STREAM = 66,
                VT_STORAGE = 67,
                VT_STREAMED_OBJECT = 68,
                VT_STORED_OBJECT = 69,
                VT_BLOB_OBJECT = 70,
                VT_CF = 71,
                VT_CLSID = 72,
                VT_VECTOR = 4096,
                VT_ARRAY = 8192,
                VT_BYREF = 16384,
            }

            enum UnmanagedType
            {
                Bool = 2,
                I1 = 3,
                U1 = 4,
                I2 = 5,
                U2 = 6,
                I4 = 7,
                U4 = 8,
                I8 = 9,
                U8 = 10,
                R4 = 11,
                R8 = 12,
                Currency = 15,
                BStr = 19,
                LPStr = 20,
                LPWStr = 21,
                LPTStr = 22,
                ByValTStr = 23,
                IUnknown = 25,
                IDispatch = 26,
                Struct = 27,
                Interface = 28,
                SafeArray = 29,
                ByValArray = 30,
                SysInt = 31,
                SysUInt = 32,
                VBByRefStr = 34,
                AnsiBStr = 35,
                TBStr = 36,
                VariantBool = 37,
                FunctionPtr = 38,
                AsAny = 40,
                LPArray = 42,
                LPStruct = 43,
                CustomMarshaler = 44,
                Error = 45,
                IInspectable = 46,
                HString = 47,
                LPUTF8Str = 48,
            }

            class ComImportAttribute : System.Attribute
            {
                /*0x31adae8*/ ComImportAttribute();
            }

            class GuidAttribute : System.Attribute
            {
                /*0x10*/ string _val;

                /*0x31adaf0*/ GuidAttribute(string guid);
            }

            class PreserveSigAttribute : System.Attribute
            {
                /*0x31adb20*/ PreserveSigAttribute();
            }

            class InAttribute : System.Attribute
            {
                /*0x31adb28*/ InAttribute();
            }

            class OutAttribute : System.Attribute
            {
                /*0x31adb30*/ OutAttribute();
            }

            class OptionalAttribute : System.Attribute
            {
                /*0x31adb38*/ OptionalAttribute();
            }

            enum DllImportSearchPath
            {
                UseDllDirectoryForDependencies = 256,
                ApplicationDirectory = 512,
                UserDirectories = 1024,
                System32 = 2048,
                SafeDirectories = 4096,
                AssemblyDirectory = 2,
                LegacyBehavior = 0,
            }

            class DefaultDllImportSearchPathsAttribute : System.Attribute
            {
                /*0x10*/ System.Runtime.InteropServices.DllImportSearchPath _paths;

                /*0x31adb40*/ DefaultDllImportSearchPathsAttribute(System.Runtime.InteropServices.DllImportSearchPath paths);
            }

            class DllImportAttribute : System.Attribute
            {
                /*0x10*/ string _val;
                /*0x18*/ string EntryPoint;
                /*0x20*/ System.Runtime.InteropServices.CharSet CharSet;
                /*0x24*/ bool SetLastError;
                /*0x25*/ bool ExactSpelling;
                /*0x26*/ bool PreserveSig;
                /*0x28*/ System.Runtime.InteropServices.CallingConvention CallingConvention;
                /*0x2c*/ bool BestFitMapping;
                /*0x2d*/ bool ThrowOnUnmappableChar;

                static /*0x31adb68*/ System.Attribute GetCustomAttribute(System.Reflection.RuntimeMethodInfo method);
                static /*0x31addb0*/ bool IsDefined(System.Reflection.RuntimeMethodInfo method);
                /*0x31add10*/ DllImportAttribute(string dllName, string entryPoint, System.Runtime.InteropServices.CharSet charSet, bool exactSpelling, bool setLastError, bool preserveSig, System.Runtime.InteropServices.CallingConvention callingConvention, bool bestFitMapping, bool throwOnUnmappableChar);
                /*0x31addd8*/ DllImportAttribute(string dllName);
                /*0x31ade08*/ string get_Value();
            }

            class FieldOffsetAttribute : System.Attribute
            {
                /*0x10*/ int _val;

                /*0x31ade10*/ FieldOffsetAttribute(int offset);
            }

            class ComCompatibleVersionAttribute : System.Attribute
            {
                /*0x10*/ int _major;
                /*0x14*/ int _minor;
                /*0x18*/ int _build;
                /*0x1c*/ int _revision;

                /*0x31ade38*/ ComCompatibleVersionAttribute(int major, int minor, int build, int revision);
            }

            enum CallingConvention
            {
                Winapi = 1,
                Cdecl = 2,
                StdCall = 3,
                ThisCall = 4,
                FastCall = 5,
            }

            class SafeHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.IDisposable
            {
                static int RefCount_Mask = 2147483644;
                static int RefCount_One = 4;
                /*0x10*/ nint handle;
                /*0x18*/ int _state;
                /*0x1c*/ bool _ownsHandle;
                /*0x1d*/ bool _fullyInitialized;

                /*0x31ade78*/ SafeHandle(nint invalidHandleValue, bool ownsHandle);
                /*0x31adf18*/ void Finalize();
                /*0x31adfa8*/ void SetHandle(nint handle);
                /*0x31adfb0*/ nint DangerousGetHandle();
                /*0x31adfb8*/ bool get_IsClosed();
                /*0x1f2fe14*/ bool get_IsInvalid();
                /*0x31adfc4*/ void Close();
                /*0x31adfd4*/ void Dispose();
                /*0x31adfe4*/ void Dispose(bool disposing);
                /*0x1f2fe14*/ bool ReleaseHandle();
                /*0x31ae0b4*/ void SetHandleAsInvalid();
                /*0x31ad64c*/ void DangerousAddRef(ref bool success);
                /*0x31ad7b0*/ void DangerousRelease();
                /*0x31ae000*/ void InternalDispose();
                /*0x31ae0a0*/ void InternalFinalize();
                /*0x31ae12c*/ void DangerousReleaseInternal(bool dispose);
            }

            struct GCHandle
            {
                /*0x10*/ nint handle;

                static /*0x31ae2d0*/ object GetRef(nint handle);
                static /*0x31ae2e8*/ void SetRef(nint handle, object value);
                static /*0x31ae308*/ bool CanDereferenceHandle(nint handle);
                static /*0x31ae4a8*/ System.Runtime.InteropServices.GCHandle Alloc(object value);
                static /*0x31ae4b4*/ System.Runtime.InteropServices.GCHandle Alloc(object value, System.Runtime.InteropServices.GCHandleType type);
                static /*0x31ae544*/ nint op_Explicit(System.Runtime.InteropServices.GCHandle value);
                static /*0x31ae548*/ System.Runtime.InteropServices.GCHandle op_Explicit(nint value);
                static /*0x31ae5e4*/ bool CheckCurrentDomain(nint handle);
                static /*0x31ae388*/ object GetTarget(nint handle);
                static /*0x31ae2bc*/ nint GetTargetHandle(object obj, nint handle, System.Runtime.InteropServices.GCHandleType type);
                static /*0x31ae540*/ void FreeHandle(nint handle);
                static /*0x31ae4a4*/ nint GetAddrOfPinnedObject(nint handle);
                static /*0x31ae5e8*/ bool op_Equality(System.Runtime.InteropServices.GCHandle a, System.Runtime.InteropServices.GCHandle b);
                static /*0x31ae674*/ System.Runtime.InteropServices.GCHandle FromIntPtr(nint value);
                static /*0x31ae678*/ nint ToIntPtr(System.Runtime.InteropServices.GCHandle value);
                /*0x31ae264*/ GCHandle(nint h);
                /*0x31ae26c*/ GCHandle(object obj);
                /*0x31ae290*/ GCHandle(object value, System.Runtime.InteropServices.GCHandleType type);
                /*0x31ae2c0*/ bool get_IsAllocated();
                /*0x31ae314*/ object get_Target();
                /*0x31ae38c*/ void set_Target(object value);
                /*0x31ae3e4*/ nint AddrOfPinnedObject();
                /*0x31ae4c8*/ void Free();
                /*0x31ae5f4*/ bool Equals(object o);
                /*0x31ae66c*/ int GetHashCode();
            }

            class Marshal
            {
                static /*0x0*/ int SystemMaxDBCSCharSize;
                static /*0x4*/ int SystemDefaultCharSize;
                static /*0x8*/ System.Collections.Generic.Dictionary<System.ValueTuple<System.Type, string>, System.Runtime.InteropServices.ICustomMarshaler> MarshalerInstanceCache;
                static /*0x10*/ object MarshalerInstanceCacheLock;

                static /*0x31b08e8*/ Marshal();
                static /*0x31ae67c*/ nint AllocCoTaskMem(int cb);
                static /*0x31ae680*/ nint AllocHGlobal(nint cb);
                static /*0x31ae684*/ nint AllocHGlobal(int cb);
                static /*0x31ae6ec*/ void copy_to_unmanaged_fixed(System.Array source, int startIndex, nint destination, int length, void* fixed_source_element);
                static /*0x31ae6f0*/ bool skip_fixed(System.Array array, int startIndex);
                static /*0x31ae724*/ void copy_to_unmanaged(byte[] source, int startIndex, nint destination, int length);
                static /*0x31ae808*/ void copy_to_unmanaged(char[] source, int startIndex, nint destination, int length);
                static /*0x31ae8ec*/ void Copy(byte[] source, int startIndex, nint destination, int length);
                static /*0x31ae9dc*/ void Copy(char[] source, int startIndex, nint destination, int length);
                static /*0x31aeacc*/ void copy_from_unmanaged(nint source, int startIndex, System.Array destination, int length);
                static /*0x31aeb4c*/ void copy_from_unmanaged_fixed(nint source, int startIndex, System.Array destination, int length, void* fixed_destination_element);
                static /*0x31aeb50*/ void Copy(nint source, byte[] destination, int startIndex, int length);
                static /*0x31aec40*/ void Copy(nint source, char[] destination, int startIndex, int length);
                static /*0x31aed30*/ void DestroyStructure(nint ptr, System.Type structuretype);
                static /*0x31aed34*/ void FreeBSTR(nint ptr);
                static /*0x31aed38*/ void FreeCoTaskMem(nint ptr);
                static /*0x31aed3c*/ void FreeHGlobal(nint hglobal);
                static /*0x31aed40*/ void ClearBSTR(nint ptr);
                static /*0x31aee58*/ void ZeroFreeBSTR(nint s);
                static /*0x31aeeb4*/ void ClearAnsi(nint ptr);
                static /*0x31aef6c*/ void ClearUnicode(nint ptr);
                static /*0x31af088*/ void ZeroFreeGlobalAllocAnsi(nint s);
                static /*0x31af0e4*/ void ZeroFreeGlobalAllocUnicode(nint s);
                static /*0x31af140*/ int GetHRForException(System.Exception e);
                static /*0x31af14c*/ bool IsComObject(object o);
                static /*0x31af154*/ int GetLastWin32Error();
                static /*0x31af158*/ string PtrToStringAnsi(nint ptr);
                static /*0x31af15c*/ string PtrToStringUni(nint ptr);
                static /*0x31af160*/ object PtrToStructure(nint ptr, System.Type structureType);
                static /*0x1ffc854*/ T PtrToStructure<T>(nint ptr);
                static /*0x31aef50*/ byte ReadByte(nint ptr, int ofs);
                static /*0x31af044*/ short ReadInt16(nint ptr, int ofs);
                static /*0x31af164*/ int ReadInt32(nint ptr);
                static /*0x31aedec*/ int ReadInt32(nint ptr, int ofs);
                static /*0x31af1a0*/ long ReadInt64(nint ptr);
                static /*0x31af1fc*/ long ReadInt64(nint ptr, int ofs);
                static /*0x31af244*/ nint ReadIntPtr(nint ptr);
                static /*0x31af2d4*/ nint ReadIntPtr(nint ptr, int ofs);
                static /*0x31af37c*/ int SizeOf(System.Type t);
                static /*0x1f31da0*/ int SizeOf<T>();
                static /*0x1ffc854*/ int SizeOf<T>(T structure);
                static /*0x31af380*/ nint StringToHGlobalAnsi(char* s, int length);
                static /*0x31af384*/ nint StringToHGlobalAnsi(string s);
                static /*0x31af3f8*/ nint SecureStringToBSTR(System.Security.SecureString s);
                static /*0x31af538*/ nint SecureStringGlobalAllocator(int len);
                static /*0x31af58c*/ nint SecureStringToUnicode(System.Security.SecureString s, System.Runtime.InteropServices.Marshal.SecureStringAllocator allocator);
                static /*0x31af810*/ nint SecureStringToGlobalAllocUnicode(System.Security.SecureString s);
                static /*0x31af994*/ void StructureToPtr(object structure, nint ptr, bool fDeleteOld);
                static /*0x1ffc854*/ void StructureToPtr<T>(T structure, nint ptr, bool fDeleteOld);
                static /*0x31af534*/ nint BufferToBSTR(char* ptr, int slen);
                static /*0x31af998*/ nint UnsafeAddrOfPinnedArrayElement(System.Array arr, int index);
                static /*0x1f325b8*/ nint UnsafeAddrOfPinnedArrayElement<T>(T[] arr, int index);
                static /*0x31aee34*/ void WriteByte(nint ptr, int ofs, byte val);
                static /*0x31af99c*/ void WriteInt16(nint ptr, short val);
                static /*0x31aeffc*/ void WriteInt16(nint ptr, int ofs, short val);
                static /*0x31af9dc*/ void WriteInt32(nint ptr, int val);
                static /*0x31afa20*/ void WriteInt32(nint ptr, int ofs, int val);
                static /*0x31afa6c*/ void WriteInt64(nint ptr, long val);
                static /*0x31afab0*/ void WriteInt64(nint ptr, int ofs, long val);
                static /*0x31afafc*/ void WriteIntPtr(nint ptr, nint val);
                static /*0x31afbb4*/ void WriteIntPtr(nint ptr, int ofs, nint val);
                static /*0x31afc84*/ System.Delegate GetDelegateForFunctionPointerInternal(nint ptr, System.Type t);
                static /*0x31afc88*/ System.Delegate GetDelegateForFunctionPointer(nint ptr, System.Type t);
                static /*0x1ffc854*/ TDelegate GetDelegateForFunctionPointer<TDelegate>(nint ptr);
                static /*0x31afea4*/ nint GetFunctionPointerForDelegateInternal(System.Delegate d);
                static /*0x31afea8*/ nint GetFunctionPointerForDelegate(System.Delegate d);
                static /*0x1ffc854*/ nint GetFunctionPointerForDelegate<TDelegate>(TDelegate d);
                static /*0x31aff48*/ System.Runtime.InteropServices.ICustomMarshaler GetCustomMarshalerInstance(System.Type type, string cookie);

                class SecureStringAllocator : System.MulticastDelegate
                {
                    /*0x31af8f4*/ SecureStringAllocator(object object, nint method);
                    /*0x31b098c*/ nint Invoke(int len);
                }

                class MarshalerInstanceKeyComparer : System.Collections.Generic.IEqualityComparer<System.ValueTuple<System.Type, string>>
                {
                    /*0x31b0a68*/ MarshalerInstanceKeyComparer();
                    /*0x31b09a0*/ bool Equals(System.ValueTuple<System.Type, string> lhs, System.ValueTuple<System.Type, string> rhs);
                    /*0x31b0a14*/ int GetHashCode(System.ValueTuple<System.Type, string> key);
                }

                class <>c
                {
                    static /*0x0*/ System.Runtime.InteropServices.Marshal.<> <>9;
                    static /*0x8*/ System.Func<System.Collections.Generic.Dictionary<System.ValueTuple<System.Type, string>, System.Runtime.InteropServices.ICustomMarshaler>> <>9__201_0;

                    static /*0x31b0a70*/ <>c();
                    /*0x31b0ad8*/ <>c();
                    /*0x31b0ae0*/ System.Collections.Generic.Dictionary<System.ValueTuple<System.Type, string>, System.Runtime.InteropServices.ICustomMarshaler> <GetCustomMarshalerInstance>b__201_0();
                }
            }

            class MarshalAsAttribute : System.Attribute
            {
                /*0x10*/ string MarshalCookie;
                /*0x18*/ string MarshalType;
                /*0x20*/ System.Type MarshalTypeRef;
                /*0x28*/ System.Type SafeArrayUserDefinedSubType;
                /*0x30*/ System.Runtime.InteropServices.UnmanagedType utype;
                /*0x34*/ System.Runtime.InteropServices.UnmanagedType ArraySubType;
                /*0x38*/ System.Runtime.InteropServices.VarEnum SafeArraySubType;
                /*0x3c*/ int SizeConst;
                /*0x40*/ int IidParameterIndex;
                /*0x44*/ short SizeParamIndex;

                /*0x31b0b7c*/ MarshalAsAttribute(System.Runtime.InteropServices.UnmanagedType unmanagedType);
                /*0x31b0ba4*/ System.Runtime.InteropServices.UnmanagedType get_Value();
                /*0x31b0bac*/ System.Runtime.InteropServices.MarshalAsAttribute Copy();
            }

            interface _Activator
            {
            }

            interface _Assembly
            {
            }

            interface _AssemblyName
            {
            }

            interface _Module
            {
            }

            interface _ParameterInfo
            {
            }
        }

        namespace ExceptionServices
        {
            class FirstChanceExceptionEventArgs : System.EventArgs
            {
            }

            class HandleProcessCorruptedStateExceptionsAttribute : System.Attribute
            {
                /*0x31b0c10*/ HandleProcessCorruptedStateExceptionsAttribute();
            }

            class ExceptionDispatchInfo
            {
                /*0x10*/ System.Exception m_Exception;
                /*0x18*/ object m_stackTrace;

                static /*0x31b07e4*/ System.Runtime.ExceptionServices.ExceptionDispatchInfo Capture(System.Exception source);
                static /*0x31b0d6c*/ void Throw(System.Exception source);
                /*0x31b0c18*/ ExceptionDispatchInfo(System.Exception exception);
                /*0x31b0d5c*/ object get_BinaryStackTraceArray();
                /*0x31b0d64*/ System.Exception get_SourceException();
                /*0x31b08a4*/ void Throw();
            }
        }

        namespace ConstrainedExecution
        {
            enum Cer
            {
                None = 0,
                MayFail = 1,
                Success = 2,
            }

            enum Consistency
            {
                MayCorruptProcess = 0,
                MayCorruptAppDomain = 1,
                MayCorruptInstance = 2,
                WillNotCorruptState = 3,
            }

            class ReliabilityContractAttribute : System.Attribute
            {
                /*0x10*/ System.Runtime.ConstrainedExecution.Consistency <ConsistencyGuarantee>k__BackingField;
                /*0x14*/ System.Runtime.ConstrainedExecution.Cer <Cer>k__BackingField;

                /*0x31b0d80*/ ReliabilityContractAttribute(System.Runtime.ConstrainedExecution.Consistency consistencyGuarantee, System.Runtime.ConstrainedExecution.Cer cer);
            }

            class PrePrepareMethodAttribute : System.Attribute
            {
                /*0x31b0dac*/ PrePrepareMethodAttribute();
            }

            class CriticalFinalizerObject
            {
                /*0x31adf10*/ CriticalFinalizerObject();
                /*0x31b0db4*/ void Finalize();
            }
        }

        namespace CompilerServices
        {
            class AsyncMethodBuilderAttribute : System.Attribute
            {
                /*0x10*/ System.Type <BuilderType>k__BackingField;

                /*0x31b0dbc*/ AsyncMethodBuilderAttribute(System.Type builderType);
            }

            class AsyncStateMachineAttribute : System.Runtime.CompilerServices.StateMachineAttribute
            {
                /*0x31b0dec*/ AsyncStateMachineAttribute(System.Type stateMachineType);
            }

            struct AsyncValueTaskMethodBuilder
            {
                /*0x10*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder _methodBuilder;
                /*0x28*/ bool _haveResult;
                /*0x29*/ bool _useBuilder;
            }

            struct AsyncValueTaskMethodBuilder<TResult>
            {
                /*0x0*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder<TResult> _methodBuilder;
                /*0x0*/ TResult _result;
                /*0x0*/ bool _haveResult;
                /*0x0*/ bool _useBuilder;

                static /*0x1ffc854*/ System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder<TResult> Create();
                /*0x1f30ebc*/ void Start<TStateMachine>(ref TStateMachine stateMachine);
                /*0x1f30ebc*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
                /*0x1ffc854*/ void SetResult(TResult result);
                /*0x1f30ebc*/ void SetException(System.Exception exception);
                /*0x1ffc854*/ System.Threading.Tasks.ValueTask<TResult> get_Task();
                /*0x1f30ff0*/ void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine);
            }

            class CallerFilePathAttribute : System.Attribute
            {
                /*0x31b0e4c*/ CallerFilePathAttribute();
            }

            class CallerLineNumberAttribute : System.Attribute
            {
                /*0x31b0e54*/ CallerLineNumberAttribute();
            }

            class CallerMemberNameAttribute : System.Attribute
            {
                /*0x31b0e5c*/ CallerMemberNameAttribute();
            }

            class CompilerGeneratedAttribute : System.Attribute
            {
                /*0x31b0e64*/ CompilerGeneratedAttribute();
            }

            struct ConfiguredValueTaskAwaitable
            {
                /*0x10*/ System.Threading.Tasks.ValueTask _value;

                /*0x31b0e6c*/ ConfiguredValueTaskAwaitable(System.Threading.Tasks.ValueTask value);
                /*0x31b0e7c*/ System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter GetAwaiter();

                struct ConfiguredValueTaskAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion
                {
                    /*0x10*/ System.Threading.Tasks.ValueTask _value;

                    /*0x31b0eac*/ ConfiguredValueTaskAwaiter(System.Threading.Tasks.ValueTask value);
                    /*0x31b0ebc*/ bool get_IsCompleted();
                    /*0x31b0ffc*/ void GetResult();
                    /*0x31b1134*/ void UnsafeOnCompleted(System.Action continuation);
                }
            }

            struct ConfiguredValueTaskAwaitable<TResult>
            {
                /*0x0*/ System.Threading.Tasks.ValueTask<TResult> _value;

                /*0x1ffc854*/ ConfiguredValueTaskAwaitable(System.Threading.Tasks.ValueTask<TResult> value);
                /*0x1ffc854*/ System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter<TResult> GetAwaiter();

                struct ConfiguredValueTaskAwaiter<TResult> : System.Runtime.CompilerServices.ICriticalNotifyCompletion
                {
                    /*0x0*/ System.Threading.Tasks.ValueTask<TResult> _value;

                    /*0x1ffc854*/ ConfiguredValueTaskAwaiter(System.Threading.Tasks.ValueTask<TResult> value);
                    /*0x1f2fe14*/ bool get_IsCompleted();
                    /*0x1ffc854*/ TResult GetResult();
                    /*0x1f30ebc*/ void UnsafeOnCompleted(System.Action continuation);
                }
            }

            class CustomConstantAttribute : System.Attribute
            {
                /*0x31b12f4*/ CustomConstantAttribute();
                /*0x1f30214*/ object get_Value();
            }

            class DateTimeConstantAttribute : System.Runtime.CompilerServices.CustomConstantAttribute
            {
                /*0x10*/ System.DateTime _date;

                /*0x31b12fc*/ object get_Value();
            }

            class DecimalConstantAttribute : System.Attribute
            {
                /*0x10*/ decimal _dec;

                /*0x31b1358*/ DecimalConstantAttribute(byte scale, byte sign, uint hi, uint mid, uint low);
                /*0x31b13f4*/ decimal get_Value();
            }

            class ExtensionAttribute : System.Attribute
            {
                /*0x31b1400*/ ExtensionAttribute();
            }

            class FixedBufferAttribute : System.Attribute
            {
                /*0x10*/ System.Type <ElementType>k__BackingField;
                /*0x18*/ int <Length>k__BackingField;

                /*0x31b1408*/ FixedBufferAttribute(System.Type elementType, int length);
                /*0x31b1444*/ System.Type get_ElementType();
                /*0x31b144c*/ int get_Length();
            }

            class FormattableStringFactory
            {
                static /*0x31b1454*/ System.FormattableString Create(string format, object[] arguments);

                class ConcreteFormattableString : System.FormattableString
                {
                    /*0x10*/ string _format;
                    /*0x18*/ object[] _arguments;

                    /*0x31b1524*/ ConcreteFormattableString(string format, object[] arguments);
                    /*0x31b1568*/ string get_Format();
                    /*0x31b1570*/ object[] GetArguments();
                    /*0x31b1578*/ int get_ArgumentCount();
                    /*0x31b1590*/ object GetArgument(int index);
                    /*0x31b15c0*/ string ToString(System.IFormatProvider formatProvider);
                }
            }

            interface IAsyncStateMachine
            {
                /*0x1f309e4*/ void MoveNext();
                /*0x1f30ebc*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }

            interface ICriticalNotifyCompletion
            {
                /*0x1f30ebc*/ void UnsafeOnCompleted(System.Action continuation);
            }

            interface ITuple
            {
                /*0x1f2ffc8*/ int get_Length();
            }

            class IntrinsicAttribute : System.Attribute
            {
                /*0x31b15d4*/ IntrinsicAttribute();
            }

            class IsByRefLikeAttribute : System.Attribute
            {
                /*0x31b15dc*/ IsByRefLikeAttribute();
            }

            class IsReadOnlyAttribute : System.Attribute
            {
                /*0x31b15e4*/ IsReadOnlyAttribute();
            }

            class IsVolatile
            {
            }

            class IteratorStateMachineAttribute : System.Runtime.CompilerServices.StateMachineAttribute
            {
                /*0x31b15ec*/ IteratorStateMachineAttribute(System.Type stateMachineType);
            }

            class RuntimeCompatibilityAttribute : System.Attribute
            {
                /*0x10*/ bool <WrapNonExceptionThrows>k__BackingField;

                /*0x31b161c*/ RuntimeCompatibilityAttribute();
                /*0x31b1624*/ void set_WrapNonExceptionThrows(bool value);
            }

            class RuntimeFeature
            {
                static /*0x31b162c*/ bool get_IsDynamicCodeSupported();
            }

            class RuntimeWrappedException : System.Exception
            {
                /*0x90*/ object _wrappedException;

                /*0x31b1634*/ RuntimeWrappedException(object thrownObject);
                /*0x31b16cc*/ RuntimeWrappedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x31b1870*/ RuntimeWrappedException();
                /*0x31b17b4*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x31b1868*/ object get_WrappedException();
            }

            class StateMachineAttribute : System.Attribute
            {
                /*0x10*/ System.Type <StateMachineType>k__BackingField;

                /*0x31b0e1c*/ StateMachineAttribute(System.Type stateMachineType);
                /*0x31b18a8*/ System.Type get_StateMachineType();
            }

            class StringFreezingAttribute : System.Attribute
            {
                /*0x31b18b0*/ StringFreezingAttribute();
            }

            class TupleElementNamesAttribute : System.Attribute
            {
                /*0x10*/ string[] _transformNames;

                /*0x31b18b8*/ TupleElementNamesAttribute(string[] transformNames);
            }

            class TypeForwardedFromAttribute : System.Attribute
            {
                /*0x10*/ string <AssemblyFullName>k__BackingField;

                /*0x31b1934*/ TypeForwardedFromAttribute(string assemblyFullName);
                /*0x31b19bc*/ string get_AssemblyFullName();
            }

            class UnsafeValueTypeAttribute : System.Attribute
            {
                /*0x31b19c4*/ UnsafeValueTypeAttribute();
            }

            struct ValueTaskAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion
            {
                static /*0x0*/ System.Action<object> s_invokeActionDelegate;
                /*0x10*/ System.Threading.Tasks.ValueTask _value;

                static /*0x31b1df0*/ ValueTaskAwaiter();
                /*0x31b19cc*/ ValueTaskAwaiter(System.Threading.Tasks.ValueTask value);
                /*0x31b19dc*/ bool get_IsCompleted();
                /*0x31b1b1c*/ void GetResult();
                /*0x31b1c54*/ void UnsafeOnCompleted(System.Action continuation);

                class <>c
                {
                    static /*0x0*/ System.Runtime.CompilerServices.ValueTaskAwaiter.<> <>9;

                    static /*0x31b1ec0*/ <>c();
                    /*0x31b1f28*/ <>c();
                    /*0x31b1f30*/ void <.cctor>b__9_0(object state);
                }
            }

            struct ValueTaskAwaiter<TResult> : System.Runtime.CompilerServices.ICriticalNotifyCompletion
            {
                /*0x0*/ System.Threading.Tasks.ValueTask<TResult> _value;

                /*0x1ffc854*/ ValueTaskAwaiter(System.Threading.Tasks.ValueTask<TResult> value);
                /*0x1f2fe14*/ bool get_IsCompleted();
                /*0x1ffc854*/ TResult GetResult();
                /*0x1f30ebc*/ void UnsafeOnCompleted(System.Action continuation);
            }

            struct TaskAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion
            {
                /*0x10*/ System.Threading.Tasks.Task m_task;

                static /*0x31b207c*/ void ValidateEnd(System.Threading.Tasks.Task task);
                static /*0x31b20c8*/ void HandleNonSuccessAndDebuggerNotification(System.Threading.Tasks.Task task);
                static /*0x31b2128*/ void ThrowForNonSuccess(System.Threading.Tasks.Task task);
                static /*0x31b1fc4*/ void OnCompletedInternal(System.Threading.Tasks.Task task, System.Action continuation, bool continueOnCapturedContext, bool flowExecutionContext);
                static /*0x31b225c*/ System.Action OutputWaitEtwEvents(System.Threading.Tasks.Task task, System.Action continuation);
                /*0x31b1fa4*/ TaskAwaiter(System.Threading.Tasks.Task task);
                /*0x31b1fac*/ bool get_IsCompleted();
                /*0x31b1de0*/ void UnsafeOnCompleted(System.Action continuation);
                /*0x31b2074*/ void GetResult();

                class <>c__DisplayClass11_0
                {
                    /*0x10*/ System.Threading.Tasks.Task task;
                    /*0x18*/ System.Action continuation;

                    /*0x31b2454*/ <>c__DisplayClass11_0();
                    /*0x31b245c*/ void <OutputWaitEtwEvents>b__0();
                }
            }

            struct TaskAwaiter<TResult> : System.Runtime.CompilerServices.ICriticalNotifyCompletion
            {
                /*0x0*/ System.Threading.Tasks.Task<TResult> m_task;

                /*0x1f30ebc*/ TaskAwaiter(System.Threading.Tasks.Task<TResult> task);
                /*0x1f2fe14*/ bool get_IsCompleted();
                /*0x1f30ebc*/ void UnsafeOnCompleted(System.Action continuation);
                /*0x1ffc854*/ TResult GetResult();
            }

            struct ConfiguredTaskAwaitable
            {
                /*0x10*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter m_configuredTaskAwaiter;

                /*0x31b25d0*/ ConfiguredTaskAwaitable(System.Threading.Tasks.Task task, bool continueOnCapturedContext);
                /*0x31b2640*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter GetAwaiter();

                struct ConfiguredTaskAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion
                {
                    /*0x10*/ System.Threading.Tasks.Task m_task;
                    /*0x18*/ bool m_continueOnCapturedContext;

                    /*0x31b2618*/ ConfiguredTaskAwaiter(System.Threading.Tasks.Task task, bool continueOnCapturedContext);
                    /*0x31b264c*/ bool get_IsCompleted();
                    /*0x31b2664*/ void OnCompleted(System.Action continuation);
                    /*0x31b12e0*/ void UnsafeOnCompleted(System.Action continuation);
                    /*0x31b2678*/ void GetResult();
                }
            }

            struct ConfiguredTaskAwaitable<TResult>
            {
                /*0x0*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter<TResult> m_configuredTaskAwaiter;

                ConfiguredTaskAwaitable(System.Threading.Tasks.Task<TResult> task, bool continueOnCapturedContext);
                /*0x1ffc854*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter<TResult> GetAwaiter();

                struct ConfiguredTaskAwaiter<TResult> : System.Runtime.CompilerServices.ICriticalNotifyCompletion
                {
                    /*0x0*/ System.Threading.Tasks.Task<TResult> m_task;
                    /*0x0*/ bool m_continueOnCapturedContext;

                    ConfiguredTaskAwaiter(System.Threading.Tasks.Task<TResult> task, bool continueOnCapturedContext);
                    /*0x1f2fe14*/ bool get_IsCompleted();
                    /*0x1f30ebc*/ void UnsafeOnCompleted(System.Action continuation);
                    /*0x1ffc854*/ TResult GetResult();
                }
            }

            class ReflectionBlockedAttribute : System.Attribute
            {
                /*0x31b2680*/ ReflectionBlockedAttribute();
            }

            struct AsyncVoidMethodBuilder
            {
                /*0x10*/ System.Threading.SynchronizationContext m_synchronizationContext;
                /*0x18*/ System.Runtime.CompilerServices.AsyncMethodBuilderCore m_coreState;
                /*0x28*/ System.Threading.Tasks.Task m_task;

                static /*0x31b2688*/ System.Runtime.CompilerServices.AsyncVoidMethodBuilder Create();
                /*0x1f30ebc*/ void Start<TStateMachine>(ref TStateMachine stateMachine);
                /*0x31b26f0*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
                /*0x1f30ff0*/ void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine);
                /*0x31b27b4*/ void SetResult();
                /*0x31b2924*/ void SetException(System.Exception exception);
                /*0x31b2880*/ void NotifySynchronizationContextOfCompletion();
                /*0x31b2810*/ System.Threading.Tasks.Task get_Task();
            }

            struct AsyncTaskMethodBuilder
            {
                static /*0x0*/ System.Threading.Tasks.Task<System.Threading.Tasks.VoidTaskResult> s_cachedCompleted;
                /*0x10*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder<System.Threading.Tasks.VoidTaskResult> m_builder;

                static /*0x31b2f1c*/ AsyncTaskMethodBuilder();
                static /*0x31b2d08*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder Create();
                /*0x1f30ebc*/ void Start<TStateMachine>(ref TStateMachine stateMachine);
                /*0x31b2d14*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
                /*0x1f30ff0*/ void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine);
                /*0x31b2d90*/ System.Threading.Tasks.Task get_Task();
                /*0x31b2dfc*/ void SetResult();
                /*0x31b2ea0*/ void SetException(System.Exception exception);
            }

            struct AsyncTaskMethodBuilder<TResult>
            {
                static /*0x0*/ System.Threading.Tasks.Task<TResult> s_defaultResultTask;
                /*0x0*/ System.Runtime.CompilerServices.AsyncMethodBuilderCore m_coreState;
                /*0x0*/ System.Threading.Tasks.Task<TResult> m_task;

                static /*0x1f33998*/ AsyncTaskMethodBuilder();
                static /*0x1ffc854*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder<TResult> Create();
                static /*0x1ffc854*/ System.Threading.Tasks.Task<TResult> GetTaskForResult(TResult result);
                /*0x1f30ebc*/ void Start<TStateMachine>(ref TStateMachine stateMachine);
                /*0x1f30ebc*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
                /*0x1f30ff0*/ void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine);
                /*0x1f30214*/ System.Threading.Tasks.Task<TResult> get_Task();
                /*0x1ffc854*/ void SetResult(TResult result);
                /*0x1f30ebc*/ void SetResult(System.Threading.Tasks.Task<TResult> completedTask);
                /*0x1f30ebc*/ void SetException(System.Exception exception);
            }

            class AsyncTaskCache
            {
                static /*0x0*/ System.Threading.Tasks.Task<bool> TrueTask;
                static /*0x8*/ System.Threading.Tasks.Task<bool> FalseTask;
                static /*0x10*/ System.Threading.Tasks.Task<int> Int32Tasks;

                static /*0x31b30cc*/ AsyncTaskCache();
                static /*0x31b2f9c*/ System.Threading.Tasks.Task<int> CreateInt32Tasks();
                static /*0x1ffc854*/ System.Threading.Tasks.Task<TResult> CreateCacheableTask<TResult>(TResult result);
            }

            struct AsyncMethodBuilderCore
            {
                /*0x10*/ System.Runtime.CompilerServices.IAsyncStateMachine m_stateMachine;
                /*0x18*/ System.Action m_defaultContextAction;

                static /*0x31b2a4c*/ void ThrowAsync(System.Exception exception, System.Threading.SynchronizationContext targetContext);
                static /*0x31b34a4*/ System.Action CreateContinuationWrapper(System.Action continuation, System.Action invokeAction, System.Threading.Tasks.Task innerTask);
                static /*0x31b377c*/ System.Threading.Tasks.Task TryGetContinuationTask(System.Action action);
                /*0x31b26f8*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
                /*0x31b3198*/ System.Action GetCompletionAction(System.Threading.Tasks.Task taskForTracing, ref System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner runnerToInitialize);
                /*0x31b33b0*/ System.Action OutputAsyncCausalityEvents(System.Threading.Tasks.Task innerTask, System.Action continuation);
                /*0x31b3560*/ void PostBoxInitialization(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine, System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner runner, System.Threading.Tasks.Task builtTask);

                class MoveNextRunner
                {
                    static /*0x0*/ System.Threading.ContextCallback s_invokeMoveNext;
                    /*0x10*/ System.Threading.ExecutionContext m_context;
                    /*0x18*/ System.Runtime.CompilerServices.IAsyncStateMachine m_stateMachine;

                    static /*0x31b3a10*/ void InvokeMoveNext(object stateMachine);
                    /*0x31b336c*/ MoveNextRunner(System.Threading.ExecutionContext context, System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
                    /*0x31b3800*/ void Run();
                }

                class ContinuationWrapper
                {
                    /*0x10*/ System.Action m_continuation;
                    /*0x18*/ System.Action m_invokeAction;
                    /*0x20*/ System.Threading.Tasks.Task m_innerTask;

                    /*0x31b370c*/ ContinuationWrapper(System.Action continuation, System.Action invokeAction, System.Threading.Tasks.Task innerTask);
                    /*0x31b3af0*/ void Invoke();
                }

                class <>c__DisplayClass5_0
                {
                    /*0x10*/ System.Threading.Tasks.Task innerTask;
                    /*0x18*/ System.Action continuation;

                    /*0x31b349c*/ <>c__DisplayClass5_0();
                    /*0x31b3b10*/ void <OutputAsyncCausalityEvents>b__0();
                }

                class <>c
                {
                    static /*0x0*/ System.Runtime.CompilerServices.AsyncMethodBuilderCore.<> <>9;
                    static /*0x8*/ System.Threading.SendOrPostCallback <>9__7_0;
                    static /*0x10*/ System.Threading.WaitCallback <>9__7_1;

                    static /*0x31b3b6c*/ <>c();
                    /*0x31b3bd4*/ <>c();
                    /*0x31b3bdc*/ void <ThrowAsync>b__7_0(object state);
                    /*0x31b3c34*/ void <ThrowAsync>b__7_1(object state);
                }
            }

            struct YieldAwaitable
            {
                /*0x31b3c8c*/ System.Runtime.CompilerServices.YieldAwaitable.YieldAwaiter GetAwaiter();

                struct YieldAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion
                {
                    static /*0x0*/ System.Threading.WaitCallback s_waitCallbackRunAction;
                    static /*0x8*/ System.Threading.SendOrPostCallback s_sendOrPostCallbackRunAction;

                    static /*0x31b4004*/ YieldAwaiter();
                    static /*0x31b3cf4*/ void QueueContinuation(System.Action continuation, bool flowContext);
                    static /*0x31b3f94*/ void RunAction(object state);
                    /*0x31b3c94*/ bool get_IsCompleted();
                    /*0x31b3c9c*/ void UnsafeOnCompleted(System.Action continuation);
                    /*0x31b4000*/ void GetResult();
                }
            }

            enum LoadHint
            {
                Default = 0,
                Always = 1,
                Sometimes = 2,
            }

            class DefaultDependencyAttribute : System.Attribute
            {
                /*0x10*/ System.Runtime.CompilerServices.LoadHint loadHint;

                /*0x31b40e8*/ DefaultDependencyAttribute(System.Runtime.CompilerServices.LoadHint loadHintArgument);
            }

            class DependencyAttribute : System.Attribute
            {
                /*0x10*/ string dependentAssembly;
                /*0x18*/ System.Runtime.CompilerServices.LoadHint loadHint;

                /*0x31b4110*/ DependencyAttribute(string dependentAssemblyArgument, System.Runtime.CompilerServices.LoadHint loadHintArgument);
            }

            enum CompilationRelaxations
            {
                NoStringInterning = 8,
            }

            class CompilationRelaxationsAttribute : System.Attribute
            {
                /*0x10*/ int m_relaxations;

                /*0x31b414c*/ CompilationRelaxationsAttribute(int relaxations);
                /*0x31b4174*/ CompilationRelaxationsAttribute(System.Runtime.CompilerServices.CompilationRelaxations relaxations);
                /*0x31b419c*/ int get_CompilationRelaxations();
            }

            class InternalsVisibleToAttribute : System.Attribute
            {
                /*0x10*/ string _assemblyName;
                /*0x18*/ bool _allInternalsVisible;

                /*0x31b41a4*/ InternalsVisibleToAttribute(string assemblyName);
                /*0x31b41dc*/ void set_AllInternalsVisible(bool value);
            }

            class FriendAccessAllowedAttribute : System.Attribute
            {
                /*0x31b41e4*/ FriendAccessAllowedAttribute();
            }

            class TypeDependencyAttribute : System.Attribute
            {
                /*0x10*/ string typeName;

                /*0x31b41ec*/ TypeDependencyAttribute(string typeName);
            }

            class JitHelpers
            {
                static /*0x1ffc854*/ T UnsafeCast<T>(object o);
                static /*0x1ffc854*/ int UnsafeEnumCast<T>(T val);
                static /*0x1ffc854*/ long UnsafeEnumCastLong<T>(T val);
            }

            struct Ephemeron
            {
                /*0x10*/ object key;
                /*0x18*/ object value;
            }

            class ConditionalWeakTable<TKey, TValue> : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.IEnumerable
            {
                /*0x0*/ System.Runtime.CompilerServices.Ephemeron[] data;
                /*0x0*/ object _lock;
                /*0x0*/ int size;

                /*0x1f309e4*/ ConditionalWeakTable();
                /*0x1f309e4*/ void Finalize();
                /*0x1f309e4*/ void RehashWithoutResize();
                /*0x1f309e4*/ void RecomputeSize();
                /*0x1f309e4*/ void Rehash();
                /*0x1ffc854*/ void Add(TKey key, TValue value);
                /*0x1ffc854*/ bool Remove(TKey key);
                /*0x1ffc854*/ bool TryGetValue(TKey key, ref TValue value);
                /*0x1ffc854*/ TValue GetValue(TKey key, System.Runtime.CompilerServices.ConditionalWeakTable.CreateValueCallback<TKey, TValue> createValueCallback);
                /*0x1f30214*/ System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
                /*0x1f30214*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();

                class CreateValueCallback<TKey, TValue> : System.MulticastDelegate
                {
                    CreateValueCallback(object object, nint method);
                    /*0x1ffc854*/ TValue Invoke(TKey key);
                }

                class Enumerator<TKey, TValue> : System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.IDisposable, System.Collections.IEnumerator
                {
                    /*0x0*/ System.Runtime.CompilerServices.ConditionalWeakTable<TKey, TValue> _table;
                    /*0x0*/ int _currentIndex;
                    /*0x0*/ System.Collections.Generic.KeyValuePair<TKey, TValue> _current;

                    /*0x1f30ebc*/ Enumerator(System.Runtime.CompilerServices.ConditionalWeakTable<TKey, TValue> table);
                    /*0x1f309e4*/ void Finalize();
                    /*0x1f309e4*/ void Dispose();
                    /*0x1f2fe14*/ bool MoveNext();
                    /*0x1ffc854*/ System.Collections.Generic.KeyValuePair<TKey, TValue> get_Current();
                    /*0x1f30214*/ object System.Collections.IEnumerator.get_Current();
                    /*0x1f309e4*/ void Reset();
                }
            }

            class RuntimeHelpers
            {
                static /*0x31b4268*/ void InitializeArray(System.Array array, nint fldHandle);
                static /*0x31b426c*/ void InitializeArray(System.Array array, System.RuntimeFieldHandle fldHandle);
                static /*0x31af3f4*/ int get_OffsetToStringData();
                static /*0x31b42b0*/ int GetHashCode(object o);
                static /*0x31b42b8*/ object GetObjectValue(object obj);
                static /*0x31b42bc*/ bool SufficientExecutionStack();
                static /*0x31b42c0*/ void EnsureSufficientExecutionStack();
                static /*0x31b4308*/ bool TryEnsureSufficientExecutionStack();
                static /*0x31b430c*/ void PrepareConstrainedRegions();
                static /*0x1f317dc*/ bool IsReferenceOrContainsReferences<T>();
            }

            class Unsafe
            {
                static /*0x1f327fc*/ ref T Add<T>(ref T source, int elementOffset);
                static /*0x1ffc854*/ ref T Add<T>(ref T source, nint elementOffset);
                static /*0x1ffc854*/ void* Add<T>(void* source, int elementOffset);
                static /*0x1ffc854*/ ref T AddByteOffset<T>(ref T source, nint byteOffset);
                static /*0x1f318fc*/ bool AreSame<T>(ref T left, ref T right);
                static /*0x1ffc854*/ T As<T>(object o);
                static /*0x1f327cc*/ ref TTo As<TFrom, TTo>(ref TFrom source);
                static /*0x1ffc854*/ void* AsPointer<T>(ref T value);
                static /*0x1ffc854*/ ref T AsRef<T>(void* source);
                static /*0x1f327cc*/ ref T AsRef<T>(ref T source);
                static /*0x31b4310*/ void InitBlockUnaligned(ref byte startAddress, byte value, uint byteCount);
                static /*0x1ffc854*/ T Read<T>(void* source);
                static /*0x1ffc854*/ T ReadUnaligned<T>(ref byte source);
                static /*0x1f31da0*/ int SizeOf<T>();
                static /*0x1ffc854*/ void WriteUnaligned<T>(ref byte destination, T value);
                static /*0x1f318fc*/ bool IsAddressLessThan<T>(ref T left, ref T right);
                static /*0x1ffc854*/ ref T AddByteOffset<T>(ref T source, ulong byteOffset);
            }
        }
    }

    namespace Resources
    {
        interface IResourceReader : System.Collections.IEnumerable, System.IDisposable
        {
            /*0x1f309e4*/ void Close();
            /*0x1f30214*/ System.Collections.IDictionaryEnumerator GetEnumerator();
        }

        class MissingManifestResourceException : System.SystemException
        {
            /*0x31b4318*/ MissingManifestResourceException();
            /*0x31b4374*/ MissingManifestResourceException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class NeutralResourcesLanguageAttribute : System.Attribute
        {
            /*0x10*/ string <CultureName>k__BackingField;
            /*0x18*/ System.Resources.UltimateResourceFallbackLocation <Location>k__BackingField;

            /*0x31b437c*/ NeutralResourcesLanguageAttribute(string cultureName);
            /*0x31b4400*/ string get_CultureName();
            /*0x31b4408*/ System.Resources.UltimateResourceFallbackLocation get_Location();
        }

        enum ResourceTypeCode
        {
            Null = 0,
            String = 1,
            Boolean = 2,
            Char = 3,
            Byte = 4,
            SByte = 5,
            Int16 = 6,
            UInt16 = 7,
            Int32 = 8,
            UInt32 = 9,
            Int64 = 10,
            UInt64 = 11,
            Single = 12,
            Double = 13,
            Decimal = 14,
            DateTime = 15,
            TimeSpan = 16,
            LastPrimitive = 16,
            ByteArray = 32,
            Stream = 33,
            StartOfUserTypes = 64,
        }

        class RuntimeResourceSet : System.Resources.ResourceSet, System.Collections.IEnumerable
        {
            static int Version = 2;
            /*0x28*/ System.Collections.Generic.Dictionary<string, System.Resources.ResourceLocator> _resCache;
            /*0x30*/ System.Resources.ResourceReader _defaultReader;
            /*0x38*/ System.Collections.Generic.Dictionary<string, System.Resources.ResourceLocator> _caseInsensitiveTable;
            /*0x40*/ bool _haveReadFromReader;

            /*0x31b4410*/ RuntimeResourceSet(string fileName);
            /*0x31b46b0*/ RuntimeResourceSet(System.IO.Stream stream);
            /*0x31b47d0*/ void Dispose(bool disposing);
            /*0x31b4a2c*/ System.Collections.IDictionaryEnumerator GetEnumerator();
            /*0x31b4b2c*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
            /*0x31b4a30*/ System.Collections.IDictionaryEnumerator GetEnumeratorHelper();
            /*0x31b4b30*/ string GetString(string key);
            /*0x31b5440*/ string GetString(string key, bool ignoreCase);
            /*0x31b5474*/ object GetObject(string key);
            /*0x31b5480*/ object GetObject(string key, bool ignoreCase);
            /*0x31b4b68*/ object GetObject(string key, bool ignoreCase, bool isString);
            /*0x31b5c74*/ object ResolveResourceLocator(System.Resources.ResourceLocator resLocation, string key, System.Collections.Generic.Dictionary<string, System.Resources.ResourceLocator> copyOfCache, bool keyInWrongCase);
        }

        class SatelliteContractVersionAttribute : System.Attribute
        {
            /*0x10*/ string <Version>k__BackingField;

            /*0x31b5e10*/ SatelliteContractVersionAttribute(string version);
        }

        enum UltimateResourceFallbackLocation
        {
            MainAssembly = 0,
            Satellite = 1,
        }

        class FastResourceComparer : System.Collections.IComparer, System.Collections.IEqualityComparer, System.Collections.Generic.IComparer<string>, System.Collections.Generic.IEqualityComparer<string>
        {
            static /*0x0*/ System.Resources.FastResourceComparer Default;

            static /*0x31b6278*/ FastResourceComparer();
            static /*0x31b5f0c*/ int HashFunction(string key);
            static /*0x31b60c4*/ int CompareOrdinal(string a, byte[] bytes, int bCharLength);
            static /*0x31b6174*/ int CompareOrdinal(byte[] bytes, int aCharLength, string b);
            static /*0x31b61e8*/ int CompareOrdinal(byte* a, int byteLen, string b);
            /*0x31b6270*/ FastResourceComparer();
            /*0x31b5e8c*/ int GetHashCode(object key);
            /*0x31b5f78*/ int GetHashCode(string key);
            /*0x31b5fcc*/ int Compare(object a, object b);
            /*0x31b6038*/ int Compare(string a, string b);
            /*0x31b6048*/ bool Equals(string a, string b);
            /*0x31b6058*/ bool Equals(object a, object b);
        }

        class FileBasedResourceGroveler : System.Resources.IResourceGroveler
        {
            /*0x10*/ System.Resources.ResourceManager.ResourceManagerMediator _mediator;

            /*0x31b62e0*/ FileBasedResourceGroveler(System.Resources.ResourceManager.ResourceManagerMediator mediator);
        }

        interface IResourceGroveler
        {
        }

        class ManifestBasedResourceGroveler : System.Resources.IResourceGroveler
        {
            /*0x10*/ System.Resources.ResourceManager.ResourceManagerMediator _mediator;

            static /*0x31b6340*/ System.Globalization.CultureInfo GetNeutralResourcesLanguage(System.Reflection.Assembly a, ref System.Resources.UltimateResourceFallbackLocation fallbackLocation);
            static /*0x31b6688*/ bool GetNeutralResourcesLanguageAttribute(System.Reflection.Assembly assembly, ref string cultureName, ref short fallbackLocation);
            /*0x31b6310*/ ManifestBasedResourceGroveler(System.Resources.ResourceManager.ResourceManagerMediator mediator);
        }

        class ResourceManager
        {
            static /*0x0*/ int MagicNumber;
            static /*0x4*/ int HeaderVersionNumber;
            static /*0x8*/ System.Type _minResourceSet;
            static /*0x10*/ string ResReaderTypeName;
            static /*0x18*/ string ResSetTypeName;
            static /*0x20*/ string MscorlibName;
            static /*0x28*/ int DEBUG;
            /*0x10*/ System.Collections.Hashtable ResourceSets;
            /*0x18*/ System.Collections.Generic.Dictionary<string, System.Resources.ResourceSet> _resourceSets;
            /*0x20*/ System.Reflection.Assembly MainAssembly;
            /*0x28*/ System.Globalization.CultureInfo _neutralResourcesCulture;
            /*0x30*/ System.Resources.ResourceManager.CultureNameResourceSetPair _lastUsedResourceCache;
            /*0x38*/ bool UseManifest;
            /*0x39*/ bool UseSatelliteAssem;
            /*0x3c*/ System.Resources.UltimateResourceFallbackLocation _fallbackLoc;
            /*0x40*/ System.Reflection.Assembly _callingAssembly;
            /*0x48*/ System.Reflection.RuntimeAssembly m_callingAssembly;
            /*0x50*/ System.Resources.IResourceGroveler resourceGroveler;

            static /*0x31b6ec8*/ ResourceManager();
            static /*0x31b6c8c*/ bool CompareNames(string asmTypeName1, string typeName2, System.Reflection.AssemblyName asmName2);
            /*0x31b683c*/ ResourceManager();
            /*0x31b670c*/ void Init();
            /*0x31b69ac*/ void OnDeserializing(System.Runtime.Serialization.StreamingContext ctx);
            /*0x31b69e4*/ void OnDeserialized(System.Runtime.Serialization.StreamingContext ctx);
            /*0x31b6c14*/ void OnSerializing(System.Runtime.Serialization.StreamingContext ctx);

            class CultureNameResourceSetPair
            {
                /*0x31b6928*/ CultureNameResourceSetPair();
            }

            class ResourceManagerMediator
            {
                /*0x10*/ System.Resources.ResourceManager _rm;

                /*0x31b6930*/ ResourceManagerMediator(System.Resources.ResourceManager rm);
            }
        }

        struct ResourceLocator
        {
            /*0x10*/ object _value;
            /*0x18*/ int _dataPos;

            static /*0x31b5ae8*/ bool CanCache(System.Resources.ResourceTypeCode value);
            /*0x31b5af4*/ ResourceLocator(int dataPos, object value);
            /*0x31b705c*/ int get_DataPosition();
            /*0x31b7064*/ object get_Value();
            /*0x31b706c*/ void set_Value(object value);
        }

        class ResourceReader : System.Resources.IResourceReader, System.Collections.IEnumerable, System.IDisposable
        {
            /*0x10*/ System.IO.BinaryReader _store;
            /*0x18*/ System.Collections.Generic.Dictionary<string, System.Resources.ResourceLocator> _resCache;
            /*0x20*/ long _nameSectionOffset;
            /*0x28*/ long _dataSectionOffset;
            /*0x30*/ int[] _nameHashes;
            /*0x38*/ int* _nameHashesPtr;
            /*0x40*/ int[] _namePositions;
            /*0x48*/ int* _namePositionsPtr;
            /*0x50*/ System.RuntimeType[] _typeTable;
            /*0x58*/ int[] _typeNamePositions;
            /*0x60*/ System.Runtime.Serialization.Formatters.Binary.BinaryFormatter _objFormatter;
            /*0x68*/ int _numResources;
            /*0x70*/ System.IO.UnmanagedMemoryStream _ums;
            /*0x78*/ int _version;

            static /*0x31b72b8*/ int ReadUnalignedI4(int* p);
            /*0x31b4570*/ ResourceReader(System.IO.Stream stream, System.Collections.Generic.Dictionary<string, System.Resources.ResourceLocator> resCache);
            /*0x31b4940*/ void Close();
            /*0x31b72b0*/ void Dispose();
            /*0x31b7208*/ void Dispose(bool disposing);
            /*0x31b72c0*/ void SkipString();
            /*0x31b7370*/ int GetNameHash(int index);
            /*0x31b73b4*/ int GetNamePosition(int index);
            /*0x31b74cc*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
            /*0x31b74d0*/ System.Collections.IDictionaryEnumerator GetEnumerator();
            /*0x31b5b04*/ System.Resources.ResourceReader.ResourceEnumerator GetEnumeratorInternal();
            /*0x31b5488*/ int FindPosForResource(string name);
            /*0x31b75e4*/ bool CompareStringEqualsName(string name);
            /*0x31b77d8*/ string AllocateStringForNameIndex(int index, ref int dataOffset);
            /*0x31b7f2c*/ object GetValueForNameIndex(int index);
            /*0x31b5824*/ string LoadString(int pos);
            /*0x31b873c*/ object LoadObject(int pos);
            /*0x31b5a98*/ object LoadObject(int pos, ref System.Resources.ResourceTypeCode typeCode);
            /*0x31b81b8*/ object LoadObjectV1(int pos);
            /*0x31b8768*/ object _LoadObjectV1(int pos);
            /*0x31b82b0*/ object LoadObjectV2(int pos, ref System.Resources.ResourceTypeCode typeCode);
            /*0x31b9048*/ object _LoadObjectV2(int pos, ref System.Resources.ResourceTypeCode typeCode);
            /*0x31b8eac*/ object DeserializeObject(int typeIndex);
            /*0x31b7074*/ void ReadResources();
            /*0x31b9794*/ void _ReadResources();
            /*0x31b83a8*/ System.RuntimeType FindType(int typeIndex);

            class ResourceEnumerator : System.Collections.IDictionaryEnumerator, System.Collections.IEnumerator
            {
                /*0x10*/ System.Resources.ResourceReader _reader;
                /*0x18*/ bool _currentIsValid;
                /*0x1c*/ int _currentName;
                /*0x20*/ int _dataPosition;

                /*0x31b75a0*/ ResourceEnumerator(System.Resources.ResourceReader reader);
                /*0x31b5c2c*/ bool MoveNext();
                /*0x31b5b7c*/ object get_Key();
                /*0x31b9e50*/ object get_Current();
                /*0x31ba1e8*/ int get_DataPosition();
                /*0x31b9eb4*/ System.Collections.DictionaryEntry get_Entry();
                /*0x31ba1f0*/ object get_Value();
                /*0x31ba298*/ void Reset();
            }
        }

        class ResourceSet : System.IDisposable, System.Collections.IEnumerable
        {
            /*0x10*/ System.Resources.IResourceReader Reader;
            /*0x18*/ System.Collections.Hashtable Table;
            /*0x20*/ System.Collections.Hashtable _caseInsensitiveTable;

            /*0x31ba31c*/ ResourceSet();
            /*0x31b4568*/ ResourceSet(bool junk);
            /*0x31ba338*/ void CommonInit();
            /*0x31b4948*/ void Dispose(bool disposing);
            /*0x31ba398*/ void Dispose();
            /*0x31ba3a8*/ System.Collections.IDictionaryEnumerator GetEnumerator();
            /*0x31ba420*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
            /*0x31ba3ac*/ System.Collections.IDictionaryEnumerator GetEnumeratorHelper();
            /*0x31ba424*/ string GetString(string name);
            /*0x31ba620*/ string GetString(string name, bool ignoreCase);
            /*0x31baacc*/ object GetObject(string name);
            /*0x31baad0*/ object GetObject(string name, bool ignoreCase);
            /*0x31ba558*/ object GetObjectInternal(string name);
            /*0x31ba7f4*/ object GetCaseInsensitiveObjectInternal(string name);
        }
    }

    namespace Reflection
    {
        class AmbiguousMatchException : System.SystemException
        {
            /*0x31bab10*/ AmbiguousMatchException();
            /*0x31bab6c*/ AmbiguousMatchException(string message);
            /*0x31bab90*/ AmbiguousMatchException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class AssemblyCompanyAttribute : System.Attribute
        {
            /*0x10*/ string <Company>k__BackingField;

            /*0x31bab98*/ AssemblyCompanyAttribute(string company);
        }

        class AssemblyConfigurationAttribute : System.Attribute
        {
            /*0x10*/ string <Configuration>k__BackingField;

            /*0x31babc8*/ AssemblyConfigurationAttribute(string configuration);
        }

        enum AssemblyContentType
        {
            Default = 0,
            WindowsRuntime = 1,
        }

        class AssemblyCopyrightAttribute : System.Attribute
        {
            /*0x10*/ string <Copyright>k__BackingField;

            /*0x31babf8*/ AssemblyCopyrightAttribute(string copyright);
        }

        class AssemblyDefaultAliasAttribute : System.Attribute
        {
            /*0x10*/ string <DefaultAlias>k__BackingField;

            /*0x31bac28*/ AssemblyDefaultAliasAttribute(string defaultAlias);
        }

        class AssemblyDelaySignAttribute : System.Attribute
        {
            /*0x10*/ bool <DelaySign>k__BackingField;

            /*0x31bac58*/ AssemblyDelaySignAttribute(bool delaySign);
        }

        class AssemblyDescriptionAttribute : System.Attribute
        {
            /*0x10*/ string <Description>k__BackingField;

            /*0x31bac80*/ AssemblyDescriptionAttribute(string description);
        }

        class AssemblyFileVersionAttribute : System.Attribute
        {
            /*0x10*/ string <Version>k__BackingField;

            /*0x31bacb0*/ AssemblyFileVersionAttribute(string version);
        }

        class AssemblyInformationalVersionAttribute : System.Attribute
        {
            /*0x10*/ string <InformationalVersion>k__BackingField;

            /*0x31bad2c*/ AssemblyInformationalVersionAttribute(string informationalVersion);
        }

        class AssemblyKeyFileAttribute : System.Attribute
        {
            /*0x10*/ string <KeyFile>k__BackingField;

            /*0x31bad5c*/ AssemblyKeyFileAttribute(string keyFile);
        }

        class AssemblyMetadataAttribute : System.Attribute
        {
            /*0x10*/ string <Key>k__BackingField;
            /*0x18*/ string <Value>k__BackingField;

            /*0x31bad8c*/ AssemblyMetadataAttribute(string key, string value);
        }

        enum AssemblyNameFlags
        {
            None = 0,
            PublicKey = 1,
            EnableJITcompileOptimizer = 16384,
            EnableJITcompileTracking = 32768,
            Retargetable = 256,
        }

        class AssemblyProductAttribute : System.Attribute
        {
            /*0x10*/ string <Product>k__BackingField;

            /*0x31badd0*/ AssemblyProductAttribute(string product);
        }

        class AssemblyTitleAttribute : System.Attribute
        {
            /*0x10*/ string <Title>k__BackingField;

            /*0x31bae00*/ AssemblyTitleAttribute(string title);
        }

        class AssemblyTrademarkAttribute : System.Attribute
        {
            /*0x10*/ string <Trademark>k__BackingField;

            /*0x31bae30*/ AssemblyTrademarkAttribute(string trademark);
        }

        class Binder
        {
            /*0x31bae60*/ Binder();
            System.Reflection.FieldInfo BindToField(System.Reflection.BindingFlags bindingAttr, System.Reflection.FieldInfo[] match, object value, System.Globalization.CultureInfo culture);
            System.Reflection.MethodBase BindToMethod(System.Reflection.BindingFlags bindingAttr, System.Reflection.MethodBase[] match, ref object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] names, ref object state);
            /*0x1f303d0*/ object ChangeType(object value, System.Type type, System.Globalization.CultureInfo culture);
            /*0x1f30ff0*/ void ReorderArgumentArray(ref object[] args, object state);
            System.Reflection.MethodBase SelectMethod(System.Reflection.BindingFlags bindingAttr, System.Reflection.MethodBase[] match, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
            System.Reflection.PropertyInfo SelectProperty(System.Reflection.BindingFlags bindingAttr, System.Reflection.PropertyInfo[] match, System.Type returnType, System.Type[] indexes, System.Reflection.ParameterModifier[] modifiers);
        }

        enum BindingFlags
        {
            Default = 0,
            IgnoreCase = 1,
            DeclaredOnly = 2,
            Instance = 4,
            Static = 8,
            Public = 16,
            NonPublic = 32,
            FlattenHierarchy = 64,
            InvokeMethod = 256,
            CreateInstance = 512,
            GetField = 1024,
            SetField = 2048,
            GetProperty = 4096,
            SetProperty = 8192,
            PutDispProperty = 16384,
            PutRefDispProperty = 32768,
            ExactBinding = 65536,
            SuppressChangeType = 131072,
            OptionalParamBinding = 262144,
            IgnoreReturn = 16777216,
            DoNotWrapExceptions = 33554432,
        }

        enum CallingConventions
        {
            Standard = 1,
            VarArgs = 2,
            Any = 3,
            HasThis = 32,
            ExplicitThis = 64,
        }

        class ConstructorInfo : System.Reflection.MethodBase
        {
            static /*0x0*/ string ConstructorName;
            static /*0x8*/ string TypeConstructorName;

            static /*0x31baf80*/ ConstructorInfo();
            static /*0x31baec0*/ bool op_Equality(System.Reflection.ConstructorInfo left, System.Reflection.ConstructorInfo right);
            static /*0x31baeec*/ bool op_Inequality(System.Reflection.ConstructorInfo left, System.Reflection.ConstructorInfo right);
            /*0x31bae68*/ ConstructorInfo();
            /*0x31bae78*/ System.Reflection.MemberTypes get_MemberType();
            /*0x31bae80*/ object Invoke(object[] parameters);
            object Invoke(System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);
            /*0x31baea0*/ bool Equals(object obj);
            /*0x31baeb0*/ int GetHashCode();
        }

        class CustomAttributeFormatException : System.FormatException
        {
            /*0x31bb018*/ CustomAttributeFormatException();
            /*0x31bb078*/ CustomAttributeFormatException(string message);
            /*0x31bb0a0*/ CustomAttributeFormatException(string message, System.Exception inner);
            /*0x31bb0c4*/ CustomAttributeFormatException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class DefaultMemberAttribute : System.Attribute
        {
            /*0x10*/ string <MemberName>k__BackingField;

            /*0x31bb0cc*/ DefaultMemberAttribute(string memberName);
            /*0x31bb0fc*/ string get_MemberName();
        }

        enum EventAttributes
        {
            None = 0,
            SpecialName = 512,
            RTSpecialName = 1024,
            ReservedMask = 1024,
        }

        class EventInfo : System.Reflection.MemberInfo
        {
            /*0x10*/ System.Reflection.EventInfo.AddEventAdapter cached_add_event;

            static /*0x31bb3c0*/ bool op_Equality(System.Reflection.EventInfo left, System.Reflection.EventInfo right);
            static /*0x31bb3ec*/ bool op_Inequality(System.Reflection.EventInfo left, System.Reflection.EventInfo right);
            static /*0x31bb5f0*/ System.Reflection.EventInfo internal_from_handle_type(nint event_handle, nint type_handle);
            static /*0x31bb5f4*/ System.Reflection.EventInfo GetEventFromHandle(Mono.RuntimeEventHandle handle, System.RuntimeTypeHandle reflectedType);
            /*0x31bb104*/ EventInfo();
            /*0x31bb114*/ System.Reflection.MemberTypes get_MemberType();
            /*0x31bb11c*/ System.Reflection.MethodInfo GetAddMethod();
            System.Reflection.MethodInfo GetAddMethod(bool nonPublic);
            System.Reflection.MethodInfo GetRemoveMethod(bool nonPublic);
            System.Reflection.MethodInfo GetRaiseMethod(bool nonPublic);
            /*0x31bb130*/ System.Type get_EventHandlerType();
            /*0x31bb24c*/ void RemoveEventHandler(object target, System.Delegate handler);
            /*0x31bb3a0*/ bool Equals(object obj);
            /*0x31bb3b0*/ int GetHashCode();
            /*0x31bb428*/ void AddEventHandler(object target, System.Delegate handler);

            class AddEventAdapter : System.MulticastDelegate
            {
                /*0x31bb674*/ AddEventAdapter(object object, nint method);
                /*0x31bb780*/ void Invoke(object _this, System.Delegate dele);
            }
        }

        enum ExceptionHandlingClauseOptions
        {
            Clause = 0,
            Filter = 1,
            Finally = 2,
            Fault = 4,
        }

        enum FieldAttributes
        {
            FieldAccessMask = 7,
            PrivateScope = 0,
            Private = 1,
            FamANDAssem = 2,
            Assembly = 3,
            Family = 4,
            FamORAssem = 5,
            Public = 6,
            Static = 16,
            InitOnly = 32,
            Literal = 64,
            NotSerialized = 128,
            SpecialName = 512,
            PinvokeImpl = 8192,
            RTSpecialName = 1024,
            HasFieldMarshal = 4096,
            HasDefault = 32768,
            HasFieldRVA = 256,
            ReservedMask = 38144,
        }

        class FieldInfo : System.Reflection.MemberInfo
        {
            static /*0x31bb884*/ bool op_Equality(System.Reflection.FieldInfo left, System.Reflection.FieldInfo right);
            static /*0x31bb8b0*/ bool op_Inequality(System.Reflection.FieldInfo left, System.Reflection.FieldInfo right);
            static /*0x31bb9ec*/ System.Reflection.FieldInfo internal_from_handle_type(nint field_handle, nint type_handle);
            static /*0x31bb9f0*/ System.Reflection.FieldInfo GetFieldFromHandle(System.RuntimeFieldHandle handle);
            static /*0x31bba48*/ System.Reflection.FieldInfo GetFieldFromHandle(System.RuntimeFieldHandle handle, System.RuntimeTypeHandle declaringType);
            /*0x31bb794*/ FieldInfo();
            /*0x31bb79c*/ System.Reflection.MemberTypes get_MemberType();
            /*0x1f2ffc8*/ System.Reflection.FieldAttributes get_Attributes();
            /*0x1f30214*/ System.Type get_FieldType();
            /*0x31bb7a4*/ bool get_IsInitOnly();
            /*0x31bb7c4*/ bool get_IsLiteral();
            /*0x31bb7e4*/ bool get_IsNotSerialized();
            /*0x31bb804*/ bool get_IsStatic();
            /*0x31bb824*/ bool get_IsPrivate();
            /*0x31bb84c*/ bool get_IsPublic();
            System.RuntimeFieldHandle get_FieldHandle();
            /*0x31bb874*/ bool Equals(object obj);
            /*0x31bb87c*/ int GetHashCode();
            /*0x1f302cc*/ object GetValue(object obj);
            /*0x31bb8ec*/ void SetValue(object obj, object value);
            void SetValue(object obj, object value, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Globalization.CultureInfo culture);
            /*0x31bb954*/ void SetValueDirect(System.TypedReference obj, object value);
            /*0x31bb9a0*/ object GetRawConstantValue();
            /*0x31bbac8*/ int GetFieldOffset();
            /*0x31bbb14*/ System.Runtime.InteropServices.MarshalAsAttribute get_marshal_info();
            /*0x31bbb18*/ object[] GetPseudoCustomAttributes();
            /*0x31bbd44*/ System.Reflection.CustomAttributeData[] GetPseudoCustomAttributesData();
        }

        enum GenericParameterAttributes
        {
            None = 0,
            VarianceMask = 3,
            Covariant = 1,
            Contravariant = 2,
            SpecialConstraintMask = 28,
            ReferenceTypeConstraint = 4,
            NotNullableValueTypeConstraint = 8,
            DefaultConstructorConstraint = 16,
        }

        interface ICustomAttributeProvider
        {
            object[] GetCustomAttributes(bool inherit);
            object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            bool IsDefined(System.Type attributeType, bool inherit);
        }

        interface IReflectableType
        {
            /*0x1f30214*/ System.Reflection.TypeInfo GetTypeInfo();
        }

        class IntrospectionExtensions
        {
            static /*0x31bc598*/ System.Reflection.TypeInfo GetTypeInfo(System.Type type);
        }

        class InvalidFilterCriteriaException : System.ApplicationException
        {
            /*0x31bc78c*/ InvalidFilterCriteriaException();
            /*0x31bc7ec*/ InvalidFilterCriteriaException(string message);
            /*0x31bc814*/ InvalidFilterCriteriaException(string message, System.Exception inner);
            /*0x31bc838*/ InvalidFilterCriteriaException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class ManifestResourceInfo
        {
            /*0x10*/ System.Reflection.Assembly <ReferencedAssembly>k__BackingField;
            /*0x18*/ string <FileName>k__BackingField;
            /*0x20*/ System.Reflection.ResourceLocation <ResourceLocation>k__BackingField;

            /*0x31bc840*/ ManifestResourceInfo(System.Reflection.Assembly containingAssembly, string containingFileName, System.Reflection.ResourceLocation resourceLocation);
            /*0x31bc898*/ System.Reflection.Assembly get_ReferencedAssembly();
            /*0x31bc8a0*/ string get_FileName();
            /*0x31bc8a8*/ System.Reflection.ResourceLocation get_ResourceLocation();
        }

        class MemberFilter : System.MulticastDelegate
        {
            /*0x31bc8b0*/ MemberFilter(object object, nint method);
            /*0x31bc9bc*/ bool Invoke(System.Reflection.MemberInfo m, object filterCriteria);
        }

        class MemberInfo : System.Reflection.ICustomAttributeProvider
        {
            static /*0x31ac4a4*/ bool op_Equality(System.Reflection.MemberInfo left, System.Reflection.MemberInfo right);
            static /*0x31ac7c4*/ bool op_Inequality(System.Reflection.MemberInfo left, System.Reflection.MemberInfo right);
            /*0x31bb10c*/ MemberInfo();
            /*0x1f2ffc8*/ System.Reflection.MemberTypes get_MemberType();
            /*0x1f30214*/ string get_Name();
            /*0x1f30214*/ System.Type get_DeclaringType();
            /*0x1f30214*/ System.Type get_ReflectedType();
            /*0x31bc9d0*/ System.Reflection.Module get_Module();
            bool IsDefined(System.Type attributeType, bool inherit);
            object[] GetCustomAttributes(bool inherit);
            object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            /*0x31bca7c*/ int get_MetadataToken();
            /*0x31bb3a8*/ bool Equals(object obj);
            /*0x31bb3b8*/ int GetHashCode();
        }

        enum MemberTypes
        {
            Constructor = 1,
            Event = 2,
            Field = 4,
            Method = 8,
            Property = 16,
            TypeInfo = 32,
            Custom = 64,
            NestedType = 128,
            All = 191,
        }

        enum MethodAttributes
        {
            MemberAccessMask = 7,
            PrivateScope = 0,
            Private = 1,
            FamANDAssem = 2,
            Assembly = 3,
            Family = 4,
            FamORAssem = 5,
            Public = 6,
            Static = 16,
            Final = 32,
            Virtual = 64,
            HideBySig = 128,
            CheckAccessOnOverride = 512,
            VtableLayoutMask = 256,
            ReuseSlot = 0,
            NewSlot = 256,
            Abstract = 1024,
            SpecialName = 2048,
            PinvokeImpl = 8192,
            UnmanagedExport = 8,
            RTSpecialName = 4096,
            HasSecurity = 16384,
            RequireSecObject = 32768,
            ReservedMask = 53248,
        }

        class MethodBase : System.Reflection.MemberInfo
        {
            static /*0x31bcacc*/ bool op_Equality(System.Reflection.MethodBase left, System.Reflection.MethodBase right);
            static /*0x31bcab4*/ bool op_Inequality(System.Reflection.MethodBase left, System.Reflection.MethodBase right);
            static /*0x31bd340*/ System.Reflection.MethodBase GetMethodFromHandle(System.RuntimeMethodHandle handle);
            static /*0x31bd02c*/ string ConstructParameters(System.Type[] parameterTypes, System.Reflection.CallingConventions callingConvention, bool serialization);
            /*0x31bae70*/ MethodBase();
            /*0x1f30214*/ System.Reflection.ParameterInfo[] GetParameters();
            /*0x1f2ffc8*/ System.Reflection.MethodAttributes get_Attributes();
            /*0x1f2ffc8*/ System.Reflection.MethodImplAttributes GetMethodImplementationFlags();
            /*0x31bccd4*/ System.Reflection.CallingConventions get_CallingConvention();
            /*0x31bccdc*/ bool get_IsAbstract();
            /*0x31bccfc*/ bool get_IsConstructor();
            /*0x31bcda0*/ bool get_IsSpecialName();
            /*0x31bb5a8*/ bool get_IsStatic();
            /*0x31bcdc0*/ bool get_IsVirtual();
            /*0x31bcde0*/ bool get_IsPublic();
            /*0x31bce08*/ bool get_IsGenericMethod();
            /*0x31bce10*/ bool get_IsGenericMethodDefinition();
            /*0x31bce18*/ System.Type[] GetGenericArguments();
            /*0x31bce64*/ bool get_ContainsGenericParameters();
            /*0x31bb380*/ object Invoke(object obj, object[] parameters);
            object Invoke(object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);
            System.RuntimeMethodHandle get_MethodHandle();
            /*0x31bce6c*/ bool get_IsSecurityCritical();
            /*0x31baea8*/ bool Equals(object obj);
            /*0x31baeb8*/ int GetHashCode();
            /*0x31bced0*/ System.Reflection.ParameterInfo[] GetParametersInternal();
            /*0x31bcee0*/ int GetParametersCount();
            /*0x31bcf08*/ string FormatNameAndSig(bool serialization);
            /*0x31bd224*/ System.Type[] GetParameterTypes();
            /*0x31bd330*/ System.Reflection.ParameterInfo[] GetParametersNoCopy();
        }

        enum MethodImplAttributes
        {
            CodeTypeMask = 3,
            IL = 0,
            Native = 1,
            OPTIL = 2,
            Runtime = 3,
            ManagedMask = 4,
            Unmanaged = 4,
            Managed = 0,
            ForwardRef = 16,
            PreserveSig = 128,
            InternalCall = 4096,
            Synchronized = 32,
            NoInlining = 8,
            AggressiveInlining = 256,
            NoOptimization = 64,
            MaxMethodImplVal = 65535,
            SecurityMitigations = 1024,
        }

        class MethodInfo : System.Reflection.MethodBase
        {
            static /*0x31b07b8*/ bool op_Equality(System.Reflection.MethodInfo left, System.Reflection.MethodInfo right);
            static /*0x31bce94*/ bool op_Inequality(System.Reflection.MethodInfo left, System.Reflection.MethodInfo right);
            /*0x31bd500*/ MethodInfo();
            /*0x31bd508*/ System.Reflection.MemberTypes get_MemberType();
            /*0x31bd510*/ System.Reflection.ParameterInfo get_ReturnParameter();
            /*0x31bd538*/ System.Type get_ReturnType();
            /*0x31bd560*/ System.Type[] GetGenericArguments();
            /*0x31bd5ac*/ System.Reflection.MethodInfo GetGenericMethodDefinition();
            /*0x31bd5f8*/ System.Reflection.MethodInfo MakeGenericMethod(System.Type[] typeArguments);
            /*0x1f30214*/ System.Reflection.MethodInfo GetBaseDefinition();
            /*0x31bd644*/ System.Delegate CreateDelegate(System.Type delegateType);
            /*0x31bd690*/ System.Delegate CreateDelegate(System.Type delegateType, object target);
            /*0x31bd6dc*/ bool Equals(object obj);
            /*0x31bd6e4*/ int GetHashCode();
            /*0x31bd6ec*/ int get_GenericParameterCount();
        }

        class Missing : System.Runtime.Serialization.ISerializable
        {
            static /*0x0*/ System.Reflection.Missing Value;

            static /*0x31bd754*/ Missing();
            /*0x31bd714*/ Missing();
            /*0x31bd71c*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class Module : System.Reflection.ICustomAttributeProvider, System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Module
        {
            static System.Reflection.BindingFlags DefaultLookup = 28;
            static /*0x0*/ System.Reflection.TypeFilter FilterTypeName;
            static /*0x8*/ System.Reflection.TypeFilter FilterTypeNameIgnoreCase;

            static /*0x31bdbd4*/ Module();
            static /*0x31bd914*/ bool op_Equality(System.Reflection.Module left, System.Reflection.Module right);
            static /*0x31bd94c*/ bool FilterTypeNameImpl(System.Type cls, object filterCriteria);
            static /*0x31bda5c*/ bool FilterTypeNameIgnoreCaseImpl(System.Type cls, object filterCriteria);
            /*0x31bd7bc*/ Module();
            /*0x31bd7c4*/ System.Reflection.Assembly get_Assembly();
            /*0x31bd7ec*/ System.Guid get_ModuleVersionId();
            /*0x31bd814*/ string get_ScopeName();
            /*0x31bd83c*/ bool IsResource();
            /*0x31bd864*/ bool IsDefined(System.Type attributeType, bool inherit);
            /*0x31bd88c*/ object[] GetCustomAttributes(bool inherit);
            /*0x31bd8b4*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            /*0x31bd8dc*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x31bd904*/ bool Equals(object o);
            /*0x31bd90c*/ int GetHashCode();
            /*0x31bd940*/ string ToString();
            /*0x31bdb9c*/ System.Guid GetModuleVersionId();
        }

        enum ParameterAttributes
        {
            None = 0,
            In = 1,
            Out = 2,
            Lcid = 4,
            Retval = 8,
            Optional = 16,
            HasDefault = 4096,
            HasFieldMarshal = 8192,
            Reserved3 = 16384,
            Reserved4 = 32768,
            ReservedMask = 61440,
        }

        class ParameterInfo : System.Reflection.ICustomAttributeProvider, System.Runtime.Serialization.IObjectReference, System.Runtime.InteropServices._ParameterInfo
        {
            static int MetadataToken_ParamDef = 134217728;
            /*0x10*/ System.Reflection.ParameterAttributes AttrsImpl;
            /*0x18*/ System.Type ClassImpl;
            /*0x20*/ object DefaultValueImpl;
            /*0x28*/ System.Reflection.MemberInfo MemberImpl;
            /*0x30*/ string NameImpl;
            /*0x38*/ int PositionImpl;

            /*0x31bddbc*/ ParameterInfo();
            /*0x31bddc4*/ System.Reflection.ParameterAttributes get_Attributes();
            /*0x31bddcc*/ System.Reflection.MemberInfo get_Member();
            /*0x31bddd4*/ string get_Name();
            /*0x31bdddc*/ System.Type get_ParameterType();
            /*0x31bdde4*/ int get_Position();
            /*0x31bddec*/ bool get_IsIn();
            /*0x31bde08*/ bool get_IsOptional();
            /*0x31bde24*/ bool get_IsOut();
            /*0x31bde40*/ object get_DefaultValue();
            /*0x31bde68*/ bool IsDefined(System.Type attributeType, bool inherit);
            /*0x31bdef0*/ object[] GetCustomAttributes(bool inherit);
            /*0x31bdf84*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            /*0x31be090*/ object GetRealObject(System.Runtime.Serialization.StreamingContext context);
            /*0x31be2f0*/ string ToString();
        }

        struct ParameterModifier
        {
            /*0x10*/ bool[] _byRef;
        }

        class Pointer : System.Runtime.Serialization.ISerializable
        {
            /*0x10*/ void* _ptr;
            /*0x18*/ System.Type _ptrType;

            static /*0x31be3ac*/ object Box(void* ptr, System.Type type);
            /*0x31be374*/ Pointer(void* ptr, System.Type ptrType);
            /*0x31be520*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        enum ProcessorArchitecture
        {
            None = 0,
            MSIL = 1,
            X86 = 2,
            IA64 = 3,
            Amd64 = 4,
            Arm = 5,
        }

        enum PropertyAttributes
        {
            None = 0,
            SpecialName = 512,
            RTSpecialName = 1024,
            HasDefault = 4096,
            Reserved2 = 8192,
            Reserved3 = 16384,
            Reserved4 = 32768,
            ReservedMask = 62464,
        }

        class PropertyInfo : System.Reflection.MemberInfo
        {
            static /*0x31bcca8*/ bool op_Equality(System.Reflection.PropertyInfo left, System.Reflection.PropertyInfo right);
            static /*0x31bcc6c*/ bool op_Inequality(System.Reflection.PropertyInfo left, System.Reflection.PropertyInfo right);
            /*0x31be558*/ PropertyInfo();
            /*0x31be560*/ System.Reflection.MemberTypes get_MemberType();
            /*0x1f30214*/ System.Type get_PropertyType();
            /*0x1f30214*/ System.Reflection.ParameterInfo[] GetIndexParameters();
            /*0x1f2fe14*/ bool get_CanRead();
            /*0x1f2fe14*/ bool get_CanWrite();
            /*0x31be568*/ System.Reflection.MethodInfo get_GetMethod();
            /*0x31be57c*/ System.Reflection.MethodInfo GetGetMethod();
            System.Reflection.MethodInfo GetGetMethod(bool nonPublic);
            /*0x31be590*/ System.Reflection.MethodInfo get_SetMethod();
            /*0x31be5a4*/ System.Reflection.MethodInfo GetSetMethod();
            System.Reflection.MethodInfo GetSetMethod(bool nonPublic);
            /*0x31be5b8*/ object GetValue(object obj);
            /*0x31be5cc*/ object GetValue(object obj, object[] index);
            object GetValue(object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] index, System.Globalization.CultureInfo culture);
            /*0x31be5ec*/ void SetValue(object obj, object value);
            /*0x31be600*/ void SetValue(object obj, object value, object[] index);
            void SetValue(object obj, object value, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] index, System.Globalization.CultureInfo culture);
            /*0x31be620*/ bool Equals(object obj);
            /*0x31be628*/ int GetHashCode();
        }

        class ReflectionTypeLoadException : System.SystemException, System.Runtime.Serialization.ISerializable
        {
            /*0x90*/ System.Type[] <Types>k__BackingField;
            /*0x98*/ System.Exception[] <LoaderExceptions>k__BackingField;

            /*0x31be630*/ ReflectionTypeLoadException(System.Type[] classes, System.Exception[] exceptions);
            /*0x31be688*/ ReflectionTypeLoadException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x31be7b8*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x31be8d4*/ System.Exception[] get_LoaderExceptions();
            /*0x31be8dc*/ string get_Message();
            /*0x31bea4c*/ string ToString();
            /*0x31be8e4*/ string CreateString(bool isMessage);
        }

        enum ResourceLocation
        {
            ContainedInAnotherAssembly = 2,
            ContainedInManifestFile = 4,
            Embedded = 1,
        }

        class SignatureArrayType : System.Reflection.SignatureHasElementType
        {
            /*0x20*/ int _rank;
            /*0x24*/ bool _isMultiDim;

            /*0x31bea54*/ SignatureArrayType(System.Reflection.SignatureType elementType, int rank, bool isMultiDim);
            /*0x31beac8*/ bool IsArrayImpl();
            /*0x31bead0*/ bool IsByRefImpl();
            /*0x31bead8*/ bool IsPointerImpl();
            /*0x31beae0*/ bool get_IsSZArray();
            /*0x31beaf0*/ bool get_IsVariableBoundArray();
            /*0x31beaf8*/ int GetArrayRank();
            /*0x31beb00*/ string get_Suffix();
        }

        class SignatureByRefType : System.Reflection.SignatureHasElementType
        {
            /*0x31bebc8*/ SignatureByRefType(System.Reflection.SignatureType elementType);
            /*0x31bebf4*/ bool IsArrayImpl();
            /*0x31bebfc*/ bool IsByRefImpl();
            /*0x31bec04*/ bool IsPointerImpl();
            /*0x31bec0c*/ bool get_IsSZArray();
            /*0x31bec14*/ bool get_IsVariableBoundArray();
            /*0x31bec1c*/ int GetArrayRank();
            /*0x31bec68*/ string get_Suffix();
        }

        class SignatureConstructedGenericType : System.Reflection.SignatureType
        {
            /*0x18*/ System.Type _genericTypeDefinition;
            /*0x20*/ System.Type[] _genericTypeArguments;

            /*0x31beca8*/ SignatureConstructedGenericType(System.Type genericTypeDefinition, System.Type[] typeArguments);
            /*0x31bee84*/ bool get_IsGenericTypeDefinition();
            /*0x31bee8c*/ bool HasElementTypeImpl();
            /*0x31bee94*/ bool IsArrayImpl();
            /*0x31bee9c*/ bool IsByRefImpl();
            /*0x31beea4*/ bool IsPointerImpl();
            /*0x31beeac*/ bool get_IsSZArray();
            /*0x31beeb4*/ bool get_IsVariableBoundArray();
            /*0x31beebc*/ bool get_IsConstructedGenericType();
            /*0x31beec4*/ bool get_IsGenericParameter();
            /*0x31beecc*/ bool get_IsGenericMethodParameter();
            /*0x31beed4*/ bool get_ContainsGenericParameters();
            /*0x31bef48*/ System.Reflection.SignatureType get_ElementType();
            /*0x31bef50*/ int GetArrayRank();
            /*0x31bef9c*/ System.Type GetGenericTypeDefinition();
            /*0x31befa4*/ System.Type[] GetGenericArguments();
            /*0x31befb4*/ System.Type[] get_GenericTypeArguments();
            /*0x31bf02c*/ int get_GenericParameterPosition();
            /*0x31bf078*/ string get_Name();
            /*0x31bf094*/ string get_Namespace();
            /*0x31bf0b4*/ string ToString();
        }

        class SignatureHasElementType : System.Reflection.SignatureType
        {
            /*0x18*/ System.Reflection.SignatureType _elementType;

            /*0x31bea9c*/ SignatureHasElementType(System.Reflection.SignatureType elementType);
            /*0x31bf1d8*/ bool get_IsGenericTypeDefinition();
            /*0x31bf1e0*/ bool HasElementTypeImpl();
            /*0x1f2fe14*/ bool IsArrayImpl();
            /*0x1f2fe14*/ bool IsByRefImpl();
            /*0x1f2fe14*/ bool IsPointerImpl();
            /*0x1f2fe14*/ bool get_IsSZArray();
            /*0x1f2fe14*/ bool get_IsVariableBoundArray();
            /*0x31bf1e8*/ bool get_IsConstructedGenericType();
            /*0x31bf1f0*/ bool get_IsGenericParameter();
            /*0x31bf1f8*/ bool get_IsGenericMethodParameter();
            /*0x31bf200*/ bool get_ContainsGenericParameters();
            /*0x31bf220*/ System.Reflection.SignatureType get_ElementType();
            /*0x1f2ffc8*/ int GetArrayRank();
            /*0x31bf228*/ System.Type GetGenericTypeDefinition();
            /*0x31bf274*/ System.Type[] GetGenericArguments();
            /*0x31bf308*/ System.Type[] get_GenericTypeArguments();
            /*0x31bf39c*/ int get_GenericParameterPosition();
            /*0x31bf3e8*/ string get_Name();
            /*0x31bf43c*/ string get_Namespace();
            /*0x31bf45c*/ string ToString();
            /*0x1f30214*/ string get_Suffix();
        }

        class SignaturePointerType : System.Reflection.SignatureHasElementType
        {
            /*0x31bf4b0*/ SignaturePointerType(System.Reflection.SignatureType elementType);
            /*0x31bf4dc*/ bool IsArrayImpl();
            /*0x31bf4e4*/ bool IsByRefImpl();
            /*0x31bf4ec*/ bool IsPointerImpl();
            /*0x31bf4f4*/ bool get_IsSZArray();
            /*0x31bf4fc*/ bool get_IsVariableBoundArray();
            /*0x31bf504*/ int GetArrayRank();
            /*0x31bf550*/ string get_Suffix();
        }

        class SignatureType : System.Type
        {
            /*0x31bee50*/ SignatureType();
            /*0x31bf590*/ bool get_IsSignatureType();
            /*0x1f2fe14*/ bool HasElementTypeImpl();
            /*0x1f2fe14*/ bool IsArrayImpl();
            /*0x1f2fe14*/ bool get_IsSZArray();
            /*0x1f2fe14*/ bool get_IsVariableBoundArray();
            /*0x1f2fe14*/ bool IsByRefImpl();
            /*0x1f2fe14*/ bool IsPointerImpl();
            /*0x31bf598*/ bool get_IsGenericType();
            /*0x1f2fe14*/ bool get_IsGenericTypeDefinition();
            /*0x1f2fe14*/ bool get_IsConstructedGenericType();
            /*0x1f2fe14*/ bool get_IsGenericParameter();
            /*0x1f2fe14*/ bool get_IsGenericMethodParameter();
            /*0x1f2fe14*/ bool get_ContainsGenericParameters();
            /*0x31bf5d8*/ System.Reflection.MemberTypes get_MemberType();
            /*0x31bf5e0*/ System.Type MakeArrayType();
            /*0x31bf650*/ System.Type MakeArrayType(int rank);
            /*0x31bf700*/ System.Type MakeByRefType();
            /*0x31bf764*/ System.Type MakePointerType();
            /*0x31bf7c8*/ System.Type MakeGenericType(System.Type[] typeArguments);
            /*0x31bf814*/ System.Type GetElementType();
            /*0x1f2ffc8*/ int GetArrayRank();
            /*0x1f30214*/ System.Type GetGenericTypeDefinition();
            /*0x1f30214*/ System.Type[] get_GenericTypeArguments();
            /*0x1f30214*/ System.Type[] GetGenericArguments();
            /*0x1f2ffc8*/ int get_GenericParameterPosition();
            /*0x1f30214*/ System.Reflection.SignatureType get_ElementType();
            /*0x31bf824*/ System.Type get_UnderlyingSystemType();
            /*0x1f30214*/ string get_Name();
            /*0x1f30214*/ string get_Namespace();
            /*0x31bf828*/ string get_FullName();
            /*0x31bf830*/ string get_AssemblyQualifiedName();
            /*0x1f30214*/ string ToString();
            /*0x31bf838*/ System.Reflection.Assembly get_Assembly();
            /*0x31bf884*/ System.Reflection.Module get_Module();
            /*0x31bf8d0*/ System.Type get_ReflectedType();
            /*0x31bf91c*/ System.Type get_BaseType();
            /*0x31bf968*/ System.Type[] GetInterfaces();
            /*0x31bf9b4*/ bool IsAssignableFrom(System.Type c);
            /*0x31bfa00*/ int get_MetadataToken();
            /*0x31bfa4c*/ System.Type get_DeclaringType();
            /*0x31bfa98*/ System.Reflection.MethodBase get_DeclaringMethod();
            /*0x31bfae4*/ System.Type[] GetGenericParameterConstraints();
            /*0x31bfb30*/ System.Reflection.GenericParameterAttributes get_GenericParameterAttributes();
            /*0x31bfb7c*/ bool IsEnumDefined(object value);
            /*0x31bfbc8*/ string GetEnumName(object value);
            /*0x31bfc14*/ string[] GetEnumNames();
            /*0x31bfc60*/ System.Type GetEnumUnderlyingType();
            /*0x31bfcac*/ System.Array GetEnumValues();
            /*0x31bfcf8*/ System.Guid get_GUID();
            /*0x31bfd44*/ System.TypeCode GetTypeCodeImpl();
            /*0x31bfd90*/ System.Reflection.TypeAttributes GetAttributeFlagsImpl();
            /*0x31bfddc*/ System.Reflection.ConstructorInfo[] GetConstructors(System.Reflection.BindingFlags bindingAttr);
            /*0x31bfe28*/ System.Reflection.EventInfo GetEvent(string name, System.Reflection.BindingFlags bindingAttr);
            /*0x31bfe74*/ System.Reflection.FieldInfo GetField(string name, System.Reflection.BindingFlags bindingAttr);
            /*0x31bfec0*/ System.Reflection.FieldInfo[] GetFields(System.Reflection.BindingFlags bindingAttr);
            /*0x31bff0c*/ System.Reflection.MemberInfo[] GetMembers(System.Reflection.BindingFlags bindingAttr);
            /*0x31bff58*/ System.Reflection.MethodInfo[] GetMethods(System.Reflection.BindingFlags bindingAttr);
            /*0x31bffa4*/ System.Type GetNestedType(string name, System.Reflection.BindingFlags bindingAttr);
            /*0x31bfff0*/ System.Reflection.PropertyInfo[] GetProperties(System.Reflection.BindingFlags bindingAttr);
            /*0x31c003c*/ object InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);
            /*0x31c0088*/ System.Reflection.MethodInfo GetMethodImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
            /*0x31c00d4*/ System.Reflection.PropertyInfo GetPropertyImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
            /*0x31c0120*/ System.Reflection.MemberInfo[] GetMember(string name, System.Reflection.BindingFlags bindingAttr);
            /*0x31c016c*/ System.Reflection.MemberInfo[] GetMember(string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);
            /*0x31c01b8*/ object[] GetCustomAttributes(bool inherit);
            /*0x31c0204*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            /*0x31c0250*/ bool IsDefined(System.Type attributeType, bool inherit);
            /*0x31c029c*/ System.Reflection.ConstructorInfo GetConstructorImpl(System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
            /*0x31c02e8*/ bool IsCOMObjectImpl();
            /*0x31c0334*/ bool IsPrimitiveImpl();
            /*0x31c0380*/ bool IsContextfulImpl();
            /*0x31c03cc*/ bool get_IsEnum();
            /*0x31c0418*/ bool IsEquivalentTo(System.Type other);
            /*0x31c0464*/ bool IsInstanceOfType(object o);
            /*0x31c04b0*/ bool IsMarshalByRefImpl();
            /*0x31c04fc*/ bool get_IsSerializable();
            /*0x31c0548*/ bool IsSubclassOf(System.Type c);
            /*0x31c0594*/ bool IsValueTypeImpl();
            /*0x31c05e0*/ System.RuntimeTypeHandle get_TypeHandle();
        }

        class SignatureTypeExtensions
        {
            static /*0x31c062c*/ bool MatchesParameterTypeExactly(System.Type pattern, System.Reflection.ParameterInfo parameter);
            static /*0x31c06e8*/ bool MatchesExactly(System.Reflection.SignatureType pattern, System.Type actual);
            static /*0x31c0a8c*/ System.Type TryResolveAgainstGenericMethod(System.Reflection.SignatureType signatureType, System.Reflection.MethodInfo genericMethod);
            static /*0x31c0ac4*/ System.Type TryResolve(System.Reflection.SignatureType signatureType, System.Type[] genericMethodParameters);
            static /*0x31c0ea0*/ System.Type TryMakeArrayType(System.Type type);
            static /*0x31c0f3c*/ System.Type TryMakeArrayType(System.Type type, int rank);
            static /*0x31c0fd8*/ System.Type TryMakeByRefType(System.Type type);
            static /*0x31c1074*/ System.Type TryMakePointerType(System.Type type);
            static /*0x31c1110*/ System.Type TryMakeGenericType(System.Type type, System.Type[] instantiation);
        }

        class TargetException : System.ApplicationException
        {
            /*0x31c11ac*/ TargetException();
            /*0x31bb5c8*/ TargetException(string message);
            /*0x31c11d8*/ TargetException(string message, System.Exception inner);
            /*0x31c11fc*/ TargetException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class TargetInvocationException : System.ApplicationException
        {
            /*0x31c1204*/ TargetInvocationException(System.Exception inner);
            /*0x31c1270*/ TargetInvocationException(string message, System.Exception inner);
            /*0x31c1294*/ TargetInvocationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class TargetParameterCountException : System.ApplicationException
        {
            /*0x31c129c*/ TargetParameterCountException();
            /*0x31c12f8*/ TargetParameterCountException(string message);
            /*0x31c131c*/ TargetParameterCountException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        enum TypeAttributes
        {
            VisibilityMask = 7,
            NotPublic = 0,
            Public = 1,
            NestedPublic = 2,
            NestedPrivate = 3,
            NestedFamily = 4,
            NestedAssembly = 5,
            NestedFamANDAssem = 6,
            NestedFamORAssem = 7,
            LayoutMask = 24,
            AutoLayout = 0,
            SequentialLayout = 8,
            ExplicitLayout = 16,
            ClassSemanticsMask = 32,
            Class = 0,
            Interface = 32,
            Abstract = 128,
            Sealed = 256,
            SpecialName = 1024,
            Import = 4096,
            Serializable = 8192,
            WindowsRuntime = 16384,
            StringFormatMask = 196608,
            AnsiClass = 0,
            UnicodeClass = 65536,
            AutoClass = 131072,
            CustomFormatClass = 196608,
            CustomFormatMask = 12582912,
            BeforeFieldInit = 1048576,
            RTSpecialName = 2048,
            HasSecurity = 262144,
            ReservedMask = 264192,
        }

        class TypeDelegator : System.Reflection.TypeInfo
        {
            /*0x18*/ System.Type typeImpl;

            /*0x31bc6ec*/ TypeDelegator(System.Type delegatingType);
            /*0x31c1324*/ bool IsAssignableFrom(System.Reflection.TypeInfo typeInfo);
            /*0x31c13e4*/ System.Guid get_GUID();
            /*0x31c1404*/ int get_MetadataToken();
            /*0x31c1424*/ object InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);
            /*0x31c1450*/ System.Reflection.Module get_Module();
            /*0x31c1470*/ System.Reflection.Assembly get_Assembly();
            /*0x31c1490*/ System.RuntimeTypeHandle get_TypeHandle();
            /*0x31c14b0*/ string get_Name();
            /*0x31c14cc*/ string get_FullName();
            /*0x31c14ec*/ string get_Namespace();
            /*0x31c150c*/ string get_AssemblyQualifiedName();
            /*0x31c152c*/ System.Type get_BaseType();
            /*0x31c154c*/ System.Reflection.ConstructorInfo GetConstructorImpl(System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
            /*0x31c1564*/ System.Reflection.ConstructorInfo[] GetConstructors(System.Reflection.BindingFlags bindingAttr);
            /*0x31c1584*/ System.Reflection.MethodInfo GetMethodImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
            /*0x31c15b4*/ System.Reflection.MethodInfo[] GetMethods(System.Reflection.BindingFlags bindingAttr);
            /*0x31c15d4*/ System.Reflection.FieldInfo GetField(string name, System.Reflection.BindingFlags bindingAttr);
            /*0x31c15f4*/ System.Reflection.FieldInfo[] GetFields(System.Reflection.BindingFlags bindingAttr);
            /*0x31c1614*/ System.Type[] GetInterfaces();
            /*0x31c1634*/ System.Reflection.EventInfo GetEvent(string name, System.Reflection.BindingFlags bindingAttr);
            /*0x31c1654*/ System.Reflection.PropertyInfo GetPropertyImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
            /*0x31c171c*/ System.Reflection.PropertyInfo[] GetProperties(System.Reflection.BindingFlags bindingAttr);
            /*0x31c173c*/ System.Type GetNestedType(string name, System.Reflection.BindingFlags bindingAttr);
            /*0x31c175c*/ System.Reflection.MemberInfo[] GetMember(string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);
            /*0x31c177c*/ System.Reflection.MemberInfo[] GetMembers(System.Reflection.BindingFlags bindingAttr);
            /*0x31c179c*/ System.Reflection.TypeAttributes GetAttributeFlagsImpl();
            /*0x31c17b4*/ bool get_IsSZArray();
            /*0x31c17d4*/ bool IsArrayImpl();
            /*0x31c17ec*/ bool IsPrimitiveImpl();
            /*0x31c1804*/ bool IsByRefImpl();
            /*0x31c181c*/ bool get_IsGenericMethodParameter();
            /*0x31c183c*/ bool IsPointerImpl();
            /*0x31c1854*/ bool IsValueTypeImpl();
            /*0x31c186c*/ bool IsCOMObjectImpl();
            /*0x31c1884*/ bool get_IsConstructedGenericType();
            /*0x31c18a4*/ bool get_IsCollectible();
            /*0x31c18c4*/ System.Type GetElementType();
            /*0x31c18e4*/ bool HasElementTypeImpl();
            /*0x31c18fc*/ System.Type get_UnderlyingSystemType();
            /*0x31c191c*/ object[] GetCustomAttributes(bool inherit);
            /*0x31c1940*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            /*0x31c1964*/ bool IsDefined(System.Type attributeType, bool inherit);
        }

        class TypeFilter : System.MulticastDelegate
        {
            /*0x31bdcb0*/ TypeFilter(object object, nint method);
            /*0x31c1984*/ bool Invoke(System.Type m, object filterCriteria);
        }

        class TypeInfo : System.Type, System.Reflection.IReflectableType
        {
            /*0x31c13b0*/ TypeInfo();
            /*0x31c1998*/ System.Reflection.TypeInfo System.Reflection.IReflectableType.GetTypeInfo();
            /*0x31c199c*/ System.Type AsType();
            /*0x31c19a0*/ System.Reflection.MethodInfo GetDeclaredMethod(string name);
            /*0x31c19ac*/ System.Reflection.PropertyInfo GetDeclaredProperty(string name);
            /*0x31c19b8*/ System.Collections.Generic.IEnumerable<System.Reflection.FieldInfo> get_DeclaredFields();
            /*0x31c19cc*/ System.Collections.Generic.IEnumerable<System.Type> get_ImplementedInterfaces();
            /*0x31c19dc*/ bool IsAssignableFrom(System.Reflection.TypeInfo typeInfo);
        }

        class RuntimeReflectionExtensions
        {
            static /*0x31c1b3c*/ System.Collections.Generic.IEnumerable<System.Reflection.FieldInfo> GetRuntimeFields(System.Type type);
            static /*0x31c1be0*/ System.Reflection.MethodInfo GetRuntimeMethod(System.Type type, string name, System.Type[] parameters);
            static /*0x31c1c90*/ System.Reflection.PropertyInfo GetRuntimeProperty(System.Type type, string name);
        }

        struct CustomAttributeNamedArgument
        {
            /*0x10*/ System.Reflection.CustomAttributeTypedArgument <TypedValue>k__BackingField;
            /*0x20*/ bool <IsField>k__BackingField;
            /*0x28*/ string <MemberName>k__BackingField;
            /*0x30*/ System.Type _attributeType;
            /*0x38*/ System.Reflection.MemberInfo _lazyMemberInfo;

            static /*0x31c2364*/ bool op_Equality(System.Reflection.CustomAttributeNamedArgument left, System.Reflection.CustomAttributeNamedArgument right);
            static /*0x31c23e4*/ bool op_Inequality(System.Reflection.CustomAttributeNamedArgument left, System.Reflection.CustomAttributeNamedArgument right);
            /*0x31c1d38*/ CustomAttributeNamedArgument(System.Type attributeType, string memberName, bool isField, System.Reflection.CustomAttributeTypedArgument typedValue);
            /*0x31c1da4*/ CustomAttributeNamedArgument(System.Reflection.MemberInfo memberInfo, object value);
            /*0x31c2028*/ CustomAttributeNamedArgument(System.Reflection.MemberInfo memberInfo, System.Reflection.CustomAttributeTypedArgument typedArgument);
            /*0x31c2174*/ System.Reflection.CustomAttributeTypedArgument get_TypedValue();
            /*0x31c2180*/ bool get_IsField();
            /*0x31c2188*/ string get_MemberName();
            /*0x31c2190*/ System.Reflection.MemberInfo get_MemberInfo();
            /*0x31c2280*/ bool Equals(object obj);
            /*0x31c22f8*/ int GetHashCode();
            /*0x31c2468*/ string ToString();
        }

        struct CustomAttributeTypedArgument
        {
            /*0x10*/ System.Type <ArgumentType>k__BackingField;
            /*0x18*/ object <Value>k__BackingField;

            static /*0x31c3224*/ bool op_Equality(System.Reflection.CustomAttributeTypedArgument left, System.Reflection.CustomAttributeTypedArgument right);
            static /*0x31c329c*/ bool op_Inequality(System.Reflection.CustomAttributeTypedArgument left, System.Reflection.CustomAttributeTypedArgument right);
            static /*0x31c30b8*/ object CanonicalizeValue(object value);
            /*0x31c3020*/ CustomAttributeTypedArgument(object value);
            /*0x31bc2e8*/ CustomAttributeTypedArgument(System.Type argumentType, object value);
            /*0x31c3140*/ System.Type get_ArgumentType();
            /*0x31c3148*/ object get_Value();
            /*0x31c3150*/ bool Equals(object obj);
            /*0x31c31c0*/ int GetHashCode();
            /*0x31c3318*/ string ToString();
            /*0x31c2774*/ string ToString(bool typed);
        }

        class MissingMetadataException : System.TypeAccessException
        {
            /*0x31c35e8*/ MissingMetadataException();
        }

        class CustomAttributeExtensions
        {
            static /*0x31c35f0*/ System.Attribute GetCustomAttribute(System.Reflection.Assembly element, System.Type attributeType);
            static /*0x31c35f8*/ System.Attribute GetCustomAttribute(System.Reflection.MemberInfo element, System.Type attributeType);
            static /*0x1ffc854*/ T GetCustomAttribute<T>(System.Reflection.Assembly element);
            static /*0x1ffc854*/ T GetCustomAttribute<T>(System.Reflection.MemberInfo element);
            static /*0x31c3600*/ System.Attribute GetCustomAttribute(System.Reflection.MemberInfo element, System.Type attributeType, bool inherit);
            static /*0x1ffc854*/ T GetCustomAttribute<T>(System.Reflection.MemberInfo element, bool inherit);
            static /*0x31c3608*/ System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(System.Reflection.MemberInfo element);
            static /*0x31c3610*/ System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(System.Reflection.MemberInfo element, System.Type attributeType);
            static /*0x1f327cc*/ System.Collections.Generic.IEnumerable<T> GetCustomAttributes<T>(System.Reflection.MemberInfo element);
            static /*0x31c3618*/ bool IsDefined(System.Reflection.MemberInfo element, System.Type attributeType);
        }

        enum CorElementType
        {
            End = 0,
            Void = 1,
            Boolean = 2,
            Char = 3,
            I1 = 4,
            U1 = 5,
            I2 = 6,
            U2 = 7,
            I4 = 8,
            U4 = 9,
            I8 = 10,
            U8 = 11,
            R4 = 12,
            R8 = 13,
            String = 14,
            Ptr = 15,
            ByRef = 16,
            ValueType = 17,
            Class = 18,
            Var = 19,
            Array = 20,
            GenericInst = 21,
            TypedByRef = 22,
            I = 24,
            U = 25,
            FnPtr = 27,
            Object = 28,
            SzArray = 29,
            MVar = 30,
            CModReqd = 31,
            CModOpt = 32,
            Internal = 33,
            Max = 34,
            Modifier = 64,
            Sentinel = 65,
            Pinned = 69,
            ELEMENT_TYPE_END = 0,
            ELEMENT_TYPE_VOID = 1,
            ELEMENT_TYPE_BOOLEAN = 2,
            ELEMENT_TYPE_CHAR = 3,
            ELEMENT_TYPE_I1 = 4,
            ELEMENT_TYPE_U1 = 5,
            ELEMENT_TYPE_I2 = 6,
            ELEMENT_TYPE_U2 = 7,
            ELEMENT_TYPE_I4 = 8,
            ELEMENT_TYPE_U4 = 9,
            ELEMENT_TYPE_I8 = 10,
            ELEMENT_TYPE_U8 = 11,
            ELEMENT_TYPE_R4 = 12,
            ELEMENT_TYPE_R8 = 13,
            ELEMENT_TYPE_STRING = 14,
            ELEMENT_TYPE_PTR = 15,
            ELEMENT_TYPE_BYREF = 16,
            ELEMENT_TYPE_VALUETYPE = 17,
            ELEMENT_TYPE_CLASS = 18,
            ELEMENT_TYPE_VAR = 19,
            ELEMENT_TYPE_ARRAY = 20,
            ELEMENT_TYPE_GENERICINST = 21,
            ELEMENT_TYPE_TYPEDBYREF = 22,
            ELEMENT_TYPE_I = 24,
            ELEMENT_TYPE_U = 25,
            ELEMENT_TYPE_FNPTR = 27,
            ELEMENT_TYPE_OBJECT = 28,
            ELEMENT_TYPE_SZARRAY = 29,
            ELEMENT_TYPE_MVAR = 30,
            ELEMENT_TYPE_CMOD_REQD = 31,
            ELEMENT_TYPE_CMOD_OPT = 32,
            ELEMENT_TYPE_INTERNAL = 33,
            ELEMENT_TYPE_MAX = 34,
            ELEMENT_TYPE_MODIFIER = 64,
            ELEMENT_TYPE_SENTINEL = 65,
            ELEMENT_TYPE_PINNED = 69,
        }

        enum PInvokeAttributes
        {
            NoMangle = 1,
            CharSetMask = 6,
            CharSetNotSpec = 0,
            CharSetAnsi = 2,
            CharSetUnicode = 4,
            CharSetAuto = 6,
            BestFitUseAssem = 0,
            BestFitEnabled = 16,
            BestFitDisabled = 32,
            BestFitMask = 48,
            ThrowOnUnmappableCharUseAssem = 0,
            ThrowOnUnmappableCharEnabled = 4096,
            ThrowOnUnmappableCharDisabled = 8192,
            ThrowOnUnmappableCharMask = 12288,
            SupportsLastError = 64,
            CallConvMask = 1792,
            CallConvWinapi = 256,
            CallConvCdecl = 512,
            CallConvStdcall = 768,
            CallConvThiscall = 1024,
            CallConvFastcall = 1280,
            MaxValue = 65535,
        }

        class MemberInfoSerializationHolder : System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IObjectReference
        {
            /*0x10*/ string m_memberName;
            /*0x18*/ System.RuntimeType m_reflectedType;
            /*0x20*/ string m_signature;
            /*0x28*/ string m_signature2;
            /*0x30*/ System.Reflection.MemberTypes m_memberType;
            /*0x38*/ System.Runtime.Serialization.SerializationInfo m_info;

            static /*0x31c3620*/ void GetSerializationInfo(System.Runtime.Serialization.SerializationInfo info, string name, System.RuntimeType reflectedClass, string signature, System.Reflection.MemberTypes type);
            static /*0x31c3630*/ void GetSerializationInfo(System.Runtime.Serialization.SerializationInfo info, string name, System.RuntimeType reflectedClass, string signature, string signature2, System.Reflection.MemberTypes type, System.Type[] genericArguments);
            /*0x31c3928*/ MemberInfoSerializationHolder(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x31c3c80*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x31c3cd8*/ object GetRealObject(System.Runtime.Serialization.StreamingContext context);
        }

        class Assembly : System.Reflection.ICustomAttributeProvider, System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Assembly
        {
            static /*0x31c4870*/ System.Reflection.Assembly GetAssembly(System.Type type);
            static /*0x31c4910*/ System.Reflection.Assembly Load(string assemblyString);
            static /*0x31c4938*/ System.Reflection.Assembly ReflectionOnlyLoad(string assemblyString);
            static /*0x31c4980*/ System.Reflection.Assembly LoadWithPartialName(string partialName);
            static /*0x31c4994*/ System.Reflection.Assembly load_with_partial_name(string name, System.Security.Policy.Evidence e);
            static /*0x31c498c*/ System.Reflection.Assembly LoadWithPartialName(string partialName, System.Security.Policy.Evidence securityEvidence);
            static /*0x31c4998*/ System.Reflection.Assembly LoadWithPartialName(string partialName, System.Security.Policy.Evidence securityEvidence, bool oldBehavior);
            static /*0x31c4a38*/ System.Reflection.Assembly GetExecutingAssembly();
            static /*0x31c4a78*/ System.Reflection.Assembly GetCallingAssembly();
            static /*0x31c4ac4*/ System.Exception CreateNIE();
            static /*0x31c4bac*/ bool op_Equality(System.Reflection.Assembly left, System.Reflection.Assembly right);
            static /*0x31c4bf4*/ bool op_Inequality(System.Reflection.Assembly left, System.Reflection.Assembly right);
            /*0x31c4c4c*/ Assembly();
            /*0x31c45b8*/ string get_CodeBase();
            /*0x31c45f0*/ string get_FullName();
            /*0x31c4628*/ nint get_MonoAssembly();
            /*0x31c4660*/ string get_Location();
            /*0x31c4698*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x31c46d0*/ bool IsDefined(System.Type attributeType, bool inherit);
            /*0x31c4708*/ object[] GetCustomAttributes(bool inherit);
            /*0x31c4740*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            /*0x31c4778*/ System.IO.Stream GetManifestResourceStream(string name);
            /*0x31c47b0*/ System.Type[] GetTypes(bool exportedOnly);
            /*0x31c47b4*/ System.Type[] GetTypes();
            /*0x31c47c8*/ System.Type[] GetExportedTypes();
            /*0x31c4800*/ System.Type GetType(string name);
            /*0x31c4818*/ System.Type InternalGetType(System.Reflection.Module module, string name, bool throwOnError, bool ignoreCase);
            /*0x31c481c*/ System.Reflection.AssemblyName GetName(bool copiedName);
            /*0x31c4854*/ System.Reflection.AssemblyName GetName();
            /*0x31c4868*/ string ToString();
            /*0x31c4a00*/ System.Reflection.Module[] GetModulesInternal();
            /*0x31c4a7c*/ System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName);
            /*0x31c4ab4*/ int GetHashCode();
            /*0x31c4abc*/ bool Equals(object o);
            /*0x31c4b30*/ bool get_IsFullyTrusted();
            /*0x31c4b38*/ System.Type GetType(string name, bool throwOnError, bool ignoreCase);
            /*0x31c4b5c*/ System.Reflection.Module GetModule(string name);
            /*0x31c4b80*/ System.Reflection.Module[] GetModules(bool getResourceModules);
            /*0x31c4ba4*/ bool get_IsDynamic();

            class ResolveEventHolder
            {
                /*0x31c4c54*/ ResolveEventHolder();
            }
        }

        class AssemblyName : System.ICloneable, System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.InteropServices._AssemblyName
        {
            /*0x10*/ string name;
            /*0x18*/ string codebase;
            /*0x20*/ int major;
            /*0x24*/ int minor;
            /*0x28*/ int build;
            /*0x2c*/ int revision;
            /*0x30*/ System.Globalization.CultureInfo cultureinfo;
            /*0x38*/ System.Reflection.AssemblyNameFlags flags;
            /*0x3c*/ System.Configuration.Assemblies.AssemblyHashAlgorithm hashalg;
            /*0x40*/ System.Reflection.StrongNameKeyPair keypair;
            /*0x48*/ byte[] publicKey;
            /*0x50*/ byte[] keyToken;
            /*0x58*/ System.Configuration.Assemblies.AssemblyVersionCompatibility versioncompat;
            /*0x60*/ System.Version version;
            /*0x68*/ System.Reflection.ProcessorArchitecture processor_architecture;
            /*0x6c*/ System.Reflection.AssemblyContentType contentType;

            static /*0x31c4c7c*/ bool ParseAssemblyName(nint name, ref Mono.MonoAssemblyName aname, ref bool is_version_definited, ref bool is_token_defined);
            static /*0x31c5e74*/ void get_public_token(byte* token, byte* pubkey, int len);
            static /*0x31c629c*/ Mono.MonoAssemblyName* GetNativeName(nint assembly_ptr);
            static /*0x31c62a0*/ System.Reflection.AssemblyName Create(System.Reflection.Assembly assembly, bool fillCodebase);
            /*0x31c4c5c*/ AssemblyName();
            /*0x31c4c80*/ AssemblyName(string assemblyName);
            /*0x31c5208*/ AssemblyName(System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext sc);
            /*0x31c57a0*/ string get_Name();
            /*0x31c57a8*/ System.Globalization.CultureInfo get_CultureInfo();
            /*0x31c57b0*/ System.Reflection.AssemblyNameFlags get_Flags();
            /*0x31c57b8*/ string get_FullName();
            /*0x31c5bf8*/ System.Version get_Version();
            /*0x31c5c00*/ void set_Version(System.Version value);
            /*0x31c5c50*/ string ToString();
            /*0x31c5c78*/ byte[] GetPublicKeyToken();
            /*0x31c5d68*/ bool get_IsPublicKeyValid();
            /*0x31c5b14*/ byte[] InternalGetPublicKeyToken();
            /*0x31c5dec*/ byte[] ComputePublicKeyToken();
            /*0x31c5e78*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x31c61a4*/ object Clone();
            /*0x31c6294*/ void OnDeserialization(object sender);
            /*0x31c4f34*/ void FillName(Mono.MonoAssemblyName* native, string codeBase, bool addVersion, bool addPublickey, bool defaultToken, bool assemblyRef);
        }

        class CustomAttributeData
        {
            /*0x10*/ System.Reflection.ConstructorInfo ctorInfo;
            /*0x18*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeTypedArgument> ctorArgs;
            /*0x20*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeNamedArgument> namedArgs;
            /*0x28*/ System.Reflection.CustomAttributeData.LazyCAttrData lazyData;

            static /*0x31c65bc*/ void ResolveArgumentsInternal(System.Reflection.ConstructorInfo ctor, System.Reflection.Assembly assembly, nint data, uint data_length, ref object[] ctorArgs, ref object[] namedArgs);
            static /*0x31c67ec*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributes(System.Reflection.Assembly target);
            static /*0x31c6848*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributes(System.Reflection.MemberInfo target);
            static /*0x31c68a4*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributesInternal(System.RuntimeType target);
            static /*0x31c6900*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributes(System.Reflection.Module target);
            static /*0x31c695c*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributes(System.Reflection.ParameterInfo target);
            static /*0x1f327cc*/ T[] UnboxValues<T>(object[] values);
            /*0x31c6368*/ CustomAttributeData();
            /*0x31c6370*/ CustomAttributeData(System.Reflection.ConstructorInfo ctorInfo, System.Reflection.Assembly assembly, nint data, uint data_length);
            /*0x31c6440*/ CustomAttributeData(System.Reflection.ConstructorInfo ctorInfo);
            /*0x31c655c*/ CustomAttributeData(System.Reflection.ConstructorInfo ctorInfo, System.Collections.Generic.IList<System.Reflection.CustomAttributeTypedArgument> ctorArgs, System.Collections.Generic.IList<System.Reflection.CustomAttributeNamedArgument> namedArgs);
            /*0x31c65c0*/ void ResolveArguments();
            /*0x31c67b4*/ System.Reflection.ConstructorInfo get_Constructor();
            /*0x31c67bc*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeTypedArgument> get_ConstructorArguments();
            /*0x31c67d4*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeNamedArgument> get_NamedArguments();
            /*0x31c69b8*/ System.Type get_AttributeType();
            /*0x31c69d4*/ string ToString();
            /*0x31c6f60*/ bool Equals(object obj);
            /*0x31c75e4*/ int GetHashCode();

            class LazyCAttrData
            {
                /*0x10*/ System.Reflection.Assembly assembly;
                /*0x18*/ nint data;
                /*0x20*/ uint data_length;

                /*0x31c6438*/ LazyCAttrData();
            }
        }

        class ExceptionHandlingClause
        {
            /*0x10*/ System.Type catch_type;
            /*0x18*/ int filter_offset;
            /*0x1c*/ System.Reflection.ExceptionHandlingClauseOptions flags;
            /*0x20*/ int try_offset;
            /*0x24*/ int try_length;
            /*0x28*/ int handler_offset;
            /*0x2c*/ int handler_length;

            /*0x31c78f0*/ ExceptionHandlingClause();
            /*0x31c78f8*/ string ToString();
        }

        class LocalVariableInfo
        {
            /*0x10*/ System.Type type;
            /*0x18*/ bool is_pinned;
            /*0x1a*/ ushort position;

            /*0x31c7bd8*/ LocalVariableInfo();
            /*0x31c7be0*/ string ToString();
        }

        class RuntimeAssembly : System.Reflection.Assembly
        {
            /*0x10*/ nint _mono_assembly;
            /*0x18*/ object _evidence;
            /*0x20*/ System.Reflection.Assembly.ResolveEventHolder resolve_event_holder;
            /*0x28*/ object _minimum;
            /*0x30*/ object _optional;
            /*0x38*/ object _refuse;
            /*0x40*/ object _granted;
            /*0x48*/ object _denied;
            /*0x50*/ bool fromByteArray;
            /*0x58*/ string assemblyName;

            static /*0x31c7d88*/ System.Reflection.RuntimeAssembly LoadWithPartialNameInternal(string partialName, System.Security.Policy.Evidence securityEvidence, ref System.Threading.StackCrawlMark stackMark);
            static /*0x31c7e10*/ System.Reflection.RuntimeAssembly LoadWithPartialNameInternal(System.Reflection.AssemblyName an, System.Security.Policy.Evidence securityEvidence, ref System.Threading.StackCrawlMark stackMark);
            static /*0x31c8184*/ byte[] GetAotId();
            static /*0x31c81e0*/ string get_code_base(System.Reflection.Assembly a, bool escaped);
            static /*0x31c81e8*/ string get_fullname(System.Reflection.Assembly a);
            static /*0x31c81dc*/ bool GetAotIdInternal(byte[] aotid);
            static /*0x31c81ec*/ string GetCodeBase(System.Reflection.Assembly a, bool escaped);
            /*0x31c7c94*/ RuntimeAssembly();
            /*0x31c7d00*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x31c7e38*/ System.Reflection.AssemblyName GetName(bool copiedName);
            /*0x31c7e40*/ System.Type GetType(string name, bool throwOnError, bool ignoreCase);
            /*0x31c7ef8*/ System.Reflection.Module GetModule(string name);
            /*0x31c8020*/ System.Reflection.Module[] GetModules(bool getResourceModules);
            /*0x31c8170*/ System.Type[] GetExportedTypes();
            /*0x31c81e4*/ string get_location();
            /*0x31c81f0*/ string get_CodeBase();
            /*0x31c81f8*/ string get_FullName();
            /*0x31c81fc*/ nint get_MonoAssembly();
            /*0x31c8204*/ string get_Location();
            /*0x31c8228*/ bool GetManifestResourceInfoInternal(string name, System.Reflection.ManifestResourceInfo info);
            /*0x31c822c*/ System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName);
            /*0x31c8330*/ nint GetManifestResourceInternal(string name, ref int size, ref System.Reflection.Module module);
            /*0x31c8334*/ System.IO.Stream GetManifestResourceStream(string name);
            /*0x31c86cc*/ bool IsDefined(System.Type attributeType, bool inherit);
            /*0x31c873c*/ object[] GetCustomAttributes(bool inherit);
            /*0x31c87a4*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            /*0x31c8814*/ System.Reflection.Module[] GetModulesInternal();
            /*0x31c8818*/ int GetHashCode();
            /*0x31c8820*/ bool Equals(object o);
            /*0x31c88bc*/ string ToString();

            class UnmanagedMemoryStreamForModule : System.IO.UnmanagedMemoryStream
            {
                /*0x68*/ System.Reflection.Module module;

                /*0x31c869c*/ UnmanagedMemoryStreamForModule(byte* pointer, long length, System.Reflection.Module module);
                /*0x31c8904*/ void Dispose(bool disposing);
            }
        }

        struct MonoEventInfo
        {
            /*0x10*/ System.Type declaring_type;
            /*0x18*/ System.Type reflected_type;
            /*0x20*/ string name;
            /*0x28*/ System.Reflection.MethodInfo add_method;
            /*0x30*/ System.Reflection.MethodInfo remove_method;
            /*0x38*/ System.Reflection.MethodInfo raise_method;
            /*0x40*/ System.Reflection.EventAttributes attrs;
            /*0x48*/ System.Reflection.MethodInfo[] other_methods;
        }

        class RuntimeEventInfo : System.Reflection.EventInfo, System.Runtime.Serialization.ISerializable
        {
            /*0x18*/ nint klass;
            /*0x20*/ nint handle;

            static /*0x31c8944*/ void get_event_info(System.Reflection.RuntimeEventInfo ev, ref System.Reflection.MonoEventInfo info);
            static /*0x31c8948*/ System.Reflection.MonoEventInfo GetEventInfo(System.Reflection.RuntimeEventInfo ev);
            static /*0x31c9074*/ int get_metadata_token(System.Reflection.RuntimeEventInfo monoEvent);
            /*0x31c9078*/ RuntimeEventInfo();
            /*0x31c8984*/ System.Reflection.Module get_Module();
            /*0x31c89a4*/ System.Reflection.BindingFlags get_BindingFlags();
            /*0x31c8b20*/ System.RuntimeType GetDeclaringTypeInternal();
            /*0x31c8ba4*/ System.RuntimeType get_ReflectedTypeInternal();
            /*0x31c8988*/ System.Reflection.RuntimeModule GetRuntimeModule();
            /*0x31c8c28*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x31c89a8*/ System.Reflection.BindingFlags GetBindingFlags();
            /*0x31c8cc4*/ System.Reflection.MethodInfo GetAddMethod(bool nonPublic);
            /*0x31c8d34*/ System.Reflection.MethodInfo GetRaiseMethod(bool nonPublic);
            /*0x31c8da4*/ System.Reflection.MethodInfo GetRemoveMethod(bool nonPublic);
            /*0x31c8e14*/ System.Type get_DeclaringType();
            /*0x31c8e40*/ System.Type get_ReflectedType();
            /*0x31c8e6c*/ string get_Name();
            /*0x31c8e98*/ string ToString();
            /*0x31c8f28*/ bool IsDefined(System.Type attributeType, bool inherit);
            /*0x31c8f98*/ object[] GetCustomAttributes(bool inherit);
            /*0x31c9000*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            /*0x31c9070*/ int get_MetadataToken();
        }

        class RtFieldInfo : System.Reflection.FieldInfo
        {
            /*0x31c9080*/ RtFieldInfo();
            /*0x1f302cc*/ object UnsafeGetValue(object obj);
            void UnsafeSetValue(object obj, object value, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Globalization.CultureInfo culture);
            /*0x1f30ebc*/ void CheckConsistency(object target);
        }

        class RuntimeFieldInfo : System.Reflection.RtFieldInfo, System.Runtime.Serialization.ISerializable
        {
            /*0x10*/ nint klass;
            /*0x18*/ System.RuntimeFieldHandle fhandle;
            /*0x20*/ string name;
            /*0x28*/ System.Type type;
            /*0x30*/ System.Reflection.FieldAttributes attrs;

            static /*0x31c99f8*/ void SetValueInternal(System.Reflection.FieldInfo fi, object obj, object value);
            static /*0x31c9ca4*/ int get_metadata_token(System.Reflection.RuntimeFieldInfo monoField);
            /*0x31c9ca8*/ RuntimeFieldInfo();
            /*0x31c9088*/ System.Reflection.BindingFlags get_BindingFlags();
            /*0x31c9090*/ System.Reflection.Module get_Module();
            /*0x31c90b0*/ System.RuntimeType GetDeclaringTypeInternal();
            /*0x31c9134*/ System.RuntimeType get_ReflectedTypeInternal();
            /*0x31c9094*/ System.Reflection.RuntimeModule GetRuntimeModule();
            /*0x31c91b8*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x31c9270*/ object UnsafeGetValue(object obj);
            /*0x31c9274*/ void CheckConsistency(object target);
            /*0x31c93e8*/ void UnsafeSetValue(object obj, object value, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Globalization.CultureInfo culture);
            /*0x31c9448*/ void SetValueDirect(System.TypedReference obj, object value);
            /*0x31c95a4*/ System.Reflection.FieldAttributes get_Attributes();
            /*0x31c95ac*/ System.RuntimeFieldHandle get_FieldHandle();
            /*0x31c95b4*/ System.Type ResolveType();
            /*0x31c95b8*/ System.Type get_FieldType();
            /*0x31c9620*/ System.Type GetParentType(bool declaring);
            /*0x31c9624*/ System.Type get_ReflectedType();
            /*0x31c962c*/ System.Type get_DeclaringType();
            /*0x31c9634*/ string get_Name();
            /*0x31c963c*/ bool IsDefined(System.Type attributeType, bool inherit);
            /*0x31c96ac*/ object[] GetCustomAttributes(bool inherit);
            /*0x31c9714*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            /*0x31c9784*/ int GetFieldOffset();
            /*0x31c9788*/ object GetValueInternal(object obj);
            /*0x31c978c*/ object GetValue(object obj);
            /*0x31c9990*/ string ToString();
            /*0x31c99fc*/ void SetValue(object obj, object val, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Globalization.CultureInfo culture);
            /*0x31c9c9c*/ object GetRawConstantValue();
            /*0x31c9914*/ void CheckGeneric();
            /*0x31c9ca0*/ int get_MetadataToken();
        }

        struct MonoMethodInfo
        {
            /*0x10*/ System.Type parent;
            /*0x18*/ System.Type ret;
            /*0x20*/ System.Reflection.MethodAttributes attrs;
            /*0x24*/ System.Reflection.MethodImplAttributes iattrs;
            /*0x28*/ System.Reflection.CallingConventions callconv;

            static /*0x31c9cb0*/ void get_method_info(nint handle, ref System.Reflection.MonoMethodInfo info);
            static /*0x31c9cb4*/ int get_method_attributes(nint handle);
            static /*0x31c9cb8*/ System.Reflection.MonoMethodInfo GetMethodInfo(nint handle);
            static /*0x31c9ce8*/ System.Type GetDeclaringType(nint handle);
            static /*0x31c9d10*/ System.Type GetReturnType(nint handle);
            static /*0x31c9d38*/ System.Reflection.MethodAttributes GetAttributes(nint handle);
            static /*0x31c9d3c*/ System.Reflection.CallingConventions GetCallingConvention(nint handle);
            static /*0x31c9d64*/ System.Reflection.MethodImplAttributes GetMethodImplementationFlags(nint handle);
            static /*0x31c9d8c*/ System.Reflection.ParameterInfo[] get_parameter_info(nint handle, System.Reflection.MemberInfo member);
            static /*0x31c9d90*/ System.Reflection.ParameterInfo[] GetParametersInfo(nint handle, System.Reflection.MemberInfo member);
            static /*0x31c9d94*/ System.Runtime.InteropServices.MarshalAsAttribute get_retval_marshal(nint handle);
            static /*0x31c9d98*/ System.Reflection.ParameterInfo GetReturnParameterInfo(System.Reflection.RuntimeMethodInfo method);
        }

        class RuntimeMethodInfo : System.Reflection.MethodInfo, System.Runtime.Serialization.ISerializable
        {
            /*0x10*/ nint mhandle;
            /*0x18*/ string name;
            /*0x20*/ System.Type reftype;

            static /*0x31ca4a8*/ System.Reflection.MethodBase GetMethodFromHandleNoGenericCheck(System.RuntimeMethodHandle handle);
            static /*0x31ca4b8*/ System.Reflection.MethodBase GetMethodFromHandleNoGenericCheck(System.RuntimeMethodHandle handle, System.RuntimeTypeHandle reflectedType);
            static /*0x31ca4c0*/ System.Reflection.MethodBase GetMethodFromHandleInternalType(nint method_handle, nint type_handle);
            static /*0x31ca4b4*/ System.Reflection.MethodBase GetMethodFromHandleInternalType_native(nint method_handle, nint type_handle, bool genericCheck);
            static /*0x31ca4d0*/ string get_name(System.Reflection.MethodBase method);
            static /*0x31ca4d4*/ System.Reflection.RuntimeMethodInfo get_base_method(System.Reflection.RuntimeMethodInfo method, bool definition);
            static /*0x31ca4d8*/ int get_metadata_token(System.Reflection.RuntimeMethodInfo method);
            static /*0x31ca900*/ void ConvertValues(System.Reflection.Binder binder, object[] args, System.Reflection.ParameterInfo[] pinfo, System.Globalization.CultureInfo culture, System.Reflection.BindingFlags invokeAttr);
            static /*0x31cbc5c*/ int get_core_clr_security_level();
            /*0x31ca4c8*/ RuntimeMethodInfo();
            /*0x31c9e60*/ System.Reflection.BindingFlags get_BindingFlags();
            /*0x31c9e68*/ System.Reflection.Module get_Module();
            /*0x31c9ef8*/ System.RuntimeType get_ReflectedTypeInternal();
            /*0x31c9f7c*/ string FormatNameAndSig(bool serialization);
            /*0x31ca2d0*/ System.Delegate CreateDelegate(System.Type delegateType);
            /*0x31ca2e4*/ System.Delegate CreateDelegate(System.Type delegateType, object target);
            /*0x31ca2fc*/ string ToString();
            /*0x31c9e6c*/ System.Reflection.RuntimeModule GetRuntimeModule();
            /*0x31ca38c*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x31c451c*/ string SerializationToString();
            /*0x31ca4dc*/ System.Reflection.MethodInfo GetBaseDefinition();
            /*0x31ca4e4*/ System.Reflection.MethodInfo GetBaseMethod();
            /*0x31ca4ec*/ System.Reflection.ParameterInfo get_ReturnParameter();
            /*0x31ca4f0*/ System.Type get_ReturnType();
            /*0x31ca51c*/ int get_MetadataToken();
            /*0x31ca520*/ System.Reflection.MethodImplAttributes GetMethodImplementationFlags();
            /*0x31ca54c*/ System.Reflection.ParameterInfo[] GetParameters();
            /*0x31ca5dc*/ System.Reflection.ParameterInfo[] GetParametersInternal();
            /*0x31ca5e8*/ int GetParametersCount();
            /*0x31ca60c*/ object InternalInvoke(object obj, object[] parameters, ref System.Exception exc);
            /*0x31ca610*/ object Invoke(object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);
            /*0x31cabd0*/ System.RuntimeMethodHandle get_MethodHandle();
            /*0x31cabd8*/ System.Reflection.MethodAttributes get_Attributes();
            /*0x31cabe0*/ System.Reflection.CallingConventions get_CallingConvention();
            /*0x31cac0c*/ System.Type get_ReflectedType();
            /*0x31cac14*/ System.Type get_DeclaringType();
            /*0x31cac40*/ string get_Name();
            /*0x31cac54*/ bool IsDefined(System.Type attributeType, bool inherit);
            /*0x31cacc4*/ object[] GetCustomAttributes(bool inherit);
            /*0x31cad2c*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            /*0x31cad9c*/ void GetPInvoke(ref System.Reflection.PInvokeAttributes flags, ref string entryPoint, ref string dllName);
            /*0x31cada0*/ object[] GetPseudoCustomAttributes();
            /*0x31caf20*/ System.Reflection.CustomAttributeData[] GetPseudoCustomAttributesData();
            /*0x31cb0f4*/ System.Reflection.CustomAttributeData GetDllImportAttributeData();
            /*0x31cb7ec*/ System.Reflection.MethodInfo MakeGenericMethod(System.Type[] methodInstantiation);
            /*0x31cbb18*/ System.Reflection.MethodInfo MakeGenericMethod_impl(System.Type[] types);
            /*0x31cbb1c*/ System.Type[] GetGenericArguments();
            /*0x31cbb20*/ System.Reflection.MethodInfo GetGenericMethodDefinition_impl();
            /*0x31cbb24*/ System.Reflection.MethodInfo GetGenericMethodDefinition();
            /*0x31cbb80*/ bool get_IsGenericMethodDefinition();
            /*0x31cbb84*/ bool get_IsGenericMethod();
            /*0x31cbb88*/ bool get_ContainsGenericParameters();
            /*0x31cbc64*/ bool get_IsSecurityCritical();
        }

        class RuntimeConstructorInfo : System.Reflection.ConstructorInfo, System.Runtime.Serialization.ISerializable
        {
            /*0x10*/ nint mhandle;
            /*0x18*/ string name;
            /*0x20*/ System.Type reftype;

            static /*0x31cc6b0*/ int get_core_clr_security_level();
            static /*0x31cc6c4*/ int get_metadata_token(System.Reflection.RuntimeConstructorInfo method);
            /*0x31cc6c8*/ RuntimeConstructorInfo();
            /*0x31cbc6c*/ System.Reflection.Module get_Module();
            /*0x31cbc70*/ System.Reflection.RuntimeModule GetRuntimeModule();
            /*0x31cbcf8*/ System.Reflection.BindingFlags get_BindingFlags();
            /*0x31cbd00*/ System.RuntimeType get_ReflectedTypeInternal();
            /*0x31cbd84*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x31c4508*/ string SerializationToString();
            /*0x31cbe58*/ void SerializationInvoke(object target, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x31cbf88*/ System.Reflection.MethodImplAttributes GetMethodImplementationFlags();
            /*0x31cbfb4*/ System.Reflection.ParameterInfo[] GetParameters();
            /*0x31cbfc0*/ System.Reflection.ParameterInfo[] GetParametersInternal();
            /*0x31cbfcc*/ int GetParametersCount();
            /*0x31cbfec*/ object InternalInvoke(object obj, object[] parameters, ref System.Exception exc);
            /*0x31cbff0*/ object Invoke(object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);
            /*0x31cc0ec*/ object DoInvoke(object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);
            /*0x31cc2a4*/ object InternalInvoke(object obj, object[] parameters, bool wrapExceptions);
            /*0x31cc438*/ object Invoke(System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);
            /*0x31cc450*/ System.RuntimeMethodHandle get_MethodHandle();
            /*0x31cc458*/ System.Reflection.MethodAttributes get_Attributes();
            /*0x31cc460*/ System.Reflection.CallingConventions get_CallingConvention();
            /*0x31cc48c*/ bool get_ContainsGenericParameters();
            /*0x31cc4b8*/ System.Type get_ReflectedType();
            /*0x31cc4c0*/ System.Type get_DeclaringType();
            /*0x31cc4ec*/ string get_Name();
            /*0x31cc500*/ bool IsDefined(System.Type attributeType, bool inherit);
            /*0x31cc570*/ object[] GetCustomAttributes(bool inherit);
            /*0x31cc5d8*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            /*0x31cc648*/ string ToString();
            /*0x31cc6b8*/ bool get_IsSecurityCritical();
            /*0x31cc6c0*/ int get_MetadataToken();
        }

        class RuntimeModule : System.Reflection.Module
        {
            /*0x10*/ nint _impl;
            /*0x18*/ System.Reflection.Assembly assembly;
            /*0x20*/ string fqname;
            /*0x28*/ string name;
            /*0x30*/ string scopename;
            /*0x38*/ bool is_resource;
            /*0x3c*/ int token;

            static /*0x31cca1c*/ void GetGuidInternal(nint module, byte[] guid);
            /*0x31cca20*/ RuntimeModule();
            /*0x31cc720*/ System.Reflection.Assembly get_Assembly();
            /*0x31cc728*/ string get_ScopeName();
            /*0x31cc730*/ System.Guid get_ModuleVersionId();
            /*0x31cc740*/ bool IsResource();
            /*0x31cc748*/ object[] GetCustomAttributes(bool inherit);
            /*0x31cc7b0*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            /*0x31cc820*/ bool IsDefined(System.Type attributeType, bool inherit);
            /*0x31cc890*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x31cc924*/ System.Reflection.RuntimeAssembly GetRuntimeAssembly();
            /*0x31cc99c*/ System.Guid GetModuleVersionId();
        }

        class RuntimeParameterInfo : System.Reflection.ParameterInfo
        {
            /*0x40*/ System.Runtime.InteropServices.MarshalAsAttribute marshalAs;

            static /*0x31ca0dc*/ void FormatParameters(System.Text.StringBuilder sb, System.Reflection.ParameterInfo[] p, System.Reflection.CallingConventions callingConvention, bool serialization);
            static /*0x31cd934*/ System.Reflection.ParameterInfo New(System.Reflection.ParameterInfo pinfo, System.Reflection.MemberInfo member);
            static /*0x31c9df0*/ System.Reflection.ParameterInfo New(System.Type type, System.Reflection.MemberInfo member, System.Runtime.InteropServices.MarshalAsAttribute marshalAs);
            /*0x31cca78*/ RuntimeParameterInfo(string name, System.Type type, int position, int attrs, object defaultValue, System.Reflection.MemberInfo member, System.Runtime.InteropServices.MarshalAsAttribute marshalAs);
            /*0x31ccb20*/ RuntimeParameterInfo(System.Reflection.ParameterInfo pinfo, System.Reflection.MemberInfo member);
            /*0x31ccc8c*/ RuntimeParameterInfo(System.Type type, System.Reflection.MemberInfo member, System.Runtime.InteropServices.MarshalAsAttribute marshalAs);
            /*0x31ccd0c*/ object get_DefaultValue();
            /*0x31cd060*/ object[] GetCustomAttributes(bool inherit);
            /*0x31cd0bc*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            /*0x31ccbdc*/ object GetDefaultValueImpl(System.Reflection.ParameterInfo pinfo);
            /*0x31cd128*/ bool IsDefined(System.Type attributeType, bool inherit);
            /*0x31cd198*/ object[] GetPseudoCustomAttributes();
            /*0x31cd410*/ System.Reflection.CustomAttributeData[] GetPseudoCustomAttributesData();
        }

        struct MonoPropertyInfo
        {
            /*0x10*/ System.Type parent;
            /*0x18*/ System.Type declaring_type;
            /*0x20*/ string name;
            /*0x28*/ System.Reflection.MethodInfo get_method;
            /*0x30*/ System.Reflection.MethodInfo set_method;
            /*0x38*/ System.Reflection.PropertyAttributes attrs;
        }

        enum PInfo
        {
            Attributes = 1,
            GetMethod = 2,
            SetMethod = 4,
            ReflectedType = 8,
            DeclaringType = 16,
            Name = 32,
        }

        class RuntimePropertyInfo : System.Reflection.PropertyInfo, System.Runtime.Serialization.ISerializable
        {
            /*0x10*/ nint klass;
            /*0x18*/ nint prop;
            /*0x20*/ System.Reflection.MonoPropertyInfo info;
            /*0x50*/ System.Reflection.PInfo cached;
            /*0x58*/ System.Reflection.RuntimePropertyInfo.GetterAdapter cached_getter;

            static /*0x31cd99c*/ void get_property_info(System.Reflection.RuntimePropertyInfo prop, ref System.Reflection.MonoPropertyInfo info, System.Reflection.PInfo req_info);
            static /*0x1f32888*/ object GetterAdapterFrame<T, R>(System.Reflection.RuntimePropertyInfo.Getter<T, R> getter, object obj);
            static /*0x1f32888*/ object StaticGetterAdapterFrame<R>(System.Reflection.RuntimePropertyInfo.StaticGetter<R> getter, object obj);
            static /*0x31ce740*/ int get_metadata_token(System.Reflection.RuntimePropertyInfo monoProperty);
            static /*0x31ce744*/ System.Reflection.PropertyInfo internal_from_handle_type(nint event_handle, nint type_handle);
            static /*0x31ce748*/ System.Reflection.PropertyInfo GetPropertyFromHandle(Mono.RuntimePropertyHandle handle, System.RuntimeTypeHandle reflectedType);
            /*0x31ce7dc*/ RuntimePropertyInfo();
            /*0x31cd9a0*/ System.Reflection.BindingFlags get_BindingFlags();
            /*0x31cd9a8*/ System.Reflection.Module get_Module();
            /*0x31cd9c8*/ System.RuntimeType GetDeclaringTypeInternal();
            /*0x31cda4c*/ System.RuntimeType get_ReflectedTypeInternal();
            /*0x31cd9ac*/ System.Reflection.RuntimeModule GetRuntimeModule();
            /*0x31cdad0*/ string ToString();
            /*0x31cdad8*/ string FormatNameAndSig(bool serialization);
            /*0x31cdc48*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x31c4500*/ string SerializationToString();
            /*0x31cdd10*/ void CachePropertyInfo(System.Reflection.PInfo flags);
            /*0x31cdd50*/ bool get_CanRead();
            /*0x31cdd90*/ bool get_CanWrite();
            /*0x31cddd0*/ System.Type get_PropertyType();
            /*0x31cde80*/ System.Type get_ReflectedType();
            /*0x31cdeb8*/ System.Type get_DeclaringType();
            /*0x31cdef0*/ string get_Name();
            /*0x31cdf28*/ System.Reflection.MethodInfo GetGetMethod(bool nonPublic);
            /*0x31cdfac*/ System.Reflection.ParameterInfo[] GetIndexParameters();
            /*0x31ce174*/ System.Reflection.MethodInfo GetSetMethod(bool nonPublic);
            /*0x31ce1f8*/ bool IsDefined(System.Type attributeType, bool inherit);
            /*0x31ce264*/ object[] GetCustomAttributes(bool inherit);
            /*0x31ce2c0*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            /*0x31ce32c*/ object GetValue(object obj, object[] index);
            /*0x31ce34c*/ object GetValue(object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] index, System.Globalization.CultureInfo culture);
            /*0x31ce540*/ void SetValue(object obj, object value, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] index, System.Globalization.CultureInfo culture);
            /*0x31ce73c*/ int get_MetadataToken();

            class GetterAdapter : System.MulticastDelegate
            {
                /*0x31ce7e4*/ GetterAdapter(object object, nint method);
                /*0x31ce8ec*/ object Invoke(object _this);
            }

            class Getter<T, R> : System.MulticastDelegate
            {
                Getter(object object, nint method);
                /*0x1ffc854*/ R Invoke(T _this);
            }

            class StaticGetter<R> : System.MulticastDelegate
            {
                StaticGetter(object object, nint method);
                /*0x1ffc854*/ R Invoke();
            }
        }

        class StrongNameKeyPair : System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IDeserializationCallback
        {
            /*0x10*/ byte[] _publicKey;
            /*0x18*/ string _keyPairContainer;
            /*0x20*/ bool _keyPairExported;
            /*0x28*/ byte[] _keyPairArray;

            /*0x31ce900*/ StrongNameKeyPair(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x31ceb28*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x31cec64*/ void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
        }

        namespace Emit
        {
            class AssemblyBuilder : System.Reflection.Assembly
            {
            }

            class ConstructorBuilder : System.Reflection.ConstructorInfo
            {
                /*0x31cec68*/ System.Reflection.MethodAttributes get_Attributes();
                /*0x31ceca0*/ System.Type get_DeclaringType();
                /*0x31cecd8*/ string get_Name();
                /*0x31ced10*/ System.Reflection.ParameterInfo[] GetParameters();
                /*0x31ced48*/ System.Reflection.MethodImplAttributes GetMethodImplementationFlags();
                /*0x31ced80*/ System.RuntimeMethodHandle get_MethodHandle();
                /*0x31cedb8*/ object Invoke(System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);
                /*0x31cedf0*/ bool IsDefined(System.Type attributeType, bool inherit);
                /*0x31cee28*/ object[] GetCustomAttributes(bool inherit);
                /*0x31cee60*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
                /*0x31cee98*/ System.Type get_ReflectedType();
                /*0x31ceed0*/ object Invoke(object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);
            }

            class DynamicMethod : System.Reflection.MethodInfo
            {
                /*0x31cef08*/ System.Reflection.MethodAttributes get_Attributes();
                /*0x31cef40*/ System.Type get_DeclaringType();
                /*0x31cef78*/ string get_Name();
                /*0x31cefb0*/ System.Reflection.ParameterInfo[] GetParameters();
                /*0x31cefe8*/ System.RuntimeMethodHandle get_MethodHandle();
                /*0x31cf020*/ System.Type get_ReflectedType();
                /*0x31cf058*/ object[] GetCustomAttributes(bool inherit);
                /*0x31cf090*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
                /*0x31cf0c8*/ System.Reflection.MethodImplAttributes GetMethodImplementationFlags();
                /*0x31cf100*/ System.Reflection.MethodInfo GetBaseDefinition();
                /*0x31cf138*/ object Invoke(object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);
                /*0x31cf170*/ bool IsDefined(System.Type attributeType, bool inherit);
            }

            class EnumBuilder : System.Reflection.TypeInfo
            {
                /*0x31cf1a8*/ System.Reflection.Assembly get_Assembly();
                /*0x31cf1e0*/ string get_AssemblyQualifiedName();
                /*0x31cf218*/ System.Type get_BaseType();
                /*0x31cf250*/ string get_FullName();
                /*0x31cf288*/ System.Guid get_GUID();
                /*0x31cf2c0*/ System.Reflection.Module get_Module();
                /*0x31cf2f8*/ string get_Name();
                /*0x31cf330*/ string get_Namespace();
                /*0x31cf368*/ System.Type get_UnderlyingSystemType();
                /*0x31cf3a0*/ System.Reflection.TypeAttributes GetAttributeFlagsImpl();
                /*0x31cf3d8*/ System.Reflection.ConstructorInfo GetConstructorImpl(System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
                /*0x31cf410*/ System.Reflection.ConstructorInfo[] GetConstructors(System.Reflection.BindingFlags bindingAttr);
                /*0x31cf448*/ object[] GetCustomAttributes(bool inherit);
                /*0x31cf480*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
                /*0x31cf4b8*/ System.Type GetElementType();
                /*0x31cf4f0*/ System.Reflection.EventInfo GetEvent(string name, System.Reflection.BindingFlags bindingAttr);
                /*0x31cf528*/ System.Reflection.FieldInfo GetField(string name, System.Reflection.BindingFlags bindingAttr);
                /*0x31cf560*/ System.Reflection.FieldInfo[] GetFields(System.Reflection.BindingFlags bindingAttr);
                /*0x31cf598*/ System.Type[] GetInterfaces();
                /*0x31cf5d0*/ System.Reflection.MemberInfo[] GetMembers(System.Reflection.BindingFlags bindingAttr);
                /*0x31cf608*/ System.Reflection.MethodInfo GetMethodImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
                /*0x31cf640*/ System.Reflection.MethodInfo[] GetMethods(System.Reflection.BindingFlags bindingAttr);
                /*0x31cf678*/ System.Type GetNestedType(string name, System.Reflection.BindingFlags bindingAttr);
                /*0x31cf6b0*/ System.Reflection.PropertyInfo[] GetProperties(System.Reflection.BindingFlags bindingAttr);
                /*0x31cf6e8*/ System.Reflection.PropertyInfo GetPropertyImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
                /*0x31cf720*/ bool HasElementTypeImpl();
                /*0x31cf758*/ object InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);
                /*0x31cf790*/ bool IsArrayImpl();
                /*0x31cf7c8*/ bool IsByRefImpl();
                /*0x31cf800*/ bool IsCOMObjectImpl();
                /*0x31cf838*/ bool IsDefined(System.Type attributeType, bool inherit);
                /*0x31cf870*/ bool IsPointerImpl();
                /*0x31cf8a8*/ bool IsPrimitiveImpl();
            }

            class EventBuilder
            {
            }

            class FieldBuilder : System.Reflection.FieldInfo
            {
                /*0x31cf8e0*/ System.Reflection.FieldAttributes get_Attributes();
                /*0x31cf8e8*/ System.Type get_DeclaringType();
                /*0x31cf8f0*/ System.RuntimeFieldHandle get_FieldHandle();
                /*0x31cf8f8*/ System.Type get_FieldType();
                /*0x31cf900*/ string get_Name();
                /*0x31cf908*/ System.Type get_ReflectedType();
                /*0x31cf910*/ object[] GetCustomAttributes(bool inherit);
                /*0x31cf918*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
                /*0x31cf920*/ object GetValue(object obj);
                /*0x31cf928*/ bool IsDefined(System.Type attributeType, bool inherit);
                /*0x31cf930*/ void SetValue(object obj, object val, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Globalization.CultureInfo culture);
            }

            class GenericTypeParameterBuilder : System.Reflection.TypeInfo
            {
                /*0x31cf968*/ System.Reflection.Assembly get_Assembly();
                /*0x31cf9a0*/ string get_AssemblyQualifiedName();
                /*0x31cf9d8*/ System.Type get_BaseType();
                /*0x31cfa10*/ string get_FullName();
                /*0x31cfa48*/ System.Guid get_GUID();
                /*0x31cfa80*/ System.Reflection.Module get_Module();
                /*0x31cfab8*/ string get_Name();
                /*0x31cfaf0*/ string get_Namespace();
                /*0x31cfb28*/ System.Type get_UnderlyingSystemType();
                /*0x31cfb60*/ System.Reflection.TypeAttributes GetAttributeFlagsImpl();
                /*0x31cfb98*/ System.Reflection.ConstructorInfo GetConstructorImpl(System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
                /*0x31cfbd0*/ System.Reflection.ConstructorInfo[] GetConstructors(System.Reflection.BindingFlags bindingAttr);
                /*0x31cfc08*/ object[] GetCustomAttributes(bool inherit);
                /*0x31cfc40*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
                /*0x31cfc78*/ System.Type GetElementType();
                /*0x31cfcb0*/ System.Reflection.EventInfo GetEvent(string name, System.Reflection.BindingFlags bindingAttr);
                /*0x31cfce8*/ System.Reflection.FieldInfo GetField(string name, System.Reflection.BindingFlags bindingAttr);
                /*0x31cfd20*/ System.Reflection.FieldInfo[] GetFields(System.Reflection.BindingFlags bindingAttr);
                /*0x31cfd58*/ System.Type[] GetInterfaces();
                /*0x31cfd90*/ System.Reflection.MemberInfo[] GetMembers(System.Reflection.BindingFlags bindingAttr);
                /*0x31cfdc8*/ System.Reflection.MethodInfo GetMethodImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
                /*0x31cfe00*/ System.Reflection.MethodInfo[] GetMethods(System.Reflection.BindingFlags bindingAttr);
                /*0x31cfe38*/ System.Type GetNestedType(string name, System.Reflection.BindingFlags bindingAttr);
                /*0x31cfe70*/ System.Reflection.PropertyInfo[] GetProperties(System.Reflection.BindingFlags bindingAttr);
                /*0x31cfea8*/ System.Reflection.PropertyInfo GetPropertyImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
                /*0x31cfee0*/ bool HasElementTypeImpl();
                /*0x31cff18*/ object InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);
                /*0x31cff50*/ bool IsArrayImpl();
                /*0x31cff88*/ bool IsByRefImpl();
                /*0x31cffc0*/ bool IsCOMObjectImpl();
                /*0x31cfff8*/ bool IsDefined(System.Type attributeType, bool inherit);
                /*0x31d0030*/ bool IsPointerImpl();
                /*0x31d0068*/ bool IsPrimitiveImpl();
            }

            class ILGenerator
            {
            }

            class LocalBuilder : System.Reflection.LocalVariableInfo
            {
                /*0x20*/ string name;
                /*0x28*/ System.Reflection.Emit.ILGenerator ilgen;
                /*0x30*/ int startOffset;
                /*0x34*/ int endOffset;
            }

            class MethodBuilder : System.Reflection.MethodInfo
            {
                /*0x31d00a0*/ System.Reflection.MethodAttributes get_Attributes();
                /*0x31d00d8*/ System.Type get_DeclaringType();
                /*0x31d0110*/ System.RuntimeMethodHandle get_MethodHandle();
                /*0x31d0148*/ string get_Name();
                /*0x31d0180*/ System.Type get_ReflectedType();
                /*0x31d01b8*/ System.Reflection.MethodInfo GetBaseDefinition();
                /*0x31d01f0*/ object[] GetCustomAttributes(bool inherit);
                /*0x31d0228*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
                /*0x31d0260*/ System.Reflection.MethodImplAttributes GetMethodImplementationFlags();
                /*0x31d0298*/ System.Reflection.ParameterInfo[] GetParameters();
                /*0x31d02d0*/ object Invoke(object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);
                /*0x31d0308*/ bool IsDefined(System.Type attributeType, bool inherit);
            }

            class ModuleBuilder : System.Reflection.Module
            {
            }

            class ParameterBuilder
            {
            }

            class PropertyBuilder : System.Reflection.PropertyInfo
            {
                /*0x31d0340*/ bool get_CanRead();
                /*0x31d0378*/ bool get_CanWrite();
                /*0x31d03b0*/ System.Type get_DeclaringType();
                /*0x31d03e8*/ string get_Name();
                /*0x31d0420*/ System.Type get_PropertyType();
                /*0x31d0458*/ System.Type get_ReflectedType();
                /*0x31d0490*/ object[] GetCustomAttributes(bool inherit);
                /*0x31d04c8*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
                /*0x31d0500*/ System.Reflection.MethodInfo GetGetMethod(bool nonPublic);
                /*0x31d0538*/ System.Reflection.ParameterInfo[] GetIndexParameters();
                /*0x31d0570*/ System.Reflection.MethodInfo GetSetMethod(bool nonPublic);
                /*0x31d05a8*/ object GetValue(object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] index, System.Globalization.CultureInfo culture);
                /*0x31d05e0*/ bool IsDefined(System.Type attributeType, bool inherit);
                /*0x31d0618*/ void SetValue(object obj, object value, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] index, System.Globalization.CultureInfo culture);
            }

            class SignatureHelper
            {
            }

            class TypeBuilder : System.Reflection.TypeInfo
            {
                static int UnspecifiedTypeSize = 0;

                /*0x31d0650*/ System.Reflection.Assembly get_Assembly();
                /*0x31d0688*/ string get_AssemblyQualifiedName();
                /*0x31d06c0*/ System.Type get_BaseType();
                /*0x31d06f8*/ string get_FullName();
                /*0x31d0730*/ System.Guid get_GUID();
                /*0x31d0768*/ System.Reflection.Module get_Module();
                /*0x31d07a0*/ string get_Name();
                /*0x31d07d8*/ string get_Namespace();
                /*0x31d0810*/ System.Type get_UnderlyingSystemType();
                /*0x31d0848*/ System.Reflection.TypeAttributes GetAttributeFlagsImpl();
                /*0x31d0880*/ System.Reflection.ConstructorInfo GetConstructorImpl(System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
                /*0x31d08b8*/ System.Reflection.ConstructorInfo[] GetConstructors(System.Reflection.BindingFlags bindingAttr);
                /*0x31d08f0*/ object[] GetCustomAttributes(bool inherit);
                /*0x31d0928*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
                /*0x31d0960*/ System.Type GetElementType();
                /*0x31d0998*/ System.Reflection.EventInfo GetEvent(string name, System.Reflection.BindingFlags bindingAttr);
                /*0x31d09d0*/ System.Reflection.FieldInfo GetField(string name, System.Reflection.BindingFlags bindingAttr);
                /*0x31d0a08*/ System.Reflection.FieldInfo[] GetFields(System.Reflection.BindingFlags bindingAttr);
                /*0x31d0a40*/ System.Type[] GetInterfaces();
                /*0x31d0a78*/ System.Reflection.MemberInfo[] GetMembers(System.Reflection.BindingFlags bindingAttr);
                /*0x31d0ab0*/ System.Reflection.MethodInfo GetMethodImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
                /*0x31d0ae8*/ System.Reflection.MethodInfo[] GetMethods(System.Reflection.BindingFlags bindingAttr);
                /*0x31d0b20*/ System.Type GetNestedType(string name, System.Reflection.BindingFlags bindingAttr);
                /*0x31d0b58*/ System.Reflection.PropertyInfo[] GetProperties(System.Reflection.BindingFlags bindingAttr);
                /*0x31d0b90*/ System.Reflection.PropertyInfo GetPropertyImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
                /*0x31d0bc8*/ bool HasElementTypeImpl();
                /*0x31d0c00*/ object InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);
                /*0x31d0c38*/ bool IsArrayImpl();
                /*0x31d0c70*/ bool IsByRefImpl();
                /*0x31d0ca8*/ bool IsCOMObjectImpl();
                /*0x31d0ce0*/ bool IsDefined(System.Type attributeType, bool inherit);
                /*0x31d0d18*/ bool IsPointerImpl();
                /*0x31d0d50*/ bool IsPrimitiveImpl();
            }

            class UnmanagedMarshal
            {
                /*0x31d0d88*/ UnmanagedMarshal();
            }
        }
    }

    namespace Numerics
    {
        class ConstantHelper
        {
            static /*0x31d0d90*/ byte GetByteWithAllBitsSet();
            static /*0x31d0d98*/ sbyte GetSByteWithAllBitsSet();
            static /*0x31d0da0*/ ushort GetUInt16WithAllBitsSet();
            static /*0x31d0da8*/ short GetInt16WithAllBitsSet();
            static /*0x31d0db0*/ uint GetUInt32WithAllBitsSet();
            static /*0x31d0db8*/ int GetInt32WithAllBitsSet();
            static /*0x31d0dc0*/ ulong GetUInt64WithAllBitsSet();
            static /*0x31d0dc8*/ long GetInt64WithAllBitsSet();
            static /*0x31d0dd0*/ float GetSingleWithAllBitsSet();
            static /*0x31d0ddc*/ double GetDoubleWithAllBitsSet();
        }

        struct Register
        {
            /*0x10*/ byte byte_0;
            /*0x11*/ byte byte_1;
            /*0x12*/ byte byte_2;
            /*0x13*/ byte byte_3;
            /*0x14*/ byte byte_4;
            /*0x15*/ byte byte_5;
            /*0x16*/ byte byte_6;
            /*0x17*/ byte byte_7;
            /*0x18*/ byte byte_8;
            /*0x19*/ byte byte_9;
            /*0x1a*/ byte byte_10;
            /*0x1b*/ byte byte_11;
            /*0x1c*/ byte byte_12;
            /*0x1d*/ byte byte_13;
            /*0x1e*/ byte byte_14;
            /*0x1f*/ byte byte_15;
            /*0x10*/ sbyte sbyte_0;
            /*0x11*/ sbyte sbyte_1;
            /*0x12*/ sbyte sbyte_2;
            /*0x13*/ sbyte sbyte_3;
            /*0x14*/ sbyte sbyte_4;
            /*0x15*/ sbyte sbyte_5;
            /*0x16*/ sbyte sbyte_6;
            /*0x17*/ sbyte sbyte_7;
            /*0x18*/ sbyte sbyte_8;
            /*0x19*/ sbyte sbyte_9;
            /*0x1a*/ sbyte sbyte_10;
            /*0x1b*/ sbyte sbyte_11;
            /*0x1c*/ sbyte sbyte_12;
            /*0x1d*/ sbyte sbyte_13;
            /*0x1e*/ sbyte sbyte_14;
            /*0x1f*/ sbyte sbyte_15;
            /*0x10*/ ushort uint16_0;
            /*0x12*/ ushort uint16_1;
            /*0x14*/ ushort uint16_2;
            /*0x16*/ ushort uint16_3;
            /*0x18*/ ushort uint16_4;
            /*0x1a*/ ushort uint16_5;
            /*0x1c*/ ushort uint16_6;
            /*0x1e*/ ushort uint16_7;
            /*0x10*/ short int16_0;
            /*0x12*/ short int16_1;
            /*0x14*/ short int16_2;
            /*0x16*/ short int16_3;
            /*0x18*/ short int16_4;
            /*0x1a*/ short int16_5;
            /*0x1c*/ short int16_6;
            /*0x1e*/ short int16_7;
            /*0x10*/ uint uint32_0;
            /*0x14*/ uint uint32_1;
            /*0x18*/ uint uint32_2;
            /*0x1c*/ uint uint32_3;
            /*0x10*/ int int32_0;
            /*0x14*/ int int32_1;
            /*0x18*/ int int32_2;
            /*0x1c*/ int int32_3;
            /*0x10*/ ulong uint64_0;
            /*0x18*/ ulong uint64_1;
            /*0x10*/ long int64_0;
            /*0x18*/ long int64_1;
            /*0x10*/ float single_0;
            /*0x14*/ float single_1;
            /*0x18*/ float single_2;
            /*0x1c*/ float single_3;
            /*0x10*/ double double_0;
            /*0x18*/ double double_1;
        }

        struct Vector<T> : System.IEquatable<System.Numerics.Vector<T>>, System.IFormattable
        {
            static /*0x0*/ int s_count;
            static /*0x0*/ System.Numerics.Vector<T> s_zero;
            static /*0x0*/ System.Numerics.Vector<T> s_one;
            static /*0x0*/ System.Numerics.Vector<T> s_allOnes;
            /*0x0*/ System.Numerics.Register register;

            static /*0x1f33998*/ Vector();
            static /*0x1f31da0*/ int get_Count();
            static /*0x1ffc854*/ System.Numerics.Vector<T> get_Zero();
            static /*0x1f31da0*/ int InitializeCount();
            static /*0x1ffc854*/ bool op_Equality(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static /*0x1ffc854*/ bool op_Inequality(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static /*0x1ffc854*/ System.Numerics.Vector<ulong> op_Explicit(System.Numerics.Vector<T> value);
            static /*0x1ffc854*/ System.Numerics.Vector<T> Equals(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static /*0x1ffc854*/ bool ScalarEquals(T left, T right);
            static /*0x1ffc854*/ T GetOneValue();
            static /*0x1ffc854*/ T GetAllBitsSetValue();
            /*0x1ffc854*/ Vector(T value);
            /*0x1ffc854*/ Vector(void* dataPointer);
            /*0x1ffc854*/ Vector(void* dataPointer, int offset);
            /*0x1f30ebc*/ Vector(ref System.Numerics.Register existingRegister);
            /*0x1ffc854*/ T get_Item(int index);
            /*0x1f2fec8*/ bool Equals(object obj);
            /*0x1ffc854*/ bool Equals(System.Numerics.Vector<T> other);
            /*0x1f2ffc8*/ int GetHashCode();
            /*0x1f30214*/ string ToString();
            /*0x1f30394*/ string ToString(string format, System.IFormatProvider formatProvider);

            struct VectorSizeHelper<T>
            {
                /*0x0*/ System.Numerics.Vector<T> _placeholder;
                /*0x0*/ byte _byte;
            }
        }

        class Vector
        {
            static /*0x1ffc854*/ System.Numerics.Vector<T> Equals<T>(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static /*0x31d0de4*/ bool get_IsHardwareAccelerated();
            static /*0x1ffc854*/ System.Numerics.Vector<ulong> AsVectorUInt64<T>(System.Numerics.Vector<T> value);
        }

        namespace Hashing
        {
            class HashHelpers
            {
                static /*0x0*/ int RandomSeed;

                static /*0x31d0dfc*/ HashHelpers();
                static /*0x31d0dec*/ int Combine(int h1, int h2);
            }
        }
    }

    namespace Globalization
    {
        enum BidiCategory
        {
            LeftToRight = 0,
            LeftToRightEmbedding = 1,
            LeftToRightOverride = 2,
            RightToLeft = 3,
            RightToLeftArabic = 4,
            RightToLeftEmbedding = 5,
            RightToLeftOverride = 6,
            PopDirectionalFormat = 7,
            EuropeanNumber = 8,
            EuropeanNumberSeparator = 9,
            EuropeanNumberTerminator = 10,
            ArabicNumber = 11,
            CommonNumberSeparator = 12,
            NonSpacingMark = 13,
            BoundaryNeutral = 14,
            ParagraphSeparator = 15,
            SegmentSeparator = 16,
            Whitespace = 17,
            OtherNeutrals = 18,
            LeftToRightIsolate = 19,
            RightToLeftIsolate = 20,
            FirstStrongIsolate = 21,
            PopDirectionIsolate = 22,
        }

        enum CalendarAlgorithmType
        {
            Unknown = 0,
            SolarCalendar = 1,
            LunarCalendar = 2,
            LunisolarCalendar = 3,
        }

        enum CalendarWeekRule
        {
            FirstDay = 0,
            FirstFullWeek = 1,
            FirstFourDayWeek = 2,
        }

        class CharUnicodeInfo
        {
            static char HIGH_SURROGATE_START = 55296;
            static char HIGH_SURROGATE_END = 56319;
            static char LOW_SURROGATE_START = 56320;
            static char LOW_SURROGATE_END = 57343;
            static int HIGH_SURROGATE_RANGE = 1023;
            static int UNICODE_CATEGORY_OFFSET = 0;
            static int BIDI_CATEGORY_OFFSET = 1;
            static int UNICODE_PLANE01_START = 65536;

            static /*0x31d0e8c*/ int InternalConvertToUtf32(string s, int index);
            static /*0x31d0f24*/ int InternalConvertToUtf32(System.Text.StringBuilder s, int index);
            static /*0x31d0fb4*/ int InternalConvertToUtf32(string s, int index, ref int charLength);
            static /*0x31d106c*/ double InternalGetNumericValue(int ch);
            static /*0x31d1470*/ byte InternalGetDigitValues(int ch, int offset);
            static /*0x31d15ec*/ double GetNumericValue(char ch);
            static /*0x31d15f4*/ double GetNumericValue(string s, int index);
            static /*0x31d16b0*/ int GetDecimalDigitValue(char ch);
            static /*0x31d16cc*/ int GetDecimalDigitValue(string s, int index);
            static /*0x31d1794*/ int GetDigitValue(char ch);
            static /*0x31d17b0*/ int GetDigitValue(string s, int index);
            static /*0x31d1878*/ System.Globalization.UnicodeCategory GetUnicodeCategory(char ch);
            static /*0x31d18ac*/ System.Globalization.UnicodeCategory GetUnicodeCategory(string s, int index);
            static /*0x31d1894*/ System.Globalization.UnicodeCategory GetUnicodeCategory(int codePoint);
            static /*0x31d1970*/ byte InternalGetCategoryValue(int ch, int offset);
            static /*0x31d1954*/ System.Globalization.UnicodeCategory InternalGetUnicodeCategory(string value, int index);
            static /*0x31d1d60*/ System.Globalization.BidiCategory GetBidiCategory(string s, int index);
            static /*0x31d1e08*/ System.Globalization.BidiCategory GetBidiCategory(System.Text.StringBuilder s, int index);
            static /*0x31d1e24*/ System.Globalization.UnicodeCategory InternalGetUnicodeCategory(string str, int index, ref int charLength);
            static /*0x31d1e40*/ bool IsCombiningCategory(System.Globalization.UnicodeCategory uc);
            static /*0x31d1e50*/ bool IsWhiteSpace(string s, int index);
            static /*0x31d1e6c*/ bool IsWhiteSpace(char c);
            static /*0x31d1a20*/ System.ReadOnlySpan<byte> get_CategoryLevel1Index();
            static /*0x31d1af0*/ System.ReadOnlySpan<byte> get_CategoryLevel2Index();
            static /*0x31d1bc0*/ System.ReadOnlySpan<byte> get_CategoryLevel3Index();
            static /*0x31d1c90*/ System.ReadOnlySpan<byte> get_CategoriesValue();
            static /*0x31d1130*/ System.ReadOnlySpan<byte> get_NumericLevel1Index();
            static /*0x31d1200*/ System.ReadOnlySpan<byte> get_NumericLevel2Index();
            static /*0x31d12d0*/ System.ReadOnlySpan<byte> get_NumericLevel3Index();
            static /*0x31d13a0*/ System.ReadOnlySpan<byte> get_NumericValues();
            static /*0x31d151c*/ System.ReadOnlySpan<byte> get_DigitValues();
        }

        class CompareInfo : System.Runtime.Serialization.IDeserializationCallback
        {
            static System.Globalization.CompareOptions ValidIndexMaskOffFlags = -32;
            static System.Globalization.CompareOptions ValidCompareMaskOffFlags = -536870944;
            static System.Globalization.CompareOptions ValidHashCodeOfStringMaskOffFlags = -32;
            static System.Globalization.CompareOptions ValidSortkeyCtorMaskOffFlags = -536870944;
            static /*0x0*/ System.Globalization.CompareInfo Invariant;
            static /*0x8*/ System.Collections.Generic.Dictionary<string, System.Globalization.ISimpleCollator> collators;
            static /*0x10*/ bool managedCollation;
            static /*0x11*/ bool managedCollationChecked;
            /*0x10*/ string m_name;
            /*0x18*/ string _sortName;
            /*0x20*/ System.Globalization.SortVersion m_SortVersion;
            /*0x28*/ int culture;
            /*0x30*/ System.Globalization.ISimpleCollator collator;

            static /*0x31d7f70*/ CompareInfo();
            static /*0x31d1e94*/ int InvariantIndexOf(string source, string value, int startIndex, int count, bool ignoreCase);
            static /*0x31d2360*/ int InvariantIndexOf(System.ReadOnlySpan<char> source, System.ReadOnlySpan<char> value, bool ignoreCase);
            static /*0x31d243c*/ int InvariantLastIndexOf(string source, string value, int startIndex, int count, bool ignoreCase);
            static /*0x31d1f60*/ int InvariantFindString(char* source, int sourceCount, char* value, int valueCount, bool ignoreCase, bool start);
            static /*0x31d2510*/ char InvariantToUpper(char c);
            static /*0x31d2824*/ System.Globalization.CompareInfo GetCompareInfo(int culture, System.Reflection.Assembly assembly);
            static /*0x31d2a44*/ System.Globalization.CompareInfo GetCompareInfo(string name, System.Reflection.Assembly assembly);
            static /*0x31d2968*/ System.Globalization.CompareInfo GetCompareInfo(int culture);
            static /*0x31d2bac*/ System.Globalization.CompareInfo GetCompareInfo(string name);
            static /*0x31d2c68*/ bool IsSortable(char ch);
            static /*0x31d2db8*/ bool IsSortable(string text);
            static /*0x31d43a0*/ int CompareOrdinalIgnoreCase(string strA, int indexA, int lengthA, string strB, int indexB, int lengthB);
            static /*0x31d3380*/ int CompareOrdinalIgnoreCase(System.ReadOnlySpan<char> strA, System.ReadOnlySpan<char> strB);
            static /*0x31d6964*/ int GetIgnoreCaseHash(string source);
            static /*0x31d736c*/ bool get_UseManagedCollation();
            static /*0x31d7f68*/ int internal_compare_icall(char* str1, int length1, char* str2, int length2, System.Globalization.CompareOptions options);
            static /*0x31d7c6c*/ int internal_compare(string str1, int offset1, int length1, string str2, int offset2, int length2, System.Globalization.CompareOptions options);
            static /*0x31d7f6c*/ int internal_index_icall(char* source, int sindex, int count, char* value, int value_length, bool first);
            static /*0x31d7a70*/ int internal_index(string source, int sindex, int count, string value, bool first);
            static /*0x31d4514*/ int CompareStringOrdinalIgnoreCase(char* pString1, int length1, char* pString2, int length2);
            static /*0x31d5bf8*/ int IndexOfOrdinalCore(string source, string value, int startIndex, int count, bool ignoreCase);
            static /*0x31d6618*/ int LastIndexOfOrdinalCore(string source, string value, int startIndex, int count, bool ignoreCase);
            static /*0x31d2d34*/ bool IsSortable(char* text, int length);
            /*0x31d27c4*/ CompareInfo(System.Globalization.CultureInfo culture);
            /*0x31d8008*/ CompareInfo();
            /*0x31d2528*/ System.Globalization.SortKey InvariantCreateSortKey(string source, System.Globalization.CompareOptions options);
            /*0x31d2ef4*/ void OnDeserializing(System.Runtime.Serialization.StreamingContext ctx);
            /*0x31d2f00*/ void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
            /*0x31d2fb4*/ void OnDeserialized(System.Runtime.Serialization.StreamingContext ctx);
            /*0x31d2f04*/ void OnDeserialized();
            /*0x31d2fb8*/ void OnSerializing(System.Runtime.Serialization.StreamingContext ctx);
            /*0x31d3044*/ string get_Name();
            /*0x31d30d0*/ int Compare(string string1, string string2);
            /*0x31d30e0*/ int Compare(string string1, string string2, System.Globalization.CompareOptions options);
            /*0x31d3670*/ int Compare(System.ReadOnlySpan<char> string1, string string2, System.Globalization.CompareOptions options);
            /*0x31d3a40*/ int CompareOptionNone(System.ReadOnlySpan<char> string1, System.ReadOnlySpan<char> string2);
            /*0x31d3ca4*/ int CompareOptionIgnoreCase(System.ReadOnlySpan<char> string1, System.ReadOnlySpan<char> string2);
            /*0x31d3de0*/ int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2);
            /*0x31d3e08*/ int Compare(string string1, int offset1, string string2, int offset2, System.Globalization.CompareOptions options);
            /*0x31d3e68*/ int Compare(string string1, int offset1, string string2, int offset2);
            /*0x31d3e78*/ int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2, System.Globalization.CompareOptions options);
            /*0x31d46a8*/ bool IsPrefix(string source, string prefix, System.Globalization.CompareOptions options);
            /*0x31d4a40*/ bool IsPrefix(System.ReadOnlySpan<char> source, System.ReadOnlySpan<char> prefix, System.Globalization.CompareOptions options);
            /*0x31d4aa4*/ bool IsPrefix(string source, string prefix);
            /*0x31d4ab4*/ bool IsSuffix(string source, string suffix, System.Globalization.CompareOptions options);
            /*0x31d4e48*/ bool IsSuffix(System.ReadOnlySpan<char> source, System.ReadOnlySpan<char> suffix, System.Globalization.CompareOptions options);
            /*0x31d4eac*/ bool IsSuffix(string source, string suffix);
            /*0x31d4ec0*/ int IndexOf(string source, char value);
            /*0x31d4f2c*/ int IndexOf(string source, string value);
            /*0x31d4f98*/ int IndexOf(string source, char value, System.Globalization.CompareOptions options);
            /*0x31d5004*/ int IndexOf(string source, string value, System.Globalization.CompareOptions options);
            /*0x31d5070*/ int IndexOf(string source, char value, int startIndex);
            /*0x31d50dc*/ int IndexOf(string source, string value, int startIndex);
            /*0x31d5148*/ int IndexOf(string source, char value, int startIndex, System.Globalization.CompareOptions options);
            /*0x31d51b4*/ int IndexOf(string source, string value, int startIndex, System.Globalization.CompareOptions options);
            /*0x31d5220*/ int IndexOf(string source, char value, int startIndex, int count);
            /*0x31d5234*/ int IndexOf(string source, string value, int startIndex, int count);
            /*0x31d5248*/ int IndexOf(string source, char value, int startIndex, int count, System.Globalization.CompareOptions options);
            /*0x31d568c*/ int IndexOf(string source, string value, int startIndex, int count, System.Globalization.CompareOptions options);
            /*0x31d594c*/ int IndexOfOrdinal(System.ReadOnlySpan<char> source, System.ReadOnlySpan<char> value, bool ignoreCase);
            /*0x31d59e0*/ int IndexOf(System.ReadOnlySpan<char> source, System.ReadOnlySpan<char> value, System.Globalization.CompareOptions options);
            /*0x31d5a68*/ int IndexOf(string source, string value, int startIndex, int count, System.Globalization.CompareOptions options, int* matchLengthPtr);
            /*0x31d5520*/ int IndexOfOrdinal(string source, string value, int startIndex, int count, bool ignoreCase);
            /*0x31d5c24*/ int LastIndexOf(string source, char value);
            /*0x31d5c90*/ int LastIndexOf(string source, string value);
            /*0x31d5cfc*/ int LastIndexOf(string source, char value, System.Globalization.CompareOptions options);
            /*0x31d5d68*/ int LastIndexOf(string source, string value, System.Globalization.CompareOptions options);
            /*0x31d5dd4*/ int LastIndexOf(string source, char value, int startIndex);
            /*0x31d5dec*/ int LastIndexOf(string source, string value, int startIndex);
            /*0x31d5e04*/ int LastIndexOf(string source, char value, int startIndex, System.Globalization.CompareOptions options);
            /*0x31d5e1c*/ int LastIndexOf(string source, string value, int startIndex, System.Globalization.CompareOptions options);
            /*0x31d5e34*/ int LastIndexOf(string source, char value, int startIndex, int count);
            /*0x31d5e48*/ int LastIndexOf(string source, string value, int startIndex, int count);
            /*0x31d5e5c*/ int LastIndexOf(string source, char value, int startIndex, int count, System.Globalization.CompareOptions options);
            /*0x31d61bc*/ int LastIndexOf(string source, string value, int startIndex, int count, System.Globalization.CompareOptions options);
            /*0x31d6500*/ int LastIndexOfOrdinal(string source, string value, int startIndex, int count, bool ignoreCase);
            /*0x31d6644*/ System.Globalization.SortKey GetSortKey(string source, System.Globalization.CompareOptions options);
            /*0x31d67c4*/ System.Globalization.SortKey GetSortKey(string source);
            /*0x31d6888*/ bool Equals(object value);
            /*0x31d693c*/ int GetHashCode();
            /*0x31d6e4c*/ int GetHashCodeOfString(string source, System.Globalization.CompareOptions options);
            /*0x31d7018*/ int GetHashCode(string source, System.Globalization.CompareOptions options);
            /*0x31d7118*/ string ToString();
            /*0x31d7178*/ System.Globalization.SortVersion get_Version();
            /*0x31d72e8*/ int get_LCID();
            /*0x31d74b8*/ System.Globalization.ISimpleCollator GetCollator();
            /*0x31d77e4*/ System.Globalization.SortKey CreateSortKeyCore(string source, System.Globalization.CompareOptions options);
            /*0x31d791c*/ int internal_index_switch(string s1, int sindex, int count, string s2, System.Globalization.CompareOptions opt, bool first);
            /*0x31d3574*/ int internal_compare_switch(string str1, int offset1, int length1, string str2, int offset2, int length2, System.Globalization.CompareOptions options);
            /*0x31d7d20*/ int internal_compare_managed(string str1, int offset1, int length1, string str2, int offset2, int length2, System.Globalization.CompareOptions options);
            /*0x31d7e20*/ int internal_index_managed(string s, int sindex, int count, char c, System.Globalization.CompareOptions opt, bool first);
            /*0x31d7b24*/ int internal_index_managed(string s1, int sindex, int count, string s2, System.Globalization.CompareOptions opt, bool first);
            /*0x31d280c*/ void InitSort(System.Globalization.CultureInfo culture);
            /*0x31d61a4*/ int LastIndexOfCore(string source, string target, int startIndex, int count, System.Globalization.CompareOptions options);
            /*0x31d5638*/ int IndexOfCore(string source, string target, int startIndex, int count, System.Globalization.CompareOptions options, int* matchLengthPtr);
            /*0x31d59e8*/ int IndexOfCore(System.ReadOnlySpan<char> source, System.ReadOnlySpan<char> target, System.Globalization.CompareOptions options, int* matchLengthPtr);
            /*0x31d5950*/ int IndexOfOrdinalCore(System.ReadOnlySpan<char> source, System.ReadOnlySpan<char> value, bool ignoreCase);
            /*0x31d39dc*/ int CompareString(System.ReadOnlySpan<char> string1, string string2, System.Globalization.CompareOptions options);
            /*0x31d3bb4*/ int CompareString(System.ReadOnlySpan<char> string1, System.ReadOnlySpan<char> string2, System.Globalization.CompareOptions options);
            /*0x31d670c*/ System.Globalization.SortKey CreateSortKey(string source, System.Globalization.CompareOptions options);
            /*0x31d48cc*/ bool StartsWith(string source, string prefix, System.Globalization.CompareOptions options);
            /*0x31d4a44*/ bool StartsWith(System.ReadOnlySpan<char> source, System.ReadOnlySpan<char> prefix, System.Globalization.CompareOptions options);
            /*0x31d4cd8*/ bool EndsWith(string source, string suffix, System.Globalization.CompareOptions options);
            /*0x31d4e4c*/ bool EndsWith(System.ReadOnlySpan<char> source, System.ReadOnlySpan<char> suffix, System.Globalization.CompareOptions options);
            /*0x31d6fec*/ int GetHashCodeOfStringCore(string source, System.Globalization.CompareOptions options);
            /*0x31d72b0*/ System.Globalization.SortVersion GetSortVersion();
        }

        enum CompareOptions
        {
            None = 0,
            IgnoreCase = 1,
            IgnoreNonSpace = 2,
            IgnoreSymbols = 4,
            IgnoreKanaType = 8,
            IgnoreWidth = 16,
            OrdinalIgnoreCase = 268435456,
            StringSort = 536870912,
            Ordinal = 1073741824,
        }

        class CultureNotFoundException : System.ArgumentException
        {
            /*0x98*/ string _invalidCultureName;
            /*0xa0*/ System.Nullable<int> _invalidCultureId;

            static /*0x31d808c*/ string get_DefaultMessage();
            /*0x31d8040*/ CultureNotFoundException();
            /*0x31d80cc*/ CultureNotFoundException(string message);
            /*0x31d80d4*/ CultureNotFoundException(string paramName, string message);
            /*0x31d80e8*/ CultureNotFoundException(string message, System.Exception innerException);
            /*0x31d80f0*/ CultureNotFoundException(string paramName, string invalidCultureName, string message);
            /*0x31d8128*/ CultureNotFoundException(string message, string invalidCultureName, System.Exception innerException);
            /*0x31d815c*/ CultureNotFoundException(string message, int invalidCultureId, System.Exception innerException);
            /*0x31d81f0*/ CultureNotFoundException(string paramName, int invalidCultureId, string message);
            /*0x31d8284*/ CultureNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x31d8478*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x31d85c0*/ System.Nullable<int> get_InvalidCultureId();
            /*0x31d85c8*/ string get_InvalidCultureName();
            /*0x31d85d0*/ string get_FormatedInvalidCultureId();
            /*0x31d8734*/ string get_Message();
        }

        enum CultureTypes
        {
            NeutralCultures = 1,
            SpecificCultures = 2,
            InstalledWin32Cultures = 4,
            AllCultures = 7,
            UserCustomCulture = 8,
            ReplacementCultures = 16,
            WindowsOnlyCultures = 32,
            FrameworkCultures = 64,
        }

        enum MonthNameStyles
        {
            Regular = 0,
            Genitive = 1,
            LeapYear = 2,
        }

        enum DateTimeFormatFlags
        {
            None = 0,
            UseGenitiveMonth = 1,
            UseLeapYearMonth = 2,
            UseSpacesInMonthNames = 4,
            UseHebrewRule = 8,
            UseSpacesInDayNames = 16,
            UseDigitPrefixInTokens = 32,
            NotInitialized = -1,
        }

        class DateTimeFormatInfo : System.IFormatProvider, System.ICloneable
        {
            static string rfc1123Pattern = "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'";
            static string sortableDateTimePattern = "yyyy'-'MM'-'dd'T'HH':'mm':'ss";
            static string universalSortableDateTimePattern = "yyyy'-'MM'-'dd HH':'mm':'ss'Z'";
            static int DEFAULT_ALL_DATETIMES_SIZE = 132;
            static string RoundtripFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK";
            static string RoundtripDateTimeUnfixed = "yyyy'-'MM'-'ddTHH':'mm':'ss zzz";
            static System.Globalization.DateTimeStyles InvalidDateTimeStyles = -256;
            static int TOKEN_HASH_SIZE = 199;
            static int SECOND_PRIME = 197;
            static string dateSeparatorOrTimeZoneOffset = "-";
            static string invariantDateSeparator = "/";
            static string invariantTimeSeparator = ":";
            static string IgnorablePeriod = ".";
            static string IgnorableComma = ",";
            static string CJKYearSuff = "";
            static string CJKMonthSuff = "";
            static string CJKDaySuff = "";
            static string KoreanYearSuff = "";
            static string KoreanMonthSuff = "";
            static string KoreanDaySuff = "";
            static string KoreanHourSuff = "";
            static string KoreanMinuteSuff = "";
            static string KoreanSecondSuff = "";
            static string CJKHourSuff = "";
            static string ChineseHourSuff = "";
            static string CJKMinuteSuff = "";
            static string CJKSecondSuff = "";
            static string JapaneseEraStart = "";
            static string LocalTimeMark = "T";
            static string GMTName = "GMT";
            static string ZuluName = "Z";
            static string KoreanLangName = "ko";
            static string JapaneseLangName = "ja";
            static string EnglishLangName = "en";
            static /*0x0*/ System.Globalization.DateTimeFormatInfo s_invariantInfo;
            static /*0x8*/ char[] s_monthSpaces;
            static /*0x10*/ System.Globalization.DateTimeFormatInfo s_jajpDTFI;
            static /*0x18*/ System.Globalization.DateTimeFormatInfo s_zhtwDTFI;
            /*0x10*/ System.Globalization.CultureData _cultureData;
            /*0x18*/ string _name;
            /*0x20*/ string _langName;
            /*0x28*/ System.Globalization.CompareInfo _compareInfo;
            /*0x30*/ System.Globalization.CultureInfo _cultureInfo;
            /*0x38*/ string amDesignator;
            /*0x40*/ string pmDesignator;
            /*0x48*/ string dateSeparator;
            /*0x50*/ string generalShortTimePattern;
            /*0x58*/ string generalLongTimePattern;
            /*0x60*/ string timeSeparator;
            /*0x68*/ string monthDayPattern;
            /*0x70*/ string dateTimeOffsetPattern;
            /*0x78*/ System.Globalization.Calendar calendar;
            /*0x80*/ int firstDayOfWeek;
            /*0x84*/ int calendarWeekRule;
            /*0x88*/ string fullDateTimePattern;
            /*0x90*/ string[] abbreviatedDayNames;
            /*0x98*/ string[] m_superShortDayNames;
            /*0xa0*/ string[] dayNames;
            /*0xa8*/ string[] abbreviatedMonthNames;
            /*0xb0*/ string[] monthNames;
            /*0xb8*/ string[] genitiveMonthNames;
            /*0xc0*/ string[] m_genitiveAbbreviatedMonthNames;
            /*0xc8*/ string[] leapYearMonthNames;
            /*0xd0*/ string longDatePattern;
            /*0xd8*/ string shortDatePattern;
            /*0xe0*/ string yearMonthPattern;
            /*0xe8*/ string longTimePattern;
            /*0xf0*/ string shortTimePattern;
            /*0xf8*/ string[] allYearMonthPatterns;
            /*0x100*/ string[] allShortDatePatterns;
            /*0x108*/ string[] allLongDatePatterns;
            /*0x110*/ string[] allShortTimePatterns;
            /*0x118*/ string[] allLongTimePatterns;
            /*0x120*/ string[] m_eraNames;
            /*0x128*/ string[] m_abbrevEraNames;
            /*0x130*/ string[] m_abbrevEnglishEraNames;
            /*0x138*/ System.Globalization.CalendarId[] optionalCalendars;
            /*0x140*/ bool _isReadOnly;
            /*0x144*/ System.Globalization.DateTimeFormatFlags formatFlags;
            /*0x148*/ string _fullTimeSpanPositivePattern;
            /*0x150*/ string _fullTimeSpanNegativePattern;
            /*0x158*/ System.Globalization.DateTimeFormatInfo.TokenHashValue[] _dtfiTokenHash;

            static /*0x31e04e0*/ DateTimeFormatInfo();
            static /*0x31d921c*/ System.Globalization.DateTimeFormatInfo get_InvariantInfo();
            static /*0x31d92fc*/ System.Globalization.DateTimeFormatInfo get_CurrentInfo();
            static /*0x31d93fc*/ System.Globalization.DateTimeFormatInfo GetInstance(System.IFormatProvider provider);
            static /*0x31db2e4*/ void CheckNullValue(string[] values, int length);
            static /*0x31dc3a4*/ string[] GetCombinedPatterns(string[] patterns1, string[] patterns2, string connectString);
            static /*0x31dcf98*/ string[] GetMergedPatterns(string[] patterns, string defaultPattern);
            static /*0x31dd154*/ System.Globalization.DateTimeFormatInfo ReadOnly(System.Globalization.DateTimeFormatInfo dtfi);
            static /*0x31ddcc0*/ void ValidateStyles(System.Globalization.DateTimeStyles style, string parameterName);
            static /*0x31de038*/ System.Globalization.DateTimeFormatInfo GetJapaneseCalendarDTFI();
            static /*0x31de1d4*/ System.Globalization.DateTimeFormatInfo GetTaiwanCalendarDTFI();
            static /*0x31df880*/ bool IsJapaneseCalendar(System.Globalization.Calendar calendar);
            static /*0x31df9a8*/ bool TryParseHebrewNumber(ref System.__DTString str, ref bool badFormat, ref int number);
            static /*0x31dfb0c*/ bool IsHebrewChar(char ch);
            /*0x31d8b60*/ DateTimeFormatInfo();
            /*0x31d8dd0*/ DateTimeFormatInfo(System.Globalization.CultureData cultureData, System.Globalization.Calendar cal);
            /*0x31d882c*/ string get_CultureName();
            /*0x31d8868*/ System.Globalization.CultureInfo get_Culture();
            /*0x31d88f4*/ string get_LanguageName();
            /*0x31d8930*/ string[] internalGetAbbreviatedDayOfWeekNames();
            /*0x31d8944*/ string[] internalGetAbbreviatedDayOfWeekNamesCore();
            /*0x31d89a0*/ string[] internalGetSuperShortDayNames();
            /*0x31d89b4*/ string[] internalGetSuperShortDayNamesCore();
            /*0x31d8a10*/ string[] internalGetDayOfWeekNames();
            /*0x31d8a24*/ string[] internalGetDayOfWeekNamesCore();
            /*0x31d8a80*/ string[] internalGetAbbreviatedMonthNames();
            /*0x31d8a94*/ string[] internalGetAbbreviatedMonthNamesCore();
            /*0x31d8af0*/ string[] internalGetMonthNames();
            /*0x31d8b04*/ string[] internalGetMonthNamesCore();
            /*0x31d8c50*/ void InitializeOverridableProperties(System.Globalization.CultureData cultureData, int calendarId);
            /*0x31d9598*/ object GetFormat(System.Type formatType);
            /*0x31d9624*/ object Clone();
            /*0x31d9740*/ string get_AMDesignator();
            /*0x31d977c*/ void set_AMDesignator(string value);
            /*0x31d9924*/ System.Globalization.Calendar get_Calendar();
            /*0x31d8e20*/ void set_Calendar(System.Globalization.Calendar value);
            /*0x31d992c*/ System.Globalization.CalendarId[] get_OptionalCalendars();
            /*0x31d996c*/ int GetEra(string eraName);
            /*0x31d9bf0*/ string[] get_EraNames();
            /*0x31d9d1c*/ string GetEraName(int era);
            /*0x31d9c54*/ string[] get_AbbreviatedEraNames();
            /*0x31d9df4*/ string GetAbbreviatedEraName(int era);
            /*0x31d9cb8*/ string[] get_AbbreviatedEnglishEraNames();
            /*0x31d9edc*/ string get_DateSeparator();
            /*0x31d9f48*/ void set_DateSeparator(string value);
            /*0x31da024*/ System.DayOfWeek get_FirstDayOfWeek();
            /*0x31da050*/ void set_FirstDayOfWeek(System.DayOfWeek value);
            /*0x31da170*/ System.Globalization.CalendarWeekRule get_CalendarWeekRule();
            /*0x31da19c*/ void set_CalendarWeekRule(System.Globalization.CalendarWeekRule value);
            /*0x31da2bc*/ string get_FullDateTimePattern();
            /*0x31da3dc*/ void set_FullDateTimePattern(string value);
            /*0x31da344*/ string get_LongDatePattern();
            /*0x31da504*/ void set_LongDatePattern(string value);
            /*0x31da390*/ string get_LongTimePattern();
            /*0x31da630*/ void set_LongTimePattern(string value);
            /*0x31da73c*/ string get_MonthDayPattern();
            /*0x31da7a8*/ void set_MonthDayPattern(string value);
            /*0x31da86c*/ string get_PMDesignator();
            /*0x31da8a8*/ void set_PMDesignator(string value);
            /*0x31da984*/ string get_RFC1123Pattern();
            /*0x31da9c4*/ string get_ShortDatePattern();
            /*0x31daa74*/ void set_ShortDatePattern(string value);
            /*0x31dab80*/ string get_ShortTimePattern();
            /*0x31dac0c*/ void set_ShortTimePattern(string value);
            /*0x31dacf8*/ string get_SortableDateTimePattern();
            /*0x31dad38*/ string get_GeneralShortTimePattern();
            /*0x31dadc0*/ string get_GeneralLongTimePattern();
            /*0x31dae48*/ string get_DateTimeOffsetPattern();
            /*0x31daff4*/ string get_TimeSeparator();
            /*0x31db030*/ void set_TimeSeparator(string value);
            /*0x31db10c*/ string get_UniversalSortableDateTimePattern();
            /*0x31db14c*/ string get_YearMonthPattern();
            /*0x31db204*/ void set_YearMonthPattern(string value);
            /*0x31db38c*/ string[] get_AbbreviatedDayNames();
            /*0x31db410*/ void set_AbbreviatedDayNames(string[] value);
            /*0x31db5d0*/ string[] get_ShortestDayNames();
            /*0x31db654*/ void set_ShortestDayNames(string[] value);
            /*0x31db7fc*/ string[] get_DayNames();
            /*0x31db880*/ void set_DayNames(string[] value);
            /*0x31dba40*/ string[] get_AbbreviatedMonthNames();
            /*0x31dbac4*/ void set_AbbreviatedMonthNames(string[] value);
            /*0x31dbc88*/ string[] get_MonthNames();
            /*0x31dbd0c*/ void set_MonthNames(string[] value);
            /*0x31dbed4*/ bool get_HasSpacesInMonthNames();
            /*0x31dbf14*/ bool get_HasSpacesInDayNames();
            /*0x31dbf3c*/ string internalGetMonthName(int month, System.Globalization.MonthNameStyles style, bool abbreviated);
            /*0x31dc098*/ string[] internalGetGenitiveMonthNames(bool abbreviated);
            /*0x31dc140*/ string[] internalGetLeapYearMonthNames();
            /*0x31dc1ac*/ string GetAbbreviatedDayName(System.DayOfWeek dayofweek);
            /*0x31dc2a8*/ string GetShortestDayName(System.DayOfWeek dayOfWeek);
            /*0x31dc4dc*/ string[] GetAllDateTimePatterns();
            /*0x31dc66c*/ string[] GetAllDateTimePatterns(char format);
            /*0x31dccac*/ string GetDayName(System.DayOfWeek dayofweek);
            /*0x31dcda8*/ string GetAbbreviatedMonthName(int month);
            /*0x31dcea0*/ string GetMonthName(int month);
            /*0x31dcc38*/ string[] get_AllYearMonthPatterns();
            /*0x31dca68*/ string[] get_AllShortDatePatterns();
            /*0x31dcb50*/ string[] get_AllShortTimePatterns();
            /*0x31dcadc*/ string[] get_AllLongDatePatterns();
            /*0x31dcbc4*/ string[] get_AllLongTimePatterns();
            /*0x31db198*/ string[] get_UnclonedYearMonthPatterns();
            /*0x31daa10*/ string[] get_UnclonedShortDatePatterns();
            /*0x31da4a0*/ string[] get_UnclonedLongDatePatterns();
            /*0x31dabcc*/ string[] get_UnclonedShortTimePatterns();
            /*0x31da5f0*/ string[] get_UnclonedLongTimePatterns();
            /*0x31d9858*/ bool get_IsReadOnly();
            /*0x31dd270*/ string get_NativeCalendarName();
            /*0x31dd2ac*/ void SetAllDateTimePatterns(string[] patterns, char format);
            /*0x31dd64c*/ string[] get_AbbreviatedMonthGenitiveNames();
            /*0x31dd6cc*/ void set_AbbreviatedMonthGenitiveNames(string[] value);
            /*0x31dd890*/ string[] get_MonthGenitiveNames();
            /*0x31dd910*/ void set_MonthGenitiveNames(string[] value);
            /*0x31ddad8*/ string get_FullTimeSpanPositivePattern();
            /*0x31ddbb4*/ string get_FullTimeSpanNegativePattern();
            /*0x31ddc2c*/ System.Globalization.CompareInfo get_CompareInfo();
            /*0x31dbefc*/ System.Globalization.DateTimeFormatFlags get_FormatFlags();
            /*0x31ddd90*/ System.Globalization.DateTimeFormatFlags InitializeFormatFlags();
            /*0x31ddea8*/ bool get_HasForceTwoDigitYears();
            /*0x31ddedc*/ bool get_HasYearMonthAdjustment();
            /*0x31ddf04*/ bool YearMonthAdjustment(ref int year, ref int month, bool parsedMonthName);
            /*0x31d98fc*/ void ClearTokenHashTable();
            /*0x31de370*/ System.Globalization.DateTimeFormatInfo.TokenHashValue[] CreateTokenHashTable();
            /*0x31def04*/ void PopulateSpecialTokenHashTable(System.Globalization.DateTimeFormatInfo.TokenHashValue[] temp, ref bool useDateSepAsIgnorableSymbol);
            /*0x31df7d4*/ void AddMonthNames(System.Globalization.DateTimeFormatInfo.TokenHashValue[] temp, string monthPostfix);
            /*0x31dfb20*/ bool IsAllowedJapaneseTokenFollowedByNonSpaceLetter(string tokenString, char nextCh);
            /*0x31dfc28*/ bool Tokenize(System.TokenType TokenMask, ref System.TokenType tokenType, ref int tokenValue, ref System.__DTString str);
            /*0x31e01e8*/ void InsertAtCurrentHashNode(System.Globalization.DateTimeFormatInfo.TokenHashValue[] hashTable, string str, char ch, System.TokenType tokenType, int tokenValue, int pos, int hashcode, int hashProbe);
            /*0x31debe8*/ void InsertHash(System.Globalization.DateTimeFormatInfo.TokenHashValue[] hashTable, string str, System.TokenType tokenType, int tokenValue);
            /*0x31e03e8*/ bool CompareStringIgnoreCaseOptimized(string string1, int offset1, int length1, string string2, int offset2, int length2);

            class TokenHashValue
            {
                /*0x10*/ string tokenString;
                /*0x18*/ System.TokenType tokenType;
                /*0x1c*/ int tokenValue;

                /*0x31e07f0*/ TokenHashValue(string tokenString, System.TokenType tokenType, int tokenValue);
            }
        }

        enum FORMATFLAGS
        {
            None = 0,
            UseGenitiveMonth = 1,
            UseLeapYearMonth = 2,
            UseSpacesInMonthNames = 4,
            UseHebrewParsing = 8,
            UseSpacesInDayNames = 16,
            UseDigitPrefixInTokens = 32,
        }

        enum CalendarId
        {
            UNINITIALIZED_VALUE = 0,
            GREGORIAN = 1,
            GREGORIAN_US = 2,
            JAPAN = 3,
            TAIWAN = 4,
            KOREA = 5,
            HIJRI = 6,
            THAI = 7,
            HEBREW = 8,
            GREGORIAN_ME_FRENCH = 9,
            GREGORIAN_ARABIC = 10,
            GREGORIAN_XLIT_ENGLISH = 11,
            GREGORIAN_XLIT_FRENCH = 12,
            JULIAN = 13,
            JAPANESELUNISOLAR = 14,
            CHINESELUNISOLAR = 15,
            SAKA = 16,
            LUNAR_ETO_CHN = 17,
            LUNAR_ETO_KOR = 18,
            LUNAR_ETO_ROKUYOU = 19,
            KOREANLUNISOLAR = 20,
            TAIWANLUNISOLAR = 21,
            PERSIAN = 22,
            UMALQURA = 23,
            LAST_CALENDAR = 23,
        }

        class DateTimeFormatInfoScanner
        {
            static char MonthPostfixChar = 57344;
            static char IgnorableSymbolChar = 57345;
            static string CJKYearSuff = "";
            static string CJKMonthSuff = "";
            static string CJKDaySuff = "";
            static string KoreanYearSuff = "";
            static string KoreanMonthSuff = "";
            static string KoreanDaySuff = "";
            static string KoreanHourSuff = "";
            static string KoreanMinuteSuff = "";
            static string KoreanSecondSuff = "";
            static string CJKHourSuff = "";
            static string ChineseHourSuff = "";
            static string CJKMinuteSuff = "";
            static string CJKSecondSuff = "";
            static /*0x0*/ System.Collections.Generic.Dictionary<string, string> s_knownWords;
            /*0x10*/ System.Collections.Generic.List<string> m_dateWords;
            /*0x18*/ System.Globalization.DateTimeFormatInfoScanner.FoundDatePattern _ymdFlags;

            static /*0x31e0838*/ System.Collections.Generic.Dictionary<string, string> get_KnownWords();
            static /*0x31e0c24*/ int SkipWhiteSpacesAndNonLetter(string pattern, int currentIndex);
            static /*0x31e123c*/ int ScanRepeatChar(string pattern, char ch, int index, ref int count);
            static /*0x31e17b8*/ System.Globalization.FORMATFLAGS GetFormatFlagGenitiveMonth(string[] monthNames, string[] genitveMonthNames, string[] abbrevMonthNames, string[] genetiveAbbrevMonthNames);
            static /*0x31e18a8*/ System.Globalization.FORMATFLAGS GetFormatFlagUseSpaceInMonthNames(string[] monthNames, string[] genitveMonthNames, string[] abbrevMonthNames, string[] genetiveAbbrevMonthNames);
            static /*0x31e1c7c*/ System.Globalization.FORMATFLAGS GetFormatFlagUseSpaceInDayNames(string[] dayNames, string[] abbrevDayNames);
            static /*0x31e1cac*/ System.Globalization.FORMATFLAGS GetFormatFlagUseHebrewCalendar(int calID);
            static /*0x31e17f8*/ bool EqualStringArrays(string[] array1, string[] array2);
            static /*0x31e1ba0*/ bool ArrayElementsHaveSpace(string[] array);
            static /*0x31e1950*/ bool ArrayElementsBeginWithDigit(string[] array);
            /*0x31e1cbc*/ DateTimeFormatInfoScanner();
            /*0x31e0d00*/ void AddDateWordOrPostfix(string formatPostfix, string str);
            /*0x31e1064*/ int AddDateWords(string pattern, int index, string formatPostfix);
            /*0x31e0f48*/ void AddIgnorableSymbols(string text);
            /*0x31e12c0*/ void ScanDateWord(string pattern);
            /*0x31e14f0*/ string[] GetDateWordsOfDTFI(System.Globalization.DateTimeFormatInfo dtfi);

            enum FoundDatePattern
            {
                None = 0,
                FoundYearPatternFlag = 1,
                FoundMonthPatternFlag = 2,
                FoundDayPatternFlag = 4,
                FoundYMDPatternFlag = 7,
            }
        }

        enum DateTimeStyles
        {
            None = 0,
            AllowLeadingWhite = 1,
            AllowTrailingWhite = 2,
            AllowInnerWhite = 4,
            AllowWhiteSpaces = 7,
            NoCurrentDateDefault = 8,
            AdjustToUniversal = 16,
            AssumeLocal = 32,
            AssumeUniversal = 64,
            RoundtripKind = 128,
        }

        class DaylightTime
        {
            /*0x10*/ System.DateTime _start;
            /*0x18*/ System.DateTime _end;
            /*0x20*/ System.TimeSpan _delta;

            /*0x31e1d44*/ DaylightTime(System.DateTime start, System.DateTime end, System.TimeSpan delta);
            /*0x31e1d80*/ System.DateTime get_Start();
            /*0x31e1d88*/ System.DateTime get_End();
            /*0x31e1d90*/ System.TimeSpan get_Delta();
        }

        struct DaylightTimeStruct
        {
            /*0x10*/ System.DateTime Start;
            /*0x18*/ System.DateTime End;
            /*0x20*/ System.TimeSpan Delta;

            /*0x31e1d98*/ DaylightTimeStruct(System.DateTime start, System.DateTime end, System.TimeSpan delta);
        }

        enum DigitShapes
        {
            Context = 0,
            None = 1,
            NativeNational = 2,
        }

        class GlobalizationExtensions
        {
            static /*0x31e1da4*/ System.StringComparer GetStringComparer(System.Globalization.CompareInfo compareInfo, System.Globalization.CompareOptions options);
        }

        struct HebrewNumberParsingContext
        {
            /*0x10*/ System.Globalization.HebrewNumber.HS state;
            /*0x14*/ int result;

            /*0x31e1f28*/ HebrewNumberParsingContext(int result);
        }

        enum HebrewNumberParsingState
        {
            InvalidHebrewNumber = 0,
            NotHebrewDigit = 1,
            FoundEndOfHebrewNumber = 2,
            ContinueParsing = 3,
        }

        class HebrewNumber
        {
            static int minHebrewNumberCh = 1488;
            static int HebrewTokenCount = 10;
            static /*0x0*/ System.Globalization.HebrewNumber.HebrewValue[] s_hebrewValues;
            static /*0x8*/ char s_maxHebrewNumberCh;
            static /*0x10*/ System.Globalization.HebrewNumber.HS[] s_numberPasingState;

            static /*0x31e244c*/ HebrewNumber();
            static /*0x31e1f3c*/ string ToString(int Number);
            static /*0x31e21e8*/ System.Globalization.HebrewNumberParsingState ParseByChar(char ch, ref System.Globalization.HebrewNumberParsingContext context);
            static /*0x31e2380*/ bool IsDigit(char ch);
            /*0x31e1f34*/ HebrewNumber();

            enum HebrewToken
            {
                Invalid = -1,
                Digit400 = 0,
                Digit200_300 = 1,
                Digit100 = 2,
                Digit10 = 3,
                Digit1 = 4,
                Digit6_7 = 5,
                Digit7 = 6,
                Digit9 = 7,
                SingleQuote = 8,
                DoubleQuote = 9,
            }

            struct HebrewValue
            {
                /*0x10*/ System.Globalization.HebrewNumber.HebrewToken token;
                /*0x12*/ short value;

                /*0x31e2710*/ HebrewValue(System.Globalization.HebrewNumber.HebrewToken token, short value);
            }

            enum HS
            {
                _err = -1,
                Start = 0,
                S400 = 1,
                S400_400 = 2,
                S400_X00 = 3,
                S400_X0 = 4,
                X00_DQ = 5,
                S400_X00_X0 = 6,
                X0_DQ = 7,
                X = 8,
                X0 = 9,
                X00 = 10,
                S400_DQ = 11,
                S400_400_DQ = 12,
                S400_400_100 = 13,
                S9 = 14,
                X00_S9 = 15,
                S9_DQ = 16,
                END = 100,
            }
        }

        class InternalGlobalizationHelper
        {
            static long TicksPerMillisecond = 10000;
            static long TicksPerTenthSecond = 1000000;
            static long TicksPerSecond = 10000000;
            static long MaxSeconds = 922337203685;
            static long MinSeconds = -922337203685;
            static int DaysPerYear = 365;
            static int DaysPer4Years = 1461;
            static int DaysPer100Years = 36524;
            static int DaysPer400Years = 146097;
            static int DaysTo10000 = 3652059;
            static long TicksPerMinute = 600000000;
            static long TicksPerHour = 36000000000;
            static long TicksPerDay = 864000000000;
            static long MaxTicks = 3155378975999999999;
            static long MinTicks = 0;
            static long MaxMilliSeconds = 922337203685477;
            static long MinMilliSeconds = -922337203685477;
            static int StringBuilderDefaultCapacity = 16;
            static long MaxOffset = 504000000000;
            static long MinOffset = -504000000000;

            static /*0x31e271c*/ long TimeToTicks(int hour, int minute, int second);
            /*0x31e27b4*/ InternalGlobalizationHelper();
        }

        enum NumberStyles
        {
            None = 0,
            AllowLeadingWhite = 1,
            AllowTrailingWhite = 2,
            AllowLeadingSign = 4,
            AllowTrailingSign = 8,
            AllowParentheses = 16,
            AllowDecimalPoint = 32,
            AllowThousands = 64,
            AllowExponent = 128,
            AllowCurrencySymbol = 256,
            AllowHexSpecifier = 512,
            Integer = 7,
            HexNumber = 515,
            Number = 111,
            Float = 167,
            Currency = 383,
            Any = 511,
        }

        class SortVersion : System.IEquatable<System.Globalization.SortVersion>
        {
            /*0x10*/ int m_NlsVersion;
            /*0x14*/ System.Guid m_SortId;

            static /*0x31e29fc*/ bool op_Equality(System.Globalization.SortVersion left, System.Globalization.SortVersion right);
            static /*0x31e297c*/ bool op_Inequality(System.Globalization.SortVersion left, System.Globalization.SortVersion right);
            /*0x31e27d4*/ SortVersion(int fullVersion, System.Guid sortId);
            /*0x31e2814*/ SortVersion(int nlsVersion, int effectiveId, System.Guid customVersion);
            /*0x31e27bc*/ int get_FullVersion();
            /*0x31e27c4*/ System.Guid get_SortId();
            /*0x31e28fc*/ bool Equals(object obj);
            /*0x31e2994*/ bool Equals(System.Globalization.SortVersion other);
            /*0x31e2a1c*/ int GetHashCode();
        }

        class TimeSpanFormat
        {
            static /*0x0*/ System.Globalization.TimeSpanFormat.FormatLiterals PositiveInvariantFormatLiterals;
            static /*0x28*/ System.Globalization.TimeSpanFormat.FormatLiterals NegativeInvariantFormatLiterals;

            static /*0x31e4168*/ TimeSpanFormat();
            static /*0x31e2a44*/ void AppendNonNegativeInt32(System.Text.StringBuilder sb, int n, int digits);
            static /*0x31e2b48*/ string Format(System.TimeSpan value, string format, System.IFormatProvider formatProvider);
            static /*0x31e2ef4*/ bool TryFormat(System.TimeSpan value, System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider formatProvider);
            static /*0x31e2c00*/ System.Text.StringBuilder FormatToBuilder(System.TimeSpan value, System.ReadOnlySpan<char> format, System.IFormatProvider formatProvider);
            static /*0x31e3014*/ System.Text.StringBuilder FormatStandard(System.TimeSpan value, bool isInvariant, System.ReadOnlySpan<char> format, System.Globalization.TimeSpanFormat.Pattern pattern);
            static /*0x31e34f0*/ System.Text.StringBuilder FormatCustomized(System.TimeSpan value, System.ReadOnlySpan<char> format, System.Globalization.DateTimeFormatInfo dtfi, System.Text.StringBuilder result);

            enum Pattern
            {
                None = 0,
                Minimum = 1,
                Full = 2,
            }

            struct FormatLiterals
            {
                /*0x10*/ string AppCompatLiteral;
                /*0x18*/ int dd;
                /*0x1c*/ int hh;
                /*0x20*/ int mm;
                /*0x24*/ int ss;
                /*0x28*/ int ff;
                /*0x30*/ string[] _literals;

                static /*0x31e4218*/ System.Globalization.TimeSpanFormat.FormatLiterals InitInvariant(bool isNegative);
                /*0x31e4064*/ string get_Start();
                /*0x31e408c*/ string get_DayHourSep();
                /*0x31e40b8*/ string get_HourMinuteSep();
                /*0x31e40e4*/ string get_MinuteSecondSep();
                /*0x31e4110*/ string get_SecondFractionSep();
                /*0x31e413c*/ string get_End();
                /*0x31e3c3c*/ void Init(System.ReadOnlySpan<char> format, bool useInvariantFieldLengths);
            }
        }

        class TimeSpanParse
        {
            static int MaxFractionDigits = 7;
            static int MaxDays = 10675199;
            static int MaxHours = 23;
            static int MaxMinutes = 59;
            static int MaxSeconds = 59;
            static int MaxFraction = 9999999;

            static /*0x31e3fd4*/ long Pow10(int pow);
            static /*0x31e43fc*/ bool TryTimeToTicks(bool positive, System.Globalization.TimeSpanParse.TimeSpanToken days, System.Globalization.TimeSpanParse.TimeSpanToken hours, System.Globalization.TimeSpanParse.TimeSpanToken minutes, System.Globalization.TimeSpanParse.TimeSpanToken seconds, System.Globalization.TimeSpanParse.TimeSpanToken fraction, ref long result);
            static /*0x31e45a8*/ System.TimeSpan Parse(System.ReadOnlySpan<char> input, System.IFormatProvider formatProvider);
            static /*0x31e4774*/ bool TryParse(System.ReadOnlySpan<char> input, System.IFormatProvider formatProvider, ref System.TimeSpan result);
            static /*0x31e47b8*/ System.TimeSpan ParseExact(System.ReadOnlySpan<char> input, System.ReadOnlySpan<char> format, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles);
            static /*0x31e4960*/ bool TryParseExact(System.ReadOnlySpan<char> input, System.ReadOnlySpan<char> format, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles, ref System.TimeSpan result);
            static /*0x31e499c*/ System.TimeSpan ParseExactMultiple(System.ReadOnlySpan<char> input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles);
            static /*0x31e4b7c*/ bool TryParseExactMultiple(System.ReadOnlySpan<char> input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles, ref System.TimeSpan result);
            static /*0x31e45e8*/ bool TryParseTimeSpan(System.ReadOnlySpan<char> input, System.Globalization.TimeSpanParse.TimeSpanStandardStyles style, System.IFormatProvider formatProvider, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
            static /*0x31e50fc*/ bool ProcessTerminalState(ref System.Globalization.TimeSpanParse.TimeSpanRawInfo raw, System.Globalization.TimeSpanParse.TimeSpanStandardStyles style, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
            static /*0x31e6f14*/ bool ProcessTerminal_DHMSF(ref System.Globalization.TimeSpanParse.TimeSpanRawInfo raw, System.Globalization.TimeSpanParse.TimeSpanStandardStyles style, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
            static /*0x31e63cc*/ bool ProcessTerminal_HMS_F_D(ref System.Globalization.TimeSpanParse.TimeSpanRawInfo raw, System.Globalization.TimeSpanParse.TimeSpanStandardStyles style, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
            static /*0x31e5800*/ bool ProcessTerminal_HM_S_D(ref System.Globalization.TimeSpanParse.TimeSpanRawInfo raw, System.Globalization.TimeSpanParse.TimeSpanStandardStyles style, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
            static /*0x31e5540*/ bool ProcessTerminal_HM(ref System.Globalization.TimeSpanParse.TimeSpanRawInfo raw, System.Globalization.TimeSpanParse.TimeSpanStandardStyles style, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
            static /*0x31e5278*/ bool ProcessTerminal_D(ref System.Globalization.TimeSpanParse.TimeSpanRawInfo raw, System.Globalization.TimeSpanParse.TimeSpanStandardStyles style, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
            static /*0x31e47e4*/ bool TryParseExactTimeSpan(System.ReadOnlySpan<char> input, System.ReadOnlySpan<char> format, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
            static /*0x31e8d14*/ bool TryParseByFormat(System.ReadOnlySpan<char> input, System.ReadOnlySpan<char> format, System.Globalization.TimeSpanStyles styles, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
            static /*0x31e93f0*/ bool ParseExactDigits(ref System.Globalization.TimeSpanParse.TimeSpanTokenizer tokenizer, int minDigitLength, ref int result);
            static /*0x31e9420*/ bool ParseExactDigits(ref System.Globalization.TimeSpanParse.TimeSpanTokenizer tokenizer, int minDigitLength, int maxDigitLength, ref int zeroes, ref int result);
            static /*0x31e94e4*/ bool ParseExactLiteral(ref System.Globalization.TimeSpanParse.TimeSpanTokenizer tokenizer, System.Text.StringBuilder enquotedString);
            static /*0x31e8ce0*/ bool TryParseTimeSpanConstant(System.ReadOnlySpan<char> input, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
            static /*0x31e49c8*/ bool TryParseExactMultipleTimeSpan(System.ReadOnlySpan<char> input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
            static /*0x31e9824*/ void ValidateStyles(System.Globalization.TimeSpanStyles style, string parameterName);

            enum ParseFailureKind
            {
                None = 0,
                ArgumentNull = 1,
                Format = 2,
                FormatWithParameter = 3,
                Overflow = 4,
            }

            enum TimeSpanStandardStyles
            {
                None = 0,
                Invariant = 1,
                Localized = 2,
                RequireFull = 4,
                Any = 3,
            }

            enum TTT
            {
                None = 0,
                End = 1,
                Num = 2,
                Sep = 3,
                NumOverflow = 4,
            }

            struct TimeSpanToken
            {
                /*0x10*/ System.Globalization.TimeSpanParse.TTT _ttt;
                /*0x14*/ int _num;
                /*0x18*/ int _zeroes;
                /*0x20*/ System.ReadOnlySpan<char> _sep;

                /*0x31e9890*/ TimeSpanToken(System.Globalization.TimeSpanParse.TTT type);
                /*0x31e7630*/ TimeSpanToken(int number);
                /*0x31e961c*/ TimeSpanToken(int number, int leadingZeroes);
                /*0x31e98a0*/ TimeSpanToken(System.Globalization.TimeSpanParse.TTT type, int number, int leadingZeroes, System.ReadOnlySpan<char> separator);
                /*0x31e454c*/ bool IsInvalidFraction();
            }

            struct TimeSpanTokenizer
            {
                /*0x10*/ System.ReadOnlySpan<char> _value;
                /*0x20*/ int _pos;

                /*0x31e4ce0*/ TimeSpanTokenizer(System.ReadOnlySpan<char> input);
                /*0x31e93e4*/ TimeSpanTokenizer(System.ReadOnlySpan<char> input, int startPosition);
                /*0x31e4d40*/ System.Globalization.TimeSpanParse.TimeSpanToken GetNextToken();
                /*0x31e95d0*/ bool get_EOL();
                /*0x31e9630*/ void BackOne();
                /*0x31e9570*/ char get_NextChar();
            }

            struct TimeSpanRawInfo
            {
                static int MaxTokens = 11;
                static int MaxLiteralTokens = 6;
                static int MaxNumericTokens = 5;
                /*0x10*/ System.Globalization.TimeSpanParse.TTT _lastSeenTTT;
                /*0x14*/ int _tokenCount;
                /*0x18*/ int _sepCount;
                /*0x1c*/ int _numCount;
                /*0x20*/ System.Globalization.TimeSpanFormat.FormatLiterals _posLoc;
                /*0x48*/ System.Globalization.TimeSpanFormat.FormatLiterals _negLoc;
                /*0x70*/ bool _posLocInit;
                /*0x71*/ bool _negLocInit;
                /*0x78*/ string _fullPosPattern;
                /*0x80*/ string _fullNegPattern;
                /*0x88*/ System.Globalization.TimeSpanParse.TimeSpanToken _numbers0;
                /*0xa8*/ System.Globalization.TimeSpanParse.TimeSpanToken _numbers1;
                /*0xc8*/ System.Globalization.TimeSpanParse.TimeSpanToken _numbers2;
                /*0xe8*/ System.Globalization.TimeSpanParse.TimeSpanToken _numbers3;
                /*0x108*/ System.Globalization.TimeSpanParse.TimeSpanToken _numbers4;
                /*0x128*/ System.ReadOnlySpan<char> _literals0;
                /*0x138*/ System.ReadOnlySpan<char> _literals1;
                /*0x148*/ System.ReadOnlySpan<char> _literals2;
                /*0x158*/ System.ReadOnlySpan<char> _literals3;
                /*0x168*/ System.ReadOnlySpan<char> _literals4;
                /*0x178*/ System.ReadOnlySpan<char> _literals5;

                /*0x31e98b0*/ System.Globalization.TimeSpanFormat.FormatLiterals get_PositiveInvariant();
                /*0x31e9918*/ System.Globalization.TimeSpanFormat.FormatLiterals get_NegativeInvariant();
                /*0x31e74cc*/ System.Globalization.TimeSpanFormat.FormatLiterals get_PositiveLocalized();
                /*0x31e757c*/ System.Globalization.TimeSpanFormat.FormatLiterals get_NegativeLocalized();
                /*0x31e7c9c*/ bool FullAppCompatMatch(System.Globalization.TimeSpanFormat.FormatLiterals pattern);
                /*0x31e85c8*/ bool PartialAppCompatMatch(System.Globalization.TimeSpanFormat.FormatLiterals pattern);
                /*0x31e7170*/ bool FullMatch(System.Globalization.TimeSpanFormat.FormatLiterals pattern);
                /*0x31e8b24*/ bool FullDMatch(System.Globalization.TimeSpanFormat.FormatLiterals pattern);
                /*0x31e88c4*/ bool FullHMMatch(System.Globalization.TimeSpanFormat.FormatLiterals pattern);
                /*0x31e82c4*/ bool FullDHMMatch(System.Globalization.TimeSpanFormat.FormatLiterals pattern);
                /*0x31e7fc0*/ bool FullHMSMatch(System.Globalization.TimeSpanFormat.FormatLiterals pattern);
                /*0x31e7970*/ bool FullDHMSMatch(System.Globalization.TimeSpanFormat.FormatLiterals pattern);
                /*0x31e7644*/ bool FullHMSFMatch(System.Globalization.TimeSpanFormat.FormatLiterals pattern);
                /*0x31e4cec*/ void Init(System.Globalization.DateTimeFormatInfo dtfi);
                /*0x31e4fe8*/ bool ProcessToken(ref System.Globalization.TimeSpanParse.TimeSpanToken tok, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
                /*0x31e9984*/ bool AddSep(System.ReadOnlySpan<char> sep, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
                /*0x31e9a98*/ bool AddNum(System.Globalization.TimeSpanParse.TimeSpanToken num, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
            }

            struct TimeSpanResult
            {
                /*0x10*/ System.TimeSpan parsedTimeSpan;
                /*0x18*/ bool _throwOnFailure;

                /*0x31e45dc*/ TimeSpanResult(bool throwOnFailure);
                /*0x31e4bb8*/ bool SetFailure(System.Globalization.TimeSpanParse.ParseFailureKind kind, string resourceKey, object messageArgument, string argumentName);
            }

            struct StringParser
            {
                /*0x10*/ System.ReadOnlySpan<char> _str;
                /*0x20*/ char _ch;
                /*0x24*/ int _pos;
                /*0x28*/ int _len;

                /*0x31e9b84*/ void NextChar();
                /*0x31e9bcc*/ char NextNonDigit();
                /*0x31e9644*/ bool TryParse(System.ReadOnlySpan<char> input, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
                /*0x31e9e14*/ bool ParseInt(int max, ref int i, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
                /*0x31e9c5c*/ bool ParseTime(ref long time, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
                /*0x31e9c2c*/ void SkipBlanks();
            }
        }

        enum TimeSpanStyles
        {
            None = 0,
            AssumeNegative = 1,
        }

        enum UnicodeCategory
        {
            UppercaseLetter = 0,
            LowercaseLetter = 1,
            TitlecaseLetter = 2,
            ModifierLetter = 3,
            OtherLetter = 4,
            NonSpacingMark = 5,
            SpacingCombiningMark = 6,
            EnclosingMark = 7,
            DecimalDigitNumber = 8,
            LetterNumber = 9,
            OtherNumber = 10,
            SpaceSeparator = 11,
            LineSeparator = 12,
            ParagraphSeparator = 13,
            Control = 14,
            Format = 15,
            Surrogate = 16,
            PrivateUse = 17,
            ConnectorPunctuation = 18,
            DashPunctuation = 19,
            OpenPunctuation = 20,
            ClosePunctuation = 21,
            InitialQuotePunctuation = 22,
            FinalQuotePunctuation = 23,
            OtherPunctuation = 24,
            MathSymbol = 25,
            CurrencySymbol = 26,
            ModifierSymbol = 27,
            OtherSymbol = 28,
            OtherNotAssigned = 29,
        }

        class ISOWeek
        {
            static int WeeksInLongYear = 53;
            static int WeeksInShortYear = 52;
            static int MinWeek = 1;
            static int MaxWeek = 53;

            static /*0x31e9f20*/ int GetWeekOfYear(System.DateTime date);
            static /*0x31ea174*/ int GetYear(System.DateTime date);
            static /*0x31ea254*/ System.DateTime GetYearStart(int year);
            static /*0x31ea438*/ System.DateTime GetYearEnd(int year);
            static /*0x31ea064*/ int GetWeeksInYear(int year);
            static /*0x31ea260*/ System.DateTime ToDateTime(int year, int week, System.DayOfWeek dayOfWeek);
            static /*0x31e9fc8*/ int GetWeekNumber(System.DateTime date);
            static /*0x31ea4c8*/ int GetWeekday(System.DayOfWeek dayOfWeek);
            static /*0x31ea458*/ int <GetWeeksInYear>g__P|8_0(int y);
        }

        class GlobalizationMode
        {
            static string c_InvariantModeConfigSwitch = "System.Globalization.Invariant";
            static /*0x0*/ bool <Invariant>k__BackingField;

            static /*0x31ea538*/ GlobalizationMode();
            static /*0x31ea4d8*/ bool get_Invariant();
            static /*0x31ea530*/ bool GetGlobalizationInvariantMode();
        }

        class CalendricalCalculationsHelper
        {
            static double FullCircleOfArc = 360;
            static int HalfCircleOfArc = 180;
            static double TwelveHours = 0.5;
            static double Noon2000Jan01 = 730120.5;
            static double MeanTropicalYearInDays = 365.242189;
            static double MeanSpeedOfSun = 1.0145616361111112;
            static double LongitudeSpring = 0;
            static double TwoDegreesAfterSpring = 2;
            static int SecondsPerDay = 86400;
            static int DaysInUniformLengthCentury = 36525;
            static int SecondsPerMinute = 60;
            static int MinutesPerDegree = 60;
            static /*0x0*/ long StartOf1810;
            static /*0x8*/ long StartOf1900Century;
            static /*0x10*/ double[] Coefficients1900to1987;
            static /*0x18*/ double[] Coefficients1800to1899;
            static /*0x20*/ double[] Coefficients1700to1799;
            static /*0x28*/ double[] Coefficients1620to1699;
            static /*0x30*/ double[] LambdaCoefficients;
            static /*0x38*/ double[] AnomalyCoefficients;
            static /*0x40*/ double[] EccentricityCoefficients;
            static /*0x48*/ double[] Coefficients;
            static /*0x50*/ double[] CoefficientsA;
            static /*0x58*/ double[] CoefficientsB;
            static /*0x60*/ System.Globalization.CalendricalCalculationsHelper.EphemerisCorrectionAlgorithmMap[] EphemerisCorrectionTable;

            static /*0x31ec128*/ CalendricalCalculationsHelper();
            static /*0x31ea580*/ double RadiansFromDegrees(double degree);
            static /*0x31ea59c*/ double SinOfDegree(double degree);
            static /*0x31ea630*/ double CosOfDegree(double degree);
            static /*0x31ea6c4*/ double TanOfDegree(double degree);
            static /*0x31ea758*/ double Angle(int degrees, int minutes, double seconds);
            static /*0x31ea77c*/ double Obliquity(double julianCenturies);
            static /*0x31ea83c*/ long GetNumberOfDays(System.DateTime date);
            static /*0x31ea8b8*/ int GetGregorianYear(double numberOfDays);
            static /*0x31ea9b0*/ double Reminder(double divisor, double dividend);
            static /*0x31eaa1c*/ double NormalizeLongitude(double longitude);
            static /*0x31eaa94*/ double AsDayFraction(double longitude);
            static /*0x31ea7e4*/ double PolynomialSum(double[] coefficients, double indeterminate);
            static /*0x31eaaa4*/ double CenturiesFrom1900(int gregorianYear);
            static /*0x31eab40*/ double DefaultEphemerisCorrection(int gregorianYear);
            static /*0x31eac30*/ double EphemerisCorrection1988to2019(int gregorianYear);
            static /*0x31eac48*/ double EphemerisCorrection1900to1987(int gregorianYear);
            static /*0x31eacac*/ double EphemerisCorrection1800to1899(int gregorianYear);
            static /*0x31ead10*/ double EphemerisCorrection1700to1799(int gregorianYear);
            static /*0x31ead84*/ double EphemerisCorrection1620to1699(int gregorianYear);
            static /*0x31eadf8*/ double EphemerisCorrection(double time);
            static /*0x31eafbc*/ double JulianCenturies(double moment);
            static /*0x31eb038*/ bool IsNegative(double value);
            static /*0x31eb0a4*/ double CopySign(double value, double sign);
            static /*0x31eb124*/ double EquationOfTime(double time);
            static /*0x31eb314*/ double AsLocalTime(double apparentMidday, double longitude);
            static /*0x31eb388*/ double Midday(double date, double longitude);
            static /*0x31eb404*/ double InitLongitude(double longitude);
            static /*0x31eb478*/ double MiddayAtPersianObservationSite(double date);
            static /*0x31eb4e4*/ double PeriodicTerm(double julianCenturies, int x, double y, double z);
            static /*0x31eb564*/ double SumLongSequenceOfPeriodicTerms(double julianCenturies);
            static /*0x31ebd1c*/ double Aberration(double julianCenturies);
            static /*0x31ebda8*/ double Nutation(double julianCenturies);
            static /*0x31ebe60*/ double Compute(double time);
            static /*0x31ebf18*/ double AsSeason(double longitude);
            static /*0x31ebf30*/ double EstimatePrior(double longitude, double time);
            static /*0x31ec010*/ long PersianNewYearOnOrBefore(long numberOfDays);
            /*0x31ec120*/ CalendricalCalculationsHelper();

            enum CorrectionAlgorithm
            {
                Default = 0,
                Year1988to2019 = 1,
                Year1900to1987 = 2,
                Year1800to1899 = 3,
                Year1700to1799 = 4,
                Year1620to1699 = 5,
            }

            struct EphemerisCorrectionAlgorithmMap
            {
                /*0x10*/ int _lowestYear;
                /*0x14*/ System.Globalization.CalendricalCalculationsHelper.CorrectionAlgorithm _algorithm;

                /*0x31ec5c0*/ EphemerisCorrectionAlgorithmMap(int year, System.Globalization.CalendricalCalculationsHelper.CorrectionAlgorithm algorithm);
            }
        }

        class PersianCalendar : System.Globalization.Calendar
        {
            static int ApproximateHalfYear = 180;
            static int DatePartYear = 0;
            static int DatePartDayOfYear = 1;
            static int DatePartMonth = 2;
            static int DatePartDay = 3;
            static int MonthsPerYear = 12;
            static int MaxCalendarYear = 9378;
            static int MaxCalendarMonth = 10;
            static int MaxCalendarDay = 13;
            static int DEFAULT_TWO_DIGIT_YEAR_MAX = 1410;
            static /*0x0*/ int PersianEra;
            static /*0x8*/ long PersianEpoch;
            static /*0x10*/ int[] DaysToMonth;
            static /*0x18*/ System.DateTime minDate;
            static /*0x20*/ System.DateTime maxDate;

            static /*0x31ee610*/ PersianCalendar();
            static /*0x31ec898*/ void CheckTicksRange(long ticks);
            static /*0x31eca78*/ void CheckEraRange(int era);
            static /*0x31ecb44*/ void CheckYearRange(int year, int era);
            static /*0x31ecc90*/ void CheckYearMonthRange(int year, int month, int era);
            static /*0x31ece0c*/ int MonthFromOrdinalDay(int ordinalDay);
            static /*0x31ec818*/ int DaysInPreviousMonths(int month);
            /*0x31ec680*/ PersianCalendar();
            /*0x31ec5c8*/ System.DateTime get_MinSupportedDateTime();
            /*0x31ec620*/ System.DateTime get_MaxSupportedDateTime();
            /*0x31ec678*/ System.Globalization.CalendarAlgorithmType get_AlgorithmType();
            /*0x31ec6a8*/ int get_BaseCalendarID();
            /*0x31ec6b0*/ int get_ID();
            /*0x31ec6b8*/ long GetAbsoluteDatePersian(int year, int month, int day);
            /*0x31ecea0*/ int GetDatePart(long ticks, int part);
            /*0x31ed0e8*/ System.DateTime AddMonths(System.DateTime time, int months);
            /*0x31ed53c*/ System.DateTime AddYears(System.DateTime time, int years);
            /*0x31ed554*/ int GetDayOfMonth(System.DateTime time);
            /*0x31ed5cc*/ System.DayOfWeek GetDayOfWeek(System.DateTime time);
            /*0x31ed674*/ int GetDayOfYear(System.DateTime time);
            /*0x31ed6ec*/ int GetDaysInMonth(int year, int month, int era);
            /*0x31ed804*/ int GetDaysInYear(int year, int era);
            /*0x31ed8e4*/ int GetEra(System.DateTime time);
            /*0x31ed980*/ int[] get_Eras();
            /*0x31eda1c*/ int GetMonth(System.DateTime time);
            /*0x31eda94*/ int GetMonthsInYear(int year, int era);
            /*0x31edb10*/ int GetYear(System.DateTime time);
            /*0x31edb88*/ bool IsLeapDay(int year, int month, int day, int era);
            /*0x31edce8*/ int GetLeapMonth(int year, int era);
            /*0x31edd54*/ bool IsLeapMonth(int year, int month, int era);
            /*0x31eddc8*/ bool IsLeapYear(int year, int era);
            /*0x31ede74*/ System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
            /*0x31ee1e0*/ int get_TwoDigitYearMax();
            /*0x31ee278*/ void set_TwoDigitYearMax(int value);
            /*0x31ee3e8*/ int ToFourDigitYear(int year);
        }

        class Calendar : System.ICloneable
        {
            static long TicksPerMillisecond = 10000;
            static long TicksPerSecond = 10000000;
            static long TicksPerMinute = 600000000;
            static long TicksPerHour = 36000000000;
            static long TicksPerDay = 864000000000;
            static int MillisPerSecond = 1000;
            static int MillisPerMinute = 60000;
            static int MillisPerHour = 3600000;
            static int MillisPerDay = 86400000;
            static int DaysPerYear = 365;
            static int DaysPer4Years = 1461;
            static int DaysPer100Years = 36524;
            static int DaysPer400Years = 146097;
            static int DaysTo10000 = 3652059;
            static long MaxMillis = 315537897600000;
            static int CAL_GREGORIAN = 1;
            static int CAL_GREGORIAN_US = 2;
            static int CAL_JAPAN = 3;
            static int CAL_TAIWAN = 4;
            static int CAL_KOREA = 5;
            static int CAL_HIJRI = 6;
            static int CAL_THAI = 7;
            static int CAL_HEBREW = 8;
            static int CAL_GREGORIAN_ME_FRENCH = 9;
            static int CAL_GREGORIAN_ARABIC = 10;
            static int CAL_GREGORIAN_XLIT_ENGLISH = 11;
            static int CAL_GREGORIAN_XLIT_FRENCH = 12;
            static int CAL_JULIAN = 13;
            static int CAL_JAPANESELUNISOLAR = 14;
            static int CAL_CHINESELUNISOLAR = 15;
            static int CAL_SAKA = 16;
            static int CAL_LUNAR_ETO_CHN = 17;
            static int CAL_LUNAR_ETO_KOR = 18;
            static int CAL_LUNAR_ETO_ROKUYOU = 19;
            static int CAL_KOREANLUNISOLAR = 20;
            static int CAL_TAIWANLUNISOLAR = 21;
            static int CAL_PERSIAN = 22;
            static int CAL_UMALQURA = 23;
            static int CurrentEra = 0;
            /*0x10*/ int m_currentEraValue;
            /*0x14*/ bool m_isReadOnly;
            /*0x18*/ int twoDigitYearMax;

            static /*0x31ee8e0*/ System.Globalization.Calendar ReadOnly(System.Globalization.Calendar calendar);
            static /*0x31ed3dc*/ void CheckAddResult(long ticks, System.DateTime minValue, System.DateTime maxValue);
            static /*0x31ee034*/ long TimeToTicks(int hour, int minute, int second, int millisecond);
            static /*0x31ee224*/ int GetSystemTwoDigitYearSetting(int CalID, int defaultYearValue);
            /*0x31ec694*/ Calendar();
            /*0x31ee784*/ System.DateTime get_MinSupportedDateTime();
            /*0x31ee7dc*/ System.DateTime get_MaxSupportedDateTime();
            /*0x31ee834*/ int get_ID();
            /*0x31ee83c*/ int get_BaseCalendarID();
            /*0x31ee848*/ System.Globalization.CalendarAlgorithmType get_AlgorithmType();
            /*0x31ee850*/ bool get_IsReadOnly();
            /*0x31ee858*/ object Clone();
            /*0x31ee384*/ void VerifyWritable();
            /*0x31ee9cc*/ void SetReadOnlyState(bool readOnly);
            /*0x31ee9d4*/ int get_CurrentEraValue();
            /*0x31eeb08*/ System.DateTime Add(System.DateTime time, double value, int scale);
            /*0x31eec94*/ System.DateTime AddMilliseconds(System.DateTime time, double milliseconds);
            /*0x31eec9c*/ System.DateTime AddDays(System.DateTime time, int days);
            /*0x31eecac*/ System.DateTime AddHours(System.DateTime time, int hours);
            /*0x31eecbc*/ System.DateTime AddMinutes(System.DateTime time, int minutes);
            System.DateTime AddMonths(System.DateTime time, int months);
            /*0x31eecc8*/ System.DateTime AddSeconds(System.DateTime time, int seconds);
            /*0x31eecd4*/ System.DateTime AddWeeks(System.DateTime time, int weeks);
            System.DateTime AddYears(System.DateTime time, int years);
            int GetDayOfMonth(System.DateTime time);
            System.DayOfWeek GetDayOfWeek(System.DateTime time);
            int GetDayOfYear(System.DateTime time);
            /*0x31eecec*/ int GetDaysInMonth(int year, int month);
            int GetDaysInMonth(int year, int month, int era);
            /*0x31eed00*/ int GetDaysInYear(int year);
            /*0x1f2fff4*/ int GetDaysInYear(int year, int era);
            int GetEra(System.DateTime time);
            /*0x1f30214*/ int[] get_Eras();
            /*0x31eed14*/ int GetHour(System.DateTime time);
            /*0x31eedac*/ double GetMilliseconds(System.DateTime time);
            /*0x31eee4c*/ int GetMinute(System.DateTime time);
            int GetMonth(System.DateTime time);
            /*0x31eeee8*/ int GetMonthsInYear(int year);
            /*0x1f2fff4*/ int GetMonthsInYear(int year, int era);
            /*0x31eeefc*/ int GetSecond(System.DateTime time);
            /*0x31eef9c*/ int GetFirstDayWeekOfYear(System.DateTime time, int firstDayOfWeek);
            /*0x31ef058*/ int GetWeekOfYearFullDays(System.DateTime time, int firstDayOfWeek, int fullDays);
            /*0x31ef21c*/ int GetWeekOfYearOfMinSupportedDateTime(int firstDayOfWeek, int minimumDaysInFirstWeek);
            /*0x31ef378*/ int get_DaysInYearBeforeMinSupportedYear();
            /*0x31ef380*/ int GetWeekOfYear(System.DateTime time, System.Globalization.CalendarWeekRule rule, System.DayOfWeek firstDayOfWeek);
            int GetYear(System.DateTime time);
            /*0x31ef660*/ bool IsLeapDay(int year, int month, int day);
            bool IsLeapDay(int year, int month, int day, int era);
            /*0x31ef674*/ bool IsLeapMonth(int year, int month);
            bool IsLeapMonth(int year, int month, int era);
            /*0x31ef688*/ int GetLeapMonth(int year);
            /*0x31ef69c*/ int GetLeapMonth(int year, int era);
            /*0x31ef73c*/ bool IsLeapYear(int year);
            bool IsLeapYear(int year, int era);
            /*0x31ef750*/ System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);
            System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
            /*0x31ef778*/ bool TryToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era, ref System.DateTime result);
            /*0x31ef8d8*/ bool IsValidYear(int year, int era);
            /*0x31ef95c*/ bool IsValidMonth(int year, int month, int era);
            /*0x31ef9d4*/ bool IsValidDay(int year, int month, int day, int era);
            /*0x31efa54*/ int get_TwoDigitYearMax();
            /*0x31efa5c*/ void set_TwoDigitYearMax(int value);
            /*0x31ee518*/ int ToFourDigitYear(int year);
        }

        class CalendarData
        {
            static int MAX_CALENDARS = 23;
            static /*0x0*/ System.Globalization.CalendarData Invariant;
            static /*0x8*/ string[] HEBREW_MONTH_NAMES;
            static /*0x10*/ string[] HEBREW_LEAP_MONTH_NAMES;
            /*0x10*/ string sNativeName;
            /*0x18*/ string[] saShortDates;
            /*0x20*/ string[] saYearMonths;
            /*0x28*/ string[] saLongDates;
            /*0x30*/ string sMonthDay;
            /*0x38*/ string[] saEraNames;
            /*0x40*/ string[] saAbbrevEraNames;
            /*0x48*/ string[] saAbbrevEnglishEraNames;
            /*0x50*/ string[] saDayNames;
            /*0x58*/ string[] saAbbrevDayNames;
            /*0x60*/ string[] saSuperShortDayNames;
            /*0x68*/ string[] saMonthNames;
            /*0x70*/ string[] saAbbrevMonthNames;
            /*0x78*/ string[] saMonthGenitiveNames;
            /*0x80*/ string[] saAbbrevMonthGenitiveNames;
            /*0x88*/ string[] saLeapYearMonthNames;
            /*0x90*/ int iTwoDigitYearMax;
            /*0x94*/ int iCurrentEra;
            /*0x98*/ bool bUseUserOverrides;

            static /*0x31efa98*/ CalendarData();
            static /*0x31f1c78*/ string[] GetJapaneseEraNames();
            static /*0x31f1b90*/ string[] GetJapaneseEnglishEraNames();
            static /*0x31eea60*/ System.Globalization.CalendarData GetCalendarData(int calendarId);
            static /*0x31f1d60*/ string CalendarIdToCultureName(int calendarId);
            static /*0x31efa80*/ int nativeGetTwoDigitYearMax(int calID);
            static /*0x31f12dc*/ bool nativeGetCalendarData(System.Globalization.CalendarData data, string localeName, int calendarId);
            /*0x31efa88*/ CalendarData();
            /*0x31f0c8c*/ CalendarData(string localeName, int calendarId, bool bUseUserOverrides);
            /*0x31f13ac*/ void InitializeEraNames(string localeName, int calendarId);
            /*0x31f1810*/ void InitializeAbbreviatedEraNames(string localeName, int calendarId);
            /*0x31f1e2c*/ bool fill_calendar_data(string localeName, int datetimeIndex);
        }

        class ChineseLunisolarCalendar : System.Globalization.EastAsianLunisolarCalendar
        {
            static int ChineseEra = 1;
            static int MIN_LUNISOLAR_YEAR = 1901;
            static int MAX_LUNISOLAR_YEAR = 2100;
            static int MIN_GREGORIAN_YEAR = 1901;
            static int MIN_GREGORIAN_MONTH = 2;
            static int MIN_GREGORIAN_DAY = 19;
            static int MAX_GREGORIAN_YEAR = 2101;
            static int MAX_GREGORIAN_MONTH = 1;
            static int MAX_GREGORIAN_DAY = 28;
            static /*0x0*/ System.DateTime minDate;
            static /*0x8*/ System.DateTime maxDate;
            static /*0x10*/ int[,] yinfo;

            static /*0x31f2594*/ ChineseLunisolarCalendar();
            /*0x31f2270*/ ChineseLunisolarCalendar();
            /*0x31f1e30*/ System.DateTime get_MinSupportedDateTime();
            /*0x31f1e88*/ System.DateTime get_MaxSupportedDateTime();
            /*0x31f1ee0*/ int get_DaysInYearBeforeMinSupportedYear();
            /*0x31f1ee8*/ int get_MinCalendarYear();
            /*0x31f1ef0*/ int get_MaxCalendarYear();
            /*0x31f1ef8*/ System.DateTime get_MinDate();
            /*0x31f1f50*/ System.DateTime get_MaxDate();
            /*0x31f1fa8*/ System.Globalization.EraInfo[] get_CalEraInfo();
            /*0x31f1fb0*/ int GetYearInfo(int LunarYear, int Index);
            /*0x31f212c*/ int GetYear(int year, System.DateTime time);
            /*0x31f2134*/ int GetGregorianYear(int year, int era);
            /*0x31f22e8*/ int GetEra(System.DateTime time);
            /*0x31f2520*/ int get_ID();
            /*0x31f2528*/ int get_BaseCalendarID();
            /*0x31f2530*/ int[] get_Eras();
        }

        class EastAsianLunisolarCalendar : System.Globalization.Calendar
        {
            static int LeapMonth = 0;
            static int Jan1Month = 1;
            static int Jan1Date = 2;
            static int nDaysPerMonth = 3;
            static int DatePartYear = 0;
            static int DatePartDayOfYear = 1;
            static int DatePartMonth = 2;
            static int DatePartDay = 3;
            static int MaxCalendarMonth = 13;
            static int MaxCalendarDay = 30;
            static int DEFAULT_GREGORIAN_TWO_DIGIT_YEAR_MAX = 2029;
            static /*0x0*/ int[] DaysToMonth365;
            static /*0x8*/ int[] DaysToMonth366;

            static /*0x31f4a3c*/ EastAsianLunisolarCalendar();
            static /*0x31f323c*/ int GregorianIsLeapYear(int y);
            /*0x31f22d4*/ EastAsianLunisolarCalendar();
            /*0x31f2708*/ System.Globalization.CalendarAlgorithmType get_AlgorithmType();
            /*0x31f2710*/ int GetSexagenaryYear(System.DateTime time);
            /*0x31f28d0*/ int GetCelestialStem(int sexagenaryYear);
            /*0x31f2a04*/ int GetTerrestrialBranch(int sexagenaryYear);
            /*0x1f2fff4*/ int GetYearInfo(int LunarYear, int Index);
            int GetYear(int year, System.DateTime time);
            /*0x1f2fff4*/ int GetGregorianYear(int year, int era);
            /*0x1f2ffc8*/ int get_MinCalendarYear();
            /*0x1f2ffc8*/ int get_MaxCalendarYear();
            /*0x1f30214*/ System.Globalization.EraInfo[] get_CalEraInfo();
            System.DateTime get_MinDate();
            System.DateTime get_MaxDate();
            /*0x31f2b38*/ int MinEraCalendarYear(int era);
            /*0x31f2cc4*/ int MaxEraCalendarYear(int era);
            /*0x31f2360*/ void CheckTicksRange(long ticks);
            /*0x31f2e50*/ void CheckEraRange(int era);
            /*0x31f2f50*/ int CheckYearRange(int year, int era);
            /*0x31f30f4*/ int CheckYearMonthRange(int year, int month, int era);
            /*0x31f31b8*/ int InternalGetDaysInMonth(int year, int month);
            /*0x31f31ec*/ int GetDaysInMonth(int year, int month, int era);
            /*0x31f3288*/ System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
            /*0x31f3754*/ void GregorianToLunar(int nSYear, int nSMonth, int nSDate, ref int nLYear, ref int nLMonth, ref int nLDate);
            /*0x31f34ac*/ bool LunarToGregorian(int nLYear, int nLMonth, int nLDate, ref int nSolarYear, ref int nSolarMonth, ref int nSolarDay);
            /*0x31f3a58*/ System.DateTime LunarToTime(System.DateTime time, int year, int month, int day);
            /*0x31f27dc*/ void TimeToLunar(System.DateTime time, ref int year, ref int month, ref int day);
            /*0x31f3bac*/ System.DateTime AddMonths(System.DateTime time, int months);
            /*0x31f3f04*/ System.DateTime AddYears(System.DateTime time, int years);
            /*0x31f40d4*/ int GetDayOfYear(System.DateTime time);
            /*0x31f41dc*/ int GetDayOfMonth(System.DateTime time);
            /*0x31f427c*/ int GetDaysInYear(int year, int era);
            /*0x31f4310*/ int GetMonth(System.DateTime time);
            /*0x31f43b0*/ int GetYear(System.DateTime time);
            /*0x31f4468*/ System.DayOfWeek GetDayOfWeek(System.DateTime time);
            /*0x31f4534*/ int GetMonthsInYear(int year, int era);
            /*0x31f4570*/ bool IsLeapDay(int year, int month, int day, int era);
            /*0x31f470c*/ bool IsLeapMonth(int year, int month, int era);
            /*0x31f4758*/ int GetLeapMonth(int year, int era);
            /*0x31f3edc*/ bool InternalIsLeapYear(int year);
            /*0x31f4790*/ bool IsLeapYear(int year, int era);
            /*0x31f47c8*/ int get_TwoDigitYearMax();
            /*0x31f4840*/ void set_TwoDigitYearMax(int value);
            /*0x31f49a0*/ int ToFourDigitYear(int year);
        }

        class GlobalizationAssembly
        {
            static /*0x3212efc*/ byte* GetGlobalizationResourceBytePtr(System.Reflection.Assembly assembly, string tableName);
            /*0x3212fd0*/ GlobalizationAssembly();
        }

        class GregorianCalendar : System.Globalization.Calendar
        {
            static int ADEra = 1;
            static int DatePartYear = 0;
            static int DatePartDayOfYear = 1;
            static int DatePartMonth = 2;
            static int DatePartDay = 3;
            static int MaxYear = 9999;
            static int MinYear = 1;
            static int DEFAULT_TWO_DIGIT_YEAR_MAX = 2029;
            static /*0x0*/ int[] DaysToMonth365;
            static /*0x8*/ int[] DaysToMonth366;
            static /*0x10*/ System.Globalization.Calendar s_defaultInstance;
            /*0x1c*/ System.Globalization.GregorianCalendarTypes m_type;

            static /*0x3215184*/ GregorianCalendar();
            static /*0x321315c*/ System.Globalization.Calendar GetDefaultInstance();
            static /*0x321363c*/ long GetAbsoluteDate(int year, int month, int day);
            /*0x3213224*/ GregorianCalendar();
            /*0x3213244*/ GregorianCalendar(System.Globalization.GregorianCalendarTypes type);
            /*0x3212fd8*/ void OnDeserialized(System.Runtime.Serialization.StreamingContext ctx);
            /*0x32130a4*/ System.DateTime get_MinSupportedDateTime();
            /*0x32130fc*/ System.DateTime get_MaxSupportedDateTime();
            /*0x3213154*/ System.Globalization.CalendarAlgorithmType get_AlgorithmType();
            /*0x3213380*/ System.Globalization.GregorianCalendarTypes get_CalendarType();
            /*0x3213388*/ void set_CalendarType(System.Globalization.GregorianCalendarTypes value);
            /*0x321342c*/ int get_ID();
            /*0x3213434*/ int GetDatePart(long ticks, int part);
            /*0x321380c*/ long DateToTicks(int year, int month, int day);
            /*0x321388c*/ System.DateTime AddMonths(System.DateTime time, int months);
            /*0x3213c74*/ System.DateTime AddYears(System.DateTime time, int years);
            /*0x3213c8c*/ int GetDayOfMonth(System.DateTime time);
            /*0x3213d10*/ System.DayOfWeek GetDayOfWeek(System.DateTime time);
            /*0x3213db8*/ int GetDayOfYear(System.DateTime time);
            /*0x3213e3c*/ int GetDaysInMonth(int year, int month, int era);
            /*0x32140cc*/ int GetDaysInYear(int year, int era);
            /*0x321424c*/ int GetEra(System.DateTime time);
            /*0x3214254*/ int[] get_Eras();
            /*0x32142b8*/ int GetMonth(System.DateTime time);
            /*0x321433c*/ int GetMonthsInYear(int year, int era);
            /*0x3214480*/ int GetYear(System.DateTime time);
            /*0x3214504*/ bool IsLeapDay(int year, int month, int day, int era);
            /*0x3214898*/ int GetLeapMonth(int year, int era);
            /*0x32149e0*/ bool IsLeapMonth(int year, int month, int era);
            /*0x3214c00*/ bool IsLeapYear(int year, int era);
            /*0x3214d90*/ System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
            /*0x3214e2c*/ bool TryToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era, ref System.DateTime result);
            /*0x3214f20*/ int get_TwoDigitYearMax();
            /*0x3214f5c*/ void set_TwoDigitYearMax(int value);
            /*0x321506c*/ int ToFourDigitYear(int year);
        }

        class EraInfo
        {
            /*0x10*/ int era;
            /*0x18*/ long ticks;
            /*0x20*/ int yearOffset;
            /*0x24*/ int minEraYear;
            /*0x28*/ int maxEraYear;
            /*0x30*/ string eraName;
            /*0x38*/ string abbrevEraName;
            /*0x40*/ string englishEraName;

            /*0x3215268*/ EraInfo(int era, int startYear, int startMonth, int startDay, int yearOffset, int minEraYear, int maxEraYear);
            /*0x321534c*/ EraInfo(int era, int startYear, int startMonth, int startDay, int yearOffset, int minEraYear, int maxEraYear, string eraName, string abbrevEraName, string englishEraName);
        }

        class GregorianCalendarHelper
        {
            static long TicksPerMillisecond = 10000;
            static long TicksPerSecond = 10000000;
            static long TicksPerMinute = 600000000;
            static long TicksPerHour = 36000000000;
            static long TicksPerDay = 864000000000;
            static int MillisPerSecond = 1000;
            static int MillisPerMinute = 60000;
            static int MillisPerHour = 3600000;
            static int MillisPerDay = 86400000;
            static int DaysPerYear = 365;
            static int DaysPer4Years = 1461;
            static int DaysPer100Years = 36524;
            static int DaysPer400Years = 146097;
            static int DaysTo10000 = 3652059;
            static long MaxMillis = 315537897600000;
            static int DatePartYear = 0;
            static int DatePartDayOfYear = 1;
            static int DatePartMonth = 2;
            static int DatePartDay = 3;
            static /*0x0*/ int[] DaysToMonth365;
            static /*0x8*/ int[] DaysToMonth366;
            /*0x10*/ int m_maxYear;
            /*0x14*/ int m_minYear;
            /*0x18*/ System.Globalization.Calendar m_Cal;
            /*0x20*/ System.Globalization.EraInfo[] m_EraInfo;
            /*0x28*/ int[] m_eras;
            /*0x30*/ System.DateTime m_minDate;

            static /*0x3217340*/ GregorianCalendarHelper();
            static /*0x3215c34*/ long GetAbsoluteDate(int year, int month, int day);
            static /*0x3215e04*/ long DateToTicks(int year, int month, int day);
            static /*0x3215e84*/ long TimeToTicks(int hour, int minute, int second, int millisecond);
            /*0x3215474*/ GregorianCalendarHelper(System.Globalization.Calendar cal, System.Globalization.EraInfo[] eraInfo);
            /*0x321546c*/ int get_MaxYear();
            /*0x3215514*/ int GetYearOffset(int year, int era, bool throwOnError);
            /*0x32157f8*/ int GetGregorianYear(int year, int era);
            /*0x3215814*/ bool IsValidYear(int year, int era);
            /*0x3215830*/ int GetDatePart(long ticks, int part);
            /*0x3215a50*/ void CheckTicksRange(long ticks);
            /*0x3216030*/ System.DateTime AddMonths(System.DateTime time, int months);
            /*0x3216438*/ System.DateTime AddYears(System.DateTime time, int years);
            /*0x3216444*/ int GetDayOfMonth(System.DateTime time);
            /*0x32164c4*/ System.DayOfWeek GetDayOfWeek(System.DateTime time);
            /*0x3216590*/ int GetDayOfYear(System.DateTime time);
            /*0x3216610*/ int GetDaysInMonth(int year, int month, int era);
            /*0x32167ac*/ int GetDaysInYear(int year, int era);
            /*0x321680c*/ int GetEra(System.DateTime time);
            /*0x3216918*/ int[] get_Eras();
            /*0x3216a24*/ int GetMonth(System.DateTime time);
            /*0x3216aa4*/ int GetMonthsInYear(int year, int era);
            /*0x3216abc*/ int GetYear(System.DateTime time);
            /*0x3216be8*/ int GetYear(int year, System.DateTime time);
            /*0x3216cfc*/ bool IsLeapDay(int year, int month, int day, int era);
            /*0x3216edc*/ int GetLeapMonth(int year, int era);
            /*0x3216ef4*/ bool IsLeapMonth(int year, int month, int era);
            /*0x3216e6c*/ bool IsLeapYear(int year, int era);
            /*0x3217000*/ System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
            /*0x3217104*/ int GetWeekOfYear(System.DateTime time, System.Globalization.CalendarWeekRule rule, System.DayOfWeek firstDayOfWeek);
            /*0x32171d4*/ int ToFourDigitYear(int year, int twoDigitYearMax);
        }

        enum GregorianCalendarTypes
        {
            Localized = 1,
            USEnglish = 2,
            MiddleEastFrench = 9,
            Arabic = 10,
            TransliteratedEnglish = 11,
            TransliteratedFrench = 12,
        }

        class HebrewCalendar : System.Globalization.Calendar
        {
            static int DatePartYear = 0;
            static int DatePartDayOfYear = 1;
            static int DatePartMonth = 2;
            static int DatePartDay = 3;
            static int DatePartDayOfWeek = 4;
            static int HebrewYearOf1AD = 3760;
            static int FirstGregorianTableYear = 1583;
            static int LastGregorianTableYear = 2239;
            static int TABLESIZE = 656;
            static int MinHebrewYear = 5343;
            static int MaxHebrewYear = 5999;
            static int DEFAULT_TWO_DIGIT_YEAR_MAX = 5790;
            static /*0x0*/ int HebrewEra;
            static /*0x8*/ int[] HebrewTable;
            static /*0x10*/ int[,] LunarMonthLen;
            static /*0x18*/ System.DateTime calendarMinValue;
            static /*0x20*/ System.DateTime calendarMaxValue;

            static /*0x3219770*/ HebrewCalendar();
            static /*0x32174ec*/ void CheckHebrewYearValue(int y, int era, string varName);
            static /*0x321762c*/ void CheckEraRange(int era);
            static /*0x3217940*/ void CheckTicksRange(long ticks);
            static /*0x3217b20*/ int GetResult(System.Globalization.HebrewCalendar.__DateBuffer result, int part);
            static /*0x3217bc0*/ int GetLunarMonthDay(int gregorianYear, System.Globalization.HebrewCalendar.__DateBuffer lunarDate);
            static /*0x3218900*/ int GetHebrewYearType(int year, int era);
            static /*0x32190c4*/ int GetDayDifference(int lunarYearType, int month1, int day1, int month2, int day2);
            static /*0x321922c*/ System.DateTime HebrewToGregorian(int hebrewYear, int hebrewMonth, int hebrewDay, int hour, int minute, int second, int millisecond);
            /*0x32174dc*/ HebrewCalendar();
            /*0x3217424*/ System.DateTime get_MinSupportedDateTime();
            /*0x321747c*/ System.DateTime get_MaxSupportedDateTime();
            /*0x32174d4*/ System.Globalization.CalendarAlgorithmType get_AlgorithmType();
            /*0x32174e4*/ int get_ID();
            /*0x32176f8*/ void CheckHebrewMonthValue(int year, int month, int era);
            /*0x321781c*/ void CheckHebrewDayValue(int year, int month, int day, int era);
            /*0x3217d24*/ int GetDatePart(long ticks, int part);
            /*0x3218194*/ System.DateTime AddMonths(System.DateTime time, int months);
            /*0x3218564*/ System.DateTime AddYears(System.DateTime time, int years);
            /*0x32187d4*/ int GetDayOfMonth(System.DateTime time);
            /*0x3218858*/ System.DayOfWeek GetDayOfWeek(System.DateTime time);
            /*0x32189b4*/ int GetDayOfYear(System.DateTime time);
            /*0x3218aec*/ int GetDaysInMonth(int year, int month, int era);
            /*0x3218c34*/ int GetDaysInYear(int year, int era);
            /*0x3218cb8*/ int GetEra(System.DateTime time);
            /*0x3218d10*/ int[] get_Eras();
            /*0x3218dac*/ int GetMonth(System.DateTime time);
            /*0x3218e30*/ int GetMonthsInYear(int year, int era);
            /*0x3218e58*/ int GetYear(System.DateTime time);
            /*0x3218edc*/ bool IsLeapDay(int year, int month, int day, int era);
            /*0x3218f84*/ int GetLeapMonth(int year, int era);
            /*0x3218fac*/ bool IsLeapMonth(int year, int month, int era);
            /*0x3219010*/ bool IsLeapYear(int year, int era);
            /*0x3219410*/ System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
            /*0x321955c*/ int get_TwoDigitYearMax();
            /*0x3219598*/ void set_TwoDigitYearMax(int value);
            /*0x3219638*/ int ToFourDigitYear(int year);

            class __DateBuffer
            {
                /*0x10*/ int year;
                /*0x14*/ int month;
                /*0x18*/ int day;

                /*0x321818c*/ __DateBuffer();
            }
        }

        class HijriCalendar : System.Globalization.Calendar
        {
            static int DatePartYear = 0;
            static int DatePartDayOfYear = 1;
            static int DatePartMonth = 2;
            static int DatePartDay = 3;
            static int MinAdvancedHijri = -2;
            static int MaxAdvancedHijri = 2;
            static string HijriAdvanceRegKeyEntry = "AddHijriDate";
            static int MaxCalendarYear = 9666;
            static int MaxCalendarMonth = 4;
            static int MaxCalendarDay = 3;
            static int DEFAULT_TWO_DIGIT_YEAR_MAX = 1451;
            static /*0x0*/ int HijriEra;
            static /*0x8*/ int[] HijriMonthDays;
            static /*0x10*/ System.DateTime calendarMinValue;
            static /*0x18*/ System.DateTime calendarMaxValue;
            /*0x1c*/ int m_HijriAdvance;

            static /*0x321b520*/ HijriCalendar();
            static /*0x3219c14*/ int GetAdvanceHijriDate();
            static /*0x3219d28*/ void CheckTicksRange(long ticks);
            static /*0x3219f08*/ void CheckEraRange(int era);
            static /*0x3219fd4*/ void CheckYearRange(int year, int era);
            static /*0x321a120*/ void CheckYearMonthRange(int year, int month, int era);
            /*0x3219a0c*/ HijriCalendar();
            /*0x3219954*/ System.DateTime get_MinSupportedDateTime();
            /*0x32199ac*/ System.DateTime get_MaxSupportedDateTime();
            /*0x3219a04*/ System.Globalization.CalendarAlgorithmType get_AlgorithmType();
            /*0x3219a1c*/ int get_ID();
            /*0x3219a24*/ int get_DaysInYearBeforeMinSupportedYear();
            /*0x3219a2c*/ long GetAbsoluteDateHijri(int y, int m, int d);
            /*0x3219af4*/ long DaysUpToHijriYear(int HijriYear);
            /*0x3219bac*/ int get_HijriAdjustment();
            /*0x3219c1c*/ void set_HijriAdjustment(int value);
            /*0x321a29c*/ int GetDatePart(long ticks, int part);
            /*0x321a50c*/ System.DateTime AddMonths(System.DateTime time, int months);
            /*0x321a82c*/ System.DateTime AddYears(System.DateTime time, int years);
            /*0x321a844*/ int GetDayOfMonth(System.DateTime time);
            /*0x321a8c8*/ System.DayOfWeek GetDayOfWeek(System.DateTime time);
            /*0x321a970*/ int GetDayOfYear(System.DateTime time);
            /*0x321a9f4*/ int GetDaysInMonth(int year, int month, int era);
            /*0x321aab0*/ int GetDaysInYear(int year, int era);
            /*0x321ab44*/ int GetEra(System.DateTime time);
            /*0x321abe0*/ int[] get_Eras();
            /*0x321ac7c*/ int GetMonth(System.DateTime time);
            /*0x321ad00*/ int GetMonthsInYear(int year, int era);
            /*0x321ad6c*/ int GetYear(System.DateTime time);
            /*0x321adf0*/ bool IsLeapDay(int year, int month, int day, int era);
            /*0x321af50*/ int GetLeapMonth(int year, int era);
            /*0x321afbc*/ bool IsLeapMonth(int year, int month, int era);
            /*0x321b030*/ bool IsLeapYear(int year, int era);
            /*0x321b0d0*/ System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
            /*0x321b2a0*/ int get_TwoDigitYearMax();
            /*0x321b2dc*/ void set_TwoDigitYearMax(int value);
            /*0x321b3ec*/ int ToFourDigitYear(int year);
        }

        class JapaneseCalendar : System.Globalization.Calendar
        {
            static string c_japaneseErasHive = "System\CurrentControlSet\Control\Nls\Calendars\Japanese\Eras";
            static string c_japaneseErasHivePermissionList = "HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Nls\Calendars\Japanese\Eras";
            static int DEFAULT_TWO_DIGIT_YEAR_MAX = 99;
            static /*0x0*/ System.DateTime calendarMinValue;
            static /*0x8*/ System.Globalization.EraInfo[] japaneseEraInfo;
            static /*0x10*/ System.Globalization.Calendar s_defaultInstance;
            /*0x20*/ System.Globalization.GregorianCalendarHelper helper;

            static /*0x321c978*/ JapaneseCalendar();
            static /*0x321b6f4*/ System.Globalization.EraInfo[] GetEraInfo();
            static /*0x321bbac*/ System.Globalization.EraInfo[] GetErasFromRegistry();
            static /*0x321bbb4*/ int CompareEraRanges(System.Globalization.EraInfo a, System.Globalization.EraInfo b);
            static /*0x321bbdc*/ System.Globalization.EraInfo GetEraFromValue(string value, string data);
            static /*0x321bf98*/ System.Globalization.Calendar GetDefaultInstance();
            static /*0x321c504*/ string[] EraNames();
            static /*0x321c5f8*/ string[] AbbrevEraNames();
            static /*0x321c6ec*/ string[] EnglishEraNames();
            /*0x321c054*/ JapaneseCalendar();
            /*0x321b63c*/ System.DateTime get_MinSupportedDateTime();
            /*0x321b694*/ System.DateTime get_MaxSupportedDateTime();
            /*0x321b6ec*/ System.Globalization.CalendarAlgorithmType get_AlgorithmType();
            /*0x321c208*/ int get_ID();
            /*0x321c210*/ System.DateTime AddMonths(System.DateTime time, int months);
            /*0x321c224*/ System.DateTime AddYears(System.DateTime time, int years);
            /*0x321c240*/ int GetDaysInMonth(int year, int month, int era);
            /*0x321c254*/ int GetDaysInYear(int year, int era);
            /*0x321c268*/ int GetDayOfMonth(System.DateTime time);
            /*0x321c27c*/ System.DayOfWeek GetDayOfWeek(System.DateTime time);
            /*0x321c290*/ int GetDayOfYear(System.DateTime time);
            /*0x321c2a4*/ int GetMonthsInYear(int year, int era);
            /*0x321c2c8*/ int GetWeekOfYear(System.DateTime time, System.Globalization.CalendarWeekRule rule, System.DayOfWeek firstDayOfWeek);
            /*0x321c2e4*/ int GetEra(System.DateTime time);
            /*0x321c2f8*/ int GetMonth(System.DateTime time);
            /*0x321c30c*/ int GetYear(System.DateTime time);
            /*0x321c320*/ bool IsLeapDay(int year, int month, int day, int era);
            /*0x321c334*/ bool IsLeapYear(int year, int era);
            /*0x321c348*/ int GetLeapMonth(int year, int era);
            /*0x321c36c*/ bool IsLeapMonth(int year, int month, int era);
            /*0x321c38c*/ System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
            /*0x321c3ac*/ int ToFourDigitYear(int year);
            /*0x321c4f0*/ int[] get_Eras();
            /*0x321c7e0*/ bool IsValidYear(int year, int era);
            /*0x321c808*/ int get_TwoDigitYearMax();
            /*0x321c844*/ void set_TwoDigitYearMax(int value);
        }

        class JapaneseLunisolarCalendar : System.Globalization.EastAsianLunisolarCalendar
        {
            static int JapaneseEra = 1;
            static int MIN_LUNISOLAR_YEAR = 1960;
            static int MAX_LUNISOLAR_YEAR = 2049;
            static int MIN_GREGORIAN_YEAR = 1960;
            static int MIN_GREGORIAN_MONTH = 1;
            static int MIN_GREGORIAN_DAY = 28;
            static int MAX_GREGORIAN_YEAR = 2050;
            static int MAX_GREGORIAN_MONTH = 1;
            static int MAX_GREGORIAN_DAY = 22;
            static /*0x0*/ System.DateTime minDate;
            static /*0x8*/ System.DateTime maxDate;
            static /*0x10*/ int[,] yinfo;
            /*0x20*/ System.Globalization.GregorianCalendarHelper helper;

            static /*0x321cfd8*/ JapaneseLunisolarCalendar();
            static /*0x321cd5c*/ System.Globalization.EraInfo[] TrimEras(System.Globalization.EraInfo[] baseEras);
            /*0x321cea8*/ JapaneseLunisolarCalendar();
            /*0x321c9e0*/ System.DateTime get_MinSupportedDateTime();
            /*0x321ca38*/ System.DateTime get_MaxSupportedDateTime();
            /*0x321ca90*/ int get_DaysInYearBeforeMinSupportedYear();
            /*0x321ca98*/ int get_MinCalendarYear();
            /*0x321caa0*/ int get_MaxCalendarYear();
            /*0x321caa8*/ System.DateTime get_MinDate();
            /*0x321cb00*/ System.DateTime get_MaxDate();
            /*0x321cb58*/ System.Globalization.EraInfo[] get_CalEraInfo();
            /*0x321cba4*/ int GetYearInfo(int LunarYear, int Index);
            /*0x321cd20*/ int GetYear(int year, System.DateTime time);
            /*0x321cd34*/ int GetGregorianYear(int year, int era);
            /*0x321cfa0*/ int GetEra(System.DateTime time);
            /*0x321cfb4*/ int get_BaseCalendarID();
            /*0x321cfbc*/ int get_ID();
            /*0x321cfc4*/ int[] get_Eras();
        }

        class JulianCalendar : System.Globalization.Calendar
        {
            static int DatePartYear = 0;
            static int DatePartDayOfYear = 1;
            static int DatePartMonth = 2;
            static int DatePartDay = 3;
            static int JulianDaysPerYear = 365;
            static int JulianDaysPer4Years = 1461;
            static /*0x0*/ int JulianEra;
            static /*0x8*/ int[] DaysToMonth365;
            static /*0x10*/ int[] DaysToMonth366;
            /*0x1c*/ int MaxYear;

            static /*0x321e89c*/ JulianCalendar();
            static /*0x321d234*/ void CheckEraRange(int era);
            static /*0x321d454*/ void CheckMonthRange(int month);
            static /*0x321d4d0*/ void CheckDayRange(int year, int month, int day);
            static /*0x321d6c8*/ int GetDatePart(long ticks, int part);
            static /*0x321d84c*/ long DateToTicks(int year, int month, int day);
            /*0x321d204*/ JulianCalendar();
            /*0x321d14c*/ System.DateTime get_MinSupportedDateTime();
            /*0x321d1a4*/ System.DateTime get_MaxSupportedDateTime();
            /*0x321d1fc*/ System.Globalization.CalendarAlgorithmType get_AlgorithmType();
            /*0x321d22c*/ int get_ID();
            /*0x321d300*/ void CheckYearEraRange(int year, int era);
            /*0x321d93c*/ System.DateTime AddMonths(System.DateTime time, int months);
            /*0x321dd10*/ System.DateTime AddYears(System.DateTime time, int years);
            /*0x321dd28*/ int GetDayOfMonth(System.DateTime time);
            /*0x321ddbc*/ System.DayOfWeek GetDayOfWeek(System.DateTime time);
            /*0x321de64*/ int GetDayOfYear(System.DateTime time);
            /*0x321def8*/ int GetDaysInMonth(int year, int month, int era);
            /*0x321dff0*/ int GetDaysInYear(int year, int era);
            /*0x321e018*/ int GetEra(System.DateTime time);
            /*0x321e070*/ int GetMonth(System.DateTime time);
            /*0x321e104*/ int[] get_Eras();
            /*0x321e1a0*/ int GetMonthsInYear(int year, int era);
            /*0x321e1b4*/ int GetYear(System.DateTime time);
            /*0x321e248*/ bool IsLeapDay(int year, int month, int day, int era);
            /*0x321e330*/ int GetLeapMonth(int year, int era);
            /*0x321e344*/ bool IsLeapMonth(int year, int month, int era);
            /*0x321e3cc*/ bool IsLeapYear(int year, int era);
            /*0x321e3e8*/ System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
            /*0x321e650*/ int get_TwoDigitYearMax();
            /*0x321e658*/ void set_TwoDigitYearMax(int value);
            /*0x321e774*/ int ToFourDigitYear(int year);
        }

        class KoreanCalendar : System.Globalization.Calendar
        {
            static int KoreanEra = 1;
            static int DEFAULT_TWO_DIGIT_YEAR_MAX = 4362;
            static /*0x0*/ System.Globalization.EraInfo[] koreanEraInfo;
            /*0x20*/ System.Globalization.GregorianCalendarHelper helper;

            static /*0x321efc4*/ KoreanCalendar();
            /*0x321ea40*/ KoreanCalendar();
            /*0x321e988*/ System.DateTime get_MinSupportedDateTime();
            /*0x321e9e0*/ System.DateTime get_MaxSupportedDateTime();
            /*0x321ea38*/ System.Globalization.CalendarAlgorithmType get_AlgorithmType();
            /*0x321ebf4*/ int get_ID();
            /*0x321ebfc*/ System.DateTime AddMonths(System.DateTime time, int months);
            /*0x321ec10*/ System.DateTime AddYears(System.DateTime time, int years);
            /*0x321ec2c*/ int GetDaysInMonth(int year, int month, int era);
            /*0x321ec40*/ int GetDaysInYear(int year, int era);
            /*0x321ec54*/ int GetDayOfMonth(System.DateTime time);
            /*0x321ec68*/ System.DayOfWeek GetDayOfWeek(System.DateTime time);
            /*0x321ec7c*/ int GetDayOfYear(System.DateTime time);
            /*0x321ec90*/ int GetMonthsInYear(int year, int era);
            /*0x321ecb4*/ int GetWeekOfYear(System.DateTime time, System.Globalization.CalendarWeekRule rule, System.DayOfWeek firstDayOfWeek);
            /*0x321ecd0*/ int GetEra(System.DateTime time);
            /*0x321ece4*/ int GetMonth(System.DateTime time);
            /*0x321ecf8*/ int GetYear(System.DateTime time);
            /*0x321ed0c*/ bool IsLeapDay(int year, int month, int day, int era);
            /*0x321ed20*/ bool IsLeapYear(int year, int era);
            /*0x321ed34*/ int GetLeapMonth(int year, int era);
            /*0x321ed58*/ bool IsLeapMonth(int year, int month, int era);
            /*0x321ed78*/ System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
            /*0x321ed98*/ int[] get_Eras();
            /*0x321edac*/ int get_TwoDigitYearMax();
            /*0x321ede8*/ void set_TwoDigitYearMax(int value);
            /*0x321ef1c*/ int ToFourDigitYear(int year);
        }

        class KoreanLunisolarCalendar : System.Globalization.EastAsianLunisolarCalendar
        {
            static int GregorianEra = 1;
            static int MIN_LUNISOLAR_YEAR = 918;
            static int MAX_LUNISOLAR_YEAR = 2050;
            static int MIN_GREGORIAN_YEAR = 918;
            static int MIN_GREGORIAN_MONTH = 2;
            static int MIN_GREGORIAN_DAY = 14;
            static int MAX_GREGORIAN_YEAR = 2051;
            static int MAX_GREGORIAN_MONTH = 2;
            static int MAX_GREGORIAN_DAY = 10;
            static /*0x0*/ System.DateTime minDate;
            static /*0x8*/ System.DateTime maxDate;
            static /*0x10*/ int[,] yinfo;

            static /*0x321f658*/ KoreanLunisolarCalendar();
            /*0x321f510*/ KoreanLunisolarCalendar();
            /*0x321f0d0*/ System.DateTime get_MinSupportedDateTime();
            /*0x321f128*/ System.DateTime get_MaxSupportedDateTime();
            /*0x321f180*/ int get_DaysInYearBeforeMinSupportedYear();
            /*0x321f188*/ int get_MinCalendarYear();
            /*0x321f190*/ int get_MaxCalendarYear();
            /*0x321f198*/ System.DateTime get_MinDate();
            /*0x321f1f0*/ System.DateTime get_MaxDate();
            /*0x321f248*/ System.Globalization.EraInfo[] get_CalEraInfo();
            /*0x321f250*/ int GetYearInfo(int LunarYear, int Index);
            /*0x321f3cc*/ int GetYear(int year, System.DateTime time);
            /*0x321f3d4*/ int GetGregorianYear(int year, int era);
            /*0x321f568*/ int GetEra(System.DateTime time);
            /*0x321f5e4*/ int get_BaseCalendarID();
            /*0x321f5ec*/ int get_ID();
            /*0x321f5f4*/ int[] get_Eras();
        }

        class NumberFormatInfo : System.ICloneable, System.IFormatProvider
        {
            static System.Globalization.NumberStyles InvalidNumberStyles = -1024;
            static /*0x0*/ System.Globalization.NumberFormatInfo invariantInfo;
            /*0x10*/ int[] numberGroupSizes;
            /*0x18*/ int[] currencyGroupSizes;
            /*0x20*/ int[] percentGroupSizes;
            /*0x28*/ string positiveSign;
            /*0x30*/ string negativeSign;
            /*0x38*/ string numberDecimalSeparator;
            /*0x40*/ string numberGroupSeparator;
            /*0x48*/ string currencyGroupSeparator;
            /*0x50*/ string currencyDecimalSeparator;
            /*0x58*/ string currencySymbol;
            /*0x60*/ string ansiCurrencySymbol;
            /*0x68*/ string nanSymbol;
            /*0x70*/ string positiveInfinitySymbol;
            /*0x78*/ string negativeInfinitySymbol;
            /*0x80*/ string percentDecimalSeparator;
            /*0x88*/ string percentGroupSeparator;
            /*0x90*/ string percentSymbol;
            /*0x98*/ string perMilleSymbol;
            /*0xa0*/ string[] nativeDigits;
            /*0xa8*/ int m_dataItem;
            /*0xac*/ int numberDecimalDigits;
            /*0xb0*/ int currencyDecimalDigits;
            /*0xb4*/ int currencyPositivePattern;
            /*0xb8*/ int currencyNegativePattern;
            /*0xbc*/ int numberNegativePattern;
            /*0xc0*/ int percentPositivePattern;
            /*0xc4*/ int percentNegativePattern;
            /*0xc8*/ int percentDecimalDigits;
            /*0xcc*/ int digitSubstitution;
            /*0xd0*/ bool isReadOnly;
            /*0xd1*/ bool m_useUserOverride;
            /*0xd2*/ bool m_isInvariant;
            /*0xd3*/ bool validForParseAsNumber;
            /*0xd4*/ bool validForParseAsCurrency;

            static /*0x321fe0c*/ void VerifyDecimalSeparator(string decSep, string propertyName);
            static /*0x321fed4*/ void VerifyGroupSeparator(string groupSep, string propertyName);
            static /*0x321ff3c*/ void VerifyNativeDigits(string[] nativeDig, string propertyName);
            static /*0x322011c*/ void VerifyDigitSubstitution(System.Globalization.DigitShapes digitSub, string propertyName);
            static /*0x321bee4*/ System.Globalization.NumberFormatInfo get_InvariantInfo();
            static /*0x322051c*/ System.Globalization.NumberFormatInfo GetInstance(System.IFormatProvider formatProvider);
            static /*0x3220994*/ void CheckGroupSize(string propName, int[] groupSize);
            static /*0x32206bc*/ System.Globalization.NumberFormatInfo get_CurrentInfo();
            static /*0x322044c*/ System.Globalization.NumberFormatInfo ReadOnly(System.Globalization.NumberFormatInfo nfi);
            static /*0x3221f68*/ void ValidateParseStyleInteger(System.Globalization.NumberStyles style);
            static /*0x3222034*/ void ValidateParseStyleFloatingPoint(System.Globalization.NumberStyles style);
            /*0x321f7cc*/ NumberFormatInfo();
            /*0x321f7d4*/ NumberFormatInfo(System.Globalization.CultureData cultureData);
            /*0x321fd80*/ void OnSerializing(System.Runtime.Serialization.StreamingContext ctx);
            /*0x321fe04*/ void OnDeserializing(System.Runtime.Serialization.StreamingContext ctx);
            /*0x321fe08*/ void OnDeserialized(System.Runtime.Serialization.StreamingContext ctx);
            /*0x32203e8*/ void VerifyWritable();
            /*0x32207a4*/ object Clone();
            /*0x3220810*/ int get_CurrencyDecimalDigits();
            /*0x3220818*/ void set_CurrencyDecimalDigits(int value);
            /*0x3220918*/ string get_CurrencyDecimalSeparator();
            /*0x3220920*/ void set_CurrencyDecimalSeparator(string value);
            /*0x322098c*/ bool get_IsReadOnly();
            /*0x3220a68*/ int[] get_CurrencyGroupSizes();
            /*0x3220ae0*/ void set_CurrencyGroupSizes(int[] value);
            /*0x3220c00*/ int[] get_NumberGroupSizes();
            /*0x3220c78*/ void set_NumberGroupSizes(int[] value);
            /*0x3220d98*/ int[] get_PercentGroupSizes();
            /*0x3220e10*/ void set_PercentGroupSizes(int[] value);
            /*0x3220f30*/ string get_CurrencyGroupSeparator();
            /*0x3220f38*/ void set_CurrencyGroupSeparator(string value);
            /*0x3220fa4*/ string get_CurrencySymbol();
            /*0x3220fac*/ void set_CurrencySymbol(string value);
            /*0x3221040*/ string get_NaNSymbol();
            /*0x3221048*/ void set_NaNSymbol(string value);
            /*0x32210dc*/ int get_CurrencyNegativePattern();
            /*0x32210e4*/ void set_CurrencyNegativePattern(int value);
            /*0x32211e4*/ int get_NumberNegativePattern();
            /*0x32211ec*/ void set_NumberNegativePattern(int value);
            /*0x32212ec*/ int get_PercentPositivePattern();
            /*0x32212f4*/ void set_PercentPositivePattern(int value);
            /*0x32213f4*/ int get_PercentNegativePattern();
            /*0x32213fc*/ void set_PercentNegativePattern(int value);
            /*0x32214fc*/ string get_NegativeInfinitySymbol();
            /*0x3221504*/ void set_NegativeInfinitySymbol(string value);
            /*0x3221598*/ string get_NegativeSign();
            /*0x32215a0*/ void set_NegativeSign(string value);
            /*0x3221634*/ int get_NumberDecimalDigits();
            /*0x322163c*/ void set_NumberDecimalDigits(int value);
            /*0x322173c*/ string get_NumberDecimalSeparator();
            /*0x3221744*/ void set_NumberDecimalSeparator(string value);
            /*0x32217b0*/ string get_NumberGroupSeparator();
            /*0x32217b8*/ void set_NumberGroupSeparator(string value);
            /*0x3221824*/ int get_CurrencyPositivePattern();
            /*0x322182c*/ void set_CurrencyPositivePattern(int value);
            /*0x322192c*/ string get_PositiveInfinitySymbol();
            /*0x3221934*/ void set_PositiveInfinitySymbol(string value);
            /*0x32219c8*/ string get_PositiveSign();
            /*0x32219d0*/ void set_PositiveSign(string value);
            /*0x3221a64*/ int get_PercentDecimalDigits();
            /*0x3221a6c*/ void set_PercentDecimalDigits(int value);
            /*0x3221b6c*/ string get_PercentDecimalSeparator();
            /*0x3221b74*/ void set_PercentDecimalSeparator(string value);
            /*0x3221be0*/ string get_PercentGroupSeparator();
            /*0x3221be8*/ void set_PercentGroupSeparator(string value);
            /*0x3221c54*/ string get_PercentSymbol();
            /*0x3221c5c*/ void set_PercentSymbol(string value);
            /*0x3221cf0*/ string get_PerMilleSymbol();
            /*0x3221cf8*/ void set_PerMilleSymbol(string value);
            /*0x3221d8c*/ string[] get_NativeDigits();
            /*0x3221e04*/ void set_NativeDigits(string[] value);
            /*0x3221e70*/ System.Globalization.DigitShapes get_DigitSubstitution();
            /*0x3221e78*/ void set_DigitSubstitution(System.Globalization.DigitShapes value);
            /*0x3221edc*/ object GetFormat(System.Type formatType);
        }

        class StringInfo
        {
            /*0x10*/ string m_str;
            /*0x18*/ int[] m_indexes;

            static /*0x3222774*/ string GetNextTextElement(string str);
            static /*0x32228c8*/ int GetCurrentTextElementLen(string str, int index, int len, ref System.Globalization.UnicodeCategory ucCurrent, ref int currentCharCount);
            static /*0x322277c*/ string GetNextTextElement(string str, int index);
            static /*0x32229dc*/ System.Globalization.TextElementEnumerator GetTextElementEnumerator(string str);
            static /*0x32229e4*/ System.Globalization.TextElementEnumerator GetTextElementEnumerator(string str, int index);
            static /*0x322235c*/ int[] ParseCombiningCharacters(string str);
            /*0x32220f8*/ StringInfo();
            /*0x3222150*/ StringInfo(string value);
            /*0x3222210*/ void OnDeserializing(System.Runtime.Serialization.StreamingContext ctx);
            /*0x322222c*/ void OnDeserialized(System.Runtime.Serialization.StreamingContext ctx);
            /*0x3222254*/ bool Equals(object value);
            /*0x32222ec*/ int GetHashCode();
            /*0x3222308*/ int[] get_Indexes();
            /*0x32224c4*/ string get_String();
            /*0x322217c*/ void set_String(string value);
            /*0x32224cc*/ int get_LengthInTextElements();
            /*0x32224f8*/ string SubstringByTextElements(int startingTextElement);
            /*0x32225b0*/ string SubstringByTextElements(int startingTextElement, int lengthInTextElements);
        }

        class TaiwanCalendar : System.Globalization.Calendar
        {
            static int DEFAULT_TWO_DIGIT_YEAR_MAX = 99;
            static /*0x0*/ System.Globalization.EraInfo[] taiwanEraInfo;
            static /*0x8*/ System.Globalization.Calendar s_defaultInstance;
            static /*0x10*/ System.DateTime calendarMinValue;
            /*0x20*/ System.Globalization.GregorianCalendarHelper helper;

            static /*0x3223314*/ TaiwanCalendar();
            static /*0x3222b80*/ System.Globalization.Calendar GetDefaultInstance();
            /*0x3222c3c*/ TaiwanCalendar();
            /*0x3222df0*/ System.DateTime get_MinSupportedDateTime();
            /*0x3222e48*/ System.DateTime get_MaxSupportedDateTime();
            /*0x3222ea0*/ System.Globalization.CalendarAlgorithmType get_AlgorithmType();
            /*0x3222ea8*/ int get_ID();
            /*0x3222eb0*/ System.DateTime AddMonths(System.DateTime time, int months);
            /*0x3222ec4*/ System.DateTime AddYears(System.DateTime time, int years);
            /*0x3222ee0*/ int GetDaysInMonth(int year, int month, int era);
            /*0x3222ef4*/ int GetDaysInYear(int year, int era);
            /*0x3222f08*/ int GetDayOfMonth(System.DateTime time);
            /*0x3222f1c*/ System.DayOfWeek GetDayOfWeek(System.DateTime time);
            /*0x3222f30*/ int GetDayOfYear(System.DateTime time);
            /*0x3222f44*/ int GetMonthsInYear(int year, int era);
            /*0x3222f68*/ int GetWeekOfYear(System.DateTime time, System.Globalization.CalendarWeekRule rule, System.DayOfWeek firstDayOfWeek);
            /*0x3222f84*/ int GetEra(System.DateTime time);
            /*0x3222f98*/ int GetMonth(System.DateTime time);
            /*0x3222fac*/ int GetYear(System.DateTime time);
            /*0x3222fc0*/ bool IsLeapDay(int year, int month, int day, int era);
            /*0x3222fd4*/ bool IsLeapYear(int year, int era);
            /*0x3222fe8*/ int GetLeapMonth(int year, int era);
            /*0x322300c*/ bool IsLeapMonth(int year, int month, int era);
            /*0x322302c*/ System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
            /*0x322304c*/ int[] get_Eras();
            /*0x3223060*/ int get_TwoDigitYearMax();
            /*0x322309c*/ void set_TwoDigitYearMax(int value);
            /*0x32231d0*/ int ToFourDigitYear(int year);
        }

        class TaiwanLunisolarCalendar : System.Globalization.EastAsianLunisolarCalendar
        {
            static int MIN_LUNISOLAR_YEAR = 1912;
            static int MAX_LUNISOLAR_YEAR = 2050;
            static int MIN_GREGORIAN_YEAR = 1912;
            static int MIN_GREGORIAN_MONTH = 2;
            static int MIN_GREGORIAN_DAY = 18;
            static int MAX_GREGORIAN_YEAR = 2051;
            static int MAX_GREGORIAN_MONTH = 2;
            static int MAX_GREGORIAN_DAY = 10;
            static /*0x0*/ System.Globalization.EraInfo[] taiwanLunisolarEraInfo;
            static /*0x8*/ System.DateTime minDate;
            static /*0x10*/ System.DateTime maxDate;
            static /*0x18*/ int[,] yinfo;
            /*0x20*/ System.Globalization.GregorianCalendarHelper helper;

            static /*0x32238d4*/ TaiwanLunisolarCalendar();
            /*0x32237d8*/ TaiwanLunisolarCalendar();
            /*0x3223450*/ System.DateTime get_MinSupportedDateTime();
            /*0x32234a8*/ System.DateTime get_MaxSupportedDateTime();
            /*0x3223500*/ int get_DaysInYearBeforeMinSupportedYear();
            /*0x3223508*/ int get_MinCalendarYear();
            /*0x3223510*/ int get_MaxCalendarYear();
            /*0x3223518*/ System.DateTime get_MinDate();
            /*0x3223570*/ System.DateTime get_MaxDate();
            /*0x32235c8*/ System.Globalization.EraInfo[] get_CalEraInfo();
            /*0x3223620*/ int GetYearInfo(int LunarYear, int Index);
            /*0x322379c*/ int GetYear(int year, System.DateTime time);
            /*0x32237b0*/ int GetGregorianYear(int year, int era);
            /*0x322389c*/ int GetEra(System.DateTime time);
            /*0x32238b0*/ int get_BaseCalendarID();
            /*0x32238b8*/ int get_ID();
            /*0x32238c0*/ int[] get_Eras();
        }

        class TextElementEnumerator : System.Collections.IEnumerator
        {
            /*0x10*/ string str;
            /*0x18*/ int index;
            /*0x1c*/ int startIndex;
            /*0x20*/ int strLen;
            /*0x24*/ int currTextElementLen;
            /*0x28*/ System.Globalization.UnicodeCategory uc;
            /*0x2c*/ int charLen;
            /*0x30*/ int endIndex;
            /*0x34*/ int nextTextElementLen;

            /*0x3222b10*/ TextElementEnumerator(string str, int startIndex, int strLen);
            /*0x3223d28*/ TextElementEnumerator();
            /*0x3223b50*/ void OnDeserializing(System.Runtime.Serialization.StreamingContext ctx);
            /*0x3223b5c*/ void OnDeserialized(System.Runtime.Serialization.StreamingContext ctx);
            /*0x3223ba0*/ void OnSerializing(System.Runtime.Serialization.StreamingContext ctx);
            /*0x3223bb0*/ bool MoveNext();
            /*0x3223c10*/ object get_Current();
            /*0x3223c14*/ string GetTextElement();
            /*0x3223cb8*/ int get_ElementIndex();
            /*0x3223b1c*/ void Reset();
        }

        class TextInfo : System.ICloneable, System.Runtime.Serialization.IDeserializationCallback
        {
            static int wordSeparatorMask = 536672256;
            static /*0x0*/ System.Globalization.TextInfo s_Invariant;
            /*0x10*/ string m_listSeparator;
            /*0x18*/ bool m_isReadOnly;
            /*0x20*/ string m_cultureName;
            /*0x28*/ System.Globalization.CultureData m_cultureData;
            /*0x30*/ string m_textInfoName;
            /*0x38*/ System.Nullable<bool> m_IsAsciiCasingSameAsInvariant;
            /*0x40*/ string customCultureName;
            /*0x48*/ int m_nDataItem;
            /*0x4c*/ bool m_useUserOverride;
            /*0x50*/ int m_win32LangID;

            static /*0x3223d60*/ System.Globalization.TextInfo get_Invariant();
            static /*0x322441c*/ int GetHashCodeOrdinalIgnoreCase(string s);
            static /*0x3224428*/ int GetHashCodeOrdinalIgnoreCase(string s, bool forceRandomizedHashing, long additionalEntropy);
            static /*0x3224544*/ int CompareOrdinalIgnoreCaseEx(string strA, int indexA, string strB, int indexB, int lengthA, int lengthB);
            static /*0x32246ec*/ int IndexOfStringOrdinalIgnoreCase(string source, string value, int startIndex, int count);
            static /*0x3224788*/ int LastIndexOfStringOrdinalIgnoreCase(string source, string value, int startIndex, int count);
            static /*0x3224978*/ System.Globalization.TextInfo ReadOnly(System.Globalization.TextInfo textInfo);
            static /*0x3224d54*/ char ToLowerAsciiInvariant(char c);
            static /*0x3225354*/ char ToUpperAsciiInvariant(char c);
            static /*0x3224bfc*/ bool IsAscii(char c);
            static /*0x3225f04*/ int AddNonLetter(ref System.Text.StringBuilder result, ref string input, int inputIndex, int charLen);
            static /*0x3225ee8*/ bool IsWordSeparator(System.Globalization.UnicodeCategory category);
            static /*0x3225edc*/ bool IsLetterCategory(System.Globalization.UnicodeCategory uc);
            static /*0x3224548*/ int InternalCompareStringOrdinalIgnoreCase(string strA, int indexA, string strB, int indexB, int lenA, int lenB);
            /*0x32241d0*/ TextInfo(System.Globalization.CultureData cultureData);
            /*0x3226300*/ TextInfo();
            /*0x322423c*/ void OnDeserializing(System.Runtime.Serialization.StreamingContext ctx);
            /*0x3224264*/ void OnDeserialized();
            /*0x322438c*/ void OnDeserialized(System.Runtime.Serialization.StreamingContext ctx);
            /*0x3224390*/ void OnSerializing(System.Runtime.Serialization.StreamingContext ctx);
            /*0x3224810*/ int get_ANSICodePage();
            /*0x3224828*/ int get_OEMCodePage();
            /*0x3224840*/ int get_MacCodePage();
            /*0x3224858*/ int get_EBCDICCodePage();
            /*0x3224870*/ int get_LCID();
            /*0x32248e0*/ string get_CultureName();
            /*0x32248e8*/ bool get_IsReadOnly();
            /*0x32248f0*/ object Clone();
            /*0x3224a64*/ void VerifyWritable();
            /*0x3224ac8*/ void SetReadOnlyState(bool readOnly);
            /*0x3224ad0*/ string get_ListSeparator();
            /*0x3224b0c*/ void set_ListSeparator(string value);
            /*0x3224ba0*/ char ToLower(char c);
            /*0x32251d8*/ string ToLower(string str);
            /*0x32252f4*/ char ToUpper(char c);
            /*0x3225828*/ string ToUpper(string str);
            /*0x3224c0c*/ bool get_IsAsciiCasingSameAsInvariant();
            /*0x3225944*/ bool Equals(object obj);
            /*0x32259dc*/ int GetHashCode();
            /*0x32259f8*/ string ToString();
            /*0x3225a50*/ string ToTitleCase(string str);
            /*0x3225d84*/ int AddTitlecaseLetter(ref System.Text.StringBuilder result, ref string input, int inputIndex, int charLen);
            /*0x3225fa0*/ bool get_IsRightToLeft();
            /*0x3225fb8*/ void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
            /*0x3225fbc*/ int GetCaseInsensitiveHashCode(string str);
            /*0x322444c*/ int GetCaseInsensitiveHashCode(string str, bool forceRandomizedHashing, long additionalEntropy);
            /*0x3225fc4*/ int GetInvariantCaseInsensitiveHashCode(string str);
            /*0x322587c*/ string ToUpperInternal(string str);
            /*0x322522c*/ string ToLowerInternal(string str);
            /*0x3225370*/ char ToUpperInternal(char c);
            /*0x3224d6c*/ char ToLowerInternal(char c);
            /*0x32260a8*/ void ToLowerAsciiInvariant(System.ReadOnlySpan<char> source, System.Span<char> destination);
            /*0x3226130*/ void ToUpperAsciiInvariant(System.ReadOnlySpan<char> source, System.Span<char> destination);
            /*0x32261b8*/ void ChangeCase(System.ReadOnlySpan<char> source, System.Span<char> destination, bool toUpper);
        }

        class ThaiBuddhistCalendar : System.Globalization.Calendar
        {
            static int ThaiBuddhistEra = 1;
            static int DEFAULT_TWO_DIGIT_YEAR_MAX = 2572;
            static /*0x0*/ System.Globalization.EraInfo[] thaiBuddhistEraInfo;
            /*0x20*/ System.Globalization.GregorianCalendarHelper helper;

            static /*0x3226860*/ ThaiBuddhistCalendar();
            /*0x32263f0*/ ThaiBuddhistCalendar();
            /*0x3226338*/ System.DateTime get_MinSupportedDateTime();
            /*0x3226390*/ System.DateTime get_MaxSupportedDateTime();
            /*0x32263e8*/ System.Globalization.CalendarAlgorithmType get_AlgorithmType();
            /*0x3226490*/ int get_ID();
            /*0x3226498*/ System.DateTime AddMonths(System.DateTime time, int months);
            /*0x32264ac*/ System.DateTime AddYears(System.DateTime time, int years);
            /*0x32264c8*/ int GetDaysInMonth(int year, int month, int era);
            /*0x32264dc*/ int GetDaysInYear(int year, int era);
            /*0x32264f0*/ int GetDayOfMonth(System.DateTime time);
            /*0x3226504*/ System.DayOfWeek GetDayOfWeek(System.DateTime time);
            /*0x3226518*/ int GetDayOfYear(System.DateTime time);
            /*0x322652c*/ int GetMonthsInYear(int year, int era);
            /*0x3226550*/ int GetWeekOfYear(System.DateTime time, System.Globalization.CalendarWeekRule rule, System.DayOfWeek firstDayOfWeek);
            /*0x322656c*/ int GetEra(System.DateTime time);
            /*0x3226580*/ int GetMonth(System.DateTime time);
            /*0x3226594*/ int GetYear(System.DateTime time);
            /*0x32265a8*/ bool IsLeapDay(int year, int month, int day, int era);
            /*0x32265bc*/ bool IsLeapYear(int year, int era);
            /*0x32265d0*/ int GetLeapMonth(int year, int era);
            /*0x32265f4*/ bool IsLeapMonth(int year, int month, int era);
            /*0x3226614*/ System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
            /*0x3226634*/ int[] get_Eras();
            /*0x3226648*/ int get_TwoDigitYearMax();
            /*0x3226684*/ void set_TwoDigitYearMax(int value);
            /*0x32267b8*/ int ToFourDigitYear(int year);
        }

        class UmAlQuraCalendar : System.Globalization.Calendar
        {
            static int MinCalendarYear = 1318;
            static int MaxCalendarYear = 1500;
            static int UmAlQuraEra = 1;
            static int DateCycle = 30;
            static int DatePartYear = 0;
            static int DatePartDayOfYear = 1;
            static int DatePartMonth = 2;
            static int DatePartDay = 3;
            static int DEFAULT_TWO_DIGIT_YEAR_MAX = 1451;
            static /*0x0*/ System.Globalization.UmAlQuraCalendar.DateMapping[] HijriYearInfo;
            static /*0x8*/ System.DateTime minDate;
            static /*0x10*/ System.DateTime maxDate;

            static /*0x3228604*/ UmAlQuraCalendar();
            static /*0x322696c*/ System.Globalization.UmAlQuraCalendar.DateMapping[] InitDateMapping();
            static /*0x3226bec*/ void ConvertHijriToGregorian(int HijriYear, int HijriMonth, int HijriDay, ref int yg, ref int mg, ref int dg);
            static /*0x3226d40*/ long GetAbsoluteDateUmAlQura(int year, int month, int day);
            static /*0x3226e04*/ void CheckTicksRange(long ticks);
            static /*0x3226fe4*/ void CheckEraRange(int era);
            static /*0x322705c*/ void CheckYearRange(int year, int era);
            static /*0x322719c*/ void CheckYearMonthRange(int year, int month, int era);
            static /*0x3227278*/ void ConvertGregorianToHijri(System.DateTime time, ref int HijriYear, ref int HijriMonth, ref int HijriDay);
            static /*0x3227bbc*/ int RealGetDaysInYear(int year);
            /*0x3226bcc*/ UmAlQuraCalendar();
            /*0x3226b14*/ System.DateTime get_MinSupportedDateTime();
            /*0x3226b6c*/ System.DateTime get_MaxSupportedDateTime();
            /*0x3226bc4*/ System.Globalization.CalendarAlgorithmType get_AlgorithmType();
            /*0x3226bd4*/ int get_BaseCalendarID();
            /*0x3226bdc*/ int get_ID();
            /*0x3226be4*/ int get_DaysInYearBeforeMinSupportedYear();
            /*0x3227564*/ int GetDatePart(System.DateTime time, int part);
            /*0x32276ec*/ System.DateTime AddMonths(System.DateTime time, int months);
            /*0x3227a20*/ System.DateTime AddYears(System.DateTime time, int years);
            /*0x3227a38*/ int GetDayOfMonth(System.DateTime time);
            /*0x3227a4c*/ System.DayOfWeek GetDayOfWeek(System.DateTime time);
            /*0x3227af4*/ int GetDayOfYear(System.DateTime time);
            /*0x3227b08*/ int GetDaysInMonth(int year, int month, int era);
            /*0x3227c5c*/ int GetDaysInYear(int year, int era);
            /*0x3227cc8*/ int GetEra(System.DateTime time);
            /*0x3227d5c*/ int[] get_Eras();
            /*0x3227dc0*/ int GetMonth(System.DateTime time);
            /*0x3227dd4*/ int GetMonthsInYear(int year, int era);
            /*0x3227e40*/ int GetYear(System.DateTime time);
            /*0x3227e54*/ bool IsLeapDay(int year, int month, int day, int era);
            /*0x3227fe0*/ int GetLeapMonth(int year, int era);
            /*0x322804c*/ bool IsLeapMonth(int year, int month, int era);
            /*0x32280c0*/ bool IsLeapYear(int year, int era);
            /*0x3228138*/ System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
            /*0x322837c*/ int get_TwoDigitYearMax();
            /*0x32283b8*/ void set_TwoDigitYearMax(int value);
            /*0x32284d0*/ int ToFourDigitYear(int year);

            struct DateMapping
            {
                /*0x10*/ int HijriMonthsLengthFlags;
                /*0x18*/ System.DateTime GregorianDate;

                /*0x3226ad4*/ DateMapping(int MonthsLengthFlags, int GYear, int GMonth, int GDay);
            }
        }

        class SortKey
        {
            /*0x10*/ string source;
            /*0x18*/ byte[] key;
            /*0x20*/ System.Globalization.CompareOptions options;
            /*0x24*/ int lcid;

            static /*0x3228728*/ int Compare(System.Globalization.SortKey sortkey1, System.Globalization.SortKey sortkey2);
            /*0x3228898*/ SortKey(int lcid, string source, System.Globalization.CompareOptions opt);
            /*0x3228988*/ SortKey(int lcid, string source, byte[] buffer, System.Globalization.CompareOptions opt, int lv1Length, int lv2Length, int lv3Length, int kanaSmallLength, int markTypeLength, int katakanaLength, int kanaWidthLength, int identLength);
            /*0x32289e8*/ SortKey(string localeName, string str, System.Globalization.CompareOptions options, byte[] keyData);
            /*0x3228ce8*/ SortKey();
            /*0x3228a28*/ string get_OriginalString();
            /*0x3228a30*/ byte[] get_KeyData();
            /*0x3228a38*/ bool Equals(object value);
            /*0x3228ae8*/ int GetHashCode();
            /*0x3228b50*/ string ToString();
        }

        interface ISimpleCollator
        {
            /*0x1f30300*/ System.Globalization.SortKey GetSortKey(string source, System.Globalization.CompareOptions options);
            int Compare(string s1, string s2);
            int Compare(string s1, int idx1, int len1, string s2, int idx2, int len2, System.Globalization.CompareOptions options);
            /*0x1f2ff40*/ bool IsPrefix(string src, string target, System.Globalization.CompareOptions opt);
            /*0x1f2ff40*/ bool IsSuffix(string src, string target, System.Globalization.CompareOptions opt);
            int IndexOf(string s, string target, int start, int length, System.Globalization.CompareOptions opt);
            int IndexOf(string s, char target, int start, int length, System.Globalization.CompareOptions opt);
            int LastIndexOf(string s, string target, System.Globalization.CompareOptions opt);
            int LastIndexOf(string s, string target, int start, int length, System.Globalization.CompareOptions opt);
            /*0x1ffc854*/ int LastIndexOf(string s, char target, System.Globalization.CompareOptions opt);
            int LastIndexOf(string s, char target, int start, int length, System.Globalization.CompareOptions opt);
        }

        class CultureData
        {
            static /*0x0*/ System.Globalization.CultureData s_Invariant;
            /*0x10*/ string sAM1159;
            /*0x18*/ string sPM2359;
            /*0x20*/ string sTimeSeparator;
            /*0x28*/ string[] saLongTimes;
            /*0x30*/ string[] saShortTimes;
            /*0x38*/ int iFirstDayOfWeek;
            /*0x3c*/ int iFirstWeekOfYear;
            /*0x40*/ int[] waCalendars;
            /*0x48*/ System.Globalization.CalendarData[] calendars;
            /*0x50*/ string sISO639Language;
            /*0x58*/ string sRealName;
            /*0x60*/ bool bUseOverrides;
            /*0x64*/ int calendarId;
            /*0x68*/ int numberIndex;
            /*0x6c*/ int iDefaultAnsiCodePage;
            /*0x70*/ int iDefaultOemCodePage;
            /*0x74*/ int iDefaultMacCodePage;
            /*0x78*/ int iDefaultEbcdicCodePage;
            /*0x7c*/ bool isRightToLeft;
            /*0x80*/ string sListSeparator;

            static /*0x3223e04*/ System.Globalization.CultureData get_Invariant();
            static /*0x3228d50*/ System.Globalization.CultureData GetCultureData(string cultureName, bool useUserOverride);
            static /*0x3228e38*/ System.Globalization.CultureData GetCultureData(string cultureName, bool useUserOverride, int datetimeIndex, int calendarId, int numberIndex, string iso2lang, int ansiCodePage, int oemCodePage, int macCodePage, int ebcdicCodePage, bool rightToLeft, string listSeparator);
            static /*0x3228f70*/ System.Globalization.CultureData GetCultureData(int culture, bool bUseUserOverride);
            static /*0x32296a0*/ string GetDateSeparator(string format);
            static /*0x32296e8*/ string GetSeparator(string format, string timeParts);
            static /*0x32297c8*/ int IndexOfTimePart(string format, int startIndex, string timeParts);
            static /*0x32298b4*/ string UnescapeNlsString(string str, int start, int end);
            static /*0x3229a58*/ string[] ReescapeWin32Strings(string[] array);
            static /*0x3229a5c*/ string ReescapeWin32String(string str);
            static /*0x3229a60*/ bool IsCustomCultureId(int cultureId);
            static /*0x3229a68*/ int strlen(byte* s);
            static /*0x3229a80*/ string idx2string(byte* data, int idx);
            static /*0x3229b78*/ byte* fill_number_data(int index, ref System.Globalization.CultureData.NumberFormatEntryManaged nfe);
            /*0x3228d20*/ CultureData(string name);
            /*0x3228f6c*/ void fill_culture_data(int datetimeIndex);
            /*0x3228f78*/ System.Globalization.CalendarData GetCalendar(int calendarId);
            /*0x32290ac*/ string[] get_LongTimes();
            /*0x32290c4*/ string[] get_ShortTimes();
            /*0x32290dc*/ string get_SISO639LANGNAME();
            /*0x32290e4*/ int get_IFIRSTDAYOFWEEK();
            /*0x32290ec*/ int get_IFIRSTWEEKOFYEAR();
            /*0x32290f4*/ string get_SAM1159();
            /*0x32290fc*/ string get_SPM2359();
            /*0x3229104*/ string get_TimeSeparator();
            /*0x322910c*/ int[] get_CalendarIds();
            /*0x32292d4*/ System.Globalization.CalendarId[] GetCalendarIds();
            /*0x32203dc*/ bool get_IsInvariantCulture();
            /*0x32293a4*/ string get_CultureName();
            /*0x32293ac*/ string get_SCOMPAREINFO();
            /*0x32293ec*/ string get_STEXTINFO();
            /*0x32293f4*/ int get_ILANGUAGE();
            /*0x32293fc*/ int get_IDEFAULTANSICODEPAGE();
            /*0x3229404*/ int get_IDEFAULTOEMCODEPAGE();
            /*0x322940c*/ int get_IDEFAULTMACCODEPAGE();
            /*0x3229414*/ int get_IDEFAULTEBCDICCODEPAGE();
            /*0x322941c*/ bool get_IsRightToLeft();
            /*0x3229424*/ string get_SLIST();
            /*0x322942c*/ bool get_UseUserOverride();
            /*0x3229434*/ string CalendarName(int calendarId);
            /*0x3229450*/ string[] EraNames(int calendarId);
            /*0x322946c*/ string[] AbbrevEraNames(int calendarId);
            /*0x3229488*/ string[] AbbreviatedEnglishEraNames(int calendarId);
            /*0x32294a4*/ string[] ShortDates(int calendarId);
            /*0x32294c0*/ string[] LongDates(int calendarId);
            /*0x32294dc*/ string[] YearMonths(int calendarId);
            /*0x32294f8*/ string[] DayNames(int calendarId);
            /*0x3229514*/ string[] AbbreviatedDayNames(int calendarId);
            /*0x3229530*/ string[] SuperShortDayNames(int calendarId);
            /*0x322954c*/ string[] MonthNames(int calendarId);
            /*0x3229568*/ string[] GenitiveMonthNames(int calendarId);
            /*0x3229584*/ string[] AbbreviatedMonthNames(int calendarId);
            /*0x32295a0*/ string[] AbbreviatedGenitiveMonthNames(int calendarId);
            /*0x32295bc*/ string[] LeapYearMonthNames(int calendarId);
            /*0x32295d8*/ string MonthDay(int calendarId);
            /*0x32295f4*/ string DateSeparator(int calendarId);
            /*0x3229ac4*/ int[] create_group_sizes_array(int gs0, int gs1);
            /*0x3220188*/ void GetNFIValues(System.Globalization.NumberFormatInfo nfi);

            struct NumberFormatEntryManaged
            {
                /*0x10*/ int currency_decimal_digits;
                /*0x14*/ int currency_decimal_separator;
                /*0x18*/ int currency_group_separator;
                /*0x1c*/ int currency_group_sizes0;
                /*0x20*/ int currency_group_sizes1;
                /*0x24*/ int currency_negative_pattern;
                /*0x28*/ int currency_positive_pattern;
                /*0x2c*/ int currency_symbol;
                /*0x30*/ int nan_symbol;
                /*0x34*/ int negative_infinity_symbol;
                /*0x38*/ int negative_sign;
                /*0x3c*/ int number_decimal_digits;
                /*0x40*/ int number_decimal_separator;
                /*0x44*/ int number_group_separator;
                /*0x48*/ int number_group_sizes0;
                /*0x4c*/ int number_group_sizes1;
                /*0x50*/ int number_negative_pattern;
                /*0x54*/ int per_mille_symbol;
                /*0x58*/ int percent_negative_pattern;
                /*0x5c*/ int percent_positive_pattern;
                /*0x60*/ int percent_symbol;
                /*0x64*/ int positive_infinity_symbol;
                /*0x68*/ int positive_sign;
            }
        }

        class CodePageDataItem
        {
            static /*0x0*/ char[] sep;
            /*0x10*/ int m_dataIndex;
            /*0x14*/ int m_uiFamilyCodePage;
            /*0x18*/ string m_webName;
            /*0x20*/ string m_headerName;
            /*0x28*/ string m_bodyName;
            /*0x30*/ uint m_flags;

            static /*0x3229f54*/ CodePageDataItem();
            static /*0x3229c20*/ string CreateString(string pStrings, uint index);
            /*0x3229b7c*/ CodePageDataItem(int dataIndex);
            /*0x3229cd4*/ string get_WebName();
            /*0x3229da4*/ int get_UIFamilyCodePage();
            /*0x3229dac*/ string get_HeaderName();
            /*0x3229e7c*/ string get_BodyName();
            /*0x3229f4c*/ uint get_Flags();
        }

        class EncodingTable
        {
            static int MIMECONTF_MAILNEWS = 1;
            static int MIMECONTF_BROWSER = 2;
            static int MIMECONTF_MINIMAL = 4;
            static int MIMECONTF_IMPORT = 8;
            static int MIMECONTF_SAVABLE_MAILNEWS = 256;
            static int MIMECONTF_SAVABLE_BROWSER = 512;
            static int MIMECONTF_EXPORT = 1024;
            static int MIMECONTF_PRIVCONVERTER = 65536;
            static int MIMECONTF_VALID = 131072;
            static int MIMECONTF_VALID_NLS = 262144;
            static int MIMECONTF_MIME_IE4 = 268435456;
            static int MIMECONTF_MIME_LATEST = 536870912;
            static int MIMECONTF_MIME_REGISTRY = 1073741824;
            static /*0x0*/ System.Globalization.InternalEncodingDataItem[] encodingDataPtr;
            static /*0x8*/ System.Globalization.InternalCodePageDataItem[] codePageDataPtr;
            static /*0x10*/ int lastEncodingItem;
            static /*0x14*/ int lastCodePageItem;
            static /*0x18*/ System.Collections.Generic.Dictionary<string, int> hashByName;
            static /*0x20*/ System.Collections.Generic.Dictionary<int, System.Globalization.CodePageDataItem> hashByCodePage;

            static /*0x322a0b0*/ EncodingTable();
            static /*0x3229fe4*/ int GetNumEncodingItems();
            static /*0x322a048*/ System.Globalization.InternalEncodingDataItem ENC(string name, ushort cp);
            static /*0x322a078*/ System.Globalization.InternalCodePageDataItem MapCodePageDataItem(ushort cp, ushort fcp, string names, uint flags);
            static /*0x3233760*/ int internalGetCodePageFromName(string name);
            static /*0x32339bc*/ System.Text.EncodingInfo[] GetEncodings();
            static /*0x3233c50*/ int GetCodePageFromName(string name);
            static /*0x3233edc*/ System.Globalization.CodePageDataItem GetCodePageDataItem(int codepage);
        }

        struct InternalEncodingDataItem
        {
            /*0x10*/ string webName;
            /*0x18*/ ushort codePage;
        }

        struct InternalCodePageDataItem
        {
            /*0x10*/ ushort codePage;
            /*0x12*/ ushort uiFamilyCodePage;
            /*0x14*/ uint flags;
            /*0x18*/ string Names;
        }

        class TextInfoToUpperData
        {
            static /*0x0*/ char[] range_00e0_0586;
            static /*0x8*/ char[] range_1e01_1ff3;
            static /*0x10*/ char[] range_2170_2184;
            static /*0x18*/ char[] range_24d0_24e9;
            static /*0x20*/ char[] range_2c30_2ce3;
            static /*0x28*/ char[] range_2d00_2d25;
            static /*0x30*/ char[] range_a641_a697;
            static /*0x38*/ char[] range_a723_a78c;

            static /*0x3234190*/ TextInfoToUpperData();
        }

        class TextInfoToLowerData
        {
            static /*0x0*/ char[] range_00c0_0556;
            static /*0x8*/ char[] range_10a0_10c5;
            static /*0x10*/ char[] range_1e00_1ffc;
            static /*0x18*/ char[] range_2160_216f;
            static /*0x20*/ char[] range_24b6_24cf;
            static /*0x28*/ char[] range_2c00_2c2e;
            static /*0x30*/ char[] range_2c60_2ce2;
            static /*0x38*/ char[] range_a640_a696;
            static /*0x40*/ char[] range_a722_a78b;

            static /*0x3234424*/ TextInfoToLowerData();
        }

        class CultureInfo : System.ICloneable, System.IFormatProvider
        {
            static int InvariantCultureId = 127;
            static int CalendarTypeBits = 8;
            static int LOCALE_INVARIANT = 127;
            static string MSG_READONLY = "This instance is read only";
            static /*0x0*/ System.Globalization.CultureInfo invariant_culture_info;
            static /*0x8*/ object shared_table_lock;
            static /*0x10*/ System.Globalization.CultureInfo default_current_culture;
            static /*0x18*/ System.Globalization.CultureInfo s_DefaultThreadCurrentUICulture;
            static /*0x20*/ System.Globalization.CultureInfo s_DefaultThreadCurrentCulture;
            static /*0x28*/ System.Collections.Generic.Dictionary<int, System.Globalization.CultureInfo> shared_by_number;
            static /*0x30*/ System.Collections.Generic.Dictionary<string, System.Globalization.CultureInfo> shared_by_name;
            static /*0x38*/ System.Globalization.CultureInfo s_UserPreferredCultureInfoInAppX;
            static /*0x40*/ bool IsTaiwanSku;
            /*0x10*/ bool m_isReadOnly;
            /*0x14*/ int cultureID;
            /*0x18*/ int parent_lcid;
            /*0x1c*/ int datetime_index;
            /*0x20*/ int number_index;
            /*0x24*/ int default_calendar_type;
            /*0x28*/ bool m_useUserOverride;
            /*0x30*/ System.Globalization.NumberFormatInfo numInfo;
            /*0x38*/ System.Globalization.DateTimeFormatInfo dateTimeInfo;
            /*0x40*/ System.Globalization.TextInfo textInfo;
            /*0x48*/ string m_name;
            /*0x50*/ string englishname;
            /*0x58*/ string nativename;
            /*0x60*/ string iso3lang;
            /*0x68*/ string iso2lang;
            /*0x70*/ string win3lang;
            /*0x78*/ string territory;
            /*0x80*/ string[] native_calendar_names;
            /*0x88*/ System.Globalization.CompareInfo compareInfo;
            /*0x90*/ void* textinfo_data;
            /*0x98*/ int m_dataItem;
            /*0xa0*/ System.Globalization.Calendar calendar;
            /*0xa8*/ System.Globalization.CultureInfo parent_culture;
            /*0xb0*/ bool constructed;
            /*0xb8*/ byte[] cached_serialized_form;
            /*0xc0*/ System.Globalization.CultureData m_cultureData;
            /*0xc8*/ bool m_isInherited;

            static /*0x323b3f8*/ CultureInfo();
            static /*0x32347ac*/ System.Globalization.CultureInfo get_InvariantCulture();
            static /*0x323399c*/ System.Globalization.CultureInfo get_CurrentCulture();
            static /*0x323480c*/ void set_CurrentCulture(System.Globalization.CultureInfo value);
            static /*0x3234834*/ System.Globalization.CultureInfo get_CurrentUICulture();
            static /*0x3234854*/ void set_CurrentUICulture(System.Globalization.CultureInfo value);
            static /*0x323487c*/ System.Globalization.CultureInfo ConstructCurrentCulture();
            static /*0x3234cb4*/ System.Globalization.CultureInfo ConstructCurrentUICulture();
            static /*0x3235078*/ System.Globalization.CultureInfo[] GetCultures(System.Globalization.CultureTypes types);
            static /*0x3236d3c*/ System.Globalization.CultureInfo ReadOnly(System.Globalization.CultureInfo ci);
            static /*0x32374a4*/ System.Globalization.CultureInfo get_InstalledUICulture();
            static /*0x3234a68*/ string get_current_locale_name();
            static /*0x3236ca4*/ System.Globalization.CultureInfo[] internal_get_cultures(bool neutral, bool specific, bool installed);
            static /*0x3237e60*/ void insert_into_shared_tables(System.Globalization.CultureInfo c);
            static /*0x3238000*/ System.Globalization.CultureInfo GetCultureInfo(int culture);
            static /*0x3235c5c*/ System.Globalization.CultureInfo GetCultureInfo(string name);
            static /*0x3238220*/ System.Globalization.CultureInfo GetCultureInfo(string name, string altName);
            static /*0x32382c8*/ System.Globalization.CultureInfo GetCultureInfoByIetfLanguageTag(string name);
            static /*0x32383c0*/ System.Globalization.CultureInfo CreateCulture(string name, bool reference);
            static /*0x3234a6c*/ System.Globalization.CultureInfo CreateSpecificCulture(string name);
            static /*0x3238434*/ System.Globalization.CultureInfo CreateSpecificCultureFromNeutral(string name);
            static /*0x323612c*/ System.Globalization.Calendar CreateCalendar(int calendarType);
            static /*0x3237d78*/ System.Exception CreateNotFoundException(string name);
            static /*0x323abe4*/ System.Globalization.CultureInfo get_DefaultThreadCurrentCulture();
            static /*0x323ac44*/ void set_DefaultThreadCurrentCulture(System.Globalization.CultureInfo value);
            static /*0x323aca8*/ System.Globalization.CultureInfo get_DefaultThreadCurrentUICulture();
            static /*0x323ad08*/ void set_DefaultThreadCurrentUICulture(System.Globalization.CultureInfo value);
            static /*0x323ad74*/ System.Globalization.CultureInfo get_UserDefaultUICulture();
            static /*0x323adc0*/ System.Globalization.CultureInfo get_UserDefaultCulture();
            static /*0x323ae0c*/ void InitializeUserPreferredCultureInfoInAppX(System.Globalization.CultureInfo.OnCultureInfoChangedDelegate onCultureInfoChangedInAppX);
            static /*0x323ae1c*/ void SetUserPreferredCultureInfoInAppX(string name);
            static /*0x32346fc*/ void OnCultureInfoChangedInAppX(string language);
            static /*0x323ae2c*/ System.Globalization.CultureInfo GetCultureInfoForUserPreferredLanguageInAppX();
            static /*0x323af04*/ void SetCultureInfoForUserPreferredLanguageInAppX(System.Globalization.CultureInfo cultureInfo);
            static /*0x323b014*/ void CheckDomainSafetyObject(object obj, object container);
            static /*0x323b21c*/ bool VerifyCultureName(string cultureName, bool throwException);
            static /*0x323b364*/ bool VerifyCultureName(System.Globalization.CultureInfo culture, bool throwException);
            /*0x3236680*/ CultureInfo(int culture);
            /*0x32377c0*/ CultureInfo(int culture, bool useUserOverride);
            /*0x32377c8*/ CultureInfo(int culture, bool useUserOverride, bool read_only);
            /*0x3236674*/ CultureInfo(string name);
            /*0x3237a74*/ CultureInfo(string name, bool useUserOverride);
            /*0x3237a7c*/ CultureInfo(string name, bool useUserOverride, bool read_only);
            /*0x3237e40*/ CultureInfo();
            /*0x323479c*/ System.Globalization.CultureData get__cultureData();
            /*0x32347a4*/ bool get__isInherited();
            /*0x3234d00*/ string get_Territory();
            /*0x3234d08*/ string get__name();
            /*0x3234d10*/ System.Globalization.CultureTypes get_CultureTypes();
            /*0x32352e4*/ System.Globalization.CultureInfo GetConsoleFallbackUICulture();
            /*0x3235e60*/ string get_IetfLanguageTag();
            /*0x3235f34*/ int get_KeyboardLayoutId();
            /*0x3235fd8*/ int get_LCID();
            /*0x3235fe0*/ string get_Name();
            /*0x3235fe8*/ string get_NativeName();
            /*0x3236038*/ string get_NativeCalendarName();
            /*0x3236094*/ System.Globalization.Calendar get_Calendar();
            /*0x3236350*/ System.Globalization.Calendar[] get_OptionalCalendars();
            /*0x3236400*/ System.Globalization.CultureInfo get_Parent();
            /*0x323668c*/ System.Globalization.TextInfo get_TextInfo();
            /*0x3236834*/ string get_ThreeLetterISOLanguageName();
            /*0x3236864*/ string get_ThreeLetterWindowsLanguageName();
            /*0x3236894*/ string get_TwoLetterISOLanguageName();
            /*0x32368c4*/ bool get_UseUserOverride();
            /*0x32368cc*/ void ClearCachedData();
            /*0x3236a5c*/ object Clone();
            /*0x3236c04*/ bool Equals(object value);
            /*0x3236ca8*/ System.Globalization.CultureInfo.Data GetTextInfoData();
            /*0x3236d30*/ int GetHashCode();
            /*0x3236f08*/ string ToString();
            /*0x3236f10*/ System.Globalization.CompareInfo get_CompareInfo();
            /*0x323706c*/ bool get_IsNeutralCulture();
            /*0x32370b4*/ void CheckNeutral();
            /*0x32370b8*/ System.Globalization.NumberFormatInfo get_NumberFormat();
            /*0x323715c*/ void set_NumberFormat(System.Globalization.NumberFormatInfo value);
            /*0x323722c*/ System.Globalization.DateTimeFormatInfo get_DateTimeFormat();
            /*0x3237394*/ void set_DateTimeFormat(System.Globalization.DateTimeFormatInfo value);
            /*0x3237464*/ string get_DisplayName();
            /*0x3237474*/ string get_EnglishName();
            /*0x32374f0*/ bool get_IsReadOnly();
            /*0x32374f8*/ object GetFormat(System.Type formatType);
            /*0x3236018*/ void Construct();
            /*0x3237604*/ bool construct_internal_locale_from_lcid(int lcid);
            /*0x3237608*/ bool construct_internal_locale_from_name(string name);
            /*0x323760c*/ void ConstructInvariant(bool read_only);
            /*0x32367b8*/ System.Globalization.TextInfo CreateTextInfo(bool readOnly);
            /*0x3237cd8*/ bool ConstructLocaleFromName(string name);
            /*0x3236cc0*/ int get_CalendarType();
            /*0x323ad6c*/ string get_SortName();
            /*0x323b190*/ bool get_HasInvariantCultureName();

            struct Data
            {
                /*0x10*/ int ansi;
                /*0x14*/ int ebcdic;
                /*0x18*/ int mac;
                /*0x1c*/ int oem;
                /*0x20*/ bool right_to_left;
                /*0x21*/ byte list_sep;
            }

            class OnCultureInfoChangedDelegate : System.MulticastDelegate
            {
                /*0x323b4a8*/ OnCultureInfoChangedDelegate(object object, nint method);
                /*0x323b558*/ void Invoke(string language);
                /*0x323b56c*/ System.IAsyncResult BeginInvoke(string language, System.AsyncCallback callback, object object);
                /*0x323b58c*/ void EndInvoke(System.IAsyncResult result);
            }
        }

        class IdnMapping
        {
            /*0x10*/ bool allow_unassigned;
            /*0x11*/ bool use_std3;
            /*0x18*/ System.Globalization.Punycode puny;

            /*0x323b598*/ IdnMapping();
            /*0x323b66c*/ bool get_AllowUnassigned();
            /*0x323b674*/ void set_AllowUnassigned(bool value);
            /*0x323b67c*/ bool get_UseStd3AsciiRules();
            /*0x323b684*/ void set_UseStd3AsciiRules(bool value);
            /*0x323b68c*/ bool Equals(object obj);
            /*0x323b70c*/ int GetHashCode();
            /*0x323b71c*/ string GetAscii(string unicode);
            /*0x323b840*/ string GetAscii(string unicode, int index);
            /*0x323b778*/ string GetAscii(string unicode, int index, int count);
            /*0x323b89c*/ string Convert(string input, int index, int count, bool toAscii);
            /*0x323bab4*/ string ToAscii(string s, int offset);
            /*0x323c4e8*/ void VerifyLength(string s, int offset);
            /*0x323beb8*/ string NamePrep(string s, int offset);
            /*0x323c5ac*/ void VerifyProhibitedCharacters(string s, int offset);
            /*0x323bfd0*/ void VerifyStd3AsciiRules(string s, int offset);
            /*0x323c79c*/ string GetUnicode(string ascii);
            /*0x323c8c0*/ string GetUnicode(string ascii, int index);
            /*0x323c7f8*/ string GetUnicode(string ascii, int index, int count);
            /*0x323bce8*/ string ToUnicode(string s, int offset);
        }

        class Bootstring
        {
            /*0x10*/ char delimiter;
            /*0x14*/ int base_num;
            /*0x18*/ int tmin;
            /*0x1c*/ int tmax;
            /*0x20*/ int skew;
            /*0x24*/ int damp;
            /*0x28*/ int initial_bias;
            /*0x2c*/ int initial_n;

            /*0x323cbf4*/ Bootstring(char delimiter, int baseNum, int tmin, int tmax, int skew, int damp, int initialBias, int initialN);
            /*0x323c1a0*/ string Encode(string s, int offset);
            /*0x323cc60*/ char EncodeDigit(int d);
            /*0x323ccec*/ int DecodeDigit(char c);
            /*0x323cc78*/ int Adapt(int delta, int numPoints, bool firstTime);
            /*0x323c91c*/ string Decode(string s, int offset);
        }

        class Punycode : System.Globalization.Bootstring
        {
            /*0x323b62c*/ Punycode();
        }

        class RegionInfo
        {
            static /*0x0*/ System.Globalization.RegionInfo currentRegion;
            /*0x10*/ int regionId;
            /*0x18*/ string iso2Name;
            /*0x20*/ string iso3Name;
            /*0x28*/ string win3Name;
            /*0x30*/ string englishName;
            /*0x38*/ string nativeName;
            /*0x40*/ string currencySymbol;
            /*0x48*/ string isoCurrencySymbol;
            /*0x50*/ string currencyEnglishName;
            /*0x58*/ string currencyNativeName;

            static /*0x323cd2c*/ System.Globalization.RegionInfo get_CurrentRegion();
            static /*0x323d4b0*/ void ClearCachedData();
            /*0x323cfe0*/ RegionInfo(int culture);
            /*0x323d190*/ RegionInfo(string name);
            /*0x323cdf0*/ RegionInfo(System.Globalization.CultureInfo ci);
            /*0x323d0e8*/ bool GetByTerritory(System.Globalization.CultureInfo ci);
            /*0x323d2c8*/ bool construct_internal_region_from_name(string name);
            /*0x323d2cc*/ string get_CurrencyEnglishName();
            /*0x323d2d4*/ string get_CurrencySymbol();
            /*0x323d2dc*/ string get_DisplayName();
            /*0x323d2e4*/ string get_EnglishName();
            /*0x323d2ec*/ int get_GeoId();
            /*0x323d2f4*/ bool get_IsMetric();
            /*0x323d380*/ string get_ISOCurrencySymbol();
            /*0x323d388*/ string get_NativeName();
            /*0x323d390*/ string get_CurrencyNativeName();
            /*0x323d398*/ string get_Name();
            /*0x323d3a0*/ string get_ThreeLetterISORegionName();
            /*0x323d3a8*/ string get_ThreeLetterWindowsRegionName();
            /*0x323d3b0*/ string get_TwoLetterISORegionName();
            /*0x323d3b8*/ bool Equals(object value);
            /*0x323d474*/ int GetHashCode();
            /*0x323d4a0*/ string ToString();
        }
    }

    namespace Diagnostics
    {
        class ConditionalAttribute : System.Attribute
        {
            /*0x10*/ string <ConditionString>k__BackingField;

            /*0x323d504*/ ConditionalAttribute(string conditionString);
        }

        class StackTraceHiddenAttribute : System.Attribute
        {
            /*0x323d534*/ StackTraceHiddenAttribute();
        }

        class DebuggerStepThroughAttribute : System.Attribute
        {
            /*0x323d53c*/ DebuggerStepThroughAttribute();
        }

        class DebuggerHiddenAttribute : System.Attribute
        {
            /*0x323d544*/ DebuggerHiddenAttribute();
        }

        class DebuggerNonUserCodeAttribute : System.Attribute
        {
            /*0x323d54c*/ DebuggerNonUserCodeAttribute();
        }

        class DebuggableAttribute : System.Attribute
        {
            /*0x10*/ System.Diagnostics.DebuggableAttribute.DebuggingModes m_debuggingModes;

            /*0x323d554*/ DebuggableAttribute(System.Diagnostics.DebuggableAttribute.DebuggingModes modes);

            enum DebuggingModes
            {
                None = 0,
                Default = 1,
                DisableOptimizations = 256,
                IgnoreSymbolStoreSequencePoints = 2,
                EnableEditAndContinue = 4,
            }
        }

        enum DebuggerBrowsableState
        {
            Never = 0,
            Collapsed = 2,
            RootHidden = 3,
        }

        class DebuggerBrowsableAttribute : System.Attribute
        {
            /*0x10*/ System.Diagnostics.DebuggerBrowsableState state;

            /*0x323d57c*/ DebuggerBrowsableAttribute(System.Diagnostics.DebuggerBrowsableState state);
        }

        class DebuggerTypeProxyAttribute : System.Attribute
        {
            /*0x10*/ string typeName;

            /*0x323d5f4*/ DebuggerTypeProxyAttribute(System.Type type);
        }

        class DebuggerDisplayAttribute : System.Attribute
        {
            /*0x10*/ string name;
            /*0x18*/ string value;
            /*0x20*/ string type;

            /*0x323d6b4*/ DebuggerDisplayAttribute(string value);
            /*0x323d744*/ void set_Name(string value);
            /*0x323d74c*/ void set_Type(string value);
        }

        class Debugger
        {
            static /*0x0*/ string DefaultCategory;

            static /*0x323d758*/ Debugger();
            static /*0x323d754*/ void NotifyOfCrossThreadDependency();
        }

        class StackFrame
        {
            static int OFFSET_UNKNOWN = -1;
            /*0x10*/ int ilOffset;
            /*0x14*/ int nativeOffset;
            /*0x18*/ long methodAddress;
            /*0x20*/ uint methodIndex;
            /*0x28*/ System.Reflection.MethodBase methodBase;
            /*0x30*/ string fileName;
            /*0x38*/ int lineNumber;
            /*0x3c*/ int columnNumber;
            /*0x40*/ string internalMethodName;

            static /*0x323d7c0*/ bool get_frame_info(int skip, bool needFileInfo, ref System.Reflection.MethodBase method, ref int iloffset, ref int native_offset, ref string file, ref int line, ref int column);
            /*0x323d7c4*/ StackFrame();
            /*0x323d810*/ StackFrame(int skipFrames, bool fNeedFileInfo);
            /*0x323d86c*/ int GetFileLineNumber();
            /*0x323d874*/ string GetFileName();
            /*0x323d87c*/ string GetSecureFileName();
            /*0x323d950*/ int GetILOffset();
            /*0x323d958*/ System.Reflection.MethodBase GetMethod();
            /*0x323d960*/ int GetNativeOffset();
            /*0x323d968*/ long GetMethodAddress();
            /*0x323d970*/ uint GetMethodIndex();
            /*0x323d978*/ string GetInternalMethodName();
            /*0x323d980*/ string ToString();
        }

        class StackTrace
        {
            static /*0x0*/ bool isAotidSet;
            static /*0x8*/ string aotid;
            /*0x10*/ System.Diagnostics.StackFrame[] frames;
            /*0x18*/ System.Diagnostics.StackTrace[] captured_traces;
            /*0x20*/ bool debug_info;

            static /*0x323de04*/ System.Diagnostics.StackFrame[] get_trace(System.Exception e, int skipFrames, bool fNeedFileInfo);
            static /*0x323df84*/ string GetAotId();
            static /*0x323eafc*/ void ConvertAsyncStateMachineMethod(ref System.Reflection.MethodBase method, ref System.Type declaringType);
            /*0x323dbb4*/ StackTrace();
            /*0x323dda0*/ StackTrace(bool fNeedFileInfo);
            /*0x323ddd0*/ StackTrace(int skipFrames, bool fNeedFileInfo);
            /*0x323de08*/ StackTrace(System.Exception e, bool fNeedFileInfo);
            /*0x323de14*/ StackTrace(System.Exception e, int skipFrames, bool fNeedFileInfo);
            /*0x323dbd8*/ void init_frames(int skipFrames, bool fNeedFileInfo);
            /*0x323df0c*/ int get_FrameCount();
            /*0x323df24*/ System.Diagnostics.StackFrame GetFrame(int index);
            /*0x323e054*/ bool AddFrames(System.Text.StringBuilder sb, bool separator, ref bool isAsync);
            /*0x323e4d4*/ void GetFullNameForStackTrace(System.Text.StringBuilder sb, System.Reflection.MethodBase mi, bool needsNewLine, ref bool skipped, ref bool isAsync);
            /*0x323ef2c*/ string ToString();
            /*0x323f08c*/ string ToString(System.Diagnostics.StackTrace.TraceFormat traceFormat);

            enum TraceFormat
            {
                Normal = 0,
                TrailingNewLine = 1,
                NoResourceLookup = 2,
            }
        }

        namespace Contracts
        {
            class Contract
            {
                static /*0x1f318fc*/ bool ForAll<T>(System.Collections.Generic.IEnumerable<T> collection, System.Predicate<T> predicate);
            }
        }

        namespace Tracing
        {
            enum EventLevel
            {
                LogAlways = 0,
                Critical = 1,
                Error = 2,
                Warning = 3,
                Informational = 4,
                Verbose = 5,
            }

            enum EventKeywords
            {
                None = 0,
                All = -1,
                MicrosoftTelemetry = 562949953421312,
                WdiContext = 562949953421312,
                WdiDiagnostic = 1125899906842624,
                Sqm = 2251799813685248,
                AuditFailure = 4503599627370496,
                AuditSuccess = 9007199254740992,
                CorrelationHint = 4503599627370496,
                EventLogClassic = 36028797018963968,
            }

            class EventAttribute : System.Attribute
            {
                /*0x10*/ int <EventId>k__BackingField;
                /*0x14*/ System.Diagnostics.Tracing.EventLevel <Level>k__BackingField;
                /*0x18*/ System.Diagnostics.Tracing.EventKeywords <Keywords>k__BackingField;
                /*0x20*/ string <Message>k__BackingField;

                /*0x323f098*/ EventAttribute(int eventId);
                /*0x323f0c0*/ void set_EventId(int value);
                /*0x323f0c8*/ void set_Level(System.Diagnostics.Tracing.EventLevel value);
                /*0x323f0d0*/ void set_Keywords(System.Diagnostics.Tracing.EventKeywords value);
                /*0x323f0d8*/ void set_Message(string value);
            }

            class EventSource : System.IDisposable
            {
                /*0x10*/ string <Name>k__BackingField;

                /*0x323f0e0*/ EventSource();
                /*0x323f124*/ EventSource(string eventSourceName);
                /*0x323f154*/ EventSource(System.Guid eventSourceGuid, string eventSourceName);
                /*0x323f184*/ void Finalize();
                /*0x323f214*/ void set_Name(string value);
                /*0x323f21c*/ bool IsEnabled();
                /*0x323f224*/ bool IsEnabled(System.Diagnostics.Tracing.EventLevel level, System.Diagnostics.Tracing.EventKeywords keywords);
                /*0x323f22c*/ void Dispose();
                /*0x323f298*/ void Dispose(bool disposing);
                /*0x323f29c*/ void WriteEvent(int eventId);
                /*0x323f2e4*/ void WriteEvent(int eventId, int arg1);
                /*0x323f3a0*/ void WriteEvent(int eventId, string arg1);
                /*0x323f434*/ void WriteEvent(int eventId, int arg1, int arg2);
                /*0x323f53c*/ void WriteEvent(int eventId, int arg1, int arg2, int arg3);
                /*0x323f698*/ void WriteEvent(int eventId, long arg1);
                /*0x323f754*/ void WriteEvent(int eventId, long arg1, string arg2);
                /*0x323f2e0*/ void WriteEvent(int eventId, object[] args);
                /*0x323f848*/ void WriteEvent(int eventId, string arg1, string arg2, string arg3);
                /*0x323f954*/ void WriteEventCore(int eventId, int eventDataCount, System.Diagnostics.Tracing.EventSource.EventData* data);

                struct EventData
                {
                    /*0x10*/ nint <DataPointer>k__BackingField;
                    /*0x18*/ int <Size>k__BackingField;
                    /*0x1c*/ int <Reserved>k__BackingField;

                    /*0x323f958*/ void set_DataPointer(nint value);
                    /*0x323f960*/ void set_Size(int value);
                    /*0x323f968*/ void set_Reserved(int value);
                }
            }

            class EventSourceAttribute : System.Attribute
            {
                /*0x10*/ string <Guid>k__BackingField;
                /*0x18*/ string <Name>k__BackingField;

                /*0x323f980*/ EventSourceAttribute();
                /*0x323f970*/ void set_Guid(string value);
                /*0x323f978*/ void set_Name(string value);
            }

            class NonEventAttribute : System.Attribute
            {
                /*0x323f988*/ NonEventAttribute();
            }
        }

        namespace CodeAnalysis
        {
            class DisallowNullAttribute : System.Attribute
            {
                /*0x323f990*/ DisallowNullAttribute();
            }

            class NotNullAttribute : System.Attribute
            {
                /*0x323f998*/ NotNullAttribute();
            }

            class MaybeNullWhenAttribute : System.Attribute
            {
                /*0x10*/ bool <ReturnValue>k__BackingField;

                /*0x323f9a0*/ MaybeNullWhenAttribute(bool returnValue);
            }

            class NotNullWhenAttribute : System.Attribute
            {
                /*0x10*/ bool <ReturnValue>k__BackingField;

                /*0x323f9c8*/ NotNullWhenAttribute(bool returnValue);
            }

            class DoesNotReturnAttribute : System.Attribute
            {
                /*0x323f9f0*/ DoesNotReturnAttribute();
            }
        }
    }

    namespace Configuration
    {
        namespace Assemblies
        {
            enum AssemblyHashAlgorithm
            {
                None = 0,
                MD5 = 32771,
                SHA1 = 32772,
                SHA256 = 32780,
                SHA384 = 32781,
                SHA512 = 32782,
            }

            enum AssemblyVersionCompatibility
            {
                SameMachine = 1,
                SameProcess = 2,
                SameDomain = 3,
            }
        }
    }

    namespace Collections
    {
        class Comparer : System.Collections.IComparer, System.Runtime.Serialization.ISerializable
        {
            static /*0x0*/ System.Collections.Comparer Default;
            static /*0x8*/ System.Collections.Comparer DefaultInvariant;
            /*0x10*/ System.Globalization.CompareInfo _compareInfo;

            static /*0x323fe9c*/ Comparer();
            /*0x323f9f8*/ Comparer(System.Globalization.CultureInfo culture);
            /*0x323fa88*/ Comparer(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x323fc00*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x323fca0*/ int Compare(object a, object b);
        }

        struct DictionaryEntry
        {
            /*0x10*/ object _key;
            /*0x18*/ object _value;

            /*0x323ff70*/ DictionaryEntry(object key, object value);
            /*0x323ffa0*/ object get_Key();
            /*0x323ffa8*/ object get_Value();
        }

        class HashHelpers
        {
            static /*0x0*/ int[] primes;
            static /*0x8*/ System.Runtime.CompilerServices.ConditionalWeakTable<object, System.Runtime.Serialization.SerializationInfo> s_serializationInfoTable;

            static /*0x3240334*/ HashHelpers();
            static /*0x323ffb0*/ bool IsPrime(int candidate);
            static /*0x3240054*/ int GetPrime(int min);
            static /*0x32401d8*/ int ExpandPrime(int oldSize);
            static /*0x324025c*/ System.Runtime.CompilerServices.ConditionalWeakTable<object, System.Runtime.Serialization.SerializationInfo> get_SerializationInfoTable();
        }

        interface ICollection : System.Collections.IEnumerable
        {
            /*0x1f30ee8*/ void CopyTo(System.Array array, int index);
            /*0x1f2ffc8*/ int get_Count();
            /*0x1f30214*/ object get_SyncRoot();
            /*0x1f2fe14*/ bool get_IsSynchronized();
        }

        interface IComparer
        {
            int Compare(object x, object y);
        }

        interface IDictionary : System.Collections.ICollection, System.Collections.IEnumerable
        {
            /*0x1f302cc*/ object get_Item(object key);
            /*0x1f30ff0*/ void set_Item(object key, object value);
            /*0x1f30214*/ System.Collections.ICollection get_Keys();
            /*0x1f30214*/ System.Collections.ICollection get_Values();
            /*0x1f2fec8*/ bool Contains(object key);
            /*0x1f30ff0*/ void Add(object key, object value);
            /*0x1f309e4*/ void Clear();
            /*0x1f2fe14*/ bool get_IsReadOnly();
            /*0x1f2fe14*/ bool get_IsFixedSize();
            /*0x1f30214*/ System.Collections.IDictionaryEnumerator GetEnumerator();
            /*0x1f30ebc*/ void Remove(object key);
        }

        interface IDictionaryEnumerator : System.Collections.IEnumerator
        {
            /*0x1f30214*/ object get_Key();
            /*0x1f30214*/ object get_Value();
            System.Collections.DictionaryEntry get_Entry();
        }

        interface IEnumerable
        {
            /*0x1f30214*/ System.Collections.IEnumerator GetEnumerator();
        }

        interface IEnumerator
        {
            /*0x1f2fe14*/ bool MoveNext();
            /*0x1f30214*/ object get_Current();
            /*0x1f309e4*/ void Reset();
        }

        interface IEqualityComparer
        {
            /*0x1f2ff00*/ bool Equals(object x, object y);
            /*0x1f3008c*/ int GetHashCode(object obj);
        }

        interface IList : System.Collections.ICollection, System.Collections.IEnumerable
        {
            /*0x1f30240*/ object get_Item(int index);
            /*0x1f30c88*/ void set_Item(int index, object value);
            /*0x1f3008c*/ int Add(object value);
            /*0x1f2fec8*/ bool Contains(object value);
            /*0x1f309e4*/ void Clear();
            /*0x1f2fe14*/ bool get_IsReadOnly();
            /*0x1f2fe14*/ bool get_IsFixedSize();
            /*0x1f3008c*/ int IndexOf(object value);
            /*0x1f30c88*/ void Insert(int index, object value);
            /*0x1f30ebc*/ void Remove(object value);
            /*0x1f30b78*/ void RemoveAt(int index);
        }

        interface IStructuralComparable
        {
            int CompareTo(object other, System.Collections.IComparer comparer);
        }

        interface IStructuralEquatable
        {
            /*0x1f2ff00*/ bool Equals(object other, System.Collections.IEqualityComparer comparer);
            /*0x1f3008c*/ int GetHashCode(System.Collections.IEqualityComparer comparer);
        }

        class ListDictionaryInternal : System.Collections.IDictionary, System.Collections.ICollection, System.Collections.IEnumerable
        {
            /*0x10*/ System.Collections.ListDictionaryInternal.DictionaryNode head;
            /*0x18*/ int version;
            /*0x1c*/ int count;
            /*0x20*/ object _syncRoot;

            /*0x32403d4*/ ListDictionaryInternal();
            /*0x32403dc*/ object get_Item(object key);
            /*0x3240490*/ void set_Item(object key, object value);
            /*0x3240618*/ int get_Count();
            /*0x3240620*/ System.Collections.ICollection get_Keys();
            /*0x32406cc*/ bool get_IsReadOnly();
            /*0x32406d4*/ bool get_IsFixedSize();
            /*0x32406dc*/ bool get_IsSynchronized();
            /*0x32406e4*/ object get_SyncRoot();
            /*0x3240754*/ System.Collections.ICollection get_Values();
            /*0x32407c0*/ void Add(object key, object value);
            /*0x3240984*/ void Clear();
            /*0x32409b4*/ bool Contains(object key);
            /*0x3240a68*/ void CopyTo(System.Array array, int index);
            /*0x3240c6c*/ System.Collections.IDictionaryEnumerator GetEnumerator();
            /*0x3240d1c*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
            /*0x3240d74*/ void Remove(object key);

            class NodeEnumerator : System.Collections.IDictionaryEnumerator, System.Collections.IEnumerator
            {
                /*0x10*/ System.Collections.ListDictionaryInternal list;
                /*0x18*/ System.Collections.ListDictionaryInternal.DictionaryNode current;
                /*0x20*/ int version;
                /*0x24*/ bool start;

                /*0x3240cc4*/ NodeEnumerator(System.Collections.ListDictionaryInternal list);
                /*0x3240e84*/ object get_Current();
                /*0x3240ee8*/ System.Collections.DictionaryEntry get_Entry();
                /*0x3240f7c*/ object get_Key();
                /*0x3240fd8*/ object get_Value();
                /*0x3241034*/ bool MoveNext();
                /*0x32410f8*/ void Reset();
            }

            class NodeKeyValueCollection : System.Collections.ICollection, System.Collections.IEnumerable
            {
                /*0x10*/ System.Collections.ListDictionaryInternal list;
                /*0x18*/ bool isKeys;

                /*0x3240690*/ NodeKeyValueCollection(System.Collections.ListDictionaryInternal list, bool isKeys);
                /*0x3241178*/ void System.Collections.ICollection.CopyTo(System.Array array, int index);
                /*0x3241334*/ int System.Collections.ICollection.get_Count();
                /*0x324136c*/ bool System.Collections.ICollection.get_IsSynchronized();
                /*0x3241374*/ object System.Collections.ICollection.get_SyncRoot();
                /*0x3241388*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();

                class NodeKeyValueEnumerator : System.Collections.IEnumerator
                {
                    /*0x10*/ System.Collections.ListDictionaryInternal list;
                    /*0x18*/ System.Collections.ListDictionaryInternal.DictionaryNode current;
                    /*0x20*/ int version;
                    /*0x24*/ bool isKeys;
                    /*0x25*/ bool start;

                    /*0x32413ec*/ NodeKeyValueEnumerator(System.Collections.ListDictionaryInternal list, bool isKeys);
                    /*0x3241458*/ object get_Current();
                    /*0x32414c8*/ bool MoveNext();
                    /*0x324158c*/ void Reset();
                }
            }

            class DictionaryNode
            {
                /*0x10*/ object key;
                /*0x18*/ object value;
                /*0x20*/ System.Collections.ListDictionaryInternal.DictionaryNode next;

                /*0x3240610*/ DictionaryNode();
            }
        }

        class CompatibleComparer : System.Collections.IEqualityComparer
        {
            /*0x10*/ System.Collections.IHashCodeProvider _hcp;
            /*0x18*/ System.Collections.IComparer _comparer;

            /*0x324160c*/ CompatibleComparer(System.Collections.IHashCodeProvider hashCodeProvider, System.Collections.IComparer comparer);
            /*0x3241650*/ System.Collections.IHashCodeProvider get_HashCodeProvider();
            /*0x3241658*/ System.Collections.IComparer get_Comparer();
            /*0x3241660*/ bool Equals(object a, object b);
            /*0x3241678*/ int Compare(object a, object b);
            /*0x3241838*/ int GetHashCode(object obj);
        }

        class CaseInsensitiveComparer : System.Collections.IComparer
        {
            /*0x10*/ System.Globalization.CompareInfo _compareInfo;

            /*0x3241940*/ CaseInsensitiveComparer();
            /*0x32419c8*/ CaseInsensitiveComparer(System.Globalization.CultureInfo culture);
            /*0x3241a58*/ int Compare(object a, object b);
        }

        class CaseInsensitiveHashCodeProvider : System.Collections.IHashCodeProvider
        {
            /*0x10*/ System.Globalization.CompareInfo _compareInfo;

            /*0x3241b38*/ CaseInsensitiveHashCodeProvider();
            /*0x3241bc0*/ CaseInsensitiveHashCodeProvider(System.Globalization.CultureInfo culture);
            /*0x3241c50*/ int GetHashCode(object obj);
        }

        class CollectionBase : System.Collections.IList, System.Collections.ICollection, System.Collections.IEnumerable
        {
            /*0x10*/ System.Collections.ArrayList _list;

            /*0x3241cf0*/ CollectionBase();
            /*0x3241e04*/ System.Collections.ArrayList get_InnerList();
            /*0x3241e0c*/ System.Collections.IList get_List();
            /*0x3241e10*/ int get_Count();
            /*0x3241e30*/ void Clear();
            /*0x3241e7c*/ void RemoveAt(int index);
            /*0x3242050*/ bool System.Collections.IList.get_IsReadOnly();
            /*0x3242070*/ bool System.Collections.IList.get_IsFixedSize();
            /*0x3242090*/ bool System.Collections.ICollection.get_IsSynchronized();
            /*0x32420b0*/ object System.Collections.ICollection.get_SyncRoot();
            /*0x32420d0*/ void System.Collections.ICollection.CopyTo(System.Array array, int index);
            /*0x32420f0*/ object System.Collections.IList.get_Item(int index);
            /*0x32421a8*/ void System.Collections.IList.set_Item(int index, object value);
            /*0x324238c*/ bool System.Collections.IList.Contains(object value);
            /*0x32423ac*/ int System.Collections.IList.Add(object value);
            /*0x32424ec*/ void System.Collections.IList.Remove(object value);
            /*0x3242684*/ int System.Collections.IList.IndexOf(object value);
            /*0x32426a4*/ void System.Collections.IList.Insert(int index, object value);
            /*0x3242854*/ System.Collections.IEnumerator GetEnumerator();
            /*0x3242874*/ void OnSet(int index, object oldValue, object newValue);
            /*0x3242878*/ void OnInsert(int index, object value);
            /*0x324287c*/ void OnClear();
            /*0x3242880*/ void OnRemove(int index, object value);
            /*0x3242884*/ void OnValidate(object value);
            /*0x32428d8*/ void OnSetComplete(int index, object oldValue, object newValue);
            /*0x32428dc*/ void OnInsertComplete(int index, object value);
            /*0x32428e0*/ void OnClearComplete();
            /*0x32428e4*/ void OnRemoveComplete(int index, object value);
        }

        class Queue : System.Collections.ICollection, System.Collections.IEnumerable, System.ICloneable
        {
            /*0x10*/ object[] _array;
            /*0x18*/ int _head;
            /*0x1c*/ int _tail;
            /*0x20*/ int _size;
            /*0x24*/ int _growFactor;
            /*0x28*/ int _version;
            /*0x30*/ object _syncRoot;

            /*0x32428e8*/ Queue();
            /*0x3242ab4*/ Queue(int capacity);
            /*0x32428f4*/ Queue(int capacity, float growFactor);
            /*0x3242abc*/ Queue(System.Collections.ICollection col);
            /*0x3242d34*/ int get_Count();
            /*0x3242d3c*/ object Clone();
            /*0x3242e1c*/ bool get_IsSynchronized();
            /*0x3242e24*/ object get_SyncRoot();
            /*0x3242e98*/ void CopyTo(System.Array array, int index);
            /*0x324307c*/ void Enqueue(object obj);
            /*0x3243274*/ System.Collections.IEnumerator GetEnumerator();
            /*0x3243344*/ object Dequeue();
            /*0x3243424*/ object Peek();
            /*0x32434b4*/ object GetElement(int i);
            /*0x3243180*/ void SetCapacity(int capacity);

            class QueueEnumerator : System.Collections.IEnumerator, System.ICloneable
            {
                /*0x10*/ System.Collections.Queue _q;
                /*0x18*/ int _index;
                /*0x1c*/ int _version;
                /*0x20*/ object _currentElement;

                /*0x32432cc*/ QueueEnumerator(System.Collections.Queue q);
                /*0x32434f4*/ object Clone();
                /*0x32434fc*/ bool MoveNext();
                /*0x32435e0*/ object get_Current();
                /*0x3243670*/ void Reset();
            }

            class QueueDebugView
            {
            }
        }

        class ReadOnlyCollectionBase : System.Collections.ICollection, System.Collections.IEnumerable
        {
            /*0x10*/ System.Collections.ArrayList _list;

            /*0x3243830*/ ReadOnlyCollectionBase();
            /*0x32436f8*/ System.Collections.ArrayList get_InnerList();
            /*0x3243764*/ int get_Count();
            /*0x3243788*/ bool System.Collections.ICollection.get_IsSynchronized();
            /*0x32437ac*/ object System.Collections.ICollection.get_SyncRoot();
            /*0x32437d0*/ void System.Collections.ICollection.CopyTo(System.Array array, int index);
            /*0x324380c*/ System.Collections.IEnumerator GetEnumerator();
        }

        class SortedList : System.Collections.IDictionary, System.Collections.ICollection, System.Collections.IEnumerable, System.ICloneable
        {
            /*0x10*/ object[] keys;
            /*0x18*/ object[] values;
            /*0x20*/ int _size;
            /*0x24*/ int version;
            /*0x28*/ System.Collections.IComparer comparer;
            /*0x30*/ System.Collections.SortedList.KeyList keyList;
            /*0x38*/ System.Collections.SortedList.ValueList valueList;
            /*0x40*/ object _syncRoot;

            static /*0x3244d40*/ System.Collections.SortedList Synchronized(System.Collections.SortedList list);
            /*0x3243838*/ SortedList();
            /*0x32439d4*/ SortedList(int initialCapacity);
            /*0x3243b2c*/ SortedList(System.Collections.IComparer comparer);
            /*0x3243854*/ void Init();
            /*0x3243b74*/ void Add(object key, object value);
            /*0x3243dd8*/ void set_Capacity(int value);
            /*0x324402c*/ int get_Count();
            /*0x3244034*/ System.Collections.ICollection get_Keys();
            /*0x3244044*/ System.Collections.ICollection get_Values();
            /*0x3244054*/ bool get_IsReadOnly();
            /*0x324405c*/ bool get_IsFixedSize();
            /*0x3244064*/ bool get_IsSynchronized();
            /*0x324406c*/ object get_SyncRoot();
            /*0x32440dc*/ void Clear();
            /*0x3244120*/ object Clone();
            /*0x32441d4*/ bool Contains(object key);
            /*0x32441f8*/ bool ContainsKey(object key);
            /*0x324421c*/ bool ContainsValue(object value);
            /*0x3244240*/ void CopyTo(System.Array array, int arrayIndex);
            /*0x32444e0*/ void EnsureCapacity(int min);
            /*0x3244528*/ object GetByIndex(int index);
            /*0x32445e0*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
            /*0x32446c0*/ System.Collections.IDictionaryEnumerator GetEnumerator();
            /*0x3244728*/ object GetKey(int index);
            /*0x32447e0*/ System.Collections.IList GetKeyList();
            /*0x3244894*/ System.Collections.IList GetValueList();
            /*0x3244948*/ object get_Item(object key);
            /*0x3244998*/ void set_Item(object key, object value);
            /*0x3244ac0*/ int IndexOfKey(object key);
            /*0x3244b5c*/ int IndexOfValue(object value);
            /*0x3243c98*/ void Insert(int index, object key, object value);
            /*0x3244bbc*/ void RemoveAt(int index);
            /*0x3244d00*/ void Remove(object key);

            class SyncSortedList : System.Collections.SortedList
            {
                /*0x48*/ System.Collections.SortedList _list;
                /*0x50*/ object _root;

                /*0x3244de4*/ SyncSortedList(System.Collections.SortedList list);
                /*0x3244e48*/ int get_Count();
                /*0x3244f2c*/ object get_SyncRoot();
                /*0x3244f34*/ bool get_IsReadOnly();
                /*0x3244f54*/ bool get_IsFixedSize();
                /*0x3244f74*/ bool get_IsSynchronized();
                /*0x3244f7c*/ object get_Item(object key);
                /*0x3245068*/ void set_Item(object key, object value);
                /*0x3245150*/ void Add(object key, object value);
                /*0x3245238*/ void Clear();
                /*0x3245308*/ object Clone();
                /*0x32453ec*/ bool Contains(object key);
                /*0x32454d8*/ bool ContainsKey(object key);
                /*0x32455c4*/ bool ContainsValue(object key);
                /*0x32456b0*/ void CopyTo(System.Array array, int index);
                /*0x3245798*/ object GetByIndex(int index);
                /*0x3245884*/ System.Collections.IDictionaryEnumerator GetEnumerator();
                /*0x3245968*/ object GetKey(int index);
                /*0x3245a54*/ System.Collections.IList GetKeyList();
                /*0x3245b38*/ System.Collections.IList GetValueList();
                /*0x3245c1c*/ int IndexOfKey(object key);
                /*0x3245d6c*/ int IndexOfValue(object value);
                /*0x3245e58*/ void RemoveAt(int index);
                /*0x3245f34*/ void Remove(object key);
            }

            class SortedListEnumerator : System.Collections.IDictionaryEnumerator, System.Collections.IEnumerator, System.ICloneable
            {
                /*0x10*/ System.Collections.SortedList _sortedList;
                /*0x18*/ object _key;
                /*0x20*/ object _value;
                /*0x28*/ int _index;
                /*0x2c*/ int _startIndex;
                /*0x30*/ int _endIndex;
                /*0x34*/ int _version;
                /*0x38*/ bool _current;
                /*0x3c*/ int _getObjectRetType;

                /*0x3244648*/ SortedListEnumerator(System.Collections.SortedList sortedList, int index, int count, int getObjRetType);
                /*0x3246010*/ object Clone();
                /*0x3246018*/ object get_Key();
                /*0x32460b4*/ bool MoveNext();
                /*0x32461f4*/ System.Collections.DictionaryEntry get_Entry();
                /*0x32462c4*/ object get_Current();
                /*0x32463b8*/ object get_Value();
                /*0x3246454*/ void Reset();
            }

            class KeyList : System.Collections.IList, System.Collections.ICollection, System.Collections.IEnumerable
            {
                /*0x10*/ System.Collections.SortedList sortedList;

                /*0x3244864*/ KeyList(System.Collections.SortedList sortedList);
                /*0x32464f0*/ int get_Count();
                /*0x3246508*/ bool get_IsReadOnly();
                /*0x3246510*/ bool get_IsFixedSize();
                /*0x3246518*/ bool get_IsSynchronized();
                /*0x3246538*/ object get_SyncRoot();
                /*0x3246558*/ int Add(object key);
                /*0x32465a4*/ void Clear();
                /*0x32465f0*/ bool Contains(object key);
                /*0x3246610*/ void CopyTo(System.Array array, int arrayIndex);
                /*0x32466dc*/ void Insert(int index, object value);
                /*0x3246728*/ object get_Item(int index);
                /*0x3246748*/ void set_Item(int index, object value);
                /*0x3246794*/ System.Collections.IEnumerator GetEnumerator();
                /*0x3246820*/ int IndexOf(object key);
                /*0x32468e8*/ void Remove(object key);
                /*0x3246934*/ void RemoveAt(int index);
            }

            class ValueList : System.Collections.IList, System.Collections.ICollection, System.Collections.IEnumerable
            {
                /*0x10*/ System.Collections.SortedList sortedList;

                /*0x3244918*/ ValueList(System.Collections.SortedList sortedList);
                /*0x3246980*/ int get_Count();
                /*0x3246998*/ bool get_IsReadOnly();
                /*0x32469a0*/ bool get_IsFixedSize();
                /*0x32469a8*/ bool get_IsSynchronized();
                /*0x32469c8*/ object get_SyncRoot();
                /*0x32469e8*/ int Add(object key);
                /*0x3246a34*/ void Clear();
                /*0x3246a80*/ bool Contains(object value);
                /*0x3246aa0*/ void CopyTo(System.Array array, int arrayIndex);
                /*0x3246b6c*/ void Insert(int index, object value);
                /*0x3246bb8*/ object get_Item(int index);
                /*0x3246bd8*/ void set_Item(int index, object value);
                /*0x3246c24*/ System.Collections.IEnumerator GetEnumerator();
                /*0x3246cb0*/ int IndexOf(object value);
                /*0x3246d28*/ void Remove(object value);
                /*0x3246d74*/ void RemoveAt(int index);
            }

            class SortedListDebugView
            {
            }
        }

        class Stack : System.Collections.ICollection, System.Collections.IEnumerable, System.ICloneable
        {
            /*0x10*/ object[] _array;
            /*0x18*/ int _size;
            /*0x1c*/ int _version;
            /*0x20*/ object _syncRoot;

            /*0x3246dc0*/ Stack();
            /*0x3246e2c*/ Stack(int initialCapacity);
            /*0x3246f04*/ int get_Count();
            /*0x3246f0c*/ bool get_IsSynchronized();
            /*0x3246f14*/ object get_SyncRoot();
            /*0x3246f84*/ void Clear();
            /*0x3246fb4*/ object Clone();
            /*0x3247040*/ void CopyTo(System.Array array, int index);
            /*0x32472f8*/ System.Collections.IEnumerator GetEnumerator();
            /*0x32473ac*/ object Peek();
            /*0x3247430*/ object Pop();
            /*0x32474d0*/ void Push(object obj);

            class StackEnumerator : System.Collections.IEnumerator, System.ICloneable
            {
                /*0x10*/ System.Collections.Stack _stack;
                /*0x18*/ int _index;
                /*0x1c*/ int _version;
                /*0x20*/ object _currentElement;

                /*0x3247350*/ StackEnumerator(System.Collections.Stack stack);
                /*0x32475f0*/ object Clone();
                /*0x32475f8*/ bool MoveNext();
                /*0x32476dc*/ object get_Current();
                /*0x3247768*/ void Reset();
            }

            class StackDebugView
            {
            }
        }

        class BitArray : System.Collections.ICollection, System.Collections.IEnumerable, System.ICloneable
        {
            /*0x10*/ int[] m_array;
            /*0x18*/ int m_length;
            /*0x1c*/ int _version;
            /*0x20*/ object _syncRoot;

            static /*0x3247940*/ int GetArrayLength(int n, int div);
            /*0x32477e8*/ BitArray(int length);
            /*0x32477f0*/ BitArray(int length, bool defaultValue);
            /*0x324795c*/ BitArray(byte[] bytes);
            /*0x3247c64*/ BitArray(System.Collections.BitArray bits);
            /*0x3247d54*/ bool get_Item(int index);
            /*0x3247e30*/ void set_Item(int index, bool value);
            /*0x3247d58*/ bool Get(int index);
            /*0x3247e34*/ void Set(int index, bool value);
            /*0x3247f50*/ void SetAll(bool value);
            /*0x3247fac*/ System.Collections.BitArray Or(System.Collections.BitArray value);
            /*0x32480bc*/ int get_Length();
            /*0x32480c4*/ void set_Length(int value);
            /*0x3248258*/ void CopyTo(System.Array array, int index);
            /*0x3248738*/ int get_Count();
            /*0x3248740*/ object get_SyncRoot();
            /*0x32487b0*/ bool get_IsSynchronized();
            /*0x32487b8*/ object Clone();
            /*0x3248810*/ System.Collections.IEnumerator GetEnumerator();

            class BitArrayEnumeratorSimple : System.Collections.IEnumerator, System.ICloneable
            {
                /*0x10*/ System.Collections.BitArray bitarray;
                /*0x18*/ int index;
                /*0x1c*/ int version;
                /*0x20*/ bool currentElement;

                /*0x3248868*/ BitArrayEnumeratorSimple(System.Collections.BitArray bitarray);
                /*0x32488b8*/ object Clone();
                /*0x32488c0*/ bool MoveNext();
                /*0x3248a64*/ object get_Current();
                /*0x3248bac*/ void Reset();
            }
        }

        class ArrayList : System.Collections.IList, System.Collections.ICollection, System.Collections.IEnumerable, System.ICloneable
        {
            /*0x10*/ object[] _items;
            /*0x18*/ int _size;
            /*0x1c*/ int _version;
            /*0x20*/ object _syncRoot;

            static /*0x32492a8*/ System.Collections.ArrayList Adapter(System.Collections.IList list);
            static /*0x3249d1c*/ System.Collections.ArrayList ReadOnly(System.Collections.ArrayList list);
            /*0x3241d58*/ ArrayList();
            /*0x3248c24*/ ArrayList(int capacity);
            /*0x3248d84*/ ArrayList(System.Collections.ICollection c);
            /*0x3248f58*/ void set_Capacity(int value);
            /*0x3249084*/ int get_Count();
            /*0x324908c*/ bool get_IsFixedSize();
            /*0x3249094*/ bool get_IsReadOnly();
            /*0x324909c*/ bool get_IsSynchronized();
            /*0x32490a4*/ object get_SyncRoot();
            /*0x3249114*/ object get_Item(int index);
            /*0x32491b8*/ void set_Item(int index, object value);
            /*0x3249390*/ int Add(object value);
            /*0x3249494*/ void AddRange(System.Collections.ICollection c);
            /*0x32494ac*/ void Clear();
            /*0x32494e8*/ object Clone();
            /*0x3249570*/ bool Contains(object item);
            /*0x324963c*/ void CopyTo(System.Array array);
            /*0x3249650*/ void CopyTo(System.Array array, int arrayIndex);
            /*0x32496fc*/ void CopyTo(int index, System.Array array, int arrayIndex, int count);
            /*0x3249440*/ void EnsureCapacity(int min);
            /*0x32497fc*/ System.Collections.IEnumerator GetEnumerator();
            /*0x3249968*/ int IndexOf(object value);
            /*0x3249980*/ void Insert(int index, object value);
            /*0x3249abc*/ void InsertRange(int index, System.Collections.ICollection c);
            /*0x3249df8*/ void Remove(object obj);
            /*0x3249e38*/ void RemoveAt(int index);
            /*0x3249f20*/ void RemoveRange(int index, int count);
            /*0x324a0a0*/ void Sort(System.Collections.IComparer comparer);
            /*0x324a0ec*/ void Sort(int index, int count, System.Collections.IComparer comparer);
            /*0x324a1e4*/ object[] ToArray();
            /*0x324a2cc*/ System.Array ToArray(System.Type type);

            class IListWrapper : System.Collections.ArrayList
            {
                /*0x28*/ System.Collections.IList _list;

                /*0x324935c*/ IListWrapper(System.Collections.IList list);
                /*0x324a398*/ void set_Capacity(int value);
                /*0x324a428*/ int get_Count();
                /*0x324a4cc*/ bool get_IsReadOnly();
                /*0x324a570*/ bool get_IsFixedSize();
                /*0x324a614*/ bool get_IsSynchronized();
                /*0x324a6b8*/ object get_Item(int index);
                /*0x324a760*/ void set_Item(int index, object value);
                /*0x324a82c*/ object get_SyncRoot();
                /*0x324a8d0*/ int Add(object obj);
                /*0x324a98c*/ void AddRange(System.Collections.ICollection c);
                /*0x324a9d4*/ void Clear();
                /*0x324ab38*/ object Clone();
                /*0x324aba4*/ bool Contains(object obj);
                /*0x324ac50*/ void CopyTo(System.Array array, int index);
                /*0x324ad08*/ void CopyTo(int index, System.Array array, int arrayIndex, int count);
                /*0x324b03c*/ System.Collections.IEnumerator GetEnumerator();
                /*0x324b0dc*/ int IndexOf(object value);
                /*0x324b188*/ void Insert(int index, object obj);
                /*0x324b254*/ void InsertRange(int index, System.Collections.ICollection c);
                /*0x324b61c*/ void Remove(object value);
                /*0x324b65c*/ void RemoveAt(int index);
                /*0x324b718*/ void RemoveRange(int index, int count);
                /*0x324b930*/ void Sort(int index, int count, System.Collections.IComparer comparer);
                /*0x324bbe8*/ object[] ToArray();
                /*0x324bd5c*/ System.Array ToArray(System.Type type);
            }

            class ReadOnlyArrayList : System.Collections.ArrayList
            {
                /*0x28*/ System.Collections.ArrayList _list;

                /*0x3249dcc*/ ReadOnlyArrayList(System.Collections.ArrayList l);
                /*0x324bf04*/ int get_Count();
                /*0x324bf24*/ bool get_IsReadOnly();
                /*0x324bf2c*/ bool get_IsFixedSize();
                /*0x324bf34*/ bool get_IsSynchronized();
                /*0x324bf54*/ object get_Item(int index);
                /*0x324bf74*/ void set_Item(int index, object value);
                /*0x324bfc0*/ object get_SyncRoot();
                /*0x324bfe0*/ int Add(object obj);
                /*0x324c02c*/ void AddRange(System.Collections.ICollection c);
                /*0x324c078*/ void set_Capacity(int value);
                /*0x324c0c4*/ void Clear();
                /*0x324c110*/ object Clone();
                /*0x324c228*/ bool Contains(object obj);
                /*0x324c248*/ void CopyTo(System.Array array, int index);
                /*0x324c268*/ void CopyTo(int index, System.Array array, int arrayIndex, int count);
                /*0x324c288*/ System.Collections.IEnumerator GetEnumerator();
                /*0x324c2a8*/ int IndexOf(object value);
                /*0x324c2c8*/ void Insert(int index, object obj);
                /*0x324c314*/ void InsertRange(int index, System.Collections.ICollection c);
                /*0x324c360*/ void Remove(object value);
                /*0x324c3ac*/ void RemoveAt(int index);
                /*0x324c3f8*/ void RemoveRange(int index, int count);
                /*0x324c444*/ void Sort(int index, int count, System.Collections.IComparer comparer);
                /*0x324c490*/ object[] ToArray();
                /*0x324c4b0*/ System.Array ToArray(System.Type type);
            }

            class ArrayListEnumeratorSimple : System.Collections.IEnumerator, System.ICloneable
            {
                static /*0x0*/ object s_dummyObject;
                /*0x10*/ System.Collections.ArrayList _list;
                /*0x18*/ int _index;
                /*0x1c*/ int _version;
                /*0x20*/ object _currentElement;
                /*0x28*/ bool _isArrayList;

                static /*0x324c858*/ ArrayListEnumeratorSimple();
                /*0x3249854*/ ArrayListEnumeratorSimple(System.Collections.ArrayList list);
                /*0x324c4d0*/ object Clone();
                /*0x324c4d8*/ bool MoveNext();
                /*0x324c6b8*/ object get_Current();
                /*0x324c784*/ void Reset();
            }

            class ArrayListDebugView
            {
            }
        }

        class Hashtable : System.Collections.IDictionary, System.Collections.ICollection, System.Collections.IEnumerable, System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IDeserializationCallback, System.ICloneable
        {
            static /*0x0*/ System.Runtime.CompilerServices.ConditionalWeakTable<object, System.Runtime.Serialization.SerializationInfo> s_serializationInfoTable;
            /*0x10*/ System.Collections.Hashtable.bucket[] _buckets;
            /*0x18*/ int _count;
            /*0x1c*/ int _occupancy;
            /*0x20*/ int _loadsize;
            /*0x24*/ float _loadFactor;
            /*0x28*/ int _version;
            /*0x2c*/ bool _isWriterInProgress;
            /*0x30*/ System.Collections.ICollection _keys;
            /*0x38*/ System.Collections.ICollection _values;
            /*0x40*/ System.Collections.IEqualityComparer _keycomparer;
            /*0x48*/ object _syncRoot;

            static /*0x324c8d4*/ System.Runtime.CompilerServices.ConditionalWeakTable<object, System.Runtime.Serialization.SerializationInfo> get_SerializationInfoTable();
            static /*0x324e560*/ System.Collections.Hashtable Synchronized(System.Collections.Hashtable table);
            /*0x324c930*/ Hashtable(bool trash);
            /*0x324c938*/ Hashtable();
            /*0x324cbe8*/ Hashtable(int capacity);
            /*0x324c944*/ Hashtable(int capacity, float loadFactor);
            /*0x324cbf0*/ Hashtable(int capacity, float loadFactor, System.Collections.IEqualityComparer equalityComparer);
            /*0x324cc1c*/ Hashtable(System.Collections.IEqualityComparer equalityComparer);
            /*0x324cc50*/ Hashtable(int capacity, System.Collections.IEqualityComparer equalityComparer);
            /*0x324cc80*/ Hashtable(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x324cce8*/ uint InitHash(object key, int hashsize, ref uint seed, ref uint incr);
            /*0x324cd3c*/ void Add(object key, object value);
            /*0x324d1c0*/ void Clear();
            /*0x324d2c0*/ object Clone();
            /*0x324d3d0*/ bool Contains(object key);
            /*0x324d3e0*/ bool ContainsKey(object key);
            /*0x324d558*/ void CopyKeys(System.Array array, int arrayIndex);
            /*0x324d604*/ void CopyEntries(System.Array array, int arrayIndex);
            /*0x324d738*/ void CopyTo(System.Array array, int arrayIndex);
            /*0x324d8d8*/ void CopyValues(System.Array array, int arrayIndex);
            /*0x324d988*/ object get_Item(object key);
            /*0x324dba0*/ void set_Item(object key, object value);
            /*0x324dba8*/ void expand();
            /*0x324dd4c*/ void rehash();
            /*0x324d294*/ void UpdateVersion();
            /*0x324dc14*/ void rehash(int newsize);
            /*0x324de74*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
            /*0x324df34*/ System.Collections.IDictionaryEnumerator GetEnumerator();
            /*0x324df90*/ int GetHash(object key);
            /*0x324e058*/ bool get_IsReadOnly();
            /*0x324e060*/ bool get_IsFixedSize();
            /*0x324e068*/ bool get_IsSynchronized();
            /*0x324e070*/ bool KeyEquals(object item, object key);
            /*0x324e178*/ System.Collections.ICollection get_Keys();
            /*0x324e22c*/ System.Collections.ICollection get_Values();
            /*0x324cd44*/ void Insert(object key, object nvalue, bool add);
            /*0x324dd64*/ void putEntry(System.Collections.Hashtable.bucket[] newBuckets, object key, object nvalue, int hashcode);
            /*0x324e2e0*/ void Remove(object key);
            /*0x324e4e8*/ object get_SyncRoot();
            /*0x324e558*/ int get_Count();
            /*0x324e644*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x324eb7c*/ void OnDeserialization(object sender);

            struct bucket
            {
                /*0x10*/ object key;
                /*0x18*/ object val;
                /*0x20*/ int hash_coll;
            }

            class KeyCollection : System.Collections.ICollection, System.Collections.IEnumerable
            {
                /*0x10*/ System.Collections.Hashtable _hashtable;

                /*0x324e1fc*/ KeyCollection(System.Collections.Hashtable hashtable);
                /*0x324f3e8*/ void CopyTo(System.Array array, int arrayIndex);
                /*0x324f564*/ System.Collections.IEnumerator GetEnumerator();
                /*0x324f5c4*/ bool get_IsSynchronized();
                /*0x324f5e4*/ object get_SyncRoot();
                /*0x324f604*/ int get_Count();
            }

            class ValueCollection : System.Collections.ICollection, System.Collections.IEnumerable
            {
                /*0x10*/ System.Collections.Hashtable _hashtable;

                /*0x324e2b0*/ ValueCollection(System.Collections.Hashtable hashtable);
                /*0x324f61c*/ void CopyTo(System.Array array, int arrayIndex);
                /*0x324f798*/ System.Collections.IEnumerator GetEnumerator();
                /*0x324f7f8*/ bool get_IsSynchronized();
                /*0x324f818*/ object get_SyncRoot();
                /*0x324f838*/ int get_Count();
            }

            class SyncHashtable : System.Collections.Hashtable, System.Collections.IEnumerable
            {
                /*0x50*/ System.Collections.Hashtable _table;

                /*0x324e614*/ SyncHashtable(System.Collections.Hashtable table);
                /*0x324f850*/ SyncHashtable(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x324f88c*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x324f8c4*/ int get_Count();
                /*0x324f8e4*/ bool get_IsReadOnly();
                /*0x324f904*/ bool get_IsFixedSize();
                /*0x324f924*/ bool get_IsSynchronized();
                /*0x324f92c*/ object get_Item(object key);
                /*0x324f94c*/ void set_Item(object key, object value);
                /*0x324fa50*/ object get_SyncRoot();
                /*0x324fa70*/ void Add(object key, object value);
                /*0x324fb74*/ void Clear();
                /*0x324fc60*/ bool Contains(object key);
                /*0x324fc80*/ bool ContainsKey(object key);
                /*0x324fd0c*/ void CopyTo(System.Array array, int arrayIndex);
                /*0x324fe10*/ object Clone();
                /*0x324ff78*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                /*0x324ff98*/ System.Collections.IDictionaryEnumerator GetEnumerator();
                /*0x324ffb8*/ System.Collections.ICollection get_Keys();
                /*0x32500b8*/ System.Collections.ICollection get_Values();
                /*0x32501b8*/ void Remove(object key);
                /*0x32502b0*/ void OnDeserialization(object sender);
            }

            class HashtableEnumerator : System.Collections.IDictionaryEnumerator, System.Collections.IEnumerator, System.ICloneable
            {
                /*0x10*/ System.Collections.Hashtable _hashtable;
                /*0x18*/ int _bucket;
                /*0x1c*/ int _version;
                /*0x20*/ bool _current;
                /*0x24*/ int _getObjectRetType;
                /*0x28*/ object _currentKey;
                /*0x30*/ object _currentValue;

                /*0x324ded0*/ HashtableEnumerator(System.Collections.Hashtable hashtable, int getObjRetType);
                /*0x32502b4*/ object Clone();
                /*0x32502bc*/ object get_Key();
                /*0x3250318*/ bool MoveNext();
                /*0x325044c*/ System.Collections.DictionaryEntry get_Entry();
                /*0x32504e0*/ object get_Current();
                /*0x32505d4*/ object get_Value();
                /*0x3250630*/ void Reset();
            }

            class HashtableDebugView
            {
            }
        }

        interface IHashCodeProvider
        {
            /*0x1f3008c*/ int GetHashCode(object obj);
        }

        namespace Concurrent
        {
            class ConcurrentQueue<T> : System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.Collections.ICollection, System.Collections.Generic.IReadOnlyCollection<T>
            {
                /*0x0*/ object _crossSegmentLock;
                /*0x0*/ System.Collections.Concurrent.ConcurrentQueue.Segment<T> _tail;
                /*0x0*/ System.Collections.Concurrent.ConcurrentQueue.Segment<T> _head;

                static /*0x1f32080*/ int GetCount(System.Collections.Concurrent.ConcurrentQueue.Segment<T> s, int head, int tail);
                static /*0x1ffc854*/ long GetCount(System.Collections.Concurrent.ConcurrentQueue.Segment<T> head, int headHead, System.Collections.Concurrent.ConcurrentQueue.Segment<T> tail, int tailTail);
                /*0x1f309e4*/ ConcurrentQueue();
                /*0x1f30ee8*/ void System.Collections.ICollection.CopyTo(System.Array array, int index);
                /*0x1f2fe14*/ bool System.Collections.ICollection.get_IsSynchronized();
                /*0x1f30214*/ object System.Collections.ICollection.get_SyncRoot();
                /*0x1f30214*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                /*0x1f2fe14*/ bool get_IsEmpty();
                /*0x1f30214*/ T[] ToArray();
                /*0x1f2ffc8*/ int get_Count();
                /*0x1f30ee8*/ void CopyTo(T[] array, int index);
                /*0x1f30214*/ System.Collections.Generic.IEnumerator<T> GetEnumerator();
                /*0x1f31134*/ void SnapForObservation(ref System.Collections.Concurrent.ConcurrentQueue.Segment<T> head, ref int headHead, ref System.Collections.Concurrent.ConcurrentQueue.Segment<T> tail, ref int tailTail);
                /*0x1ffc854*/ T GetItemWhenAvailable(System.Collections.Concurrent.ConcurrentQueue.Segment<T> segment, int i);
                /*0x1ffc854*/ System.Collections.Generic.IEnumerator<T> Enumerate(System.Collections.Concurrent.ConcurrentQueue.Segment<T> head, int headHead, System.Collections.Concurrent.ConcurrentQueue.Segment<T> tail, int tailTail);
                /*0x1ffc854*/ void Enqueue(T item);
                /*0x1ffc854*/ void EnqueueSlow(T item);
                /*0x1f2fec8*/ bool TryDequeue(ref T result);
                /*0x1f2fec8*/ bool TryDequeueSlow(ref T item);
                bool TryPeek(ref T result, bool resultUsed);
                /*0x1f309e4*/ void Clear();

                class Segment<T>
                {
                    /*0x0*/ System.Collections.Concurrent.ConcurrentQueue.Segment.Slot<T> _slots;
                    /*0x0*/ int _slotsMask;
                    /*0x0*/ System.Collections.Concurrent.PaddedHeadAndTail _headAndTail;
                    /*0x0*/ bool _preservedForObservation;
                    /*0x0*/ bool _frozenForEnqueues;
                    /*0x0*/ System.Collections.Concurrent.ConcurrentQueue.Segment<T> _nextSegment;

                    /*0x1f30b78*/ Segment(int boundedLength);
                    /*0x1f2ffc8*/ int get_Capacity();
                    /*0x1f2ffc8*/ int get_FreezeOffset();
                    /*0x1f309e4*/ void EnsureFrozenForEnqueues();
                    /*0x1f2fec8*/ bool TryDequeue(ref T item);
                    bool TryPeek(ref T result, bool resultUsed);
                    /*0x1ffc854*/ bool TryEnqueue(T item);

                    struct Slot<T>
                    {
                        /*0x0*/ T Item;
                        /*0x0*/ int SequenceNumber;
                    }
                }

                class <Enumerate>d__28<T> : System.Collections.Generic.IEnumerator<T>, System.IDisposable, System.Collections.IEnumerator
                {
                    /*0x0*/ int <>1__state;
                    /*0x0*/ T <>2__current;
                    /*0x0*/ System.Collections.Concurrent.ConcurrentQueue.Segment<T> head;
                    /*0x0*/ System.Collections.Concurrent.ConcurrentQueue.Segment<T> tail;
                    /*0x0*/ int tailTail;
                    /*0x0*/ int headHead;
                    /*0x0*/ System.Collections.Concurrent.ConcurrentQueue<T> <>4__this;
                    /*0x0*/ int <headTail>5__2;
                    /*0x0*/ int <i>5__3;
                    /*0x0*/ System.Collections.Concurrent.ConcurrentQueue.Segment<T> <s>5__4;
                    /*0x0*/ int <i>5__5;

                    /*0x1f30b78*/ <Enumerate>d__28(int <>1__state);
                    /*0x1f309e4*/ void System.IDisposable.Dispose();
                    /*0x1f2fe14*/ bool MoveNext();
                    /*0x1ffc854*/ T System.Collections.Generic.IEnumerator<T>.get_Current();
                    /*0x1f309e4*/ void System.Collections.IEnumerator.Reset();
                    /*0x1f30214*/ object System.Collections.IEnumerator.get_Current();
                }
            }

            struct PaddedHeadAndTail
            {
                /*0x90*/ int Head;
                /*0x110*/ int Tail;
            }

            class CDSCollectionETWBCLProvider : System.Diagnostics.Tracing.EventSource
            {
                static /*0x0*/ System.Collections.Concurrent.CDSCollectionETWBCLProvider Log;

                static /*0x32506f0*/ CDSCollectionETWBCLProvider();
                /*0x32506e8*/ CDSCollectionETWBCLProvider();
                /*0x32506ec*/ void ConcurrentDictionary_AcquiringAllLocks(int numOfBuckets);
            }

            class ConcurrentDictionary<TKey, TValue> : System.Collections.Generic.IDictionary<TKey, TValue>, System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.IEnumerable, System.Collections.IDictionary, System.Collections.ICollection, System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>, System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>
            {
                static /*0x0*/ bool s_isValueWriteAtomic;
                /*0x0*/ System.Collections.Concurrent.ConcurrentDictionary.Tables<TKey, TValue> _tables;
                /*0x0*/ System.Collections.Generic.IEqualityComparer<TKey> _comparer;
                /*0x0*/ bool _growLockArray;
                /*0x0*/ int _budget;
                /*0x0*/ System.Collections.Generic.KeyValuePair<TKey, TValue> _serializationArray;
                /*0x0*/ int _serializationConcurrencyLevel;
                /*0x0*/ int _serializationCapacity;

                static /*0x1f33998*/ ConcurrentDictionary();
                static /*0x1f317dc*/ bool IsValueWriteAtomic();
                static /*0x1f350f8*/ void ThrowKeyNotFoundException(object key);
                static /*0x1f33998*/ void ThrowKeyNullException();
                static /*0x1f31e78*/ int GetBucket(int hashcode, int bucketCount);
                static /*0x1ffc854*/ void GetBucketAndLockNo(int hashcode, ref int bucketNo, ref int lockNo, int bucketCount, int lockCount);
                static /*0x1f31da0*/ int get_DefaultConcurrencyLevel();
                /*0x1f309e4*/ ConcurrentDictionary();
                /*0x1f30ebc*/ ConcurrentDictionary(System.Collections.Generic.IEqualityComparer<TKey> comparer);
                /*0x1ffc854*/ ConcurrentDictionary(int concurrencyLevel, int capacity, bool growLockArray, System.Collections.Generic.IEqualityComparer<TKey> comparer);
                /*0x1f30ebc*/ void InitializeFromCollection(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> collection);
                /*0x1ffc854*/ bool TryAdd(TKey key, TValue value);
                /*0x1ffc854*/ bool ContainsKey(TKey key);
                /*0x1ffc854*/ bool TryRemove(TKey key, ref TValue value);
                /*0x1ffc854*/ bool TryRemoveInternal(TKey key, ref TValue value, bool matchValue, TValue oldValue);
                /*0x1ffc854*/ bool TryGetValue(TKey key, ref TValue value);
                /*0x1ffc854*/ bool TryGetValueInternal(TKey key, int hashcode, ref TValue value);
                /*0x1ffc854*/ bool TryUpdateInternal(TKey key, int hashcode, TValue newValue, TValue comparisonValue);
                /*0x1f309e4*/ void Clear();
                /*0x1f30ee8*/ void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(System.Collections.Generic.KeyValuePair<TKey, TValue> array, int index);
                /*0x1f30214*/ System.Collections.Generic.KeyValuePair<TKey, TValue> ToArray();
                /*0x1f30ee8*/ void CopyToPairs(System.Collections.Generic.KeyValuePair<TKey, TValue> array, int index);
                /*0x1f30ee8*/ void CopyToEntries(System.Collections.DictionaryEntry[] array, int index);
                /*0x1f30ee8*/ void CopyToObjects(object[] array, int index);
                /*0x1f30214*/ System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>> GetEnumerator();
                /*0x1ffc854*/ bool TryAddInternal(TKey key, int hashcode, TValue value, bool updateIfExists, bool acquireLock, ref TValue resultingValue);
                /*0x1ffc854*/ TValue get_Item(TKey key);
                /*0x1ffc854*/ void set_Item(TKey key, TValue value);
                /*0x1f2ffc8*/ int get_Count();
                /*0x1f2ffc8*/ int GetCountInternal();
                /*0x1ffc854*/ TValue GetOrAdd(TKey key, System.Func<TKey, TValue> valueFactory);
                /*0x1ffc854*/ TValue GetOrAdd(TKey key, TValue value);
                /*0x1ffc854*/ TValue AddOrUpdate(TKey key, System.Func<TKey, TValue> addValueFactory, System.Func<TKey, TValue, TValue> updateValueFactory);
                /*0x1ffc854*/ TValue AddOrUpdate(TKey key, TValue addValue, System.Func<TKey, TValue, TValue> updateValueFactory);
                /*0x1ffc854*/ void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
                /*0x1ffc854*/ bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
                /*0x1f30214*/ System.Collections.Generic.ICollection<TKey> get_Keys();
                /*0x1f30214*/ System.Collections.Generic.IEnumerable<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
                /*0x1f30214*/ System.Collections.Generic.ICollection<TValue> get_Values();
                /*0x1f30214*/ System.Collections.Generic.IEnumerable<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
                /*0x1ffc854*/ void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(System.Collections.Generic.KeyValuePair<TKey, TValue> keyValuePair);
                /*0x1ffc854*/ bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(System.Collections.Generic.KeyValuePair<TKey, TValue> keyValuePair);
                /*0x1f2fe14*/ bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
                /*0x1ffc854*/ bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(System.Collections.Generic.KeyValuePair<TKey, TValue> keyValuePair);
                /*0x1f30214*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                /*0x1f30ff0*/ void System.Collections.IDictionary.Add(object key, object value);
                /*0x1f2fec8*/ bool System.Collections.IDictionary.Contains(object key);
                /*0x1f30214*/ System.Collections.IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
                /*0x1f2fe14*/ bool System.Collections.IDictionary.get_IsFixedSize();
                /*0x1f2fe14*/ bool System.Collections.IDictionary.get_IsReadOnly();
                /*0x1f30214*/ System.Collections.ICollection System.Collections.IDictionary.get_Keys();
                /*0x1f30ebc*/ void System.Collections.IDictionary.Remove(object key);
                /*0x1f30214*/ System.Collections.ICollection System.Collections.IDictionary.get_Values();
                /*0x1f302cc*/ object System.Collections.IDictionary.get_Item(object key);
                /*0x1f30ff0*/ void System.Collections.IDictionary.set_Item(object key, object value);
                /*0x1f30ee8*/ void System.Collections.ICollection.CopyTo(System.Array array, int index);
                /*0x1f2fe14*/ bool System.Collections.ICollection.get_IsSynchronized();
                /*0x1f30214*/ object System.Collections.ICollection.get_SyncRoot();
                /*0x1f30ebc*/ void GrowTable(System.Collections.Concurrent.ConcurrentDictionary.Tables<TKey, TValue> tables);
                /*0x1f30ebc*/ void AcquireAllLocks(ref int locksAcquired);
                /*0x1f30bfc*/ void AcquireLocks(int fromInclusive, int toExclusive, ref int locksAcquired);
                /*0x1f30bb4*/ void ReleaseLocks(int fromInclusive, int toExclusive);
                /*0x1f30214*/ System.Collections.ObjectModel.ReadOnlyCollection<TKey> GetKeys();
                /*0x1f30214*/ System.Collections.ObjectModel.ReadOnlyCollection<TValue> GetValues();
                /*0x1f315f0*/ void OnSerializing(System.Runtime.Serialization.StreamingContext context);
                /*0x1f315f0*/ void OnSerialized(System.Runtime.Serialization.StreamingContext context);
                /*0x1f315f0*/ void OnDeserialized(System.Runtime.Serialization.StreamingContext context);

                class Tables<TKey, TValue>
                {
                    /*0x0*/ System.Collections.Concurrent.ConcurrentDictionary.Node<TKey, TValue> _buckets;
                    /*0x0*/ object[] _locks;
                    /*0x0*/ int[] _countPerLock;

                    /*0x1f310fc*/ Tables(System.Collections.Concurrent.ConcurrentDictionary.Node<TKey, TValue> buckets, object[] locks, int[] countPerLock);
                }

                class Node<TKey, TValue>
                {
                    /*0x0*/ TKey _key;
                    /*0x0*/ TValue _value;
                    /*0x0*/ System.Collections.Concurrent.ConcurrentDictionary.Node<TKey, TValue> _next;
                    /*0x0*/ int _hashcode;

                    /*0x1ffc854*/ Node(TKey key, TValue value, int hashcode, System.Collections.Concurrent.ConcurrentDictionary.Node<TKey, TValue> next);
                }

                class DictionaryEnumerator<TKey, TValue> : System.Collections.IDictionaryEnumerator, System.Collections.IEnumerator
                {
                    /*0x0*/ System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>> _enumerator;

                    /*0x1f30ebc*/ DictionaryEnumerator(System.Collections.Concurrent.ConcurrentDictionary<TKey, TValue> dictionary);
                    System.Collections.DictionaryEntry get_Entry();
                    /*0x1f30214*/ object get_Key();
                    /*0x1f30214*/ object get_Value();
                    /*0x1f30214*/ object get_Current();
                    /*0x1f2fe14*/ bool MoveNext();
                    /*0x1f309e4*/ void Reset();
                }

                class <GetEnumerator>d__35<TKey, TValue> : System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.IDisposable, System.Collections.IEnumerator
                {
                    /*0x0*/ int <>1__state;
                    /*0x0*/ System.Collections.Generic.KeyValuePair<TKey, TValue> <>2__current;
                    /*0x0*/ System.Collections.Concurrent.ConcurrentDictionary<TKey, TValue> <>4__this;
                    /*0x0*/ System.Collections.Concurrent.ConcurrentDictionary.Node<TKey, TValue> <buckets>5__2;
                    /*0x0*/ int <i>5__3;
                    /*0x0*/ System.Collections.Concurrent.ConcurrentDictionary.Node<TKey, TValue> <current>5__4;

                    /*0x1f30b78*/ <GetEnumerator>d__35(int <>1__state);
                    /*0x1f309e4*/ void System.IDisposable.Dispose();
                    /*0x1f2fe14*/ bool MoveNext();
                    /*0x1ffc854*/ System.Collections.Generic.KeyValuePair<TKey, TValue> System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_Current();
                    /*0x1f309e4*/ void System.Collections.IEnumerator.Reset();
                    /*0x1f30214*/ object System.Collections.IEnumerator.get_Current();
                }
            }

            class IDictionaryDebugView<K, V>
            {
            }

            class IProducerConsumerCollectionDebugView<T>
            {
            }
        }

        namespace ObjectModel
        {
            class Collection<T> : System.Collections.Generic.IList<T>, System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.Collections.IList, System.Collections.ICollection, System.Collections.Generic.IReadOnlyList<T>, System.Collections.Generic.IReadOnlyCollection<T>
            {
                /*0x0*/ System.Collections.Generic.IList<T> items;

                static /*0x1f31840*/ bool IsCompatibleObject(object value);
                /*0x1f309e4*/ Collection();
                /*0x1f30ebc*/ Collection(System.Collections.Generic.IList<T> list);
                /*0x1f2ffc8*/ int get_Count();
                /*0x1f30214*/ System.Collections.Generic.IList<T> get_Items();
                /*0x1ffc854*/ T get_Item(int index);
                /*0x1ffc854*/ void set_Item(int index, T value);
                /*0x1ffc854*/ void Add(T item);
                /*0x1f309e4*/ void Clear();
                /*0x1f30ee8*/ void CopyTo(T[] array, int index);
                /*0x1ffc854*/ bool Contains(T item);
                /*0x1f30214*/ System.Collections.Generic.IEnumerator<T> GetEnumerator();
                /*0x1ffc854*/ int IndexOf(T item);
                /*0x1ffc854*/ void Insert(int index, T item);
                /*0x1ffc854*/ bool Remove(T item);
                /*0x1f30b78*/ void RemoveAt(int index);
                /*0x1f309e4*/ void ClearItems();
                /*0x1ffc854*/ void InsertItem(int index, T item);
                /*0x1f30b78*/ void RemoveItem(int index);
                /*0x1ffc854*/ void SetItem(int index, T item);
                /*0x1f2fe14*/ bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
                /*0x1f30214*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                /*0x1f2fe14*/ bool System.Collections.ICollection.get_IsSynchronized();
                /*0x1f30214*/ object System.Collections.ICollection.get_SyncRoot();
                /*0x1f30ee8*/ void System.Collections.ICollection.CopyTo(System.Array array, int index);
                /*0x1f30240*/ object System.Collections.IList.get_Item(int index);
                /*0x1f30c88*/ void System.Collections.IList.set_Item(int index, object value);
                /*0x1f2fe14*/ bool System.Collections.IList.get_IsReadOnly();
                /*0x1f2fe14*/ bool System.Collections.IList.get_IsFixedSize();
                /*0x1f3008c*/ int System.Collections.IList.Add(object value);
                /*0x1f2fec8*/ bool System.Collections.IList.Contains(object value);
                /*0x1f3008c*/ int System.Collections.IList.IndexOf(object value);
                /*0x1f30c88*/ void System.Collections.IList.Insert(int index, object value);
                /*0x1f30ebc*/ void System.Collections.IList.Remove(object value);
            }

            class ReadOnlyCollection<T> : System.Collections.Generic.IList<T>, System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.Collections.IList, System.Collections.ICollection, System.Collections.Generic.IReadOnlyList<T>, System.Collections.Generic.IReadOnlyCollection<T>
            {
                /*0x0*/ System.Collections.Generic.IList<T> list;
                /*0x0*/ object _syncRoot;

                static /*0x1f31840*/ bool IsCompatibleObject(object value);
                /*0x1f30ebc*/ ReadOnlyCollection(System.Collections.Generic.IList<T> list);
                /*0x1f2ffc8*/ int get_Count();
                /*0x1ffc854*/ T get_Item(int index);
                /*0x1ffc854*/ bool Contains(T value);
                /*0x1f30ee8*/ void CopyTo(T[] array, int index);
                /*0x1f30214*/ System.Collections.Generic.IEnumerator<T> GetEnumerator();
                /*0x1ffc854*/ int IndexOf(T value);
                /*0x1f2fe14*/ bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
                /*0x1ffc854*/ T System.Collections.Generic.IList<T>.get_Item(int index);
                /*0x1ffc854*/ void System.Collections.Generic.IList<T>.set_Item(int index, T value);
                /*0x1ffc854*/ void System.Collections.Generic.ICollection<T>.Add(T value);
                /*0x1f309e4*/ void System.Collections.Generic.ICollection<T>.Clear();
                /*0x1ffc854*/ void System.Collections.Generic.IList<T>.Insert(int index, T value);
                /*0x1ffc854*/ bool System.Collections.Generic.ICollection<T>.Remove(T value);
                /*0x1f30b78*/ void System.Collections.Generic.IList<T>.RemoveAt(int index);
                /*0x1f30214*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                /*0x1f2fe14*/ bool System.Collections.ICollection.get_IsSynchronized();
                /*0x1f30214*/ object System.Collections.ICollection.get_SyncRoot();
                /*0x1f30ee8*/ void System.Collections.ICollection.CopyTo(System.Array array, int index);
                /*0x1f2fe14*/ bool System.Collections.IList.get_IsFixedSize();
                /*0x1f2fe14*/ bool System.Collections.IList.get_IsReadOnly();
                /*0x1f30240*/ object System.Collections.IList.get_Item(int index);
                /*0x1f30c88*/ void System.Collections.IList.set_Item(int index, object value);
                /*0x1f3008c*/ int System.Collections.IList.Add(object value);
                /*0x1f309e4*/ void System.Collections.IList.Clear();
                /*0x1f2fec8*/ bool System.Collections.IList.Contains(object value);
                /*0x1f3008c*/ int System.Collections.IList.IndexOf(object value);
                /*0x1f30c88*/ void System.Collections.IList.Insert(int index, object value);
                /*0x1f30ebc*/ void System.Collections.IList.Remove(object value);
                /*0x1f30b78*/ void System.Collections.IList.RemoveAt(int index);
            }

            class KeyedCollection<TKey, TItem> : System.Collections.ObjectModel.Collection<TItem>
            {
                /*0x0*/ System.Collections.Generic.IEqualityComparer<TKey> comparer;
                /*0x0*/ System.Collections.Generic.Dictionary<TKey, TItem> dict;
                /*0x0*/ int keyCount;
                /*0x0*/ int threshold;

                /*0x1f309e4*/ KeyedCollection();
                /*0x1f30ebc*/ KeyedCollection(System.Collections.Generic.IEqualityComparer<TKey> comparer);
                /*0x1f30ee8*/ KeyedCollection(System.Collections.Generic.IEqualityComparer<TKey> comparer, int dictionaryCreationThreshold);
                /*0x1f30214*/ System.Collections.Generic.List<TItem> get_Items();
                /*0x1ffc854*/ TItem get_Item(TKey key);
                /*0x1ffc854*/ bool Contains(TKey key);
                /*0x1ffc854*/ bool TryGetValue(TKey key, ref TItem item);
                /*0x1f30214*/ System.Collections.Generic.IDictionary<TKey, TItem> get_Dictionary();
                /*0x1f309e4*/ void ClearItems();
                /*0x1ffc854*/ TKey GetKeyForItem(TItem item);
                /*0x1ffc854*/ void InsertItem(int index, TItem item);
                /*0x1f30b78*/ void RemoveItem(int index);
                /*0x1ffc854*/ void SetItem(int index, TItem item);
                /*0x1ffc854*/ void AddKey(TKey key, TItem item);
                /*0x1f309e4*/ void CreateDictionary();
                /*0x1ffc854*/ void RemoveKey(TKey key);
            }

            class ReadOnlyDictionary<TKey, TValue> : System.Collections.Generic.IDictionary<TKey, TValue>, System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.IEnumerable, System.Collections.IDictionary, System.Collections.ICollection, System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>, System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>
            {
                /*0x0*/ System.Collections.Generic.IDictionary<TKey, TValue> m_dictionary;
                /*0x0*/ object _syncRoot;
                /*0x0*/ System.Collections.ObjectModel.ReadOnlyDictionary.KeyCollection<TKey, TValue> _keys;
                /*0x0*/ System.Collections.ObjectModel.ReadOnlyDictionary.ValueCollection<TKey, TValue> _values;

                static /*0x1f31840*/ bool IsCompatibleKey(object key);
                /*0x1f30ebc*/ ReadOnlyDictionary(System.Collections.Generic.IDictionary<TKey, TValue> dictionary);
                /*0x1f30214*/ System.Collections.ObjectModel.ReadOnlyDictionary.KeyCollection<TKey, TValue> get_Keys();
                /*0x1f30214*/ System.Collections.ObjectModel.ReadOnlyDictionary.ValueCollection<TKey, TValue> get_Values();
                /*0x1ffc854*/ bool ContainsKey(TKey key);
                /*0x1f30214*/ System.Collections.Generic.ICollection<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
                /*0x1ffc854*/ bool TryGetValue(TKey key, ref TValue value);
                /*0x1f30214*/ System.Collections.Generic.ICollection<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
                /*0x1ffc854*/ TValue get_Item(TKey key);
                /*0x1ffc854*/ void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
                /*0x1ffc854*/ bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
                /*0x1ffc854*/ TValue System.Collections.Generic.IDictionary<TKey,TValue>.get_Item(TKey key);
                /*0x1ffc854*/ void System.Collections.Generic.IDictionary<TKey,TValue>.set_Item(TKey key, TValue value);
                /*0x1f2ffc8*/ int get_Count();
                /*0x1ffc854*/ bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(System.Collections.Generic.KeyValuePair<TKey, TValue> item);
                /*0x1f30ee8*/ void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(System.Collections.Generic.KeyValuePair<TKey, TValue> array, int arrayIndex);
                /*0x1f2fe14*/ bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
                /*0x1ffc854*/ void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(System.Collections.Generic.KeyValuePair<TKey, TValue> item);
                /*0x1f309e4*/ void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear();
                /*0x1ffc854*/ bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(System.Collections.Generic.KeyValuePair<TKey, TValue> item);
                /*0x1f30214*/ System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>> GetEnumerator();
                /*0x1f30214*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                /*0x1f30ff0*/ void System.Collections.IDictionary.Add(object key, object value);
                /*0x1f309e4*/ void System.Collections.IDictionary.Clear();
                /*0x1f2fec8*/ bool System.Collections.IDictionary.Contains(object key);
                /*0x1f30214*/ System.Collections.IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
                /*0x1f2fe14*/ bool System.Collections.IDictionary.get_IsFixedSize();
                /*0x1f2fe14*/ bool System.Collections.IDictionary.get_IsReadOnly();
                /*0x1f30214*/ System.Collections.ICollection System.Collections.IDictionary.get_Keys();
                /*0x1f30ebc*/ void System.Collections.IDictionary.Remove(object key);
                /*0x1f30214*/ System.Collections.ICollection System.Collections.IDictionary.get_Values();
                /*0x1f302cc*/ object System.Collections.IDictionary.get_Item(object key);
                /*0x1f30ff0*/ void System.Collections.IDictionary.set_Item(object key, object value);
                /*0x1f30ee8*/ void System.Collections.ICollection.CopyTo(System.Array array, int index);
                /*0x1f2fe14*/ bool System.Collections.ICollection.get_IsSynchronized();
                /*0x1f30214*/ object System.Collections.ICollection.get_SyncRoot();
                /*0x1f30214*/ System.Collections.Generic.IEnumerable<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
                /*0x1f30214*/ System.Collections.Generic.IEnumerable<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();

                struct DictionaryEnumerator<TKey, TValue> : System.Collections.IDictionaryEnumerator, System.Collections.IEnumerator
                {
                    /*0x0*/ System.Collections.Generic.IDictionary<TKey, TValue> _dictionary;
                    /*0x0*/ System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>> _enumerator;

                    /*0x1f30ebc*/ DictionaryEnumerator(System.Collections.Generic.IDictionary<TKey, TValue> dictionary);
                    System.Collections.DictionaryEntry get_Entry();
                    /*0x1f30214*/ object get_Key();
                    /*0x1f30214*/ object get_Value();
                    /*0x1f30214*/ object get_Current();
                    /*0x1f2fe14*/ bool MoveNext();
                    /*0x1f309e4*/ void Reset();
                }

                class KeyCollection<TKey, TValue> : System.Collections.Generic.ICollection<TKey>, System.Collections.Generic.IEnumerable<TKey>, System.Collections.IEnumerable, System.Collections.ICollection, System.Collections.Generic.IReadOnlyCollection<TKey>
                {
                    /*0x0*/ System.Collections.Generic.ICollection<TKey> _collection;
                    /*0x0*/ object _syncRoot;

                    /*0x1f30ebc*/ KeyCollection(System.Collections.Generic.ICollection<TKey> collection);
                    /*0x1f309e4*/ KeyCollection();
                    /*0x1ffc854*/ void System.Collections.Generic.ICollection<TKey>.Add(TKey item);
                    /*0x1f309e4*/ void System.Collections.Generic.ICollection<TKey>.Clear();
                    /*0x1ffc854*/ bool System.Collections.Generic.ICollection<TKey>.Contains(TKey item);
                    /*0x1f30ee8*/ void CopyTo(TKey[] array, int arrayIndex);
                    /*0x1f2ffc8*/ int get_Count();
                    /*0x1f2fe14*/ bool System.Collections.Generic.ICollection<TKey>.get_IsReadOnly();
                    /*0x1ffc854*/ bool System.Collections.Generic.ICollection<TKey>.Remove(TKey item);
                    /*0x1f30214*/ System.Collections.Generic.IEnumerator<TKey> GetEnumerator();
                    /*0x1f30214*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                    /*0x1f30ee8*/ void System.Collections.ICollection.CopyTo(System.Array array, int index);
                    /*0x1f2fe14*/ bool System.Collections.ICollection.get_IsSynchronized();
                    /*0x1f30214*/ object System.Collections.ICollection.get_SyncRoot();
                }

                class ValueCollection<TKey, TValue> : System.Collections.Generic.ICollection<TValue>, System.Collections.Generic.IEnumerable<TValue>, System.Collections.IEnumerable, System.Collections.ICollection, System.Collections.Generic.IReadOnlyCollection<TValue>
                {
                    /*0x0*/ System.Collections.Generic.ICollection<TValue> _collection;
                    /*0x0*/ object _syncRoot;

                    /*0x1f30ebc*/ ValueCollection(System.Collections.Generic.ICollection<TValue> collection);
                    /*0x1f309e4*/ ValueCollection();
                    /*0x1ffc854*/ void System.Collections.Generic.ICollection<TValue>.Add(TValue item);
                    /*0x1f309e4*/ void System.Collections.Generic.ICollection<TValue>.Clear();
                    /*0x1ffc854*/ bool System.Collections.Generic.ICollection<TValue>.Contains(TValue item);
                    /*0x1f30ee8*/ void CopyTo(TValue[] array, int arrayIndex);
                    /*0x1f2ffc8*/ int get_Count();
                    /*0x1f2fe14*/ bool System.Collections.Generic.ICollection<TValue>.get_IsReadOnly();
                    /*0x1ffc854*/ bool System.Collections.Generic.ICollection<TValue>.Remove(TValue item);
                    /*0x1f30214*/ System.Collections.Generic.IEnumerator<TValue> GetEnumerator();
                    /*0x1f30214*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                    /*0x1f30ee8*/ void System.Collections.ICollection.CopyTo(System.Array array, int index);
                    /*0x1f2fe14*/ bool System.Collections.ICollection.get_IsSynchronized();
                    /*0x1f30214*/ object System.Collections.ICollection.get_SyncRoot();
                }
            }

            class ReadOnlyDictionaryHelpers
            {
                static /*0x1f370c8*/ void CopyToNonGenericICollectionHelper<T>(System.Collections.Generic.ICollection<T> collection, System.Array array, int index);
            }
        }

        namespace Generic
        {
            enum InsertionBehavior
            {
                None = 0,
                OverwriteExisting = 1,
                ThrowOnExisting = 2,
            }

            class Dictionary<TKey, TValue> : System.Collections.Generic.IDictionary<TKey, TValue>, System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.IEnumerable, System.Collections.IDictionary, System.Collections.ICollection, System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>, System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IDeserializationCallback
            {
                /*0x0*/ int[] _buckets;
                /*0x0*/ System.Collections.Generic.Dictionary.Entry<TKey, TValue> _entries;
                /*0x0*/ int _count;
                /*0x0*/ int _freeList;
                /*0x0*/ int _freeCount;
                /*0x0*/ int _version;
                /*0x0*/ System.Collections.Generic.IEqualityComparer<TKey> _comparer;
                /*0x0*/ System.Collections.Generic.Dictionary.KeyCollection<TKey, TValue> _keys;
                /*0x0*/ System.Collections.Generic.Dictionary.ValueCollection<TKey, TValue> _values;
                /*0x0*/ object _syncRoot;

                static /*0x1f31840*/ bool IsCompatibleKey(object key);
                /*0x1f309e4*/ Dictionary();
                /*0x1f30b78*/ Dictionary(int capacity);
                /*0x1f30ebc*/ Dictionary(System.Collections.Generic.IEqualityComparer<TKey> comparer);
                /*0x1f30c88*/ Dictionary(int capacity, System.Collections.Generic.IEqualityComparer<TKey> comparer);
                /*0x1f30ebc*/ Dictionary(System.Collections.Generic.IDictionary<TKey, TValue> dictionary);
                /*0x1f30ff0*/ Dictionary(System.Collections.Generic.IDictionary<TKey, TValue> dictionary, System.Collections.Generic.IEqualityComparer<TKey> comparer);
                Dictionary(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x1f2ffc8*/ int get_Count();
                /*0x1f30214*/ System.Collections.Generic.Dictionary.KeyCollection<TKey, TValue> get_Keys();
                /*0x1f30214*/ System.Collections.Generic.ICollection<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
                /*0x1f30214*/ System.Collections.Generic.IEnumerable<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
                /*0x1f30214*/ System.Collections.Generic.Dictionary.ValueCollection<TKey, TValue> get_Values();
                /*0x1f30214*/ System.Collections.Generic.ICollection<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
                /*0x1f30214*/ System.Collections.Generic.IEnumerable<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
                /*0x1ffc854*/ TValue get_Item(TKey key);
                /*0x1ffc854*/ void set_Item(TKey key, TValue value);
                /*0x1ffc854*/ void Add(TKey key, TValue value);
                /*0x1ffc854*/ void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(System.Collections.Generic.KeyValuePair<TKey, TValue> keyValuePair);
                /*0x1ffc854*/ bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(System.Collections.Generic.KeyValuePair<TKey, TValue> keyValuePair);
                /*0x1ffc854*/ bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(System.Collections.Generic.KeyValuePair<TKey, TValue> keyValuePair);
                /*0x1f309e4*/ void Clear();
                /*0x1ffc854*/ bool ContainsKey(TKey key);
                /*0x1ffc854*/ bool ContainsValue(TValue value);
                /*0x1f30ee8*/ void CopyTo(System.Collections.Generic.KeyValuePair<TKey, TValue> array, int index);
                /*0x1ffc854*/ System.Collections.Generic.Dictionary.Enumerator<TKey, TValue> GetEnumerator();
                /*0x1f30214*/ System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
                void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x1ffc854*/ int FindEntry(TKey key);
                int Initialize(int capacity);
                /*0x1ffc854*/ bool TryInsert(TKey key, TValue value, System.Collections.Generic.InsertionBehavior behavior);
                /*0x1f30ebc*/ void OnDeserialization(object sender);
                /*0x1f309e4*/ void Resize();
                void Resize(int newSize, bool forceNewHashCodes);
                /*0x1ffc854*/ bool Remove(TKey key);
                /*0x1ffc854*/ bool Remove(TKey key, ref TValue value);
                /*0x1ffc854*/ bool TryGetValue(TKey key, ref TValue value);
                /*0x1ffc854*/ bool TryAdd(TKey key, TValue value);
                /*0x1f2fe14*/ bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
                /*0x1f30ee8*/ void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(System.Collections.Generic.KeyValuePair<TKey, TValue> array, int index);
                /*0x1f30ee8*/ void System.Collections.ICollection.CopyTo(System.Array array, int index);
                /*0x1f30214*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                int EnsureCapacity(int capacity);
                /*0x1f2fe14*/ bool System.Collections.ICollection.get_IsSynchronized();
                /*0x1f30214*/ object System.Collections.ICollection.get_SyncRoot();
                /*0x1f2fe14*/ bool System.Collections.IDictionary.get_IsFixedSize();
                /*0x1f2fe14*/ bool System.Collections.IDictionary.get_IsReadOnly();
                /*0x1f30214*/ System.Collections.ICollection System.Collections.IDictionary.get_Keys();
                /*0x1f30214*/ System.Collections.ICollection System.Collections.IDictionary.get_Values();
                /*0x1f302cc*/ object System.Collections.IDictionary.get_Item(object key);
                /*0x1f30ff0*/ void System.Collections.IDictionary.set_Item(object key, object value);
                /*0x1f30ff0*/ void System.Collections.IDictionary.Add(object key, object value);
                /*0x1f2fec8*/ bool System.Collections.IDictionary.Contains(object key);
                /*0x1f30214*/ System.Collections.IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
                /*0x1f30ebc*/ void System.Collections.IDictionary.Remove(object key);

                struct Entry<TKey, TValue>
                {
                    /*0x0*/ int hashCode;
                    /*0x0*/ int next;
                    /*0x0*/ TKey key;
                    /*0x0*/ TValue value;
                }

                struct Enumerator<TKey, TValue> : System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.IDisposable, System.Collections.IEnumerator, System.Collections.IDictionaryEnumerator
                {
                    /*0x0*/ System.Collections.Generic.Dictionary<TKey, TValue> _dictionary;
                    /*0x0*/ int _version;
                    /*0x0*/ int _index;
                    /*0x0*/ System.Collections.Generic.KeyValuePair<TKey, TValue> _current;
                    /*0x0*/ int _getEnumeratorRetType;

                    /*0x1f30ee8*/ Enumerator(System.Collections.Generic.Dictionary<TKey, TValue> dictionary, int getEnumeratorRetType);
                    /*0x1f2fe14*/ bool MoveNext();
                    /*0x1ffc854*/ System.Collections.Generic.KeyValuePair<TKey, TValue> get_Current();
                    /*0x1f309e4*/ void Dispose();
                    /*0x1f30214*/ object System.Collections.IEnumerator.get_Current();
                    /*0x1f309e4*/ void System.Collections.IEnumerator.Reset();
                    System.Collections.DictionaryEntry System.Collections.IDictionaryEnumerator.get_Entry();
                    /*0x1f30214*/ object System.Collections.IDictionaryEnumerator.get_Key();
                    /*0x1f30214*/ object System.Collections.IDictionaryEnumerator.get_Value();
                }

                class KeyCollection<TKey, TValue> : System.Collections.Generic.ICollection<TKey>, System.Collections.Generic.IEnumerable<TKey>, System.Collections.IEnumerable, System.Collections.ICollection, System.Collections.Generic.IReadOnlyCollection<TKey>
                {
                    /*0x0*/ System.Collections.Generic.Dictionary<TKey, TValue> _dictionary;

                    /*0x1f30ebc*/ KeyCollection(System.Collections.Generic.Dictionary<TKey, TValue> dictionary);
                    /*0x1ffc854*/ System.Collections.Generic.Dictionary.KeyCollection.Enumerator<TKey, TValue> GetEnumerator();
                    /*0x1f30ee8*/ void CopyTo(TKey[] array, int index);
                    /*0x1f2ffc8*/ int get_Count();
                    /*0x1f2fe14*/ bool System.Collections.Generic.ICollection<TKey>.get_IsReadOnly();
                    /*0x1ffc854*/ void System.Collections.Generic.ICollection<TKey>.Add(TKey item);
                    /*0x1f309e4*/ void System.Collections.Generic.ICollection<TKey>.Clear();
                    /*0x1ffc854*/ bool System.Collections.Generic.ICollection<TKey>.Contains(TKey item);
                    /*0x1ffc854*/ bool System.Collections.Generic.ICollection<TKey>.Remove(TKey item);
                    /*0x1f30214*/ System.Collections.Generic.IEnumerator<TKey> System.Collections.Generic.IEnumerable<TKey>.GetEnumerator();
                    /*0x1f30214*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                    /*0x1f30ee8*/ void System.Collections.ICollection.CopyTo(System.Array array, int index);
                    /*0x1f2fe14*/ bool System.Collections.ICollection.get_IsSynchronized();
                    /*0x1f30214*/ object System.Collections.ICollection.get_SyncRoot();

                    struct Enumerator<TKey, TValue> : System.Collections.Generic.IEnumerator<TKey>, System.IDisposable, System.Collections.IEnumerator
                    {
                        /*0x0*/ System.Collections.Generic.Dictionary<TKey, TValue> _dictionary;
                        /*0x0*/ int _index;
                        /*0x0*/ int _version;
                        /*0x0*/ TKey _currentKey;

                        /*0x1f30ebc*/ Enumerator(System.Collections.Generic.Dictionary<TKey, TValue> dictionary);
                        /*0x1f309e4*/ void Dispose();
                        /*0x1f2fe14*/ bool MoveNext();
                        /*0x1ffc854*/ TKey get_Current();
                        /*0x1f30214*/ object System.Collections.IEnumerator.get_Current();
                        /*0x1f309e4*/ void System.Collections.IEnumerator.Reset();
                    }
                }

                class ValueCollection<TKey, TValue> : System.Collections.Generic.ICollection<TValue>, System.Collections.Generic.IEnumerable<TValue>, System.Collections.IEnumerable, System.Collections.ICollection, System.Collections.Generic.IReadOnlyCollection<TValue>
                {
                    /*0x0*/ System.Collections.Generic.Dictionary<TKey, TValue> _dictionary;

                    /*0x1f30ebc*/ ValueCollection(System.Collections.Generic.Dictionary<TKey, TValue> dictionary);
                    /*0x1ffc854*/ System.Collections.Generic.Dictionary.ValueCollection.Enumerator<TKey, TValue> GetEnumerator();
                    /*0x1f30ee8*/ void CopyTo(TValue[] array, int index);
                    /*0x1f2ffc8*/ int get_Count();
                    /*0x1f2fe14*/ bool System.Collections.Generic.ICollection<TValue>.get_IsReadOnly();
                    /*0x1ffc854*/ void System.Collections.Generic.ICollection<TValue>.Add(TValue item);
                    /*0x1ffc854*/ bool System.Collections.Generic.ICollection<TValue>.Remove(TValue item);
                    /*0x1f309e4*/ void System.Collections.Generic.ICollection<TValue>.Clear();
                    /*0x1ffc854*/ bool System.Collections.Generic.ICollection<TValue>.Contains(TValue item);
                    /*0x1f30214*/ System.Collections.Generic.IEnumerator<TValue> System.Collections.Generic.IEnumerable<TValue>.GetEnumerator();
                    /*0x1f30214*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                    /*0x1f30ee8*/ void System.Collections.ICollection.CopyTo(System.Array array, int index);
                    /*0x1f2fe14*/ bool System.Collections.ICollection.get_IsSynchronized();
                    /*0x1f30214*/ object System.Collections.ICollection.get_SyncRoot();

                    struct Enumerator<TKey, TValue> : System.Collections.Generic.IEnumerator<TValue>, System.IDisposable, System.Collections.IEnumerator
                    {
                        /*0x0*/ System.Collections.Generic.Dictionary<TKey, TValue> _dictionary;
                        /*0x0*/ int _index;
                        /*0x0*/ int _version;
                        /*0x0*/ TValue _currentValue;

                        /*0x1f30ebc*/ Enumerator(System.Collections.Generic.Dictionary<TKey, TValue> dictionary);
                        /*0x1f309e4*/ void Dispose();
                        /*0x1f2fe14*/ bool MoveNext();
                        /*0x1ffc854*/ TValue get_Current();
                        /*0x1f30214*/ object System.Collections.IEnumerator.get_Current();
                        /*0x1f309e4*/ void System.Collections.IEnumerator.Reset();
                    }
                }
            }

            interface ICollection<T> : System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable
            {
                /*0x1f2ffc8*/ int get_Count();
                /*0x1f2fe14*/ bool get_IsReadOnly();
                /*0x1ffc854*/ void Add(T item);
                /*0x1f309e4*/ void Clear();
                /*0x1ffc854*/ bool Contains(T item);
                /*0x1f30ee8*/ void CopyTo(T[] array, int arrayIndex);
                /*0x1ffc854*/ bool Remove(T item);
            }

            class ICollectionDebugView<T>
            {
            }

            interface IComparer<T>
            {
                /*0x1ffc854*/ int Compare(T x, T y);
            }

            interface IDictionary<TKey, TValue> : System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.IEnumerable
            {
                /*0x1ffc854*/ TValue get_Item(TKey key);
                /*0x1ffc854*/ void set_Item(TKey key, TValue value);
                /*0x1f30214*/ System.Collections.Generic.ICollection<TKey> get_Keys();
                /*0x1f30214*/ System.Collections.Generic.ICollection<TValue> get_Values();
                /*0x1ffc854*/ bool ContainsKey(TKey key);
                /*0x1ffc854*/ void Add(TKey key, TValue value);
                /*0x1ffc854*/ bool Remove(TKey key);
                /*0x1ffc854*/ bool TryGetValue(TKey key, ref TValue value);
            }

            class IDictionaryDebugView<K, V>
            {
            }

            class DictionaryKeyCollectionDebugView<TKey, TValue>
            {
            }

            class DictionaryValueCollectionDebugView<TKey, TValue>
            {
            }

            interface IEnumerable<T> : System.Collections.IEnumerable
            {
                /*0x1f30214*/ System.Collections.Generic.IEnumerator<T> GetEnumerator();
            }

            interface IEnumerator<T> : System.IDisposable, System.Collections.IEnumerator
            {
                /*0x1ffc854*/ T get_Current();
            }

            interface IEqualityComparer<T>
            {
                /*0x1ffc854*/ bool Equals(T x, T y);
                /*0x1ffc854*/ int GetHashCode(T obj);
            }

            interface IList<T> : System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable
            {
                /*0x1ffc854*/ T get_Item(int index);
                /*0x1ffc854*/ void set_Item(int index, T value);
                /*0x1ffc854*/ int IndexOf(T item);
                /*0x1ffc854*/ void Insert(int index, T item);
                /*0x1f30b78*/ void RemoveAt(int index);
            }

            interface IReadOnlyCollection<T> : System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable
            {
                /*0x1f2ffc8*/ int get_Count();
            }

            interface IReadOnlyDictionary<TKey, TValue> : System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.IEnumerable
            {
                /*0x1ffc854*/ bool ContainsKey(TKey key);
                /*0x1ffc854*/ bool TryGetValue(TKey key, ref TValue value);
                /*0x1ffc854*/ TValue get_Item(TKey key);
                /*0x1f30214*/ System.Collections.Generic.IEnumerable<TKey> get_Keys();
                /*0x1f30214*/ System.Collections.Generic.IEnumerable<TValue> get_Values();
            }

            interface IReadOnlyList<T> : System.Collections.Generic.IReadOnlyCollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable
            {
                /*0x1ffc854*/ T get_Item(int index);
            }

            class KeyNotFoundException : System.SystemException
            {
                /*0x3250754*/ KeyNotFoundException();
                /*0x32507b0*/ KeyNotFoundException(string message);
                /*0x32507d4*/ KeyNotFoundException(string message, System.Exception innerException);
                /*0x32507f8*/ KeyNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            }

            class KeyValuePair
            {
                static /*0x3250800*/ string PairToString(object key, object value);
            }

            struct KeyValuePair<TKey, TValue>
            {
                /*0x0*/ TKey key;
                /*0x0*/ TValue value;

                /*0x1ffc854*/ KeyValuePair(TKey key, TValue value);
                /*0x1ffc854*/ TKey get_Key();
                /*0x1ffc854*/ TValue get_Value();
                /*0x1f30214*/ string ToString();
                /*0x1f30ff0*/ void Deconstruct(ref TKey key, ref TValue value);
            }

            class List<T> : System.Collections.Generic.IList<T>, System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.Collections.IList, System.Collections.ICollection, System.Collections.Generic.IReadOnlyList<T>, System.Collections.Generic.IReadOnlyCollection<T>
            {
                static /*0x0*/ T[] s_emptyArray;
                /*0x0*/ T[] _items;
                /*0x0*/ int _size;
                /*0x0*/ int _version;
                /*0x0*/ object _syncRoot;

                static /*0x1f33998*/ List();
                static /*0x1f31840*/ bool IsCompatibleObject(object value);
                /*0x1f309e4*/ List();
                /*0x1f30b78*/ List(int capacity);
                /*0x1f30ebc*/ List(System.Collections.Generic.IEnumerable<T> collection);
                /*0x1f2ffc8*/ int get_Capacity();
                /*0x1f30b78*/ void set_Capacity(int value);
                /*0x1f2ffc8*/ int get_Count();
                /*0x1f2fe14*/ bool System.Collections.IList.get_IsFixedSize();
                /*0x1f2fe14*/ bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
                /*0x1f2fe14*/ bool System.Collections.IList.get_IsReadOnly();
                /*0x1f2fe14*/ bool System.Collections.ICollection.get_IsSynchronized();
                /*0x1f30214*/ object System.Collections.ICollection.get_SyncRoot();
                /*0x1ffc854*/ T get_Item(int index);
                /*0x1ffc854*/ void set_Item(int index, T value);
                /*0x1f30240*/ object System.Collections.IList.get_Item(int index);
                /*0x1f30c88*/ void System.Collections.IList.set_Item(int index, object value);
                /*0x1ffc854*/ void Add(T item);
                /*0x1ffc854*/ void AddWithResize(T item);
                /*0x1f3008c*/ int System.Collections.IList.Add(object item);
                /*0x1f30ebc*/ void AddRange(System.Collections.Generic.IEnumerable<T> collection);
                /*0x1f30214*/ System.Collections.ObjectModel.ReadOnlyCollection<T> AsReadOnly();
                /*0x1ffc854*/ int BinarySearch(int index, int count, T item, System.Collections.Generic.IComparer<T> comparer);
                /*0x1ffc854*/ int BinarySearch(T item);
                /*0x1ffc854*/ int BinarySearch(T item, System.Collections.Generic.IComparer<T> comparer);
                /*0x1f309e4*/ void Clear();
                /*0x1ffc854*/ bool Contains(T item);
                /*0x1f2fec8*/ bool System.Collections.IList.Contains(object item);
                /*0x1f302cc*/ System.Collections.Generic.List<TOutput> ConvertAll<TOutput>(System.Converter<T, TOutput> converter);
                /*0x1f30ebc*/ void CopyTo(T[] array);
                /*0x1f30ee8*/ void System.Collections.ICollection.CopyTo(System.Array array, int arrayIndex);
                void CopyTo(int index, T[] array, int arrayIndex, int count);
                /*0x1f30ee8*/ void CopyTo(T[] array, int arrayIndex);
                /*0x1f30b78*/ void EnsureCapacity(int min);
                /*0x1f2fec8*/ bool Exists(System.Predicate<T> match);
                /*0x1ffc854*/ T Find(System.Predicate<T> match);
                /*0x1f302cc*/ System.Collections.Generic.List<T> FindAll(System.Predicate<T> match);
                /*0x1f3008c*/ int FindIndex(System.Predicate<T> match);
                int FindIndex(int startIndex, System.Predicate<T> match);
                /*0x1ffc854*/ int FindIndex(int startIndex, int count, System.Predicate<T> match);
                /*0x1f30ebc*/ void ForEach(System.Action<T> action);
                /*0x1ffc854*/ System.Collections.Generic.List.Enumerator<T> GetEnumerator();
                /*0x1f30214*/ System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
                /*0x1f30214*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                System.Collections.Generic.List<T> GetRange(int index, int count);
                /*0x1ffc854*/ int IndexOf(T item);
                /*0x1f3008c*/ int System.Collections.IList.IndexOf(object item);
                /*0x1ffc854*/ void Insert(int index, T item);
                /*0x1f30c88*/ void System.Collections.IList.Insert(int index, object item);
                /*0x1f30c88*/ void InsertRange(int index, System.Collections.Generic.IEnumerable<T> collection);
                /*0x1ffc854*/ bool Remove(T item);
                /*0x1f30ebc*/ void System.Collections.IList.Remove(object item);
                /*0x1f3008c*/ int RemoveAll(System.Predicate<T> match);
                /*0x1f30b78*/ void RemoveAt(int index);
                /*0x1f30bb4*/ void RemoveRange(int index, int count);
                /*0x1f309e4*/ void Reverse();
                /*0x1f30bb4*/ void Reverse(int index, int count);
                /*0x1f309e4*/ void Sort();
                /*0x1f30ebc*/ void Sort(System.Collections.Generic.IComparer<T> comparer);
                /*0x1f30bfc*/ void Sort(int index, int count, System.Collections.Generic.IComparer<T> comparer);
                /*0x1f30ebc*/ void Sort(System.Comparison<T> comparison);
                /*0x1f30214*/ T[] ToArray();
                /*0x1f309e4*/ void TrimExcess();
                /*0x1f30ebc*/ void AddEnumerable(System.Collections.Generic.IEnumerable<T> enumerable);

                struct Enumerator<T> : System.Collections.Generic.IEnumerator<T>, System.IDisposable, System.Collections.IEnumerator
                {
                    /*0x0*/ System.Collections.Generic.List<T> _list;
                    /*0x0*/ int _index;
                    /*0x0*/ int _version;
                    /*0x0*/ T _current;

                    /*0x1f30ebc*/ Enumerator(System.Collections.Generic.List<T> list);
                    /*0x1f309e4*/ void Dispose();
                    /*0x1f2fe14*/ bool MoveNext();
                    /*0x1f2fe14*/ bool MoveNextRare();
                    /*0x1ffc854*/ T get_Current();
                    /*0x1f30214*/ object System.Collections.IEnumerator.get_Current();
                    /*0x1f309e4*/ void System.Collections.IEnumerator.Reset();
                }
            }

            struct ValueListBuilder<T>
            {
                /*0x0*/ System.Span<T> _span;
                /*0x0*/ T[] _arrayFromPool;
                /*0x0*/ int _pos;

                /*0x1ffc854*/ ValueListBuilder(System.Span<T> initialSpan);
                /*0x1f2ffc8*/ int get_Length();
                /*0x1ffc854*/ void Append(T item);
                /*0x1ffc854*/ System.ReadOnlySpan<T> AsSpan();
                /*0x1f309e4*/ void Dispose();
                /*0x1f309e4*/ void Grow();
            }

            struct ArrayBuilder<T>
            {
                /*0x0*/ T[] _array;
                /*0x0*/ int _count;

                /*0x1f2ffc8*/ int get_Capacity();
                /*0x1f2ffc8*/ int get_Count();
                /*0x1ffc854*/ T get_Item(int index);
                /*0x1ffc854*/ void Add(T item);
                /*0x1ffc854*/ void UncheckedAdd(T item);
                /*0x1f30b78*/ void EnsureCapacity(int minimum);
            }

            class EnumerableHelpers
            {
                static /*0x1f327cc*/ T[] ToArray<T>(System.Collections.Generic.IEnumerable<T> source);
                static /*0x1f32888*/ T[] ToArray<T>(System.Collections.Generic.IEnumerable<T> source, ref int length);
            }

            struct LargeArrayBuilder<T>
            {
                /*0x0*/ int _maxCapacity;
                /*0x0*/ T[] _first;
                /*0x0*/ System.Collections.Generic.ArrayBuilder<T[]> _buffers;
                /*0x0*/ T[] _current;
                /*0x0*/ int _index;
                /*0x0*/ int _count;

                /*0x1f30a84*/ LargeArrayBuilder(bool initialize);
                /*0x1f30b78*/ LargeArrayBuilder(int maxCapacity);
                /*0x1f30ebc*/ void AddRange(System.Collections.Generic.IEnumerable<T> items);
                /*0x1ffc854*/ void AddWithBufferAllocation(T item, ref T[] destination, ref int index);
                void CopyTo(T[] array, int arrayIndex, int count);
                /*0x1f30240*/ T[] GetBuffer(int index);
                /*0x1f30214*/ T[] ToArray();
                /*0x1f2fec8*/ bool TryMove(ref T[] array);
                /*0x1f309e4*/ void AllocateBuffer();
            }

            class LowLevelDictionary<TKey, TValue>
            {
                /*0x0*/ System.Collections.Generic.LowLevelDictionary.Entry<TKey, TValue> _buckets;
                /*0x0*/ int _numEntries;
                /*0x0*/ int _version;
                /*0x0*/ System.Collections.Generic.IEqualityComparer<TKey> _comparer;

                /*0x1f309e4*/ LowLevelDictionary();
                /*0x1f30c88*/ LowLevelDictionary(int capacity, System.Collections.Generic.IEqualityComparer<TKey> comparer);
                /*0x1ffc854*/ void set_Item(TKey key, TValue value);
                /*0x1f30b78*/ void Clear(int capacity);
                /*0x1ffc854*/ bool Remove(TKey key);
                /*0x1ffc854*/ System.Collections.Generic.LowLevelDictionary.Entry<TKey, TValue> Find(TKey key);
                /*0x1ffc854*/ System.Collections.Generic.LowLevelDictionary.Entry<TKey, TValue> UncheckedAdd(TKey key, TValue value);
                /*0x1f309e4*/ void ExpandBuckets();
                /*0x1ffc854*/ int GetBucket(TKey key, int numBuckets);

                class Entry<TKey, TValue>
                {
                    /*0x0*/ TKey _key;
                    /*0x0*/ TValue _value;
                    /*0x0*/ System.Collections.Generic.LowLevelDictionary.Entry<TKey, TValue> _next;

                    /*0x1f309e4*/ Entry();
                }

                class DefaultComparer`1<TKey, TValue, T> : System.Collections.Generic.IEqualityComparer<T>
                {
                    /*0x1f309e4*/ DefaultComparer`1();
                    /*0x1ffc854*/ bool Equals(T x, T y);
                    /*0x1ffc854*/ int GetHashCode(T obj);
                }
            }

            class CollectionExtensions
            {
                static /*0x1ffc854*/ TValue GetValueOrDefault<TKey, TValue>(System.Collections.Generic.IReadOnlyDictionary<TKey, TValue> dictionary, TKey key);
                static /*0x1ffc854*/ TValue GetValueOrDefault<TKey, TValue>(System.Collections.Generic.IReadOnlyDictionary<TKey, TValue> dictionary, TKey key, TValue defaultValue);
            }

            class Queue<T> : System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.Collections.ICollection, System.Collections.Generic.IReadOnlyCollection<T>
            {
                /*0x0*/ T[] _array;
                /*0x0*/ int _head;
                /*0x0*/ int _tail;
                /*0x0*/ int _size;
                /*0x0*/ int _version;
                /*0x0*/ object _syncRoot;

                /*0x1f309e4*/ Queue();
                /*0x1f30b78*/ Queue(int capacity);
                /*0x1f30ebc*/ Queue(System.Collections.Generic.IEnumerable<T> collection);
                /*0x1f2ffc8*/ int get_Count();
                /*0x1f2fe14*/ bool System.Collections.ICollection.get_IsSynchronized();
                /*0x1f30214*/ object System.Collections.ICollection.get_SyncRoot();
                /*0x1f309e4*/ void Clear();
                /*0x1f30ee8*/ void System.Collections.ICollection.CopyTo(System.Array array, int index);
                /*0x1ffc854*/ void Enqueue(T item);
                /*0x1ffc854*/ System.Collections.Generic.Queue.Enumerator<T> GetEnumerator();
                /*0x1f30214*/ System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
                /*0x1f30214*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                /*0x1ffc854*/ T Dequeue();
                /*0x1f2fec8*/ bool TryDequeue(ref T result);
                /*0x1ffc854*/ T Peek();
                /*0x1f2fec8*/ bool TryPeek(ref T result);
                /*0x1ffc854*/ bool Contains(T item);
                /*0x1f30214*/ T[] ToArray();
                /*0x1f30b78*/ void SetCapacity(int capacity);
                /*0x1f30ebc*/ void MoveNext(ref int index);
                /*0x1f309e4*/ void ThrowForEmptyQueue();

                struct Enumerator<T> : System.Collections.Generic.IEnumerator<T>, System.IDisposable, System.Collections.IEnumerator
                {
                    /*0x0*/ System.Collections.Generic.Queue<T> _q;
                    /*0x0*/ int _version;
                    /*0x0*/ int _index;
                    /*0x0*/ T _currentElement;

                    /*0x1f30ebc*/ Enumerator(System.Collections.Generic.Queue<T> q);
                    /*0x1f309e4*/ void Dispose();
                    /*0x1f2fe14*/ bool MoveNext();
                    /*0x1ffc854*/ T get_Current();
                    /*0x1f309e4*/ void ThrowEnumerationNotStartedOrEnded();
                    /*0x1f30214*/ object System.Collections.IEnumerator.get_Current();
                    /*0x1f309e4*/ void System.Collections.IEnumerator.Reset();
                }
            }

            class QueueDebugView<T>
            {
            }

            class Stack<T> : System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.Collections.ICollection, System.Collections.Generic.IReadOnlyCollection<T>
            {
                /*0x0*/ T[] _array;
                /*0x0*/ int _size;
                /*0x0*/ int _version;
                /*0x0*/ object _syncRoot;

                /*0x1f309e4*/ Stack();
                /*0x1f30b78*/ Stack(int capacity);
                /*0x1f2ffc8*/ int get_Count();
                /*0x1f2fe14*/ bool System.Collections.ICollection.get_IsSynchronized();
                /*0x1f30214*/ object System.Collections.ICollection.get_SyncRoot();
                /*0x1f309e4*/ void Clear();
                /*0x1ffc854*/ bool Contains(T item);
                /*0x1f30ee8*/ void System.Collections.ICollection.CopyTo(System.Array array, int arrayIndex);
                /*0x1ffc854*/ System.Collections.Generic.Stack.Enumerator<T> GetEnumerator();
                /*0x1f30214*/ System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
                /*0x1f30214*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                /*0x1ffc854*/ T Peek();
                /*0x1ffc854*/ T Pop();
                /*0x1f2fec8*/ bool TryPop(ref T result);
                /*0x1ffc854*/ void Push(T item);
                /*0x1ffc854*/ void PushWithResize(T item);
                /*0x1f30214*/ T[] ToArray();
                /*0x1f309e4*/ void ThrowForEmptyStack();

                struct Enumerator<T> : System.Collections.Generic.IEnumerator<T>, System.IDisposable, System.Collections.IEnumerator
                {
                    /*0x0*/ System.Collections.Generic.Stack<T> _stack;
                    /*0x0*/ int _version;
                    /*0x0*/ int _index;
                    /*0x0*/ T _currentElement;

                    /*0x1f30ebc*/ Enumerator(System.Collections.Generic.Stack<T> stack);
                    /*0x1f309e4*/ void Dispose();
                    /*0x1f2fe14*/ bool MoveNext();
                    /*0x1ffc854*/ T get_Current();
                    /*0x1f309e4*/ void ThrowEnumerationNotStartedOrEnded();
                    /*0x1f30214*/ object System.Collections.IEnumerator.get_Current();
                    /*0x1f309e4*/ void System.Collections.IEnumerator.Reset();
                }
            }

            class StackDebugView<T>
            {
            }

            class CollectionDebugView<T>
            {
            }

            class DictionaryDebugView<K, V>
            {
            }

            class LowLevelList<T>
            {
                static /*0x0*/ T[] s_emptyArray;
                /*0x0*/ T[] _items;
                /*0x0*/ int _size;
                /*0x0*/ int _version;

                static /*0x1f33998*/ LowLevelList();
                /*0x1f309e4*/ LowLevelList();
                /*0x1f30b78*/ LowLevelList(int capacity);
                /*0x1f2ffc8*/ int get_Capacity();
                /*0x1f30b78*/ void set_Capacity(int value);
                /*0x1f2ffc8*/ int get_Count();
                /*0x1ffc854*/ T get_Item(int index);
                /*0x1ffc854*/ void set_Item(int index, T value);
                /*0x1ffc854*/ void Add(T item);
                /*0x1f30b78*/ void EnsureCapacity(int min);
                /*0x1f30ebc*/ void AddRange(System.Collections.Generic.IEnumerable<T> collection);
                /*0x1f309e4*/ void Clear();
                /*0x1ffc854*/ bool Contains(T item);
                /*0x1f30ee8*/ void CopyTo(T[] array, int arrayIndex);
                /*0x1ffc854*/ int IndexOf(T item);
                /*0x1ffc854*/ void Insert(int index, T item);
                /*0x1f30c88*/ void InsertRange(int index, System.Collections.Generic.IEnumerable<T> collection);
                /*0x1ffc854*/ bool Remove(T item);
                /*0x1f3008c*/ int RemoveAll(System.Predicate<T> match);
                /*0x1f30b78*/ void RemoveAt(int index);
            }

            class LowLevelListWithIList<T> : System.Collections.Generic.LowLevelList<T>, System.Collections.Generic.IList<T>, System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable
            {
                /*0x1f309e4*/ LowLevelListWithIList();
                /*0x1f30b78*/ LowLevelListWithIList(int capacity);
                /*0x1f2fe14*/ bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
                /*0x1f30214*/ System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
                /*0x1f30214*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();

                struct Enumerator<T> : System.Collections.Generic.IEnumerator<T>, System.IDisposable, System.Collections.IEnumerator
                {
                    /*0x0*/ System.Collections.Generic.LowLevelListWithIList<T> _list;
                    /*0x0*/ int _index;
                    /*0x0*/ int _version;
                    /*0x0*/ T _current;

                    /*0x1f30ebc*/ Enumerator(System.Collections.Generic.LowLevelListWithIList<T> list);
                    /*0x1f309e4*/ void Dispose();
                    /*0x1f2fe14*/ bool MoveNext();
                    /*0x1f2fe14*/ bool MoveNextRare();
                    /*0x1ffc854*/ T get_Current();
                    /*0x1f30214*/ object System.Collections.IEnumerator.get_Current();
                    /*0x1f309e4*/ void System.Collections.IEnumerator.Reset();
                }
            }

            class IntrospectiveSortUtilities
            {
                static /*0x32508c0*/ int FloorLog2PlusOne(int n);
                static /*0x32508f0*/ void ThrowOrIgnoreBadComparer(object comparer);
            }

            class ArraySortHelper<T>
            {
                static /*0x0*/ System.Collections.Generic.ArraySortHelper<T> s_defaultArraySortHelper;

                static /*0x1f33998*/ ArraySortHelper();
                static /*0x1f36320*/ void Sort(T[] keys, int index, int length, System.Comparison<T> comparer);
                static /*0x1ffc854*/ int InternalBinarySearch(T[] array, int index, int length, T value, System.Collections.Generic.IComparer<T> comparer);
                static /*0x1f37108*/ void SwapIfGreater(T[] keys, System.Comparison<T> comparer, int a, int b);
                static /*0x1f36284*/ void Swap(T[] a, int i, int j);
                static /*0x1f36320*/ void IntrospectiveSort(T[] keys, int left, int length, System.Comparison<T> comparer);
                static /*0x1ffc854*/ void IntroSort(T[] keys, int lo, int hi, int depthLimit, System.Comparison<T> comparer);
                static /*0x1ffc854*/ int PickPivotAndPartition(T[] keys, int lo, int hi, System.Comparison<T> comparer);
                static /*0x1f36320*/ void Heapsort(T[] keys, int lo, int hi, System.Comparison<T> comparer);
                static /*0x1ffc854*/ void DownHeap(T[] keys, int i, int n, int lo, System.Comparison<T> comparer);
                static /*0x1f36320*/ void InsertionSort(T[] keys, int lo, int hi, System.Comparison<T> comparer);
                static /*0x1f327a0*/ System.Collections.Generic.ArraySortHelper<T> get_Default();
                /*0x1f309e4*/ ArraySortHelper();
                void Sort(T[] keys, int index, int length, System.Collections.Generic.IComparer<T> comparer);
                /*0x1ffc854*/ int BinarySearch(T[] array, int index, int length, T value, System.Collections.Generic.IComparer<T> comparer);
            }

            class ArraySortHelper<TKey, TValue>
            {
                static /*0x0*/ System.Collections.Generic.ArraySortHelper<TKey, TValue> s_defaultArraySortHelper;

                static /*0x1f33998*/ ArraySortHelper();
                static /*0x1ffc854*/ void SwapIfGreaterWithItems(TKey[] keys, TValue[] values, System.Collections.Generic.IComparer<TKey> comparer, int a, int b);
                static /*0x1f37108*/ void Swap(TKey[] keys, TValue[] values, int i, int j);
                static /*0x1f3714c*/ void IntrospectiveSort(TKey[] keys, TValue[] values, int left, int length, System.Collections.Generic.IComparer<TKey> comparer);
                static /*0x1ffc854*/ void IntroSort(TKey[] keys, TValue[] values, int lo, int hi, int depthLimit, System.Collections.Generic.IComparer<TKey> comparer);
                static /*0x1ffc854*/ int PickPivotAndPartition(TKey[] keys, TValue[] values, int lo, int hi, System.Collections.Generic.IComparer<TKey> comparer);
                static /*0x1f3714c*/ void Heapsort(TKey[] keys, TValue[] values, int lo, int hi, System.Collections.Generic.IComparer<TKey> comparer);
                static /*0x1ffc854*/ void DownHeap(TKey[] keys, TValue[] values, int i, int n, int lo, System.Collections.Generic.IComparer<TKey> comparer);
                static /*0x1f3714c*/ void InsertionSort(TKey[] keys, TValue[] values, int lo, int hi, System.Collections.Generic.IComparer<TKey> comparer);
                static /*0x1f327a0*/ System.Collections.Generic.ArraySortHelper<TKey, TValue> get_Default();
                /*0x1f309e4*/ ArraySortHelper();
                void Sort(TKey[] keys, TValue[] values, int index, int length, System.Collections.Generic.IComparer<TKey> comparer);
            }

            class Comparer<T> : System.Collections.IComparer, System.Collections.Generic.IComparer<T>
            {
                static /*0x0*/ System.Collections.Generic.Comparer<T> defaultComparer;

                static /*0x1f327a0*/ System.Collections.Generic.Comparer<T> get_Default();
                static /*0x1f327cc*/ System.Collections.Generic.Comparer<T> Create(System.Comparison<T> comparison);
                static /*0x1f327a0*/ System.Collections.Generic.Comparer<T> CreateComparer();
                /*0x1f309e4*/ Comparer();
                /*0x1ffc854*/ int Compare(T x, T y);
                int System.Collections.IComparer.Compare(object x, object y);
            }

            class GenericComparer<T> : System.Collections.Generic.Comparer<T>
            {
                /*0x1f309e4*/ GenericComparer();
                /*0x1ffc854*/ int Compare(T x, T y);
                /*0x1f2fec8*/ bool Equals(object obj);
                /*0x1f2ffc8*/ int GetHashCode();
            }

            class NullableComparer<T> : System.Collections.Generic.Comparer<System.Nullable<T>>
            {
                /*0x1f309e4*/ NullableComparer();
                /*0x1ffc854*/ int Compare(System.Nullable<T> x, System.Nullable<T> y);
                /*0x1f2fec8*/ bool Equals(object obj);
                /*0x1f2ffc8*/ int GetHashCode();
            }

            class ObjectComparer<T> : System.Collections.Generic.Comparer<T>
            {
                /*0x1f309e4*/ ObjectComparer();
                /*0x1ffc854*/ int Compare(T x, T y);
                /*0x1f2fec8*/ bool Equals(object obj);
                /*0x1f2ffc8*/ int GetHashCode();
            }

            class ComparisonComparer<T> : System.Collections.Generic.Comparer<T>
            {
                /*0x0*/ System.Comparison<T> _comparison;

                /*0x1f30ebc*/ ComparisonComparer(System.Comparison<T> comparison);
                /*0x1ffc854*/ int Compare(T x, T y);
            }

            class EqualityComparer<T> : System.Collections.IEqualityComparer, System.Collections.Generic.IEqualityComparer<T>
            {
                static /*0x0*/ System.Collections.Generic.EqualityComparer<T> defaultComparer;

                static /*0x1f327a0*/ System.Collections.Generic.EqualityComparer<T> get_Default();
                static /*0x1f327a0*/ System.Collections.Generic.EqualityComparer<T> CreateComparer();
                /*0x1f309e4*/ EqualityComparer();
                /*0x1ffc854*/ bool Equals(T x, T y);
                /*0x1ffc854*/ int GetHashCode(T obj);
                /*0x1ffc854*/ int IndexOf(T[] array, T value, int startIndex, int count);
                /*0x1ffc854*/ int LastIndexOf(T[] array, T value, int startIndex, int count);
                /*0x1f3008c*/ int System.Collections.IEqualityComparer.GetHashCode(object obj);
                /*0x1f2ff00*/ bool System.Collections.IEqualityComparer.Equals(object x, object y);
            }

            class GenericEqualityComparer<T> : System.Collections.Generic.EqualityComparer<T>
            {
                /*0x1f309e4*/ GenericEqualityComparer();
                /*0x1ffc854*/ bool Equals(T x, T y);
                /*0x1ffc854*/ int GetHashCode(T obj);
                /*0x1ffc854*/ int IndexOf(T[] array, T value, int startIndex, int count);
                /*0x1ffc854*/ int LastIndexOf(T[] array, T value, int startIndex, int count);
                /*0x1f2fec8*/ bool Equals(object obj);
                /*0x1f2ffc8*/ int GetHashCode();
            }

            class NullableEqualityComparer<T> : System.Collections.Generic.EqualityComparer<System.Nullable<T>>
            {
                /*0x1f309e4*/ NullableEqualityComparer();
                /*0x1ffc854*/ bool Equals(System.Nullable<T> x, System.Nullable<T> y);
                /*0x1ffc854*/ int GetHashCode(System.Nullable<T> obj);
                /*0x1ffc854*/ int IndexOf(System.Nullable<T> array, System.Nullable<T> value, int startIndex, int count);
                /*0x1ffc854*/ int LastIndexOf(System.Nullable<T> array, System.Nullable<T> value, int startIndex, int count);
                /*0x1f2fec8*/ bool Equals(object obj);
                /*0x1f2ffc8*/ int GetHashCode();
            }

            class ObjectEqualityComparer<T> : System.Collections.Generic.EqualityComparer<T>
            {
                /*0x1f309e4*/ ObjectEqualityComparer();
                /*0x1ffc854*/ bool Equals(T x, T y);
                /*0x1ffc854*/ int GetHashCode(T obj);
                /*0x1ffc854*/ int IndexOf(T[] array, T value, int startIndex, int count);
                /*0x1ffc854*/ int LastIndexOf(T[] array, T value, int startIndex, int count);
                /*0x1f2fec8*/ bool Equals(object obj);
                /*0x1f2ffc8*/ int GetHashCode();
            }

            class ByteEqualityComparer : System.Collections.Generic.EqualityComparer<byte>
            {
                /*0x3250c14*/ ByteEqualityComparer();
                /*0x3250950*/ bool Equals(byte x, byte y);
                /*0x3250960*/ int GetHashCode(byte b);
                /*0x325097c*/ int IndexOf(byte[] array, byte value, int startIndex, int count);
                /*0x3250b0c*/ int LastIndexOf(byte[] array, byte value, int startIndex, int count);
                /*0x3250b68*/ bool Equals(object obj);
                /*0x3250be0*/ int GetHashCode();
            }

            class EnumEqualityComparer<T> : System.Collections.Generic.EqualityComparer<T>, System.Runtime.Serialization.ISerializable
            {
                /*0x1f309e4*/ EnumEqualityComparer();
                EnumEqualityComparer(System.Runtime.Serialization.SerializationInfo information, System.Runtime.Serialization.StreamingContext context);
                /*0x1ffc854*/ bool Equals(T x, T y);
                /*0x1ffc854*/ int GetHashCode(T obj);
                void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x1f2fec8*/ bool Equals(object obj);
                /*0x1f2ffc8*/ int GetHashCode();
            }

            class SByteEnumEqualityComparer<T> : System.Collections.Generic.EnumEqualityComparer<T>, System.Runtime.Serialization.ISerializable
            {
                /*0x1f309e4*/ SByteEnumEqualityComparer();
                SByteEnumEqualityComparer(System.Runtime.Serialization.SerializationInfo information, System.Runtime.Serialization.StreamingContext context);
                /*0x1ffc854*/ int GetHashCode(T obj);
            }

            class ShortEnumEqualityComparer<T> : System.Collections.Generic.EnumEqualityComparer<T>, System.Runtime.Serialization.ISerializable
            {
                /*0x1f309e4*/ ShortEnumEqualityComparer();
                ShortEnumEqualityComparer(System.Runtime.Serialization.SerializationInfo information, System.Runtime.Serialization.StreamingContext context);
                /*0x1ffc854*/ int GetHashCode(T obj);
            }

            class LongEnumEqualityComparer<T> : System.Collections.Generic.EqualityComparer<T>, System.Runtime.Serialization.ISerializable
            {
                /*0x1f309e4*/ LongEnumEqualityComparer();
                LongEnumEqualityComparer(System.Runtime.Serialization.SerializationInfo information, System.Runtime.Serialization.StreamingContext context);
                /*0x1ffc854*/ bool Equals(T x, T y);
                /*0x1ffc854*/ int GetHashCode(T obj);
                /*0x1f2fec8*/ bool Equals(object obj);
                /*0x1f2ffc8*/ int GetHashCode();
                void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            }

            class InternalStringComparer : System.Collections.Generic.EqualityComparer<string>
            {
                /*0x3250d14*/ InternalStringComparer();
                /*0x3250c5c*/ int GetHashCode(string obj);
                /*0x3250c7c*/ bool Equals(string x, string y);
                /*0x3250cac*/ int IndexOf(string[] array, string value, int startIndex, int count);
            }
        }
    }

    namespace Buffers
    {
        class SpanAction<T, TArg> : System.MulticastDelegate
        {
            SpanAction(object object, nint method);
            /*0x1ffc854*/ void Invoke(System.Span<T> span, TArg arg);
        }

        class ArrayPool<T>
        {
            static /*0x0*/ System.Buffers.ArrayPool<T> <Shared>k__BackingField;

            static /*0x1f33998*/ ArrayPool();
            static /*0x1f327a0*/ System.Buffers.ArrayPool<T> get_Shared();
            /*0x1f309e4*/ ArrayPool();
            /*0x1f30240*/ T[] Rent(int minimumLength);
            void Return(T[] array, bool clearArray);
        }

        class ArrayPoolEventSource : System.Diagnostics.Tracing.EventSource
        {
            static /*0x0*/ System.Buffers.ArrayPoolEventSource Log;

            static /*0x3251038*/ ArrayPoolEventSource();
            /*0x3250d5c*/ ArrayPoolEventSource();
            /*0x3250e14*/ void BufferRented(int bufferId, int bufferSize, int poolId, int bucketId);
            /*0x3250f00*/ void BufferAllocated(int bufferId, int bufferSize, int poolId, int bucketId, System.Buffers.ArrayPoolEventSource.BufferAllocatedReason reason);
            /*0x325100c*/ void BufferReturned(int bufferId, int bufferSize, int poolId);
            /*0x325101c*/ void BufferTrimmed(int bufferId, int bufferSize, int poolId);
            /*0x325102c*/ void BufferTrimPoll(int milliseconds, int pressure);

            enum BufferAllocatedReason
            {
                Pooled = 0,
                OverMaximumSize = 1,
                PoolExhausted = 2,
            }
        }

        interface IMemoryOwner<T> : System.IDisposable
        {
            /*0x1ffc854*/ System.Memory<T> get_Memory();
        }

        interface IPinnable
        {
            /*0x1f309e4*/ void Unpin();
        }

        struct MemoryHandle : System.IDisposable
        {
            /*0x10*/ void* _pointer;
            /*0x18*/ System.Runtime.InteropServices.GCHandle _handle;
            /*0x20*/ System.Buffers.IPinnable _pinnable;

            /*0x325109c*/ MemoryHandle(void* pointer, System.Runtime.InteropServices.GCHandle handle, System.Buffers.IPinnable pinnable);
            /*0x32510ac*/ void* get_Pointer();
            /*0x32510b4*/ void Dispose();
        }

        class MemoryManager<T>
        {
            /*0x1ffc854*/ System.Memory<T> get_Memory();
            /*0x1ffc854*/ System.Span<T> GetSpan();
            System.Buffers.MemoryHandle Pin(int elementIndex);
            /*0x1f2fec8*/ bool TryGetArray(ref System.ArraySegment<T> segment);
        }

        class TlsOverPerCoreLockedStacksArrayPool<T> : System.Buffers.ArrayPool<T>
        {
            static /*0x0*/ bool s_trimBuffers;
            static /*0x0*/ System.Runtime.CompilerServices.ConditionalWeakTable<T[][], object> s_allTlsBuckets;
            [ThreadStatic] static T[][] t_tlsBuckets;
            /*0x0*/ int[] _bucketArraySizes;
            /*0x0*/ System.Buffers.TlsOverPerCoreLockedStacksArrayPool.PerCoreLockedStacks<T> _buckets;
            /*0x0*/ int _callbackCreated;

            static /*0x1f33998*/ TlsOverPerCoreLockedStacksArrayPool();
            static /*0x1f31840*/ bool Gen2GcCallbackFunc(object target);
            static /*0x1ffc854*/ System.Buffers.TlsOverPerCoreLockedStacksArrayPool.MemoryPressure<T> GetMemoryPressure();
            static /*0x1f317dc*/ bool GetTrimBuffers();
            /*0x1f309e4*/ TlsOverPerCoreLockedStacksArrayPool();
            /*0x1f30240*/ System.Buffers.TlsOverPerCoreLockedStacksArrayPool.PerCoreLockedStacks<T> CreatePerCoreLockedStacks(int bucketIndex);
            /*0x1f2ffc8*/ int get_Id();
            /*0x1f30240*/ T[] Rent(int minimumLength);
            void Return(T[] array, bool clearArray);
            /*0x1f2fe14*/ bool Trim();

            enum MemoryPressure<T>
            {
                Low = 0,
                Medium = 1,
                High = 2,
            }

            class PerCoreLockedStacks<T>
            {
                /*0x0*/ System.Buffers.TlsOverPerCoreLockedStacksArrayPool.LockedStack<T> _perCoreStacks;

                /*0x1f309e4*/ PerCoreLockedStacks();
                /*0x1f30ebc*/ void TryPush(T[] array);
                /*0x1f30214*/ T[] TryPop();
                /*0x1ffc854*/ bool Trim(uint tickCount, int id, System.Buffers.TlsOverPerCoreLockedStacksArrayPool.MemoryPressure<T> pressure, int[] bucketSizes);
            }

            class LockedStack<T>
            {
                /*0x0*/ T[][] _arrays;
                /*0x0*/ int _count;
                /*0x0*/ uint _firstStackItemMS;

                /*0x1f309e4*/ LockedStack();
                /*0x1f2fec8*/ bool TryPush(T[] array);
                /*0x1f30214*/ T[] TryPop();
                /*0x1ffc854*/ void Trim(uint tickCount, int id, System.Buffers.TlsOverPerCoreLockedStacksArrayPool.MemoryPressure<T> pressure, int bucketSize);
            }
        }

        class Utilities
        {
            static /*0x3251180*/ int SelectBucketIndex(int bufferSize);
            static /*0x32511fc*/ int GetMaxSizeForBucket(int binIndex);
        }

        class ArrayMemoryPool<T> : System.Buffers.MemoryPool<T>
        {
            /*0x1f309e4*/ ArrayMemoryPool();
            /*0x1f30240*/ System.Buffers.IMemoryOwner<T> Rent(int minimumBufferSize);
            /*0x1f30a84*/ void Dispose(bool disposing);

            class ArrayMemoryPoolBuffer<T> : System.Buffers.IMemoryOwner<T>, System.IDisposable
            {
                /*0x0*/ T[] _array;

                /*0x1f30b78*/ ArrayMemoryPoolBuffer(int size);
                /*0x1ffc854*/ System.Memory<T> get_Memory();
                /*0x1f309e4*/ void Dispose();
            }
        }

        class BuffersExtensions
        {
            static /*0x1ffc854*/ void CopyTo<T>(ref System.Buffers.ReadOnlySequence<T> source, System.Span<T> destination);
            static /*0x1ffc854*/ void CopyToMultiSegment<T>(ref System.Buffers.ReadOnlySequence<T> sequence, System.Span<T> destination);
        }

        interface IBufferWriter<T>
        {
            /*0x1f30b78*/ void Advance(int count);
            /*0x1ffc854*/ System.Span<T> GetSpan(int sizeHint);
        }

        class MemoryPool<T> : System.IDisposable
        {
            static /*0x0*/ System.Buffers.MemoryPool<T> s_shared;

            static /*0x1f33998*/ MemoryPool();
            static /*0x1f327a0*/ System.Buffers.MemoryPool<T> get_Shared();
            /*0x1f309e4*/ MemoryPool();
            /*0x1f30240*/ System.Buffers.IMemoryOwner<T> Rent(int minBufferSize);
            /*0x1f309e4*/ void Dispose();
            /*0x1f30a84*/ void Dispose(bool disposing);
        }

        enum OperationStatus
        {
            Done = 0,
            DestinationTooSmall = 1,
            NeedMoreData = 2,
            InvalidData = 3,
        }

        struct ReadOnlySequence<T>
        {
            static /*0x0*/ System.Buffers.ReadOnlySequence<T> Empty;
            /*0x0*/ object _startObject;
            /*0x0*/ object _endObject;
            /*0x0*/ int _startInteger;
            /*0x0*/ int _endInteger;

            static /*0x1f33998*/ ReadOnlySequence();
            static /*0x1f31f88*/ int GetIndex(ref System.SequencePosition position);
            static /*0x1f31e40*/ int GetIndex(int Integer);
            /*0x1f30ebc*/ ReadOnlySequence(T[] array);
            long get_Length();
            /*0x1f2fe14*/ bool get_IsSingleSegment();
            /*0x1ffc854*/ System.ReadOnlyMemory<T> get_First();
            /*0x1ffc854*/ System.SequencePosition get_Start();
            /*0x1f30214*/ string ToString();
            /*0x1ffc854*/ System.Buffers.ReadOnlySequence.Enumerator<T> GetEnumerator();
            bool TryGet(ref System.SequencePosition position, ref System.ReadOnlyMemory<T> memory, bool advance);
            bool TryGetBuffer(ref System.SequencePosition position, ref System.ReadOnlyMemory<T> memory, ref System.SequencePosition next);
            /*0x1ffc854*/ System.ReadOnlyMemory<T> GetFirstBuffer();
            /*0x1ffc854*/ System.ReadOnlyMemory<T> GetFirstBufferSlow(object startObject, bool isMultiSegment);
            /*0x1ffc854*/ System.Buffers.ReadOnlySequence.SequenceType<T> GetSequenceType();
            long GetLength();
            bool TryGetString(ref string text, ref int start, ref int length);

            struct Enumerator<T>
            {
                /*0x0*/ System.Buffers.ReadOnlySequence<T> _sequence;
                /*0x0*/ System.SequencePosition _next;
                /*0x0*/ System.ReadOnlyMemory<T> _currentMemory;

                /*0x1f30ebc*/ Enumerator(ref System.Buffers.ReadOnlySequence<T> sequence);
                /*0x1ffc854*/ System.ReadOnlyMemory<T> get_Current();
                /*0x1f2fe14*/ bool MoveNext();
            }

            enum SequenceType<T>
            {
                MultiSegment = 0,
                Array = 1,
                MemoryManager = 2,
                String = 3,
                Empty = 4,
            }

            class <>c<T>
            {
                static /*0x0*/ System.Buffers.ReadOnlySequence.<>c<T> <>9;
                static /*0x0*/ System.Buffers.SpanAction<char, System.Buffers.ReadOnlySequence<char>> <>9__33_0;

                static /*0x1f33998*/ <>c();
                /*0x1f309e4*/ <>c();
                /*0x1ffc854*/ void <ToString>b__33_0(System.Span<char> span, System.Buffers.ReadOnlySequence<char> sequence);
            }
        }

        class ReadOnlySequence
        {
            static /*0x3251208*/ int ArrayToSequenceStart(int startIndex);
            static /*0x325120c*/ int ArrayToSequenceEnd(int endIndex);
        }

        class ReadOnlySequenceDebugView<T>
        {
        }

        class ReadOnlySequenceSegment<T>
        {
            /*0x0*/ System.ReadOnlyMemory<T> <Memory>k__BackingField;
            /*0x0*/ System.Buffers.ReadOnlySequenceSegment<T> <Next>k__BackingField;
            /*0x0*/ long <RunningIndex>k__BackingField;

            /*0x1ffc854*/ System.ReadOnlyMemory<T> get_Memory();
            /*0x1f30214*/ System.Buffers.ReadOnlySequenceSegment<T> get_Next();
            long get_RunningIndex();
        }

        namespace Binary
        {
            class BinaryPrimitives
            {
                static /*0x3251214*/ int ReverseEndianness(int value);
                static /*0x325121c*/ long ReverseEndianness(long value);
                static /*0x3251224*/ ushort ReverseEndianness(ushort value);
                static /*0x3251230*/ uint ReverseEndianness(uint value);
                static /*0x3251238*/ ulong ReverseEndianness(ulong value);
                static /*0x3251240*/ uint ReadUInt32BigEndian(System.ReadOnlySpan<byte> source);
                static /*0x32512a8*/ ulong ReadUInt64BigEndian(System.ReadOnlySpan<byte> source);
                static /*0x3251310*/ uint ReadUInt32LittleEndian(System.ReadOnlySpan<byte> source);
                static /*0x3251374*/ ulong ReadUInt64LittleEndian(System.ReadOnlySpan<byte> source);
                static /*0x32513d8*/ void WriteUInt32BigEndian(System.Span<byte> destination, uint value);
                static /*0x3251450*/ void WriteUInt64BigEndian(System.Span<byte> destination, ulong value);
                static /*0x32514c8*/ void WriteUInt32LittleEndian(System.Span<byte> destination, uint value);
                static /*0x325152c*/ void WriteUInt64LittleEndian(System.Span<byte> destination, ulong value);
            }
        }

        namespace Text
        {
            class FormattingHelpers
            {
                static /*0x3251590*/ int CountDigits(ulong value);
                static /*0x325166c*/ int CountDigits(uint value);
                static /*0x32516d4*/ int CountHexDigits(ulong value);
            }
        }
    }

    namespace IO
    {
        class FileSystem
        {
            static /*0x325171c*/ bool CopyDanglingSymlink(string sourceFullPath, string destFullPath);
            static /*0x3251884*/ void CopyFile(string sourceFullPath, string destFullPath, bool overwrite);
            static /*0x3251c5c*/ void LinkOrCopyFile(string sourceFullPath, string destFullPath);
            static /*0x3251f5c*/ void MoveFile(string sourceFullPath, string destFullPath);
            static /*0x3252074*/ void DeleteFile(string fullPath);
            static /*0x325246c*/ void CreateDirectory(string fullPath);
            static /*0x3252ca0*/ void RemoveDirectory(string fullPath, bool recursive);
            static /*0x3252de8*/ void RemoveDirectoryInternal(System.IO.DirectoryInfo directory, bool recursive, bool throwOnTopLevelDirectoryNotFound);
            static /*0x3251c40*/ bool DirectoryExists(System.ReadOnlySpan<char> fullPath);
            static /*0x3252c94*/ bool DirectoryExists(System.ReadOnlySpan<char> fullPath, ref Interop.ErrorInfo errorInfo);
            static /*0x3252c18*/ bool FileExists(System.ReadOnlySpan<char> fullPath);
            static /*0x325235c*/ bool FileExists(System.ReadOnlySpan<char> fullPath, int fileType, ref Interop.ErrorInfo errorInfo);
            static /*0x32535f0*/ bool ShouldIgnoreDirectory(string name);
            static /*0x3253788*/ System.IO.FileAttributes GetAttributes(string fullPath);
            static /*0x32539e0*/ void SetAttributes(string fullPath, System.IO.FileAttributes attributes);
            static /*0x3253a74*/ System.DateTimeOffset GetLastAccessTime(string fullPath);
            static /*0x3253b90*/ System.DateTimeOffset GetLastWriteTime(string fullPath);
            static /*0x3253cac*/ void SetLastWriteTime(string fullPath, System.DateTimeOffset time, bool asDirectory);
        }

        class DirectoryNotFoundException : System.IO.IOException
        {
            /*0x3253dd8*/ DirectoryNotFoundException();
            /*0x3253e34*/ DirectoryNotFoundException(string message);
            /*0x3253e58*/ DirectoryNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class EndOfStreamException : System.IO.IOException
        {
            /*0x3253e68*/ EndOfStreamException();
            /*0x3253ec4*/ EndOfStreamException(string message);
            /*0x3253ee8*/ EndOfStreamException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class Error
        {
            static /*0x3253ef0*/ System.Exception GetStreamIsClosed();
            static /*0x3253f60*/ System.Exception GetEndOfFile();
            static /*0x3253fd8*/ System.Exception GetReadNotSupported();
            static /*0x3254044*/ System.Exception GetWriteNotSupported();
        }

        enum FileAccess
        {
            Read = 1,
            Write = 2,
            ReadWrite = 3,
        }

        class FileLoadException : System.IO.IOException
        {
            /*0x90*/ string <FileName>k__BackingField;
            /*0x98*/ string <FusionLog>k__BackingField;

            static /*0x3254170*/ string FormatFileLoadExceptionMessage(string fileName, int hResult);
            /*0x32540b0*/ FileLoadException();
            /*0x325410c*/ FileLoadException(string message);
            /*0x32543d8*/ FileLoadException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x3254130*/ string get_Message();
            /*0x32541e4*/ string get_FileName();
            /*0x32541ec*/ string get_FusionLog();
            /*0x32541f4*/ string ToString();
            /*0x325449c*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        enum FileMode
        {
            CreateNew = 1,
            Create = 2,
            Open = 3,
            OpenOrCreate = 4,
            Truncate = 5,
            Append = 6,
        }

        class FileNotFoundException : System.IO.IOException
        {
            /*0x90*/ string <FileName>k__BackingField;
            /*0x98*/ string <FusionLog>k__BackingField;

            /*0x3254590*/ FileNotFoundException();
            /*0x32545ec*/ FileNotFoundException(string message);
            /*0x3254610*/ FileNotFoundException(string message, string fileName);
            /*0x32548e4*/ FileNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x325464c*/ string get_Message();
            /*0x3254664*/ void SetMessageField();
            /*0x32546f0*/ string get_FileName();
            /*0x32546f8*/ string get_FusionLog();
            /*0x3254700*/ string ToString();
            /*0x32549a8*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        enum FileOptions
        {
            None = 0,
            WriteThrough = -2147483648,
            Asynchronous = 1073741824,
            RandomAccess = 268435456,
            DeleteOnClose = 67108864,
            SequentialScan = 134217728,
            Encrypted = 16384,
        }

        enum FileShare
        {
            None = 0,
            Read = 1,
            Write = 2,
            ReadWrite = 3,
            Delete = 4,
            Inheritable = 16,
        }

        class IOException : System.SystemException
        {
            /*0x3254a9c*/ IOException();
            /*0x3252ac0*/ IOException(string message);
            /*0x3254af8*/ IOException(string message, int hresult);
            /*0x3254b20*/ IOException(string message, System.Exception innerException);
            /*0x3253e60*/ IOException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class MemoryStream : System.IO.Stream
        {
            /*0x28*/ byte[] _buffer;
            /*0x30*/ int _origin;
            /*0x34*/ int _position;
            /*0x38*/ int _length;
            /*0x3c*/ int _capacity;
            /*0x40*/ bool _expandable;
            /*0x41*/ bool _writable;
            /*0x42*/ bool _exposable;
            /*0x43*/ bool _isOpen;
            /*0x48*/ System.Threading.Tasks.Task<int> _lastReadTask;

            /*0x3254b44*/ MemoryStream();
            /*0x3254b4c*/ MemoryStream(int capacity);
            /*0x3254ccc*/ MemoryStream(byte[] buffer);
            /*0x3254cd4*/ MemoryStream(byte[] buffer, bool writable);
            /*0x3254dcc*/ MemoryStream(byte[] buffer, int index, int count);
            /*0x3254fac*/ MemoryStream(byte[] buffer, int index, int count, bool writable);
            /*0x3254dd8*/ MemoryStream(byte[] buffer, int index, int count, bool writable, bool publiclyVisible);
            /*0x3254fb4*/ bool get_CanRead();
            /*0x3254fbc*/ bool get_CanSeek();
            /*0x3254fc4*/ bool get_CanWrite();
            /*0x3254fcc*/ void EnsureNotClosed();
            /*0x3254ffc*/ void EnsureWriteable();
            /*0x3255038*/ void Dispose(bool disposing);
            /*0x32550ec*/ bool EnsureCapacity(int value);
            /*0x32551a0*/ void Flush();
            /*0x32551a4*/ System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken cancellationToken);
            /*0x3255360*/ byte[] GetBuffer();
            /*0x32553bc*/ byte[] InternalGetBuffer();
            /*0x32553c4*/ int InternalGetPosition();
            /*0x32553cc*/ int InternalReadInt32();
            /*0x3255484*/ int InternalEmulateRead(int count);
            /*0x32554c0*/ int get_Capacity();
            /*0x32554e0*/ void set_Capacity(int value);
            /*0x325566c*/ long get_Length();
            /*0x3255690*/ long get_Position();
            /*0x32556b0*/ void set_Position(long value);
            /*0x3255774*/ int Read(byte[] buffer, int offset, int count);
            /*0x325598c*/ int Read(System.Span<byte> buffer);
            /*0x3255b2c*/ System.Threading.Tasks.Task<int> ReadAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
            /*0x3255f00*/ System.Threading.Tasks.ValueTask<int> ReadAsync(System.Memory<byte> buffer, System.Threading.CancellationToken cancellationToken);
            /*0x325629c*/ int ReadByte();
            /*0x32562f4*/ void CopyTo(System.IO.Stream destination, int bufferSize);
            /*0x325664c*/ System.Threading.Tasks.Task CopyToAsync(System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);
            /*0x32569b8*/ long Seek(long offset, System.IO.SeekOrigin loc);
            /*0x3256b04*/ void SetLength(long value);
            /*0x3256bdc*/ byte[] ToArray();
            /*0x3256cd0*/ void Write(byte[] buffer, int offset, int count);
            /*0x3256f68*/ void Write(System.ReadOnlySpan<byte> buffer);
            /*0x3257158*/ System.Threading.Tasks.Task WriteAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
            /*0x32574bc*/ System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory<byte> buffer, System.Threading.CancellationToken cancellationToken);
            /*0x32577e4*/ void WriteByte(byte value);
            /*0x32578b0*/ void WriteTo(System.IO.Stream stream);
        }

        class PathInternal
        {
            static /*0x0*/ bool s_isCaseSensitive;

            static /*0x3257f48*/ PathInternal();
            static /*0x3252ae4*/ int GetRootLength(System.ReadOnlySpan<char> path);
            static /*0x3252ab0*/ bool IsDirectorySeparator(char c);
            static /*0x3252a30*/ bool EndsInDirectorySeparator(System.ReadOnlySpan<char> path);
            static /*0x3257950*/ bool StartsWithDirectorySeparator(System.ReadOnlySpan<char> path);
            static /*0x325221c*/ string TrimEndingDirectorySeparator(string path);
            static /*0x3253674*/ System.ReadOnlySpan<char> TrimEndingDirectorySeparator(System.ReadOnlySpan<char> path);
            static /*0x32579cc*/ bool IsRoot(System.ReadOnlySpan<char> path);
            static /*0x3257a48*/ bool get_IsCaseSensitive();
            static /*0x3257aa0*/ bool GetIsCaseSensitive();
            static /*0x3257f40*/ bool IsPartiallyQualified(string path);
        }

        class PathTooLongException : System.IO.IOException
        {
            /*0x3257f98*/ PathTooLongException();
            /*0x3257ff4*/ PathTooLongException(string message);
            /*0x3258018*/ PathTooLongException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class PinnedBufferMemoryStream : System.IO.UnmanagedMemoryStream
        {
            /*0x68*/ byte[] _array;
            /*0x70*/ System.Runtime.InteropServices.GCHandle _pinningHandle;

            /*0x3258020*/ PinnedBufferMemoryStream(byte[] array);
            /*0x3258334*/ int Read(System.Span<byte> buffer);
            /*0x3258558*/ void Write(System.ReadOnlySpan<byte> buffer);
            /*0x325883c*/ void Finalize();
            /*0x32588d0*/ void Dispose(bool disposing);
        }

        enum SeekOrigin
        {
            Begin = 0,
            Current = 1,
            End = 2,
        }

        class StreamHelpers
        {
            static /*0x3256428*/ void ValidateCopyToArgs(System.IO.Stream source, System.IO.Stream destination, int bufferSize);
        }

        class StreamReader : System.IO.TextReader
        {
            static /*0x0*/ System.IO.StreamReader Null;
            /*0x18*/ System.IO.Stream _stream;
            /*0x20*/ System.Text.Encoding _encoding;
            /*0x28*/ System.Text.Decoder _decoder;
            /*0x30*/ byte[] _byteBuffer;
            /*0x38*/ char[] _charBuffer;
            /*0x40*/ int _charPos;
            /*0x44*/ int _charLen;
            /*0x48*/ int _byteLen;
            /*0x4c*/ int _bytePos;
            /*0x50*/ int _maxCharsPerBuffer;
            /*0x54*/ bool _detectEncoding;
            /*0x55*/ bool _checkPreamble;
            /*0x56*/ bool _isBlocked;
            /*0x57*/ bool _closable;
            /*0x58*/ System.Threading.Tasks.Task _asyncReadTask;

            static /*0x325a47c*/ StreamReader();
            static /*0x325898c*/ void ThrowAsyncIOInProgress();
            /*0x32589d8*/ StreamReader();
            /*0x3258aa4*/ StreamReader(System.IO.Stream stream, System.Text.Encoding encoding);
            /*0x3258ccc*/ StreamReader(System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks);
            /*0x3258ab4*/ StreamReader(System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);
            /*0x3258e40*/ StreamReader(string path);
            /*0x3258e78*/ StreamReader(string path, bool detectEncodingFromByteOrderMarks);
            /*0x32590f0*/ StreamReader(string path, System.Text.Encoding encoding);
            /*0x32590fc*/ StreamReader(string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks);
            /*0x3258eb4*/ StreamReader(string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
            /*0x3258920*/ void CheckAsyncTaskInProgress();
            /*0x3258cd8*/ void Init(System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);
            /*0x3259104*/ void Init(System.IO.Stream stream);
            /*0x3259128*/ void Close();
            /*0x3259138*/ void Dispose(bool disposing);
            /*0x32591dc*/ System.Text.Encoding get_CurrentEncoding();
            /*0x32591e4*/ System.IO.Stream get_BaseStream();
            /*0x32591cc*/ bool get_LeaveOpen();
            /*0x32591ec*/ int Peek();
            /*0x32592b0*/ int Read();
            /*0x3259374*/ int Read(char[] buffer, int index, int count);
            /*0x3259510*/ int ReadSpan(System.Span<char> buffer);
            /*0x3259b44*/ string ReadToEnd();
            /*0x3259c5c*/ void CompressBuffer(int n);
            /*0x3259ca0*/ void DetectEncoding();
            /*0x3259f78*/ bool IsPreamble();
            /*0x325a0a0*/ int ReadBuffer();
            /*0x325976c*/ int ReadBuffer(System.Span<char> userBuffer, ref bool readToUserBuffer);
            /*0x325a204*/ string ReadLine();
            /*0x325a46c*/ bool DataAvailable();

            class NullStreamReader : System.IO.StreamReader
            {
                /*0x325a4f4*/ NullStreamReader();
                /*0x325a590*/ System.IO.Stream get_BaseStream();
                /*0x325a5e8*/ System.Text.Encoding get_CurrentEncoding();
                /*0x325a5f0*/ void Dispose(bool disposing);
                /*0x325a5f4*/ int Peek();
                /*0x325a5fc*/ int Read();
                /*0x325a604*/ int Read(char[] buffer, int index, int count);
                /*0x325a60c*/ string ReadLine();
                /*0x325a614*/ string ReadToEnd();
                /*0x325a62c*/ int ReadBuffer();
            }
        }

        class StreamWriter : System.IO.TextWriter
        {
            static /*0x0*/ System.IO.StreamWriter Null;
            /*0x30*/ System.IO.Stream _stream;
            /*0x38*/ System.Text.Encoding _encoding;
            /*0x40*/ System.Text.Encoder _encoder;
            /*0x48*/ byte[] _byteBuffer;
            /*0x50*/ char[] _charBuffer;
            /*0x58*/ int _charPos;
            /*0x5c*/ int _charLen;
            /*0x60*/ bool _autoFlush;
            /*0x61*/ bool _haveWrittenPreamble;
            /*0x62*/ bool _closable;
            /*0x68*/ System.Threading.Tasks.Task _asyncWriteTask;

            static /*0x325b9f8*/ StreamWriter();
            static /*0x325a6a0*/ void ThrowAsyncIOInProgress();
            static /*0x325a6ec*/ System.Text.Encoding get_UTF8NoBOM();
            /*0x325a73c*/ StreamWriter();
            /*0x325a8a4*/ StreamWriter(System.IO.Stream stream);
            /*0x325ab20*/ StreamWriter(System.IO.Stream stream, System.Text.Encoding encoding);
            /*0x325a918*/ StreamWriter(System.IO.Stream stream, System.Text.Encoding encoding, int bufferSize, bool leaveOpen);
            /*0x325acac*/ StreamWriter(string path);
            /*0x325af64*/ StreamWriter(string path, bool append);
            /*0x325ad20*/ StreamWriter(string path, bool append, System.Text.Encoding encoding, int bufferSize);
            /*0x325a634*/ void CheckAsyncTaskInProgress();
            /*0x325ab2c*/ void Init(System.IO.Stream streamArg, System.Text.Encoding encodingArg, int bufferSize, bool shouldLeaveOpen);
            /*0x325b074*/ void Close();
            /*0x325b0e0*/ void Dispose(bool disposing);
            /*0x325b2ec*/ void Flush();
            /*0x325b170*/ void Flush(bool flushStream, bool flushEncoder);
            /*0x325b30c*/ void set_AutoFlush(bool value);
            /*0x325b34c*/ System.IO.Stream get_BaseStream();
            /*0x325b354*/ bool get_LeaveOpen();
            /*0x325b364*/ System.Text.Encoding get_Encoding();
            /*0x325b36c*/ void Write(char value);
            /*0x325b3f8*/ void Write(char[] buffer);
            /*0x325b46c*/ void Write(char[] buffer, int index, int count);
            /*0x325b658*/ void WriteSpan(System.ReadOnlySpan<char> buffer, bool appendNewLine);
            /*0x325b914*/ void Write(string value);
            /*0x325b984*/ void WriteLine(string value);
        }

        class TextReader : System.MarshalByRefObject, System.IDisposable
        {
            static /*0x0*/ System.IO.TextReader Null;

            static /*0x325c068*/ TextReader();
            static /*0x325bf40*/ System.IO.TextReader Synchronized(System.IO.TextReader reader);
            /*0x3258a9c*/ TextReader();
            /*0x325bab0*/ void Close();
            /*0x325bb1c*/ void Dispose();
            /*0x325bb88*/ void Dispose(bool disposing);
            /*0x325bb8c*/ int Peek();
            /*0x325bb94*/ int Read();
            /*0x325bb9c*/ int Read(char[] buffer, int index, int count);
            /*0x325bd48*/ string ReadToEnd();
            /*0x325be48*/ string ReadLine();

            class NullTextReader : System.IO.TextReader
            {
                /*0x325c0e0*/ NullTextReader();
                /*0x325c138*/ int Read(char[] buffer, int index, int count);
                /*0x325c140*/ string ReadLine();
            }

            class SyncTextReader : System.IO.TextReader
            {
                /*0x18*/ System.IO.TextReader _in;

                /*0x325bff4*/ SyncTextReader(System.IO.TextReader t);
                /*0x325c148*/ void Close();
                /*0x325c164*/ void Dispose(bool disposing);
                /*0x325c218*/ int Peek();
                /*0x325c234*/ int Read();
                /*0x325c250*/ int Read(char[] buffer, int index, int count);
                /*0x325c26c*/ string ReadLine();
                /*0x325c28c*/ string ReadToEnd();
            }
        }

        class TextWriter : System.MarshalByRefObject, System.IDisposable
        {
            static /*0x0*/ System.IO.TextWriter Null;
            static /*0x8*/ char[] s_coreNewLine;
            /*0x18*/ char[] CoreNewLine;
            /*0x20*/ string CoreNewLineStr;
            /*0x28*/ System.IFormatProvider _internalFormatProvider;

            static /*0x325c76c*/ TextWriter();
            static /*0x325c634*/ System.IO.TextWriter Synchronized(System.IO.TextWriter writer);
            /*0x325afdc*/ TextWriter();
            /*0x325a800*/ TextWriter(System.IFormatProvider formatProvider);
            /*0x325c2a8*/ System.IFormatProvider get_FormatProvider();
            /*0x325c310*/ void Close();
            /*0x325c37c*/ void Dispose(bool disposing);
            /*0x325c380*/ void Dispose();
            /*0x325c3ec*/ void Flush();
            /*0x1f30214*/ System.Text.Encoding get_Encoding();
            /*0x325c3f0*/ string get_NewLine();
            /*0x325c3f8*/ void Write(char value);
            /*0x325c3fc*/ void Write(char[] buffer);
            /*0x325c41c*/ void Write(char[] buffer, int index, int count);
            /*0x325c5ac*/ void Write(string value);
            /*0x325c5e4*/ void WriteLine();
            /*0x325c5f8*/ void WriteLine(string value);

            class NullTextWriter : System.IO.TextWriter
            {
                /*0x325c814*/ NullTextWriter();
                /*0x325c8a0*/ System.Text.Encoding get_Encoding();
                /*0x325c8a8*/ void Write(char[] buffer, int index, int count);
                /*0x325c8ac*/ void Write(string value);
                /*0x325c8b0*/ void WriteLine();
                /*0x325c8b4*/ void WriteLine(string value);
                /*0x325c8b8*/ void Write(char value);
            }

            class SyncTextWriter : System.IO.TextWriter, System.IDisposable
            {
                /*0x30*/ System.IO.TextWriter _out;

                /*0x325c6e8*/ SyncTextWriter(System.IO.TextWriter t);
                /*0x325c8bc*/ System.Text.Encoding get_Encoding();
                /*0x325c8d8*/ System.IFormatProvider get_FormatProvider();
                /*0x325c8f4*/ string get_NewLine();
                /*0x325c910*/ void Close();
                /*0x325c92c*/ void Dispose(bool disposing);
                /*0x325c9e0*/ void Flush();
                /*0x325c9fc*/ void Write(char value);
                /*0x325ca1c*/ void Write(char[] buffer);
                /*0x325ca3c*/ void Write(char[] buffer, int index, int count);
                /*0x325ca5c*/ void Write(string value);
                /*0x325ca7c*/ void WriteLine();
                /*0x325ca9c*/ void WriteLine(string value);
            }
        }

        class UnmanagedMemoryStream : System.IO.Stream
        {
            /*0x28*/ System.Runtime.InteropServices.SafeBuffer _buffer;
            /*0x30*/ byte* _mem;
            /*0x38*/ long _length;
            /*0x40*/ long _capacity;
            /*0x48*/ long _position;
            /*0x50*/ long _offset;
            /*0x58*/ System.IO.FileAccess _access;
            /*0x5c*/ bool _isOpen;
            /*0x60*/ System.Threading.Tasks.Task<int> _lastReadTask;

            /*0x32580e4*/ UnmanagedMemoryStream();
            /*0x325cabc*/ UnmanagedMemoryStream(byte* pointer, long length);
            /*0x325cb3c*/ UnmanagedMemoryStream(byte* pointer, long length, long capacity, System.IO.FileAccess access);
            /*0x3258148*/ void Initialize(byte* pointer, long length, long capacity, System.IO.FileAccess access);
            /*0x325cbcc*/ bool get_CanRead();
            /*0x325cbe8*/ bool get_CanSeek();
            /*0x325cbf0*/ bool get_CanWrite();
            /*0x3258910*/ void Dispose(bool disposing);
            /*0x325cc0c*/ void EnsureNotClosed();
            /*0x325cc3c*/ void EnsureReadable();
            /*0x325cc78*/ void EnsureWriteable();
            /*0x325ccb4*/ void Flush();
            /*0x325ccb8*/ System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken cancellationToken);
            /*0x325ce74*/ long get_Length();
            /*0x325ce90*/ long get_Position();
            /*0x325ced8*/ void set_Position(long value);
            /*0x325cf7c*/ byte* get_PositionPointer();
            /*0x325d034*/ int Read(byte[] buffer, int offset, int count);
            /*0x325d1cc*/ int Read(System.Span<byte> buffer);
            /*0x3258338*/ int ReadCore(System.Span<byte> buffer);
            /*0x325d298*/ System.Threading.Tasks.Task<int> ReadAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
            /*0x325d600*/ System.Threading.Tasks.ValueTask<int> ReadAsync(System.Memory<byte> buffer, System.Threading.CancellationToken cancellationToken);
            /*0x325d930*/ int ReadByte();
            /*0x325da8c*/ long Seek(long offset, System.IO.SeekOrigin loc);
            /*0x325db7c*/ void SetLength(long value);
            /*0x325dce4*/ void Write(byte[] buffer, int offset, int count);
            /*0x325dea8*/ void Write(System.ReadOnlySpan<byte> buffer);
            /*0x325855c*/ void WriteCore(System.ReadOnlySpan<byte> buffer);
            /*0x325df74*/ System.Threading.Tasks.Task WriteAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
            /*0x325e26c*/ System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory<byte> buffer, System.Threading.CancellationToken cancellationToken);
            /*0x325e528*/ void WriteByte(byte value);
        }

        class DriveNotFoundException : System.IO.IOException
        {
            /*0x325e73c*/ DriveNotFoundException();
            /*0x325e798*/ DriveNotFoundException(string message);
            /*0x325e7bc*/ DriveNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class Directory
        {
            static /*0x325e7c4*/ System.IO.DirectoryInfo CreateDirectory(string path);
            static /*0x3251de0*/ bool Exists(string path);
            static /*0x325e904*/ string[] GetFiles(string path);
            static /*0x325ea14*/ string[] GetFiles(string path, string searchPattern);
            static /*0x325eab4*/ string[] GetFiles(string path, string searchPattern, System.IO.SearchOption searchOption);
            static /*0x325e9ac*/ string[] GetFiles(string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);
            static /*0x325ee34*/ string[] GetDirectories(string path);
            static /*0x325eedc*/ string[] GetDirectories(string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);
            static /*0x325ec74*/ System.Collections.Generic.IEnumerable<string> InternalEnumeratePaths(string path, string searchPattern, System.IO.SearchTarget searchTarget, System.IO.EnumerationOptions options);
            static /*0x3253544*/ System.Collections.Generic.IEnumerable<string> EnumerateFileSystemEntries(string path);
            static /*0x325ef44*/ System.Collections.Generic.IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);
            static /*0x3252b60*/ string InternalGetDirectoryRoot(string path);
            static /*0x325ef50*/ string GetCurrentDirectory();
            static /*0x325ef58*/ void Delete(string path, bool recursive);
            static /*0x325efc4*/ string InsecureGetCurrentDirectory();
        }

        class DirectoryInfo : System.IO.FileSystemInfo
        {
            static /*0x325f608*/ System.Collections.Generic.IEnumerable<System.IO.FileSystemInfo> InternalEnumerateInfos(string path, string searchPattern, System.IO.SearchTarget searchTarget, System.IO.EnumerationOptions options);
            /*0x3252d64*/ DirectoryInfo(string path);
            /*0x3253d7c*/ DirectoryInfo(string originalPath, string fullPath, string fileName, bool isNormalized);
            /*0x325f7c0*/ DirectoryInfo(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x325f0d4*/ void Init(string originalPath, string fullPath, string fileName, bool isNormalized);
            /*0x325f374*/ System.IO.DirectoryInfo get_Parent();
            /*0x325f4c0*/ System.IO.FileInfo[] GetFiles();
            /*0x325f568*/ System.IO.FileInfo[] GetFiles(string searchPattern, System.IO.EnumerationOptions enumerationOptions);
        }

        class EnumerationOptions
        {
            static /*0x0*/ System.IO.EnumerationOptions <Compatible>k__BackingField;
            static /*0x8*/ System.IO.EnumerationOptions <CompatibleRecursive>k__BackingField;
            static /*0x10*/ System.IO.EnumerationOptions <Default>k__BackingField;
            /*0x10*/ bool <RecurseSubdirectories>k__BackingField;
            /*0x11*/ bool <IgnoreInaccessible>k__BackingField;
            /*0x14*/ System.IO.FileAttributes <AttributesToSkip>k__BackingField;
            /*0x18*/ System.IO.MatchType <MatchType>k__BackingField;
            /*0x1c*/ System.IO.MatchCasing <MatchCasing>k__BackingField;
            /*0x20*/ bool <ReturnSpecialDirectories>k__BackingField;

            static /*0x325faa4*/ EnumerationOptions();
            static /*0x325f924*/ System.IO.EnumerationOptions get_Compatible();
            static /*0x325f97c*/ System.IO.EnumerationOptions get_CompatibleRecursive();
            static /*0x325f9d4*/ System.IO.EnumerationOptions get_Default();
            static /*0x325eb28*/ System.IO.EnumerationOptions FromSearchOption(System.IO.SearchOption searchOption);
            /*0x325fa2c*/ EnumerationOptions();
            /*0x325fa54*/ bool get_RecurseSubdirectories();
            /*0x325fa5c*/ void set_RecurseSubdirectories(bool value);
            /*0x325fa64*/ bool get_IgnoreInaccessible();
            /*0x325fa6c*/ void set_IgnoreInaccessible(bool value);
            /*0x325fa74*/ System.IO.FileAttributes get_AttributesToSkip();
            /*0x325fa7c*/ void set_AttributesToSkip(System.IO.FileAttributes value);
            /*0x325fa84*/ System.IO.MatchType get_MatchType();
            /*0x325fa8c*/ void set_MatchType(System.IO.MatchType value);
            /*0x325fa94*/ System.IO.MatchCasing get_MatchCasing();
            /*0x325fa9c*/ bool get_ReturnSpecialDirectories();
        }

        class File
        {
            static /*0x325fb8c*/ System.IO.StreamReader OpenText(string path);
            static /*0x325fc48*/ System.IO.StreamWriter AppendText(string path);
            static /*0x325fcf0*/ void Copy(string sourceFileName, string destFileName, bool overwrite);
            static /*0x325fe84*/ System.IO.FileStream Create(string path);
            static /*0x325fe8c*/ System.IO.FileStream Create(string path, int bufferSize);
            static /*0x325ff04*/ void Delete(string path);
            static /*0x3257d84*/ bool Exists(string path);
            static /*0x325ffac*/ System.IO.FileStream Open(string path, System.IO.FileMode mode);
            static /*0x325ffc0*/ System.IO.FileStream Open(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
            static /*0x3260044*/ System.DateTimeOffset GetUtcDateTimeOffset(System.DateTime dateTime);
            static /*0x3260120*/ System.DateTime GetLastAccessTimeUtc(string path);
            static /*0x32601c4*/ void SetLastWriteTimeUtc(string path, System.DateTime lastWriteTimeUtc);
            static /*0x3260250*/ System.DateTime GetLastWriteTime(string path);
            static /*0x32602f4*/ System.IO.FileAttributes GetAttributes(string path);
            static /*0x3260350*/ void SetAttributes(string path, System.IO.FileAttributes fileAttributes);
            static /*0x3260464*/ System.IO.FileStream OpenRead(string path);
            static /*0x32604cc*/ string ReadAllText(string path);
            static /*0x3260590*/ string InternalReadAllText(string path, System.Text.Encoding encoding);
            static /*0x3260704*/ void WriteAllText(string path, string contents);
            static /*0x32608f8*/ byte[] ReadAllBytes(string path);
            static /*0x3260b80*/ byte[] ReadAllBytesUnknownLength(System.IO.FileStream fs);
            static /*0x3261110*/ void WriteAllBytes(string path, byte[] bytes);
            static /*0x326120c*/ void InternalWriteAllBytes(string path, byte[] bytes);
            static /*0x3261388*/ string[] ReadAllLines(string path);
            static /*0x326144c*/ string[] InternalReadAllLines(string path, System.Text.Encoding encoding);
            static /*0x3261668*/ void WriteAllLines(string path, System.Collections.Generic.IEnumerable<string> contents);
            static /*0x3261788*/ void InternalWriteAllLines(System.IO.TextWriter writer, System.Collections.Generic.IEnumerable<string> contents);
            static /*0x3261b04*/ void Move(string sourceFileName, string destFileName);
        }

        class FileInfo : System.IO.FileSystemInfo
        {
            /*0x3261d2c*/ FileInfo();
            /*0x3261d30*/ FileInfo(string fileName);
            /*0x3253808*/ FileInfo(string originalPath, string fullPath, string fileName, bool isNormalized);
            /*0x3261e64*/ FileInfo(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x3261d40*/ long get_Length();
            /*0x3261e34*/ void set_IsReadOnly(bool value);
            /*0x3261e68*/ string get_Name();
        }

        struct FileStatus
        {
            /*0x10*/ Interop.Sys.FileStatus _fileStatus;
            /*0x80*/ int _fileStatusInitialized;
            /*0x84*/ bool <InitiallyDirectory>k__BackingField;
            /*0x85*/ bool _isDirectory;
            /*0x86*/ bool _exists;

            static /*0x3261e80*/ void Initialize(ref System.IO.FileStatus status, bool isDirectory);
            /*0x3261e70*/ bool get_InitiallyDirectory();
            /*0x3261e78*/ void set_InitiallyDirectory(bool value);
            /*0x3261e90*/ bool IsReadOnly(System.ReadOnlySpan<char> path, bool continueOnError);
            /*0x326203c*/ System.IO.FileAttributes GetAttributes(System.ReadOnlySpan<char> path, System.ReadOnlySpan<char> fileName);
            /*0x3262124*/ void SetAttributes(string path, System.IO.FileAttributes attributes);
            /*0x326231c*/ bool GetExists(System.ReadOnlySpan<char> path);
            /*0x32624f0*/ System.DateTimeOffset GetLastAccessTime(System.ReadOnlySpan<char> path, bool continueOnError);
            /*0x3262644*/ System.DateTimeOffset GetLastWriteTime(System.ReadOnlySpan<char> path, bool continueOnError);
            /*0x32626e0*/ void SetLastWriteTime(string path, System.DateTimeOffset time);
            /*0x326258c*/ System.DateTimeOffset UnixTimeToDateTimeOffset(long seconds, long nanoseconds);
            /*0x326282c*/ void SetAccessWriteTimes(string path, System.Nullable<long> accessSec, System.Nullable<long> accessUSec, System.Nullable<long> writeSec, System.Nullable<long> writeUSec);
            /*0x3262c8c*/ long GetLength(System.ReadOnlySpan<char> path, bool continueOnError);
            /*0x3262360*/ void Refresh(System.ReadOnlySpan<char> path);
            /*0x3261f7c*/ void EnsureStatInitialized(System.ReadOnlySpan<char> path, bool continueOnError);
        }

        class FileSystemInfo : System.MarshalByRefObject, System.Runtime.Serialization.ISerializable
        {
            /*0x18*/ System.IO.FileStatus _fileStatus;
            /*0x90*/ string FullPath;
            /*0x98*/ string OriginalPath;
            /*0xa0*/ string _name;

            static /*0x3262ca4*/ System.IO.FileSystemInfo Create(string fullPath, string fileName, ref System.IO.FileStatus fileStatus);
            static /*0x3253948*/ void ThrowNotFound(string path);
            /*0x325f060*/ FileSystemInfo();
            /*0x325f7c4*/ FileSystemInfo(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x3262d74*/ void Init(ref System.IO.FileStatus fileStatus);
            /*0x3253478*/ System.IO.FileAttributes get_Attributes();
            /*0x3253a60*/ void set_Attributes(System.IO.FileAttributes value);
            /*0x3262dec*/ bool get_ExistsCore();
            /*0x3262e84*/ System.DateTimeOffset get_LastAccessTimeCore();
            /*0x3262ef0*/ System.DateTimeOffset get_LastWriteTimeCore();
            /*0x3253dc4*/ void set_LastWriteTimeCore(System.DateTimeOffset value);
            /*0x3261dc0*/ long get_LengthCore();
            /*0x3262f5c*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x3263088*/ string get_FullName();
            /*0x3263090*/ string get_Extension();
            /*0x32631b0*/ string get_Name();
            /*0x32631b8*/ bool get_Exists();
            /*0x3253b18*/ System.DateTime get_LastAccessTime();
            /*0x3263240*/ System.DateTime get_LastAccessTimeUtc();
            /*0x3253c34*/ System.DateTime get_LastWriteTime();
            /*0x32632b8*/ System.DateTime get_LastWriteTimeUtc();
            /*0x3263330*/ void set_LastWriteTimeUtc(System.DateTime value);
            /*0x3263358*/ string ToString();
        }

        enum MatchCasing
        {
            PlatformDefault = 0,
            CaseSensitive = 1,
            CaseInsensitive = 2,
        }

        enum MatchType
        {
            Simple = 0,
            Win32 = 1,
        }

        enum SearchOption
        {
            TopDirectoryOnly = 0,
            AllDirectories = 1,
        }

        enum SearchTarget
        {
            Files = 1,
            Directories = 2,
            Both = 3,
        }

        class BufferedStream : System.IO.Stream
        {
            /*0x28*/ System.IO.Stream _stream;
            /*0x30*/ byte[] _buffer;
            /*0x38*/ int _bufferSize;
            /*0x3c*/ int _readPos;
            /*0x40*/ int _readLen;
            /*0x44*/ int _writePos;
            /*0x48*/ System.Threading.Tasks.Task<int> _lastSyncCompletedReadTask;
            /*0x50*/ System.Threading.SemaphoreSlim _asyncActiveSemaphore;

            /*0x3263474*/ BufferedStream(System.IO.Stream stream);
            /*0x326347c*/ BufferedStream(System.IO.Stream stream, int bufferSize);
            /*0x326337c*/ System.Threading.SemaphoreSlim LazyEnsureAsyncActiveSemaphoreInitialized();
            /*0x3263660*/ void EnsureNotClosed();
            /*0x32636bc*/ void EnsureCanSeek();
            /*0x326372c*/ void EnsureCanRead();
            /*0x326379c*/ void EnsureCanWrite();
            /*0x326380c*/ void EnsureShadowBufferAllocated();
            /*0x32638f8*/ void EnsureBufferAllocated();
            /*0x3263968*/ bool get_CanRead();
            /*0x3263980*/ bool get_CanWrite();
            /*0x3263998*/ bool get_CanSeek();
            /*0x32639b0*/ long get_Length();
            /*0x3263a3c*/ long get_Position();
            /*0x3263a84*/ void set_Position(long value);
            /*0x3263b44*/ void Dispose(bool disposing);
            /*0x3263ca4*/ void Flush();
            /*0x3263dac*/ System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken cancellationToken);
            /*0x3263e78*/ System.Threading.Tasks.Task FlushAsyncInternal(System.Threading.CancellationToken cancellationToken);
            /*0x3263d68*/ void FlushRead();
            /*0x3263f70*/ void ClearReadBufferBeforeWrite();
            /*0x32639ec*/ void FlushWrite();
            /*0x3264000*/ System.Threading.Tasks.Task FlushWriteAsync(System.Threading.CancellationToken cancellationToken);
            /*0x32640f8*/ int ReadFromBuffer(byte[] array, int offset, int count);
            /*0x326415c*/ int ReadFromBuffer(System.Span<byte> destination);
            /*0x32642c4*/ int ReadFromBuffer(byte[] array, int offset, int count, ref System.Exception error);
            /*0x32643a4*/ int Read(byte[] array, int offset, int count);
            /*0x32645bc*/ int Read(System.Span<byte> destination);
            /*0x326474c*/ System.Threading.Tasks.Task<int> LastSyncCompletedReadTask(int val);
            /*0x326481c*/ System.Threading.Tasks.Task<int> ReadAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
            /*0x3264d5c*/ System.Threading.Tasks.ValueTask<int> ReadAsync(System.Memory<byte> buffer, System.Threading.CancellationToken cancellationToken);
            /*0x3264c0c*/ System.Threading.Tasks.ValueTask<int> ReadFromUnderlyingStreamAsync(System.Memory<byte> buffer, System.Threading.CancellationToken cancellationToken, int bytesAlreadySatisfied, System.Threading.Tasks.Task semaphoreLockTask);
            /*0x32650a0*/ System.IAsyncResult BeginRead(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state);
            /*0x3265154*/ int EndRead(System.IAsyncResult asyncResult);
            /*0x32651b0*/ int ReadByte();
            /*0x3265200*/ int ReadByteSlow();
            /*0x3265290*/ void WriteToBuffer(byte[] array, ref int offset, ref int count);
            /*0x326536c*/ int WriteToBuffer(System.ReadOnlySpan<byte> buffer);
            /*0x32654f0*/ void Write(byte[] array, int offset, int count);
            /*0x3265800*/ void Write(System.ReadOnlySpan<byte> buffer);
            /*0x3265ab0*/ System.Threading.Tasks.Task WriteAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
            /*0x3265ca4*/ System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory<byte> buffer, System.Threading.CancellationToken cancellationToken);
            /*0x3265f3c*/ System.Threading.Tasks.Task WriteToUnderlyingStreamAsync(System.ReadOnlyMemory<byte> buffer, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.Task semaphoreLockTask);
            /*0x3266078*/ System.IAsyncResult BeginWrite(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state);
            /*0x326612c*/ void EndWrite(System.IAsyncResult asyncResult);
            /*0x3266138*/ void WriteByte(byte value);
            /*0x32661c4*/ long Seek(long offset, System.IO.SeekOrigin origin);
            /*0x32662e4*/ void SetLength(long value);
            /*0x32663a4*/ void CopyTo(System.IO.Stream destination, int bufferSize);
            /*0x3266430*/ System.Threading.Tasks.Task CopyToAsync(System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);
            /*0x326651c*/ System.Threading.Tasks.Task CopyToAsyncCore(System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);

            class <>c
            {
                static /*0x0*/ System.IO.BufferedStream.<> <>9;
                static /*0x8*/ System.Func<System.Threading.SemaphoreSlim> <>9__10_0;

                static /*0x326663c*/ <>c();
                /*0x32666a4*/ <>c();
                /*0x32666ac*/ System.Threading.SemaphoreSlim <LazyEnsureAsyncActiveSemaphoreInitialized>b__10_0();
            }

            struct <FlushAsyncInternal>d__38 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder <>t__builder;
                /*0x30*/ System.IO.BufferedStream <>4__this;
                /*0x38*/ System.Threading.CancellationToken cancellationToken;
                /*0x40*/ System.Threading.SemaphoreSlim <sem>5__2;
                /*0x48*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter <>u__1;

                /*0x3266708*/ void MoveNext();
                /*0x3266d84*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }

            struct <FlushWriteAsync>d__42 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder <>t__builder;
                /*0x30*/ System.IO.BufferedStream <>4__this;
                /*0x38*/ System.Threading.CancellationToken cancellationToken;
                /*0x40*/ System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter <>u__1;
                /*0x50*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter <>u__2;

                /*0x3266dec*/ void MoveNext();
                /*0x32671e4*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }

            struct <ReadFromUnderlyingStreamAsync>d__51 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder<int> <>t__builder;
                /*0x38*/ System.Threading.Tasks.Task semaphoreLockTask;
                /*0x40*/ System.IO.BufferedStream <>4__this;
                /*0x48*/ System.Memory<byte> buffer;
                /*0x58*/ int bytesAlreadySatisfied;
                /*0x60*/ System.Threading.CancellationToken cancellationToken;
                /*0x68*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter <>u__1;
                /*0x78*/ int <>7__wrap1;
                /*0x80*/ System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter<int> <>u__2;

                /*0x326724c*/ void MoveNext();
                /*0x3267b20*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }

            struct <WriteToUnderlyingStreamAsync>d__63 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder <>t__builder;
                /*0x30*/ System.Threading.Tasks.Task semaphoreLockTask;
                /*0x38*/ System.IO.BufferedStream <>4__this;
                /*0x40*/ System.ReadOnlyMemory<byte> buffer;
                /*0x50*/ System.Threading.CancellationToken cancellationToken;
                /*0x58*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter <>u__1;
                /*0x68*/ System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter <>u__2;

                /*0x3267b78*/ void MoveNext();
                /*0x32687d8*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }

            struct <CopyToAsyncCore>d__71 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder <>t__builder;
                /*0x30*/ System.IO.BufferedStream <>4__this;
                /*0x38*/ System.IO.Stream destination;
                /*0x40*/ System.Threading.CancellationToken cancellationToken;
                /*0x48*/ int bufferSize;
                /*0x50*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter <>u__1;
                /*0x60*/ System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter <>u__2;

                /*0x3268b40*/ void MoveNext();
                /*0x32691f4*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }
        }

        enum FileAttributes
        {
            ReadOnly = 1,
            Hidden = 2,
            System = 4,
            Directory = 16,
            Archive = 32,
            Device = 64,
            Normal = 128,
            Temporary = 256,
            SparseFile = 512,
            ReparsePoint = 1024,
            Compressed = 2048,
            Offline = 4096,
            NotContentIndexed = 8192,
            Encrypted = 16384,
            IntegrityStream = 32768,
            NoScrubData = 131072,
        }

        class Stream : System.MarshalByRefObject, System.IDisposable
        {
            static /*0x0*/ System.IO.Stream Null;
            /*0x18*/ System.IO.Stream.ReadWriteTask _activeReadWriteTask;
            /*0x20*/ System.Threading.SemaphoreSlim _asyncActiveSemaphore;

            static /*0x326bfd8*/ Stream();
            static /*0x326bc4c*/ int BlockingEndRead(System.IAsyncResult asyncResult);
            static /*0x326bee0*/ void BlockingEndWrite(System.IAsyncResult asyncResult);
            static /*0x326a8a8*/ System.Threading.Tasks.ValueTask<int> <ReadAsync>g__FinishReadAsync|44_0(System.Threading.Tasks.Task<int> readTask, byte[] localBuffer, System.Memory<byte> localDestination);
            /*0x326bfd0*/ Stream();
            /*0x326925c*/ System.Threading.SemaphoreSlim EnsureAsyncActiveSemaphoreInitialized();
            /*0x1f2fe14*/ bool get_CanRead();
            /*0x1f2fe14*/ bool get_CanSeek();
            /*0x3269354*/ bool get_CanTimeout();
            /*0x1f2fe14*/ bool get_CanWrite();
            long get_Length();
            long get_Position();
            /*0x1f30d60*/ void set_Position(long value);
            /*0x326935c*/ int get_ReadTimeout();
            /*0x32693a8*/ void set_ReadTimeout(int value);
            /*0x32693f4*/ int get_WriteTimeout();
            /*0x3269440*/ void set_WriteTimeout(int value);
            /*0x326948c*/ System.Threading.Tasks.Task CopyToAsync(System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);
            /*0x32694d0*/ System.Threading.Tasks.Task CopyToAsyncInternal(System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);
            /*0x32695f4*/ void CopyTo(System.IO.Stream destination);
            /*0x32696f0*/ void CopyTo(System.IO.Stream destination, int bufferSize);
            /*0x326962c*/ int GetCopyBufferSize();
            /*0x32698bc*/ void Close();
            /*0x326992c*/ void Dispose();
            /*0x326993c*/ void Dispose(bool disposing);
            /*0x1f309e4*/ void Flush();
            /*0x3269940*/ System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken cancellationToken);
            /*0x3269b08*/ System.IAsyncResult BeginRead(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state);
            /*0x3269b28*/ System.IAsyncResult BeginReadInternal(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state, bool serializeAsynchronously, bool apm);
            /*0x326a0fc*/ int EndRead(System.IAsyncResult asyncResult);
            /*0x326a2bc*/ System.Threading.Tasks.Task<int> ReadAsync(byte[] buffer, int offset, int count);
            /*0x326a350*/ System.Threading.Tasks.Task<int> ReadAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
            /*0x326a610*/ System.Threading.Tasks.ValueTask<int> ReadAsync(System.Memory<byte> buffer, System.Threading.CancellationToken cancellationToken);
            /*0x326a430*/ System.Threading.Tasks.Task<int> BeginEndReadAsync(byte[] buffer, int offset, int count);
            /*0x326a9dc*/ System.IAsyncResult BeginWrite(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state);
            /*0x326a9fc*/ System.IAsyncResult BeginWriteInternal(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state, bool serializeAsynchronously, bool apm);
            /*0x3269eac*/ void RunReadWriteTaskWhenReady(System.Threading.Tasks.Task asyncWaiter, System.IO.Stream.ReadWriteTask readWriteTask);
            /*0x326a034*/ void RunReadWriteTask(System.IO.Stream.ReadWriteTask readWriteTask);
            /*0x326ac08*/ void FinishTrackingAsyncOperation();
            /*0x326ac38*/ void EndWrite(System.IAsyncResult asyncResult);
            /*0x326adf0*/ System.Threading.Tasks.Task WriteAsync(byte[] buffer, int offset, int count);
            /*0x326ae84*/ System.Threading.Tasks.Task WriteAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
            /*0x326b130*/ System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory<byte> buffer, System.Threading.CancellationToken cancellationToken);
            /*0x326b3f8*/ System.Threading.Tasks.Task FinishWriteAsync(System.Threading.Tasks.Task writeTask, byte[] localBuffer);
            /*0x326af50*/ System.Threading.Tasks.Task BeginEndWriteAsync(byte[] buffer, int offset, int count);
            long Seek(long offset, System.IO.SeekOrigin origin);
            /*0x1f30d60*/ void SetLength(long value);
            int Read(byte[] buffer, int offset, int count);
            /*0x326b4f8*/ int Read(System.Span<byte> buffer);
            /*0x326b74c*/ int ReadByte();
            void Write(byte[] buffer, int offset, int count);
            /*0x326b7e0*/ void Write(System.ReadOnlySpan<byte> buffer);
            /*0x326b9b8*/ void WriteByte(byte value);
            /*0x326ba44*/ System.IAsyncResult BlockingBeginRead(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state);
            /*0x326bd38*/ System.IAsyncResult BlockingBeginWrite(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state);
            /*0x326a9d4*/ bool HasOverriddenBeginEndRead();
            /*0x326b4f0*/ bool HasOverriddenBeginEndWrite();

            struct ReadWriteParameters
            {
                /*0x10*/ byte[] Buffer;
                /*0x18*/ int Offset;
                /*0x1c*/ int Count;
            }

            class ReadWriteTask : System.Threading.Tasks.Task<int>, System.Threading.Tasks.ITaskCompletionAction
            {
                static /*0x0*/ System.Threading.ContextCallback s_invokeAsyncCallback;
                /*0x54*/ bool _isRead;
                /*0x55*/ bool _apm;
                /*0x58*/ System.IO.Stream _stream;
                /*0x60*/ byte[] _buffer;
                /*0x68*/ int _offset;
                /*0x6c*/ int _count;
                /*0x70*/ System.AsyncCallback _callback;
                /*0x78*/ System.Threading.ExecutionContext _context;

                static /*0x326c0d0*/ void InvokeAsyncCallback(object completedTask);
                /*0x3269d28*/ ReadWriteTask(bool isRead, bool apm, System.Func<object, int> function, object state, System.IO.Stream stream, byte[] buffer, int offset, int count, System.AsyncCallback callback);
                /*0x326c0a8*/ void ClearBeginState();
                /*0x326c158*/ void System.Threading.Tasks.ITaskCompletionAction.Invoke(System.Threading.Tasks.Task completingTask);
                /*0x326c29c*/ bool System.Threading.Tasks.ITaskCompletionAction.get_InvokeMayRunArbitraryCode();
            }

            class NullStream : System.IO.Stream
            {
                static /*0x0*/ System.Threading.Tasks.Task<int> s_zeroTask;

                static /*0x326c9d8*/ NullStream();
                /*0x326c050*/ NullStream();
                /*0x326c2a4*/ bool get_CanRead();
                /*0x326c2ac*/ bool get_CanWrite();
                /*0x326c2b4*/ bool get_CanSeek();
                /*0x326c2bc*/ long get_Length();
                /*0x326c2c4*/ long get_Position();
                /*0x326c2cc*/ void set_Position(long value);
                /*0x326c2d0*/ void CopyTo(System.IO.Stream destination, int bufferSize);
                /*0x326c2d8*/ System.Threading.Tasks.Task CopyToAsync(System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);
                /*0x326c3ec*/ void Dispose(bool disposing);
                /*0x326c3f0*/ void Flush();
                /*0x326c3f4*/ System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken cancellationToken);
                /*0x326c4d8*/ System.IAsyncResult BeginRead(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state);
                /*0x326c564*/ int EndRead(System.IAsyncResult asyncResult);
                /*0x326c604*/ System.IAsyncResult BeginWrite(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state);
                /*0x326c690*/ void EndWrite(System.IAsyncResult asyncResult);
                /*0x326c730*/ int Read(byte[] buffer, int offset, int count);
                /*0x326c738*/ int Read(System.Span<byte> buffer);
                /*0x326c740*/ System.Threading.Tasks.Task<int> ReadAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
                /*0x326c798*/ System.Threading.Tasks.ValueTask<int> ReadAsync(System.Memory<byte> buffer, System.Threading.CancellationToken cancellationToken);
                /*0x326c7f8*/ int ReadByte();
                /*0x326c800*/ void Write(byte[] buffer, int offset, int count);
                /*0x326c804*/ void Write(System.ReadOnlySpan<byte> buffer);
                /*0x326c808*/ System.Threading.Tasks.Task WriteAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
                /*0x326c8ec*/ System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory<byte> buffer, System.Threading.CancellationToken cancellationToken);
                /*0x326c9c8*/ void WriteByte(byte value);
                /*0x326c9cc*/ long Seek(long offset, System.IO.SeekOrigin origin);
                /*0x326c9d4*/ void SetLength(long length);
            }

            class SynchronousAsyncResult : System.IAsyncResult
            {
                /*0x10*/ object _stateObject;
                /*0x18*/ bool _isWrite;
                /*0x20*/ System.Threading.ManualResetEvent _waitHandle;
                /*0x28*/ System.Runtime.ExceptionServices.ExceptionDispatchInfo _exceptionInfo;
                /*0x30*/ bool _endXxxCalled;
                /*0x34*/ int _bytesRead;

                static /*0x326bc50*/ int EndRead(System.IAsyncResult asyncResult);
                static /*0x326bee4*/ void EndWrite(System.IAsyncResult asyncResult);
                /*0x326bbb0*/ SynchronousAsyncResult(int bytesRead, object asyncStateObject);
                /*0x326bea4*/ SynchronousAsyncResult(object asyncStateObject);
                /*0x326bbe8*/ SynchronousAsyncResult(System.Exception ex, object asyncStateObject, bool isWrite);
                /*0x326ca78*/ bool get_IsCompleted();
                /*0x326ca80*/ System.Threading.WaitHandle get_AsyncWaitHandle();
                /*0x326cb78*/ object get_AsyncState();
                /*0x326cb80*/ bool get_CompletedSynchronously();
                /*0x326cb88*/ void ThrowIfError();

                class <>c
                {
                    static /*0x0*/ System.IO.Stream.SynchronousAsyncResult.<> <>9;
                    static /*0x8*/ System.Func<System.Threading.ManualResetEvent> <>9__12_0;

                    static /*0x326cb9c*/ <>c();
                    /*0x326cc04*/ <>c();
                    /*0x326cc0c*/ System.Threading.ManualResetEvent <get_AsyncWaitHandle>b__12_0();
                }
            }

            class <>c
            {
                static /*0x0*/ System.IO.Stream.<> <>9;
                static /*0x8*/ System.Func<System.Threading.SemaphoreSlim> <>9__4_0;
                static /*0x10*/ System.Action<object> <>9__37_0;
                static /*0x18*/ System.Func<object, int> <>9__40_0;
                static /*0x20*/ System.Func<System.IO.Stream, System.IO.Stream.ReadWriteParameters, System.AsyncCallback, object, System.IAsyncResult> <>9__45_0;
                static /*0x28*/ System.Func<System.IO.Stream, System.IAsyncResult, int> <>9__45_1;
                static /*0x30*/ System.Func<object, int> <>9__48_0;
                static /*0x38*/ System.Action<System.Threading.Tasks.Task, object> <>9__49_0;
                static /*0x40*/ System.Func<System.IO.Stream, System.IO.Stream.ReadWriteParameters, System.AsyncCallback, object, System.IAsyncResult> <>9__58_0;
                static /*0x48*/ System.Func<System.IO.Stream, System.IAsyncResult, System.Threading.Tasks.VoidTaskResult> <>9__58_1;

                static /*0x326cc64*/ <>c();
                /*0x326cccc*/ <>c();
                /*0x326ccd4*/ System.Threading.SemaphoreSlim <EnsureAsyncActiveSemaphoreInitialized>b__4_0();
                /*0x326cd30*/ void <FlushAsync>b__37_0(object state);
                /*0x326cdb8*/ int <BeginReadInternal>b__40_0(object <p0>);
                /*0x326cf60*/ System.IAsyncResult <BeginEndReadAsync>b__45_0(System.IO.Stream stream, System.IO.Stream.ReadWriteParameters args, System.AsyncCallback callback, object state);
                /*0x326cf90*/ int <BeginEndReadAsync>b__45_1(System.IO.Stream stream, System.IAsyncResult asyncResult);
                /*0x326cfb8*/ int <BeginWriteInternal>b__48_0(object <p0>);
                /*0x326d150*/ void <RunReadWriteTaskWhenReady>b__49_0(System.Threading.Tasks.Task t, object state);
                /*0x326d1bc*/ System.IAsyncResult <BeginEndWriteAsync>b__58_0(System.IO.Stream stream, System.IO.Stream.ReadWriteParameters args, System.AsyncCallback callback, object state);
                /*0x326d1ec*/ System.Threading.Tasks.VoidTaskResult <BeginEndWriteAsync>b__58_1(System.IO.Stream stream, System.IAsyncResult asyncResult);
            }

            struct <CopyToAsyncInternal>d__28 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder <>t__builder;
                /*0x30*/ int bufferSize;
                /*0x38*/ System.IO.Stream <>4__this;
                /*0x40*/ System.Threading.CancellationToken cancellationToken;
                /*0x48*/ System.IO.Stream destination;
                /*0x50*/ byte[] <buffer>5__2;
                /*0x58*/ System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter<int> <>u__1;
                /*0x68*/ System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter <>u__2;

                /*0x326d220*/ void MoveNext();
                /*0x326d8e4*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }

            struct <FinishWriteAsync>d__57 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder <>t__builder;
                /*0x30*/ System.Threading.Tasks.Task writeTask;
                /*0x38*/ byte[] localBuffer;
                /*0x40*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter <>u__1;

                /*0x326d94c*/ void MoveNext();
                /*0x326dbe8*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }

            struct <<ReadAsync>g__FinishReadAsync|44_0>d : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder<int> <>t__builder;
                /*0x38*/ System.Threading.Tasks.Task<int> readTask;
                /*0x40*/ byte[] localBuffer;
                /*0x48*/ System.Memory<byte> localDestination;
                /*0x58*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter<int> <>u__1;

                /*0x326dc50*/ void MoveNext();
                /*0x326dfcc*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }
        }

        class __Error
        {
            static /*0x326e024*/ void EndOfFile();
            static /*0x326e07c*/ void FileNotOpen();
            static /*0x326e0d8*/ void ReaderClosed();
            static /*0x326e134*/ string GetDisplayablePath(string path, bool isInvalidPath);
            static /*0x326e408*/ void WinIOError(int errorCode, string maybeFullPath);
            static /*0x326e948*/ void WriterClosed();
        }

        class BinaryReader : System.IDisposable
        {
            /*0x10*/ System.IO.Stream m_stream;
            /*0x18*/ byte[] m_buffer;
            /*0x20*/ System.Text.Decoder m_decoder;
            /*0x28*/ byte[] m_charBytes;
            /*0x30*/ char[] m_singleChar;
            /*0x38*/ char[] m_charBuffer;
            /*0x40*/ int m_maxCharsSize;
            /*0x44*/ bool m_2BytesPerChar;
            /*0x45*/ bool m_isMemoryStream;
            /*0x46*/ bool m_leaveOpen;

            /*0x326e9a4*/ BinaryReader(System.IO.Stream input);
            /*0x326eca4*/ BinaryReader(System.IO.Stream input, System.Text.Encoding encoding);
            /*0x326ea14*/ BinaryReader(System.IO.Stream input, System.Text.Encoding encoding, bool leaveOpen);
            /*0x326ecac*/ System.IO.Stream get_BaseStream();
            /*0x326ecb4*/ void Close();
            /*0x326ecc4*/ void Dispose(bool disposing);
            /*0x326ed70*/ void Dispose();
            /*0x326ed80*/ int Read();
            /*0x326f028*/ bool ReadBoolean();
            /*0x326f070*/ byte ReadByte();
            /*0x326f0a4*/ sbyte ReadSByte();
            /*0x326f0e4*/ char ReadChar();
            /*0x326f108*/ short ReadInt16();
            /*0x326f150*/ ushort ReadUInt16();
            /*0x326f198*/ int ReadInt32();
            /*0x326f28c*/ uint ReadUInt32();
            /*0x326f2fc*/ long ReadInt64();
            /*0x326f3ac*/ ulong ReadUInt64();
            /*0x326f45c*/ float ReadSingle();
            /*0x326f48c*/ double ReadDouble();
            /*0x326f4bc*/ decimal ReadDecimal();
            /*0x326f6a4*/ string ReadString();
            /*0x326f9f8*/ int InternalReadChars(char[] buffer, int index, int count);
            /*0x326ed94*/ int InternalReadOneChar();
            /*0x326fd0c*/ char[] ReadChars(int count);
            /*0x326fe68*/ int Read(byte[] buffer, int index, int count);
            /*0x326ffd8*/ byte[] ReadBytes(int count);
            /*0x3270164*/ void FillBuffer(int numBytes);
            /*0x326f958*/ int Read7BitEncodedInt();
        }

        class BinaryWriter : System.IDisposable
        {
            static /*0x0*/ System.IO.BinaryWriter Null;
            /*0x10*/ System.IO.Stream OutStream;
            /*0x18*/ byte[] _buffer;
            /*0x20*/ System.Text.Encoding _encoding;
            /*0x28*/ System.Text.Encoder _encoder;
            /*0x30*/ bool _leaveOpen;
            /*0x38*/ byte[] _largeByteBuffer;
            /*0x40*/ int _maxChars;

            static /*0x32710ac*/ BinaryWriter();
            /*0x3270280*/ BinaryWriter();
            /*0x3270398*/ BinaryWriter(System.IO.Stream output);
            /*0x32705b8*/ BinaryWriter(System.IO.Stream output, System.Text.Encoding encoding);
            /*0x3270410*/ BinaryWriter(System.IO.Stream output, System.Text.Encoding encoding, bool leaveOpen);
            /*0x32705c0*/ void Dispose(bool disposing);
            /*0x3270614*/ void Dispose();
            /*0x3270624*/ void Flush();
            /*0x3270644*/ void Write(bool value);
            /*0x3270694*/ void Write(byte value);
            /*0x32706b4*/ void Write(byte[] buffer);
            /*0x327072c*/ void Write(byte[] buffer, int index, int count);
            /*0x327074c*/ void Write(char ch);
            /*0x3270848*/ void Write(char[] chars);
            /*0x32708ec*/ void Write(double value);
            /*0x3270928*/ void Write(short value);
            /*0x3270990*/ void Write(ushort value);
            /*0x32709f8*/ void Write(int value);
            /*0x3270a98*/ void Write(uint value);
            /*0x3270b38*/ void Write(long value);
            /*0x3270c48*/ void Write(ulong value);
            /*0x3270d58*/ void Write(float value);
            /*0x3270d94*/ void Write(string value);
            /*0x3271050*/ void Write7BitEncodedInt(int value);
        }

        class StringReader : System.IO.TextReader
        {
            /*0x18*/ string _s;
            /*0x20*/ int _pos;
            /*0x24*/ int _length;

            /*0x3271110*/ StringReader(string s);
            /*0x32711dc*/ void Close();
            /*0x32711ec*/ void Dispose(bool disposing);
            /*0x3271224*/ int Peek();
            /*0x3271260*/ int Read();
            /*0x32712a4*/ int Read(char[] buffer, int index, int count);
            /*0x327144c*/ string ReadToEnd();
            /*0x3271488*/ string ReadLine();
        }

        class StringWriter : System.IO.TextWriter
        {
            static /*0x0*/ System.Text.UnicodeEncoding m_encoding;
            /*0x30*/ System.Text.StringBuilder _sb;
            /*0x38*/ bool _isOpen;

            /*0x327159c*/ StringWriter();
            /*0x3271720*/ StringWriter(System.IFormatProvider formatProvider);
            /*0x327178c*/ StringWriter(System.Text.StringBuilder sb);
            /*0x3271630*/ StringWriter(System.Text.StringBuilder sb, System.IFormatProvider formatProvider);
            /*0x32717fc*/ void Close();
            /*0x327180c*/ void Dispose(bool disposing);
            /*0x3271818*/ System.Text.Encoding get_Encoding();
            /*0x32718cc*/ void Write(char value);
            /*0x32718f4*/ void Write(char[] buffer, int index, int count);
            /*0x3271a68*/ void Write(string value);
            /*0x3271a9c*/ string ToString();
        }

        class FileStream : System.IO.Stream
        {
            static /*0x0*/ byte[] buf_recycle;
            static /*0x8*/ object buf_recycle_lock;
            /*0x28*/ byte[] buf;
            /*0x30*/ string name;
            /*0x38*/ Microsoft.Win32.SafeHandles.SafeFileHandle safeHandle;
            /*0x40*/ bool isExposed;
            /*0x48*/ long append_startpos;
            /*0x50*/ System.IO.FileAccess access;
            /*0x54*/ bool owner;
            /*0x55*/ bool async;
            /*0x56*/ bool canseek;
            /*0x57*/ bool anonymous;
            /*0x58*/ bool buf_dirty;
            /*0x5c*/ int buf_size;
            /*0x60*/ int buf_length;
            /*0x64*/ int buf_offset;
            /*0x68*/ long buf_start;

            static /*0x3276b44*/ FileStream();
            /*0x3271ab8*/ FileStream(nint handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);
            /*0x3271ac4*/ FileStream(nint handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync, bool isConsoleWrapper);
            /*0x3271f48*/ FileStream(string path, System.IO.FileMode mode);
            /*0x3272688*/ FileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access);
            /*0x32726cc*/ FileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
            /*0x32726f0*/ FileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);
            /*0x3272710*/ FileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);
            /*0x3272738*/ FileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);
            /*0x32726b4*/ FileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool isAsync, bool anonymous);
            /*0x3271f7c*/ FileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool anonymous, System.IO.FileOptions options);
            /*0x3271c64*/ void Init(Microsoft.Win32.SafeHandles.SafeFileHandle safeHandle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync, bool isConsoleWrapper);
            /*0x3273ff0*/ bool get_CanRead();
            /*0x3274004*/ bool get_CanWrite();
            /*0x3274018*/ bool get_CanSeek();
            /*0x3274020*/ string get_Name();
            /*0x3274028*/ long get_Length();
            /*0x32742c8*/ long get_Position();
            /*0x3274430*/ void set_Position(long value);
            /*0x32744b4*/ Microsoft.Win32.SafeHandles.SafeFileHandle get_SafeFileHandle();
            /*0x3273e7c*/ void ExposeHandle();
            /*0x3274668*/ int ReadByte();
            /*0x32748f8*/ void WriteByte(byte value);
            /*0x3274a4c*/ int Read(byte[] array, int offset, int count);
            /*0x3274c98*/ int ReadInternal(byte[] dest, int offset, int count);
            /*0x3274df0*/ System.IAsyncResult BeginRead(byte[] array, int offset, int numBytes, System.AsyncCallback userCallback, object stateObject);
            /*0x32751b4*/ int EndRead(System.IAsyncResult asyncResult);
            /*0x3275338*/ void Write(byte[] array, int offset, int count);
            /*0x327555c*/ void WriteInternal(byte[] src, int offset, int count);
            /*0x32758e8*/ System.IAsyncResult BeginWrite(byte[] array, int offset, int numBytes, System.AsyncCallback userCallback, object stateObject);
            /*0x3275df4*/ void EndWrite(System.IAsyncResult asyncResult);
            /*0x3275f60*/ long Seek(long offset, System.IO.SeekOrigin origin);
            /*0x32761c0*/ void SetLength(long value);
            /*0x3276500*/ void Flush();
            /*0x3276574*/ void Finalize();
            /*0x3276608*/ void Dispose(bool disposing);
            /*0x3276960*/ System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken cancellationToken);
            /*0x32769e4*/ System.Threading.Tasks.Task<int> ReadAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
            /*0x32769e8*/ System.Threading.Tasks.Task WriteAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
            /*0x3274d38*/ int ReadSegment(byte[] dest, int dest_offset, int count);
            /*0x3275870*/ int WriteSegment(byte[] src, int src_offset, int count);
            /*0x32744f0*/ void FlushBuffer();
            /*0x3274184*/ void FlushBufferIfDirty();
            /*0x32748c8*/ void RefillBuffer();
            /*0x32747a8*/ int ReadData(System.Runtime.InteropServices.SafeHandle safeHandle, byte[] buf, int offset, int count);
            /*0x3273bb8*/ void InitBuffer(int size, bool isZeroSize);
            /*0x32732f8*/ string GetSecureFileName(string filename);
            /*0x3272dd4*/ string GetSecureFileName(string filename, bool full);

            class ReadDelegate : System.MulticastDelegate
            {
                /*0x327507c*/ ReadDelegate(object object, nint method);
                /*0x3276bb8*/ int Invoke(byte[] buffer, int offset, int count);
                /*0x3275130*/ System.IAsyncResult BeginInvoke(byte[] buffer, int offset, int count, System.AsyncCallback callback, object object);
                /*0x3275310*/ int EndInvoke(System.IAsyncResult result);
            }

            class WriteDelegate : System.MulticastDelegate
            {
                /*0x3275cbc*/ WriteDelegate(object object, nint method);
                /*0x3276bcc*/ void Invoke(byte[] buffer, int offset, int count);
                /*0x3275d70*/ System.IAsyncResult BeginInvoke(byte[] buffer, int offset, int count, System.AsyncCallback callback, object object);
                /*0x3275f54*/ void EndInvoke(System.IAsyncResult result);
            }
        }

        class FileStreamAsyncResult : System.IAsyncResult
        {
            /*0x10*/ object state;
            /*0x18*/ bool completed;
            /*0x20*/ System.Threading.ManualResetEvent wh;
            /*0x28*/ System.AsyncCallback cb;
            /*0x30*/ bool completedSynch;
            /*0x34*/ int Count;
            /*0x38*/ int OriginalCount;
            /*0x3c*/ int BytesRead;
            /*0x40*/ System.AsyncCallback realcb;

            static /*0x3276be0*/ void CBWrapper(System.IAsyncResult ares);
            /*0x3275bbc*/ FileStreamAsyncResult(System.AsyncCallback cb, object state);
            /*0x3276c74*/ object get_AsyncState();
            /*0x3276c7c*/ bool get_CompletedSynchronously();
            /*0x3276c84*/ System.Threading.WaitHandle get_AsyncWaitHandle();
            /*0x3276c8c*/ bool get_IsCompleted();
        }

        enum MonoFileType
        {
            Unknown = 0,
            Disk = 1,
            Char = 2,
            Pipe = 3,
            Remote = 32768,
        }

        class MonoIO
        {
            static /*0x0*/ nint InvalidHandle;
            static /*0x8*/ bool dump_handles;

            static /*0x3276fb0*/ MonoIO();
            static /*0x3276c94*/ System.Exception GetException(System.IO.MonoIOError error);
            static /*0x327337c*/ System.Exception GetException(string path, System.IO.MonoIOError error);
            static /*0x3276db0*/ string GetCurrentDirectory(ref System.IO.MonoIOError error);
            static /*0x3276db4*/ bool SetFileAttributes(char* path, System.IO.FileAttributes attrs, ref System.IO.MonoIOError error);
            static /*0x3276db8*/ bool SetFileAttributes(string path, System.IO.FileAttributes attrs, ref System.IO.MonoIOError error);
            static /*0x3276e34*/ System.IO.MonoFileType GetFileType(nint handle, ref System.IO.MonoIOError error);
            static /*0x3273a84*/ System.IO.MonoFileType GetFileType(System.Runtime.InteropServices.SafeHandle safeHandle, ref System.IO.MonoIOError error);
            static /*0x3276e38*/ nint Open(char* filename, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.IO.FileOptions options, ref System.IO.MonoIOError error);
            static /*0x327325c*/ nint Open(string filename, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.IO.FileOptions options, ref System.IO.MonoIOError error);
            static /*0x3276e3c*/ bool Cancel_internal(nint handle, ref System.IO.MonoIOError error);
            static /*0x3276e40*/ bool Cancel(System.Runtime.InteropServices.SafeHandle safeHandle, ref System.IO.MonoIOError error);
            static /*0x327695c*/ bool Close(nint handle, ref System.IO.MonoIOError error);
            static /*0x3276f74*/ int Read(nint handle, byte[] dest, int dest_offset, int count, ref System.IO.MonoIOError error);
            static /*0x32769ec*/ int Read(System.Runtime.InteropServices.SafeHandle safeHandle, byte[] dest, int dest_offset, int count, ref System.IO.MonoIOError error);
            static /*0x3276f78*/ int Write(nint handle, byte[] src, int src_offset, int count, ref System.IO.MonoIOError error);
            static /*0x3275718*/ int Write(System.Runtime.InteropServices.SafeHandle safeHandle, byte[] src, int src_offset, int count, ref System.IO.MonoIOError error);
            static /*0x3276f7c*/ long Seek(nint handle, long offset, System.IO.SeekOrigin origin, ref System.IO.MonoIOError error);
            static /*0x3273ea4*/ long Seek(System.Runtime.InteropServices.SafeHandle safeHandle, long offset, System.IO.SeekOrigin origin, ref System.IO.MonoIOError error);
            static /*0x3276f80*/ long GetLength(nint handle, ref System.IO.MonoIOError error);
            static /*0x3274194*/ long GetLength(System.Runtime.InteropServices.SafeHandle safeHandle, ref System.IO.MonoIOError error);
            static /*0x3276f84*/ bool SetLength(nint handle, long length, ref System.IO.MonoIOError error);
            static /*0x32763c0*/ bool SetLength(System.Runtime.InteropServices.SafeHandle safeHandle, long length, ref System.IO.MonoIOError error);
            static /*0x3276f88*/ nint get_ConsoleOutput();
            static /*0x3276f8c*/ nint get_ConsoleInput();
            static /*0x3276f90*/ nint get_ConsoleError();
            static /*0x3276f94*/ bool CreatePipe(ref nint read_handle, ref nint write_handle, ref System.IO.MonoIOError error);
            static /*0x3276f98*/ bool DuplicateHandle(nint source_process_handle, nint source_handle, nint target_process_handle, ref nint target_handle, int access, int inherit, int options, ref System.IO.MonoIOError error);
            static /*0x3276f9c*/ char get_VolumeSeparatorChar();
            static /*0x3276fa0*/ char get_DirectorySeparatorChar();
            static /*0x3276fa4*/ char get_AltDirectorySeparatorChar();
            static /*0x3276fa8*/ char get_PathSeparator();
            static /*0x3276dac*/ void DumpHandles();
            static /*0x3276fac*/ bool RemapPath(string path, ref string newPath);
        }

        enum MonoIOError
        {
            ERROR_SUCCESS = 0,
            ERROR_FILE_NOT_FOUND = 2,
            ERROR_PATH_NOT_FOUND = 3,
            ERROR_TOO_MANY_OPEN_FILES = 4,
            ERROR_ACCESS_DENIED = 5,
            ERROR_INVALID_HANDLE = 6,
            ERROR_INVALID_DRIVE = 15,
            ERROR_NOT_SAME_DEVICE = 17,
            ERROR_NO_MORE_FILES = 18,
            ERROR_NOT_READY = 21,
            ERROR_WRITE_FAULT = 29,
            ERROR_READ_FAULT = 30,
            ERROR_GEN_FAILURE = 31,
            ERROR_SHARING_VIOLATION = 32,
            ERROR_LOCK_VIOLATION = 33,
            ERROR_HANDLE_DISK_FULL = 39,
            ERROR_NOT_SUPPORTED = 50,
            ERROR_FILE_EXISTS = 80,
            ERROR_CANNOT_MAKE = 82,
            ERROR_INVALID_PARAMETER = 87,
            ERROR_BROKEN_PIPE = 109,
            ERROR_INVALID_NAME = 123,
            ERROR_DIR_NOT_EMPTY = 145,
            ERROR_ALREADY_EXISTS = 183,
            ERROR_FILENAME_EXCED_RANGE = 206,
            ERROR_DIRECTORY = 267,
            ERROR_ENCRYPTION_FAILED = 6000,
        }

        struct MonoIOStat
        {
            /*0x10*/ System.IO.FileAttributes fileAttributes;
            /*0x18*/ long Length;
            /*0x20*/ long CreationTime;
            /*0x28*/ long LastAccessTime;
            /*0x30*/ long LastWriteTime;
        }

        class Path
        {
            static /*0x0*/ char[] InvalidPathChars;
            static /*0x8*/ char AltDirectorySeparatorChar;
            static /*0xa*/ char DirectorySeparatorChar;
            static /*0xc*/ char PathSeparator;
            static /*0x10*/ string DirectorySeparatorStr;
            static /*0x18*/ char VolumeSeparatorChar;
            static /*0x20*/ char[] PathSeparatorChars;
            static /*0x28*/ bool dirEqualsVolume;
            static /*0x30*/ char[] trimEndCharsWindows;
            static /*0x38*/ char[] trimEndCharsUnix;

            static /*0x3278964*/ Path();
            static /*0x327703c*/ string ChangeExtension(string path, string extension);
            static /*0x32772b4*/ string Combine(string path1, string path2);
            static /*0x3277638*/ string CleanPath(string s);
            static /*0x3272e7c*/ string GetDirectoryName(string path);
            static /*0x3277eb4*/ System.ReadOnlySpan<char> GetDirectoryName(System.ReadOnlySpan<char> path);
            static /*0x3277f84*/ string GetExtension(string path);
            static /*0x326e2fc*/ string GetFileName(string path);
            static /*0x32780a0*/ string GetFileNameWithoutExtension(string path);
            static /*0x32731f4*/ string GetFullPath(string path);
            static /*0x32780fc*/ string GetFullPathInternal(string path);
            static /*0x3272758*/ string InsecureGetFullPath(string path);
            static /*0x326e26c*/ bool IsDirectorySeparator(char c);
            static /*0x3277a94*/ string GetPathRoot(string path);
            static /*0x3278564*/ string GetTempPath();
            static /*0x3278664*/ string get_temp_path();
            static /*0x3278668*/ bool IsPathRooted(System.ReadOnlySpan<char> path);
            static /*0x3277514*/ bool IsPathRooted(string path);
            static /*0x327876c*/ char[] GetInvalidPathChars();
            static /*0x32787fc*/ string GetRandomFileName();
            static /*0x3277220*/ int findExtension(string path);
            static /*0x3278150*/ string CanonicalizePath(string path);
            static /*0x3278b64*/ string Combine(string[] paths);
            static /*0x3278e54*/ string Combine(string path1, string path2, string path3);
            static /*0x3278fd4*/ string Combine(string path1, string path2, string path3, string path4);
            static /*0x32791a4*/ void Validate(string path);
            static /*0x3279210*/ void Validate(string path, string parameterName);
            static /*0x327932c*/ System.ReadOnlySpan<char> GetFileName(System.ReadOnlySpan<char> path);
            static /*0x32794a8*/ string Join(System.ReadOnlySpan<char> path1, System.ReadOnlySpan<char> path2);
            static /*0x32797f0*/ string Join(System.ReadOnlySpan<char> path1, System.ReadOnlySpan<char> path2, System.ReadOnlySpan<char> path3);
            static /*0x3279cac*/ bool TryJoin(System.ReadOnlySpan<char> path1, System.ReadOnlySpan<char> path2, System.Span<char> destination, ref int charsWritten);
            static /*0x3279560*/ string JoinInternal(System.ReadOnlySpan<char> first, System.ReadOnlySpan<char> second);
            static /*0x3279900*/ string JoinInternal(System.ReadOnlySpan<char> first, System.ReadOnlySpan<char> second, System.ReadOnlySpan<char> third);

            class <>c
            {
                static /*0x0*/ System.IO.Path.<> <>9;
                static /*0x8*/ System.Buffers.SpanAction<char, System.ValueTuple<nint, int, nint, int, bool>> <>9__56_0;
                static /*0x10*/ System.Buffers.SpanAction<char, System.ValueTuple<nint, int, nint, int, nint, int, bool, System.ValueTuple<bool>>> <>9__57_0;

                static /*0x3279f4c*/ <>c();
                /*0x3279fb4*/ <>c();
                /*0x3279fbc*/ void <JoinInternal>b__56_0(System.Span<char> destination, System.ValueTuple<nint, int, nint, int, bool> state);
                /*0x327a24c*/ void <JoinInternal>b__57_0(System.Span<char> destination, System.ValueTuple<nint, int, nint, int, nint, int, bool, System.ValueTuple<bool>> state);
            }
        }

        class UnexceptionalStreamReader : System.IO.StreamReader
        {
            static /*0x0*/ bool[] newline;
            static /*0x8*/ char newlineChar;

            static /*0x327a624*/ UnexceptionalStreamReader();
            /*0x327a6d4*/ UnexceptionalStreamReader(System.IO.Stream stream, System.Text.Encoding encoding);
            /*0x327a744*/ int Peek();
            /*0x327a7cc*/ int Read();
            /*0x327a854*/ int Read(char[] dest_buffer, int index, int count);
            /*0x327aad8*/ bool CheckEOL(char current);
            /*0x327ac70*/ string ReadLine();
            /*0x327acf8*/ string ReadToEnd();
        }

        class UnexceptionalStreamWriter : System.IO.StreamWriter
        {
            /*0x327ad80*/ UnexceptionalStreamWriter(System.IO.Stream stream, System.Text.Encoding encoding);
            /*0x327adf8*/ void Flush();
            /*0x327ae7c*/ void Write(char[] buffer, int index, int count);
            /*0x327af00*/ void Write(char value);
            /*0x327af84*/ void Write(char[] value);
            /*0x327b008*/ void Write(string value);
        }

        class CStreamReader : System.IO.StreamReader
        {
            /*0x60*/ System.TermInfoDriver driver;

            /*0x327b08c*/ CStreamReader(System.IO.Stream stream, System.Text.Encoding encoding);
            /*0x327b1b0*/ int Peek();
            /*0x327b238*/ int Read();
            /*0x327b308*/ int Read(char[] dest, int index, int count);
            /*0x327b4a8*/ string ReadLine();
            /*0x327b540*/ string ReadToEnd();
        }

        class CStreamWriter : System.IO.StreamWriter
        {
            /*0x70*/ System.TermInfoDriver driver;

            /*0x327b5d8*/ CStreamWriter(System.IO.Stream stream, System.Text.Encoding encoding, bool leaveOpen);
            /*0x327b710*/ void Write(char[] buffer, int index, int count);
            /*0x327baac*/ void Write(char val);
            /*0x327bcc4*/ void InternalWriteString(string val);
            /*0x327bc40*/ void InternalWriteChar(char val);
            /*0x327bd48*/ void InternalWriteChars(char[] buffer, int n);
            /*0x327bdd4*/ void Write(char[] val);
            /*0x327bdf8*/ void Write(string val);
            /*0x327bec4*/ void WriteLine(string val);
        }

        class MonoLinqHelper
        {
            static /*0x1f327cc*/ T[] ToArray<T>(System.Collections.Generic.IEnumerable<T> source);
        }

        namespace Enumeration
        {
            struct FileSystemEntry
            {
                /*0x10*/ Interop.Sys.DirectoryEntry _directoryEntry;
                /*0x20*/ System.IO.FileStatus _status;
                /*0x98*/ System.Span<char> _pathBuffer;
                /*0xa8*/ System.ReadOnlySpan<char> _fullPath;
                /*0xb8*/ System.ReadOnlySpan<char> _fileName;
                /*0xc8*/ System.IO.Enumeration.FileSystemEntry.<_fileNameBuffer> _fileNameBuffer;
                /*0x2c8*/ System.IO.FileAttributes _initialAttributes;
                /*0x2d0*/ System.ReadOnlySpan<char> <Directory>k__BackingField;
                /*0x2e0*/ System.ReadOnlySpan<char> <RootDirectory>k__BackingField;
                /*0x2f0*/ System.ReadOnlySpan<char> <OriginalRootDirectory>k__BackingField;

                static /*0x327bf08*/ System.IO.FileAttributes Initialize(ref System.IO.Enumeration.FileSystemEntry entry, Interop.Sys.DirectoryEntry directoryEntry, System.ReadOnlySpan<char> directory, System.ReadOnlySpan<char> rootDirectory, System.ReadOnlySpan<char> originalRootDirectory, System.Span<char> pathBuffer);
                /*0x327c204*/ System.ReadOnlySpan<char> get_FullPath();
                /*0x327c368*/ System.ReadOnlySpan<char> get_FileName();
                /*0x327c454*/ System.ReadOnlySpan<char> get_Directory();
                /*0x327c464*/ void set_Directory(System.ReadOnlySpan<char> value);
                /*0x327c470*/ System.ReadOnlySpan<char> get_RootDirectory();
                /*0x327c480*/ void set_RootDirectory(System.ReadOnlySpan<char> value);
                /*0x327c48c*/ System.ReadOnlySpan<char> get_OriginalRootDirectory();
                /*0x327c49c*/ void set_OriginalRootDirectory(System.ReadOnlySpan<char> value);
                /*0x327c4a8*/ System.IO.FileAttributes get_Attributes();
                /*0x327c4f0*/ bool get_IsDirectory();
                /*0x327c4f8*/ System.IO.FileSystemInfo ToFileSystemInfo();
                /*0x327c568*/ string ToFullPath();
                /*0x327c590*/ string ToSpecifiedFullPath();

                struct <_fileNameBuffer>e__FixedBuffer
                {
                    /*0x10*/ char FixedElementField;
                }
            }

            class FileSystemEnumerable<TResult> : System.Collections.Generic.IEnumerable<TResult>, System.Collections.IEnumerable
            {
                /*0x0*/ System.IO.Enumeration.FileSystemEnumerable.DelegateEnumerator<TResult> _enumerator;
                /*0x0*/ System.IO.Enumeration.FileSystemEnumerable.FindTransform<TResult> _transform;
                /*0x0*/ System.IO.EnumerationOptions _options;
                /*0x0*/ string _directory;
                /*0x0*/ System.IO.Enumeration.FileSystemEnumerable.FindPredicate<TResult> <ShouldIncludePredicate>k__BackingField;
                /*0x0*/ System.IO.Enumeration.FileSystemEnumerable.FindPredicate<TResult> <ShouldRecursePredicate>k__BackingField;

                /*0x1f310fc*/ FileSystemEnumerable(string directory, System.IO.Enumeration.FileSystemEnumerable.FindTransform<TResult> transform, System.IO.EnumerationOptions options);
                /*0x1f30214*/ System.IO.Enumeration.FileSystemEnumerable.FindPredicate<TResult> get_ShouldIncludePredicate();
                /*0x1f30ebc*/ void set_ShouldIncludePredicate(System.IO.Enumeration.FileSystemEnumerable.FindPredicate<TResult> value);
                /*0x1f30214*/ System.IO.Enumeration.FileSystemEnumerable.FindPredicate<TResult> get_ShouldRecursePredicate();
                /*0x1f30214*/ System.Collections.Generic.IEnumerator<TResult> GetEnumerator();
                /*0x1f30214*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();

                class FindPredicate<TResult> : System.MulticastDelegate
                {
                    FindPredicate(object object, nint method);
                    /*0x1f2fec8*/ bool Invoke(ref System.IO.Enumeration.FileSystemEntry entry);
                }

                class FindTransform<TResult> : System.MulticastDelegate
                {
                    FindTransform(object object, nint method);
                    /*0x1ffc854*/ TResult Invoke(ref System.IO.Enumeration.FileSystemEntry entry);
                }

                class DelegateEnumerator<TResult> : System.IO.Enumeration.FileSystemEnumerator<TResult>
                {
                    /*0x0*/ System.IO.Enumeration.FileSystemEnumerable<TResult> _enumerable;

                    /*0x1f30ebc*/ DelegateEnumerator(System.IO.Enumeration.FileSystemEnumerable<TResult> enumerable);
                    /*0x1ffc854*/ TResult TransformEntry(ref System.IO.Enumeration.FileSystemEntry entry);
                    /*0x1f2fec8*/ bool ShouldRecurseIntoEntry(ref System.IO.Enumeration.FileSystemEntry entry);
                    /*0x1f2fec8*/ bool ShouldIncludeEntry(ref System.IO.Enumeration.FileSystemEntry entry);
                }
            }

            class FileSystemEnumerableFactory
            {
                static /*0x0*/ char[] s_unixEscapeChars;

                static /*0x327df70*/ FileSystemEnumerableFactory();
                static /*0x327c774*/ void NormalizeInputs(ref string directory, ref string expression, System.IO.EnumerationOptions options);
                static /*0x327d050*/ bool MatchesPattern(string expression, System.ReadOnlySpan<char> name, System.IO.EnumerationOptions options);
                static /*0x327d388*/ System.Collections.Generic.IEnumerable<string> UserFiles(string directory, string expression, System.IO.EnumerationOptions options);
                static /*0x327d584*/ System.Collections.Generic.IEnumerable<string> UserDirectories(string directory, string expression, System.IO.EnumerationOptions options);
                static /*0x327d780*/ System.Collections.Generic.IEnumerable<string> UserEntries(string directory, string expression, System.IO.EnumerationOptions options);
                static /*0x327d97c*/ System.Collections.Generic.IEnumerable<System.IO.FileInfo> FileInfos(string directory, string expression, System.IO.EnumerationOptions options);
                static /*0x327db78*/ System.Collections.Generic.IEnumerable<System.IO.DirectoryInfo> DirectoryInfos(string directory, string expression, System.IO.EnumerationOptions options);
                static /*0x327dd74*/ System.Collections.Generic.IEnumerable<System.IO.FileSystemInfo> FileSystemInfos(string directory, string expression, System.IO.EnumerationOptions options);

                class <>c__DisplayClass3_0
                {
                    /*0x10*/ string expression;
                    /*0x18*/ System.IO.EnumerationOptions options;

                    /*0x327d57c*/ <>c__DisplayClass3_0();
                    /*0x327e010*/ bool <UserFiles>b__1(ref System.IO.Enumeration.FileSystemEntry entry);
                }

                class <>c
                {
                    static /*0x0*/ System.IO.Enumeration.FileSystemEnumerableFactory.<> <>9;
                    static /*0x8*/ System.IO.Enumeration.FileSystemEnumerable.FindTransform<string> <>9__3_0;
                    static /*0x10*/ System.IO.Enumeration.FileSystemEnumerable.FindTransform<string> <>9__4_0;
                    static /*0x18*/ System.IO.Enumeration.FileSystemEnumerable.FindTransform<string> <>9__5_0;
                    static /*0x20*/ System.IO.Enumeration.FileSystemEnumerable.FindTransform<System.IO.FileInfo> <>9__6_0;
                    static /*0x28*/ System.IO.Enumeration.FileSystemEnumerable.FindTransform<System.IO.DirectoryInfo> <>9__7_0;
                    static /*0x30*/ System.IO.Enumeration.FileSystemEnumerable.FindTransform<System.IO.FileSystemInfo> <>9__8_0;

                    static /*0x327e0b0*/ <>c();
                    /*0x327e118*/ <>c();
                    /*0x327e120*/ string <UserFiles>b__3_0(ref System.IO.Enumeration.FileSystemEntry entry);
                    /*0x327e128*/ string <UserDirectories>b__4_0(ref System.IO.Enumeration.FileSystemEntry entry);
                    /*0x327e130*/ string <UserEntries>b__5_0(ref System.IO.Enumeration.FileSystemEntry entry);
                    /*0x327e138*/ System.IO.FileInfo <FileInfos>b__6_0(ref System.IO.Enumeration.FileSystemEntry entry);
                    /*0x327e198*/ System.IO.DirectoryInfo <DirectoryInfos>b__7_0(ref System.IO.Enumeration.FileSystemEntry entry);
                    /*0x327e1f8*/ System.IO.FileSystemInfo <FileSystemInfos>b__8_0(ref System.IO.Enumeration.FileSystemEntry entry);
                }

                class <>c__DisplayClass4_0
                {
                    /*0x10*/ string expression;
                    /*0x18*/ System.IO.EnumerationOptions options;

                    /*0x327d778*/ <>c__DisplayClass4_0();
                    /*0x327e200*/ bool <UserDirectories>b__1(ref System.IO.Enumeration.FileSystemEntry entry);
                }

                class <>c__DisplayClass5_0
                {
                    /*0x10*/ string expression;
                    /*0x18*/ System.IO.EnumerationOptions options;

                    /*0x327d974*/ <>c__DisplayClass5_0();
                    /*0x327e2a0*/ bool <UserEntries>b__1(ref System.IO.Enumeration.FileSystemEntry entry);
                }

                class <>c__DisplayClass6_0
                {
                    /*0x10*/ string expression;
                    /*0x18*/ System.IO.EnumerationOptions options;

                    /*0x327db70*/ <>c__DisplayClass6_0();
                    /*0x327e324*/ bool <FileInfos>b__1(ref System.IO.Enumeration.FileSystemEntry entry);
                }

                class <>c__DisplayClass7_0
                {
                    /*0x10*/ string expression;
                    /*0x18*/ System.IO.EnumerationOptions options;

                    /*0x327dd6c*/ <>c__DisplayClass7_0();
                    /*0x327e3c4*/ bool <DirectoryInfos>b__1(ref System.IO.Enumeration.FileSystemEntry entry);
                }

                class <>c__DisplayClass8_0
                {
                    /*0x10*/ string expression;
                    /*0x18*/ System.IO.EnumerationOptions options;

                    /*0x327df68*/ <>c__DisplayClass8_0();
                    /*0x327e464*/ bool <FileSystemInfos>b__1(ref System.IO.Enumeration.FileSystemEntry entry);
                }
            }

            class FileSystemEnumerator<TResult> : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Collections.Generic.IEnumerator<TResult>, System.IDisposable, System.Collections.IEnumerator
            {
                /*0x0*/ string _originalRootDirectory;
                /*0x0*/ string _rootDirectory;
                /*0x0*/ System.IO.EnumerationOptions _options;
                /*0x0*/ object _lock;
                /*0x0*/ string _currentPath;
                /*0x0*/ nint _directoryHandle;
                /*0x0*/ bool _lastEntryFound;
                /*0x0*/ System.Collections.Generic.Queue<string> _pending;
                /*0x0*/ Interop.Sys.DirectoryEntry _entry;
                /*0x0*/ TResult _current;
                /*0x0*/ char[] _pathBuffer;
                /*0x0*/ byte[] _entryBuffer;

                static /*0x1ffc854*/ bool IsDirectoryNotFound(Interop.ErrorInfo info);
                static /*0x1ffc854*/ bool IsAccessError(Interop.ErrorInfo info);
                /*0x1f30ff0*/ FileSystemEnumerator(string directory, System.IO.EnumerationOptions options);
                /*0x1ffc854*/ bool InternalContinueOnError(Interop.ErrorInfo info, bool ignoreNotFound);
                /*0x1ffc854*/ nint CreateDirectoryHandle(string path, bool ignoreNotFound);
                /*0x1f309e4*/ void CloseDirectoryHandle();
                /*0x1f2fe14*/ bool MoveNext();
                /*0x1f309e4*/ void FindNextEntry();
                /*0x1ffc854*/ void FindNextEntry(byte* entryBufferPtr, int bufferLength);
                /*0x1f2fe14*/ bool DequeueNextDirectory();
                /*0x1f30a84*/ void InternalDispose(bool disposing);
                /*0x1f2fec8*/ bool ShouldIncludeEntry(ref System.IO.Enumeration.FileSystemEntry entry);
                /*0x1f2fec8*/ bool ShouldRecurseIntoEntry(ref System.IO.Enumeration.FileSystemEntry entry);
                /*0x1ffc854*/ TResult TransformEntry(ref System.IO.Enumeration.FileSystemEntry entry);
                void OnDirectoryFinished(System.ReadOnlySpan<char> directory);
                /*0x1f2fe40*/ bool ContinueOnError(int error);
                /*0x1ffc854*/ TResult get_Current();
                /*0x1f30214*/ object System.Collections.IEnumerator.get_Current();
                /*0x1f309e4*/ void DirectoryFinished();
                /*0x1f309e4*/ void Reset();
                /*0x1f309e4*/ void Dispose();
                /*0x1f30a84*/ void Dispose(bool disposing);
                /*0x1f309e4*/ void Finalize();
            }

            class FileSystemName
            {
                static /*0x0*/ char[] s_wildcardChars;
                static /*0x8*/ char[] s_simpleWildcardChars;

                static /*0x327ed7c*/ FileSystemName();
                static /*0x327cc38*/ string TranslateWin32Expression(string expression);
                static /*0x327d300*/ bool MatchesWin32Expression(System.ReadOnlySpan<char> expression, System.ReadOnlySpan<char> name, bool ignoreCase);
                static /*0x327d278*/ bool MatchesSimpleExpression(System.ReadOnlySpan<char> expression, System.ReadOnlySpan<char> name, bool ignoreCase);
                static /*0x327e4e8*/ bool MatchPattern(System.ReadOnlySpan<char> expression, System.ReadOnlySpan<char> name, bool ignoreCase, bool useExtendedWildcards);
            }
        }
    }
}

class <PrivateImplementationDetails>
{
    static /*0x0*/ <PrivateImplementationDetails> 001D686DB504E20C792EAA07FE09224A45FF328E24A80072D04D16ABC5C2B5D2;
    static /*0x40*/ <PrivateImplementationDetails> 021022D5891F99B3B525763EB77BAEC69B107268F560721F5060FCDBD4D5AAE8;
    static /*0xea*/ <PrivateImplementationDetails> 042957A0DB5FF2D38A343AC5AE5F8635B88F10C32EB87A238B1DFB4756468476;
    static /*0xf6*/ <PrivateImplementationDetails> 06B65E85E7DE323D68D88C332DBDA9DB89C27652506CE5B4EA2C86A5BBBEABE9;
    static /*0x27e*/ <PrivateImplementationDetails> 07FA6E88C946B2528C09C16C2FB8E9CDA49AFFAFC601774C437FD9F2DF3ECE01;
    static /*0x2b6*/ <PrivateImplementationDetails> 0C496C9AE05419BD25256D0EF4F31AFD291119F14B8BD683BF1774F91E08659D;
    static /*0x30a*/ <PrivateImplementationDetails> 0E499E7743BCDFF289B85890E4DFDD635594DB16246DC094C3C19556B6C1262C;
    static /*0x352*/ <PrivateImplementationDetails> 0F9E3C7E66CDEF5C44FA29E65CA676C480F7A2A4A067F70107FDC292C68D38B0;
    static /*0x35e*/ <PrivateImplementationDetails> 1199C3B39A2FA058EFF5B3829616AE81EE2B59A51D89C107A5FA4B6FEF95DD16;
    static /*0x3aa*/ <PrivateImplementationDetails> 125CF2084D7EEC18DC9795BE4BAA221655C0EABAB89E90A74FB0370378A60293;
    static /*0x62a*/ <PrivateImplementationDetails> 12D518BA10F3DD1A331E65FBD4C330930C0A0BD9F50F37BE0BDF596E964B9A78;
    static /*0xe5e*/ <PrivateImplementationDetails> 1537CF074FEBB1EDD62F5C35E2A77A575ED00CD6C5D8F479EFA4302E2F757688;
    static /*0xe76*/ <PrivateImplementationDetails> 195ABC1ABB69B6BD65F20ACAFA79EED2D330BF513E25C830F24B8A78D8703446;
    static /*0xef6*/ <PrivateImplementationDetails> 1A07BC77B9912D8D87E9B28E0167F53A9B09BB017B35A35F3913989C9440A60B;
    static /*0xf00*/ <PrivateImplementationDetails> 1A52279427700E21F7E68A077A8F17857A850718317B7228442260DBA2AF68F0;
    static /*0x104a*/ <PrivateImplementationDetails> 1B9CC34A0CF8DBCC350E200673FAC4124DDAD581F1FC2C16FF9A1C0154691687;
    static /*0x15f4*/ <PrivateImplementationDetails> 1C4B3A80ED7AEC83916479BCE280E1258D5785D07F0EA22A5E27592ACCAE692B;
    static /*0x175c*/ <PrivateImplementationDetails> 1E398465A9EE43BEF177E8E00D8C5348363E726339A46C767812C81310C00CB2;
    static /*0x1774*/ <PrivateImplementationDetails> 1F38DEB3F70291588D06D3830D0D4241CE0570C9F4EE8B00F606C4753EB016E2;
    static /*0x179e*/ <PrivateImplementationDetails> 215E3E0B11A214B3198654E87B3D953AC8FB1ABC7045AF841A7C4892624BDE49;
    static /*0x17a8*/ <PrivateImplementationDetails> 2403FBEA85D0741C5727760E97EF16C9BF23294F21C0F1265A4BAF7F22202A64;
    static /*0x17b4*/ <PrivateImplementationDetails> 24CB9F17C8326D8BB8EC908716519DF7F265AE825F0DD13BB04E03A90B07D90E;
    static /*0x17c4*/ <PrivateImplementationDetails> 25308BAB47481701F1E861B1EA4F2409E73ABB14E9579C26DF4ABE440A0DCF0A;
    static /*0x1810*/ <PrivateImplementationDetails> 25E3E48132FBDBE9B7C0C6C54D7C10A5DE12A105AA3E5DE2A0DC808BF245B7A5;
    static /*0x244c*/ <PrivateImplementationDetails> 2CCF4119215BDAD102DA7AD5B57E0E6CA19CC8FF5524856FC58907E824213E1F;
    static /*0x2494*/ <PrivateImplementationDetails> 31B56A7232040CADEA08E3A0A4AE95187D35A3278C4E84C774569CB0D48BBA5E;
    static /*0x2a34*/ <PrivateImplementationDetails> 3444EB31231B2CCC1B05C7A44EBD1B2A009C1D9977A99B453F52E2F81DD6C32F;
    static /*0x2a7c*/ <PrivateImplementationDetails> 3C847C0018C758197C8564174888A84F5621BA50DBB59D1EBA7FF28C73D279A1;
    static /*0x3f0c*/ <PrivateImplementationDetails> 3D95E4501B1964D7FCE16E3F5682A038752B462357D87343880B1E819F6163FE;
    static /*0x3f1c*/ <PrivateImplementationDetails> 3F1431B31172B4BE5418BDA2F4063F512F2F7A7CFDCE81A60B131792B5F7F694;
    static /*0x3f4c*/ <PrivateImplementationDetails> 3F62692E2AD5078353EC4471A13421A61EE493294CF59DC66626A6EF9CCCD2C4;
    static /*0x3f94*/ <PrivateImplementationDetails> 40EC13C575237954625B718CA2B291A90543D086FE5E3258F158FDDD3A9067CC;
    static /*0x3fec*/ <PrivateImplementationDetails> 425CE249C852AD06731DB313704890E29BD6FBF1FFB08F99948EB9ACF9053017;
    static /*0x489c*/ <PrivateImplementationDetails> 42E1421FC2A5A6A33E964D7EB9603EB101818D858DDA09B2BC9B5A888C1C351C;
    static /*0x48a8*/ <PrivateImplementationDetails> 44D066BAE9848B4A4B2C31F1854666526A32D0588635569423BDA1DA303C97DF;
    static /*0x48ae*/ <PrivateImplementationDetails> 4623CA5867960AA898AA1F65E720CD5ECD3552542E0C6F6FB65B21D14DD1CBC2;
    static /*0x4926*/ <PrivateImplementationDetails> 4800FBFC4566EB02D1727A4B1C949CCBC7535C216A0766564C199308631B5DD6;
    static /*0x4956*/ <PrivateImplementationDetails> 493402F3E4397B2945B16273E795816C0BDF80F76F42FCAA75F3DF2E215ABC1B;
    static /*0x5956*/ <PrivateImplementationDetails> 494C32E1A18F6E8AD8ED5FAB0A5AF07F801BE7AF3C936942B020918CE2953046;
    static /*0x5a04*/ <PrivateImplementationDetails> 4E0B9E024FA510B6F03C92D95BB204E78CDC6E3FD2EC8D35787B7BC76F0655A0;
    static /*0x6352*/ <PrivateImplementationDetails> 501E4F476B5C5D742AB5526561490A19EF5F752BEC30E7C5B172D05897A98932;
    static /*0x6372*/ <PrivateImplementationDetails> 508085E0DDEEA9CE48BFAE98CEC779F8D06301AE973555D37680D08190CAFA70;
    static /*0x639e*/ <PrivateImplementationDetails> 510FDFA4743E58DD45DCDD7CB4F8509BF6294CC1D1D4958CA30A9E7604973006;
    static /*0x63e6*/ <PrivateImplementationDetails> 5292FD0A8E62FCCBE41F34EFE7575D097990A66FE23B3507971C5BF272A4362E;
    static /*0x6410*/ <PrivateImplementationDetails> 533B8C444F951E83EFF7305E3807B66CE0005DE0A2D0A44873C130895A3BE6AA;
    static /*0x6424*/ <PrivateImplementationDetails> 543172FF9822CE5240DF89FF3AD8C7FD9824F97D0EED9B1432E60345FBBDE9A9;
    static /*0x6458*/ <PrivateImplementationDetails> 55D0BF716B334D123E0088CFB3F8E2FEA17AF5025BB527F95EEB09BA978EA329;
    static /*0x6558*/ <PrivateImplementationDetails> 56073E3CC3FC817690CC306D0DB7EA63EBCB0801359567CA44CA3D3B9BF63854;
    static /*0x8f88*/ <PrivateImplementationDetails> 5857EE4CE98BFABBD62B385C1098507DD0052FF3951043AAD6A1DABD495F18AA;
    static /*0x8fbc*/ <PrivateImplementationDetails> 5DF6E0E2761359D30A8275058E299FCC0381534545F55CF43E41983F5D4C9456;
    static /*0x8fdc*/ <PrivateImplementationDetails> 5EC4E50DA95A113769D73E5F7F8221A876185CEE6498ABB16FBB9F0563C15BBF;
    static /*0x9024*/ <PrivateImplementationDetails> 61D639BE11384EE21CDE2B40357F4F9D80A106C97C592D18A9F4CAA442CA5D31;
    static /*0x9082*/ <PrivateImplementationDetails> 62E6F13B53D67FDD780E20D89A6E8EE503B197AC16AC3F1D2571C147FDD324C9;
    static /*0x9182*/ <PrivateImplementationDetails> 668BB69E184E0C32DC3BC488001C506C87EE5A95C7E7B6B87D24C3A6DC779956;
    static /*0x9982*/ <PrivateImplementationDetails> 6708B572BDBE5D5E79701DBB9744AF74B50FED7608218F2D7BF1B5D87E5A53ED;
    static /*0x99b2*/ <PrivateImplementationDetails> 67856A16DB0550FDAB4D1A9B208B0C155C4679CA116BF867B74ED2A0AA4D2955;
    static /*0x9c3a*/ <PrivateImplementationDetails> 692DE452EE427272A5F6154F04360D24165B56693B08F60D93127DEDC12D1DDE;
    static /*0xa162*/ <PrivateImplementationDetails> 6DC92D3617F0357376502FBA4CDD465B5423818DABE8B2CA1A06E1351F2F1C85;
    static /*0xa1aa*/ <PrivateImplementationDetails> 70871E7CEBC5FB665C6CDA09BCB582780757E8F266C78289B5A1553B02AA3D82;
    static /*0xa1ea*/ <PrivateImplementationDetails> 71F7F6B226CBC11C8B26D506869FAE022928427389882579DB316F36FF34A096;
    static /*0xa2be*/ <PrivateImplementationDetails> 739592F1F51C1B5B4053CDFD26932FE506C041EC6B08A39DCE012EADDA72ADA7;
    static /*0xa2de*/ <PrivateImplementationDetails> 73F5D95C401726B2C92EC96A696BA15F0E5A5C6DD9AC6BEB3736A81772A11531;
    static /*0xaade*/ <PrivateImplementationDetails> 74BCD6ED20AF2231F2BB1CDE814C5F4FF48E54BAC46029EEF90DDF4A208E2B20;
    static /*0xabfe*/ <PrivateImplementationDetails> 74EF7306E7452D6859B6463CE496B8DF30925F69E1B2969E1F3F34BBC9C6AF04;
    static /*0xacfe*/ <PrivateImplementationDetails> 765BD07ED3CB498A599FFB48B31E077C45B4C2C37CD1547CEA27E60655CF21B6;
    static /*0xaff7*/ <PrivateImplementationDetails> 78AD7906208AA1E531D0C1100062DE3D252210B1E4214061294A0BB7C94762B8;
    static /*0xb06f*/ <PrivateImplementationDetails> 7BEC6AD454781FDCD8D475B3418629CBABB3BF9CA66FA80009D608A1A60D0696;
    static /*0xb62f*/ <PrivateImplementationDetails> 7F777906B0704EB248888E491577584D5BEBE71B375BD595A06444390B471915;
    static /*0xb677*/ <PrivateImplementationDetails> 801494072CDD59E61F9AA9345A80D045378705DFDCE94902C22EAEAE049BE780;
    static /*0xb778*/ long 819B40F8CF7DC49B4275955A17C10239F1BBBB3BF96E26E25ED844B96B645D7F;
    static /*0xb780*/ <PrivateImplementationDetails> 8259E3EBA4D41CA02AE5322BBD280034A9C9860D9CD0D2038139FC9EBE6B6C77;
    static /*0xb7c8*/ long 82B100804CE219CD73E155C7C6457FCF04EA539DE5B19F4736E800098714EB21;
    static /*0xb7d0*/ <PrivateImplementationDetails> 83F180C4F05CDA92C6CE1FB81ECB9031C503C1906040707C412F2BC7CB609F2A;
    static /*0xb7e8*/ <PrivateImplementationDetails> 861FD05B0EAD3D0AA9418B140CC37846BBC5F195214D90CEF42919D1E36EED10;
    static /*0xb830*/ <PrivateImplementationDetails> 86BDA34D2165AC08F2DE4918B302E44205CDEA674FCA7F2C7F56D4F12D8B0C73;
    static /*0xbc18*/ long 8BFD94DEAAC0F168DC8B50A00AC120A113B550B68FEF344F807D503D1A6E5DED;
    static /*0xbc20*/ <PrivateImplementationDetails> 8CCE27079B32C13BB310169A6AD26AE419CDC98B7E2EFD3CC9997257F4BC1DEF;
    static /*0xc2a1*/ <PrivateImplementationDetails> 9086502742CE7F0595B57A4E5B32901FF4CF97959B92F7E91A435E4765AC1115;
    static /*0xd9e1*/ <PrivateImplementationDetails> 9287D942CCFE5B2A54D81BDDC56BD89F2DC6C4C8B31507E6284F8D25D1009367;
    static /*0xd9f9*/ <PrivateImplementationDetails> 93B42898102ACB2421875C45676880B8A07390D8DF0E1EE85C5D1AA26964B0C6;
    static /*0xdb49*/ <PrivateImplementationDetails> 93F28AF88A06482BE13F8D0354B6A7676DDAED573EA3938C50F6E53E6D6BB0B6;
    static /*0xdb7d*/ <PrivateImplementationDetails> 95BDE712712F10D07813AE3DEEA40D1F38E3FCF1A92CC435F17A326CC22242EB;
    static /*0xdc2b*/ <PrivateImplementationDetails> 964889A5283FD0A3DFC8AE256721E6F67B8212FD6841AB1C821DE3134DE79B07;
    static /*0xdd31*/ <PrivateImplementationDetails> 96E3FDE919EC36694EFBEC22FEF80F84EE640CC5E46CED07C3E65AC04607C7D6;
    static /*0xdd40*/ <PrivateImplementationDetails> 9960C7FC60CDD325C8A2A00995BE7064EAC3F6295C6A5C4E797D2281846131E4;
    static /*0xdd64*/ <PrivateImplementationDetails> 99E66DACA3EFF94776AF1258E0E5B2F4DF2900E4EA32351B0DF37A87F2426B1F;
    static /*0xdd90*/ <PrivateImplementationDetails> A252A93D042C5E2453990C2829A425C6DD749CCDCDF13DB58C11BBC78E8D3CE9;
    static /*0xddd8*/ <PrivateImplementationDetails> A2DFDF9C2CED8BB1C0B9B06064345ACC9C22DFE5FEC9976FF061F0994451519B;
    static /*0xde50*/ <PrivateImplementationDetails> A2EC7CB9B0FE89F9A9BEA547D773225AFE6E4535DF28325A0D6CD7A5E2D20376;
    static /*0xde9c*/ <PrivateImplementationDetails> A30E1152CFB528AE968FAC58E83BBEB3611BFDE2E6CF60B4FA9535A7D0A9B8EA;
    static /*0xdee4*/ <PrivateImplementationDetails> A516EECB41051151F0183A8B0B6F6693C43F7D9E1815F85CAAAB18E00A5269A2;
    static /*0xdf0c*/ <PrivateImplementationDetails> AAF4528994DD7C464F43C131F6CD44DF41ACC18462C95877252FFC7EAC0164EF;
    static /*0xdf54*/ <PrivateImplementationDetails> AB0B9733AAEC4A2806711E41E36D3D0923BAF116156F33445DC2AA58DA5DF877;
    static /*0xe674*/ <PrivateImplementationDetails> AE4D29CF65CDB056FD3752F023E1C7B9E470FA189E45CAB74EB9AB81AD18BBD8;
    static /*0x12d44*/ <PrivateImplementationDetails> B215DD70A77190680641703C6DF73729B4583E285AF8B51ACF9086655FB2D0F3;
    static /*0x13d44*/ <PrivateImplementationDetails> B21802DE889E5F4F5344C8E0D366F59B68F886F88EFE45EA5CE01534A3F5C0E5;
    static /*0x13d78*/ <PrivateImplementationDetails> B55F94CD2F415D0279D7A1AF2265C4D9A90CE47F8C900D5D09AD088796210838;
    static /*0x145f8*/ <PrivateImplementationDetails> BABD01C34E7E65E57E4C431281E782B4101CE0644A8090AD6E501F1C6CF2C9DF;
    static /*0x1461c*/ <PrivateImplementationDetails> BB425A9B43E10C921902A25D07A4317DEFF9F606A788672E1B21633C143407F0;
    static /*0x1462c*/ <PrivateImplementationDetails> C250CAD28060A4EB63B4C4A643DDA196CCD35FD2FC67FB749ADF4BAC6D62E1A0;
    static /*0x14650*/ <PrivateImplementationDetails> C2D8E5EED6CBEBD8625FC18F81486A7733C04F9B0129FFBE974C68B90308B4F2;
    static /*0x14750*/ <PrivateImplementationDetails> C5733A1245383FBF067B4A9BDB41E3FB8E3A6BDEF37B3D5418F389422875783F;
    static /*0x14798*/ <PrivateImplementationDetails> C8EC70AC5A448C3A45CF1DFCC1375BE4E80DC6793E97D5E89BD97A0DC232B2E3;
    static /*0x14b98*/ <PrivateImplementationDetails> C95D810E738DB5F591EE691CE884EED2F110D9F82B1F7A8BE6ED257FDF4CDBEB;
    static /*0x14ba8*/ <PrivateImplementationDetails> C9830DF6956357ACE51CE1F82298578B36EB45A0CFDB8AEC5B9FDA7DB17E8063;
    static /*0x14c2a*/ <PrivateImplementationDetails> CAF8A46B3A07E26F84FE849B57A877051A0D06194B1C057985446B64BCC6E016;
    static /*0x14c72*/ <PrivateImplementationDetails> CAFFFC9D15E4037EE8FBDB1A45DFE456F0936BDC7310F1882EAF14B706A76658;
    static /*0x14c96*/ <PrivateImplementationDetails> CE11D6DEAFFC6D6EF6030E30E7444C933E6261F32AA737064EF0446C219ECE22;
    static /*0x15c96*/ <PrivateImplementationDetails> D1A99909A2923269BB67E72C1AED693F74961BDA58360FCC133007740CEBF5F1;
    static /*0x15cde*/ <PrivateImplementationDetails> D3B16F8D71CB719B941527D5A1ADA7ED83F4EB967FEE117DDA2FE4021E1D283F;
    static /*0x15ce4*/ <PrivateImplementationDetails> D503954AE2C3616EA32CEB0D66F5B2E119D03CE722773E5D7E1A8BC8F1803631;
    static /*0x15d2c*/ <PrivateImplementationDetails> D6691EE5A533DE7E0859066942261B24D0C836D7EE016D2251377BFEE40FEA15;
    static /*0x15dd8*/ <PrivateImplementationDetails> D870074914025E855AA5985A2D6778F1E277036BF9C9F03DEC61F3C496FEC35C;
    static /*0x165d8*/ <PrivateImplementationDetails> D896D464C3726A21162F271ACB711464AD07EA9C9CE78E0297FD0DE934471FA6;
    static /*0x165e4*/ <PrivateImplementationDetails> D8A29F3D197FBB54CF9F4B105AFBA6B1257ADF6449F0184F843380AAAA24639C;
    static /*0x1662c*/ <PrivateImplementationDetails> DCDCF594464B904F763D4CE53B1DBE08A47E551AE86FD5D61F63FD0C3313FDC3;
    static /*0x16674*/ <PrivateImplementationDetails> DCE88EE5233B9D0FD0D7A6222C82BC3AEE83B15E9992F939B17AB40530DB555C;
    static /*0x16fa2*/ <PrivateImplementationDetails> DD471F12FFA94CC557A02A91C2CBB95F551AB28C8BBF297B2F953B8886BCCF6D;
    static /*0x1703a*/ <PrivateImplementationDetails> DF29A050CD2EBD9DFDC783DB1CC74D3D716DAEC1630A337EE31B9E2E03D34D2D;
    static /*0x17082*/ <PrivateImplementationDetails> E148B2057CF0C1595155635E761FB66AAE634C40D8FABC4CE79A2DB8886525D4;
    static /*0x18082*/ <PrivateImplementationDetails> E2C673A3A737B04369A63F1FB1A30F6E742B066E2CCCD9B1838793CBB5590598;
    static /*0x180a8*/ <PrivateImplementationDetails> E32C465157D21F39B3DBF186A98FB02185C63B0260B47247A7A5FDF2B061EAA8;
    static /*0x180b4*/ <PrivateImplementationDetails> E5F4F6214036DF103321A8A0CE30C2EF935694B4199D52BC538E7EF3F045CB92;
    static /*0x180cc*/ <PrivateImplementationDetails> E768EDCAE10BAB68BB5DF102FDBB8CF4F31B9D60159B44DA3F33ABC36388308B;
    static /*0x1810c*/ <PrivateImplementationDetails> E8588351183F6F6A7DAD54DC28357628F3C4D4B358AB92A18AE7D08B0D9B0092;
    static /*0x18506*/ <PrivateImplementationDetails> EBE07C3718876777F609CD22058F4C3A6CCCC695F5BDE90998DC1E12E0CBE63D;
    static /*0x18512*/ <PrivateImplementationDetails> EC85ED774A75308D011FEF4A32204FB9725776189F565C95E968E241738E89D4;
    static /*0x1852a*/ <PrivateImplementationDetails> EE415D5C3ECC6C8C19F71BCD4E03847F5A15931374A7F5BF88C24B722F04B8FE;
    static /*0x1854a*/ <PrivateImplementationDetails> EF39C5A882F9477B2A250BA257247825CEB07FC53C3C984385F2C2E5F8222431;
    static /*0x1864a*/ <PrivateImplementationDetails> EF82B163CA8252A793A6E73F57775D843C9A21F65586926EB11893FA8BB603E9;
    static /*0x1865a*/ <PrivateImplementationDetails> F0CF66F9B123DCEBB39C38C5D8E4821D4E94DB593889C506BCA0827036F1B7EB;
    static /*0x1874a*/ <PrivateImplementationDetails> F1945CD6C19E56B3C1C78943EF5EC18116907A4CA1EFC40A57D48AB1DB7ADFC5;
    static /*0x1874d*/ <PrivateImplementationDetails> F19B89DC2C99490D8E4D92B7FC5B5E48BB37E76012F4DA195023267C1C7FDD6A;
    static /*0x193cd*/ <PrivateImplementationDetails> F2830F044682E33B39018B5912634835B641562914E192CA66C654F5E4492FA8;
    static /*0x194cd*/ <PrivateImplementationDetails> F4BD8144313C3B67E191C6F3CD8B00540FF1809837C5BCA5C2FDA0D518681563;
    static /*0x19515*/ <PrivateImplementationDetails> F7D2AD02ED768134B31339AB059D864789E0A60090CC368B3881EB0631BBAF93;
    static /*0x19915*/ <PrivateImplementationDetails> F7D381AF73D85950E0B064CF1AA8F14938A1F38084B46CE36AAEFE81BEF739F3;
    static /*0x199e9*/ <PrivateImplementationDetails> FADB218011E7702BB9575D0C32A685DA10B5C72EB809BD9A955DB1C76E4D8315;
    static /*0x19a1d*/ <PrivateImplementationDetails> FB2089AF82E09593374B65EC2440779FDCF5DD6DA07D26E57AF6790667B937CD;
    static /*0x19ed5*/ <PrivateImplementationDetails> FC405235E052D3DED17776A6B4C52CF9EFAE85050127AA6C45B5BA95F87ACCFD;
    static /*0x19f05*/ <PrivateImplementationDetails> FC5B0FD4492EC7BC85845E312A7A1469DF87CA5BCA5B5B9E0B3030E6E11E48E6;
    static /*0x19f39*/ <PrivateImplementationDetails> FD68700E95459C5E7A49C5830F8BD0A9BA4BD171252663D8066B09E7768C5C5D;
    static /*0x1a029*/ <PrivateImplementationDetails> FEC387BA57A54BB6066E4CA8A4F9C0FF9C36B9CBD6600C3683F6FB1BDB5077EB;

    static /*0x327ee68*/ uint ComputeStringHash(string s);

    struct __StaticArrayInitTypeSize=3
    {
    }

    struct __StaticArrayInitTypeSize=6
    {
    }

    struct __StaticArrayInitTypeSize=10
    {
    }

    struct __StaticArrayInitTypeSize=12
    {
    }

    struct __StaticArrayInitTypeSize=15
    {
    }

    struct __StaticArrayInitTypeSize=16
    {
    }

    struct __StaticArrayInitTypeSize=20
    {
    }

    struct __StaticArrayInitTypeSize=24
    {
    }

    struct __StaticArrayInitTypeSize=32
    {
    }

    struct __StaticArrayInitTypeSize=36
    {
    }

    struct __StaticArrayInitTypeSize=38
    {
    }

    struct __StaticArrayInitTypeSize=40
    {
    }

    struct __StaticArrayInitTypeSize=42
    {
    }

    struct __StaticArrayInitTypeSize=44
    {
    }

    struct __StaticArrayInitTypeSize=48
    {
    }

    struct __StaticArrayInitTypeSize=52
    {
    }

    struct __StaticArrayInitTypeSize=56
    {
    }

    struct __StaticArrayInitTypeSize=64
    {
    }

    struct __StaticArrayInitTypeSize=72
    {
    }

    struct __StaticArrayInitTypeSize=76
    {
    }

    struct __StaticArrayInitTypeSize=84
    {
    }

    struct __StaticArrayInitTypeSize=88
    {
    }

    struct __StaticArrayInitTypeSize=94
    {
    }

    struct __StaticArrayInitTypeSize=120
    {
    }

    struct __StaticArrayInitTypeSize=128
    {
    }

    struct __StaticArrayInitTypeSize=130
    {
    }

    struct __StaticArrayInitTypeSize=152
    {
    }

    struct __StaticArrayInitTypeSize=170
    {
    }

    struct __StaticArrayInitTypeSize=172
    {
    }

    struct __StaticArrayInitTypeSize=174
    {
    }

    struct __StaticArrayInitTypeSize=212
    {
    }

    struct __StaticArrayInitTypeSize=240
    {
    }

    struct __StaticArrayInitTypeSize=256
    {
    }

    struct __StaticArrayInitTypeSize=262
    {
    }

    struct __StaticArrayInitTypeSize=288
    {
    }

    struct __StaticArrayInitTypeSize=330
    {
    }

    struct __StaticArrayInitTypeSize=336
    {
    }

    struct __StaticArrayInitTypeSize=360
    {
    }

    struct __StaticArrayInitTypeSize=392
    {
    }

    struct __StaticArrayInitTypeSize=640
    {
    }

    struct __StaticArrayInitTypeSize=648
    {
    }

    struct __StaticArrayInitTypeSize=761
    {
    }

    struct __StaticArrayInitTypeSize=998
    {
    }

    struct __StaticArrayInitTypeSize=1018
    {
    }

    struct __StaticArrayInitTypeSize=1024
    {
    }

    struct __StaticArrayInitTypeSize=1208
    {
    }

    struct __StaticArrayInitTypeSize=1320
    {
    }

    struct __StaticArrayInitTypeSize=1440
    {
    }

    struct __StaticArrayInitTypeSize=1450
    {
    }

    struct __StaticArrayInitTypeSize=1472
    {
    }

    struct __StaticArrayInitTypeSize=1665
    {
    }

    struct __StaticArrayInitTypeSize=1824
    {
    }

    struct __StaticArrayInitTypeSize=2048
    {
    }

    struct __StaticArrayInitTypeSize=2100
    {
    }

    struct __StaticArrayInitTypeSize=2176
    {
    }

    struct __StaticArrayInitTypeSize=2224
    {
    }

    struct __StaticArrayInitTypeSize=2350
    {
    }

    struct __StaticArrayInitTypeSize=2382
    {
    }

    struct __StaticArrayInitTypeSize=3132
    {
    }

    struct __StaticArrayInitTypeSize=3200
    {
    }

    struct __StaticArrayInitTypeSize=4096
    {
    }

    struct __StaticArrayInitTypeSize=5264
    {
    }

    struct __StaticArrayInitTypeSize=5952
    {
    }

    struct __StaticArrayInitTypeSize=10800
    {
    }

    struct __StaticArrayInitTypeSize=18128
    {
    }
}

namespace Unity
{
    class ThrowStub : System.ObjectDisposedException
    {
        static /*0x327eee4*/ void ThrowNotSupportedException();
    }
}
